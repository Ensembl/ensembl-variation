#!/usr/bin/env python3

"""
Filter a SpliceAI gene annotation file to remove exons that belong to MANE Select transcripts.

Inputs:
  - SpliceAI annotation file generated by spliceai_annotation_file.py
  - Source of MANE Select exons:
      * Default: MANE Select protein-coding transcripts fetched from a core DB (supply host/port/user/db at runtime)
      * Or: a GFF3 file containing MANE Select transcripts (default: Homo_sapiens.GRCh38.116.gff3.gz)

Outputs:
  - A filtered annotation file with any MANE Select exons removed; genes with no exons after filtering are dropped.
"""

import argparse
import gzip
import sys
from typing import Dict, List, Set, Tuple

import mysql.connector
from mysql.connector import Error

DEFAULT_GFF3 = "/nfs/production/flicek/ensembl/variation/Homo_sapiens.GRCh38.116.gff3.gz"


def strip_prefix(value: str) -> str:
    if not value:
        return None
    val = value.split(",")[0]
    return val.split(":", 1)[1] if ":" in val else val


def parse_attrs(attrs: str) -> Dict[str, str]:
    attr_dict = {}
    for entry in attrs.split(";"):
        if "=" in entry:
            k, v = entry.split("=", 1)
            attr_dict[k] = v
    return attr_dict


def load_mane_select_exons(gff3_path: str) -> Tuple[Set[str], Set[Tuple[str, int, int]]]:
    transcripts = set()
    mane_exons = set()
    open_func = gzip.open if gff3_path.endswith(".gz") else open

    with open_func(gff3_path, "rt") as handle:
        for line in handle:
            if not line or line.startswith("#"):
                continue
            fields = line.rstrip("\n").split("\t")
            if len(fields) < 9:
                continue
            chrom, source, feature, start, end, score, strand, phase, attrs = fields
            chrom = chrom.replace("chr", "")
            attr_dict = parse_attrs(attrs)

            if feature in ("transcript", "mRNA"):
                if "mane_select" not in attrs.lower():
                    continue
                tid = strip_prefix(attr_dict.get("ID") or attr_dict.get("transcript_id"))
                if tid:
                    transcripts.add(tid)
                continue

            if feature == "exon":
                parents_raw = attr_dict.get("Parent", "")
                for parent in parents_raw.split(","):
                    tid = strip_prefix(parent)
                    if tid and tid in transcripts:
                        mane_exons.add((chrom, int(start), int(end)))

    return transcripts, mane_exons


def load_mane_select_exons_db(host: str, port: int, user: str, password: str, database: str) -> Tuple[Set[str], Set[Tuple[str, int, int]]]:
    transcripts = set()
    mane_exons = set()
    try:
        connection = mysql.connector.connect(
            host=host,
            port=port,
            user=user,
            password=password or "",
            database=database,
        )
        cursor = connection.cursor()
        query = """
            SELECT t.stable_id, sr.name, e.seq_region_start, e.seq_region_end
            FROM transcript t
            JOIN transcript_attrib ta ON ta.transcript_id = t.transcript_id
            JOIN attrib_type atp ON atp.attrib_type_id = ta.attrib_type_id
            JOIN seq_region sr ON sr.seq_region_id = t.seq_region_id
            JOIN coord_system cs ON cs.coord_system_id = sr.coord_system_id
            LEFT JOIN seq_region_attrib sra
              ON sra.seq_region_id = sr.seq_region_id
             AND sra.attrib_type_id = (SELECT attrib_type_id FROM attrib_type WHERE code = 'non_ref')
            JOIN exon_transcript et ON et.transcript_id = t.transcript_id
            JOIN exon e ON e.exon_id = et.exon_id
            WHERE atp.code = 'MANE_Select'
              AND t.biotype = 'protein_coding'
              AND cs.name = 'chromosome'
              AND cs.version = 'GRCh38'
              AND sra.seq_region_id IS NULL;
        """
        cursor.execute(query)
        for tid, chrom, start, end in cursor:
            transcripts.add(tid)
            mane_exons.add((str(chrom).replace("chr", ""), int(start), int(end)))
    except Error as e:
        print(f"[filter_annotation_file] Error fetching MANE exons from DB {database}@{host}:{port} - {e}", file=sys.stderr)
        sys.exit(1)
    finally:
        try:
            cursor.close()
            connection.close()
        except Exception:
            pass

    return transcripts, mane_exons


def parse_annotation_line(line: str) -> Tuple[str, str, str, int, int, List[int], List[int]]:
    parts = line.rstrip("\n").split("\t")
    if len(parts) < 7:
        raise ValueError("Line does not have 7 columns")
    name, chrom, strand, tx_start, tx_end, exon_starts_raw, exon_ends_raw = parts[:7]
    exon_starts = [int(x) for x in exon_starts_raw.split(",") if x]
    exon_ends = [int(x) for x in exon_ends_raw.split(",") if x]
    if len(exon_starts) != len(exon_ends):
        raise ValueError("Mismatched exon start/end counts")
    return name, chrom, strand, int(tx_start), int(tx_end), exon_starts, exon_ends


def filter_annotation(annotation_path: str, mane_exons: Set[Tuple[str, int, int]], output_path: str) -> Dict[str, int]:
    stats = {
        "genes_in": 0,
        "genes_out": 0,
        "exons_in": 0,
        "exons_removed": 0,
        "exons_out": 0,
        "genes_dropped_empty": 0,
    }
    with open(annotation_path, "r") as handle, open(output_path, "w") as out:
        for line in handle:
            if line.startswith("#"):
                out.write(line)
                continue
            if not line.strip():
                continue
            stats["genes_in"] += 1
            try:
                name, chrom, strand, tx_start, tx_end, exon_starts, exon_ends = parse_annotation_line(line)
            except ValueError as e:
                print(f"[filter_annotation_file] Skipping line due to parse error: {e} | line={line.strip()}", file=sys.stderr)
                continue

            stats["exons_in"] += len(exon_starts)
            kept_starts = []
            kept_ends = []
            for s, e in zip(exon_starts, exon_ends):
                if (chrom, s, e) in mane_exons:
                    stats["exons_removed"] += 1
                    continue
                kept_starts.append(s)
                kept_ends.append(e)

            if not kept_starts:
                stats["genes_dropped_empty"] += 1
                continue

            tx_start_new = min(kept_starts)
            tx_end_new = max(kept_ends)
            stats["exons_out"] += len(kept_starts)
            stats["genes_out"] += 1

            exon_start_field = ",".join(str(x) for x in kept_starts) + ","
            exon_end_field = ",".join(str(x) for x in kept_ends) + ","
            out.write(f"{name}\t{chrom}\t{strand}\t{tx_start_new}\t{tx_end_new}\t{exon_start_field}\t{exon_end_field}\n")

    return stats


def main():
    parser = argparse.ArgumentParser(description="Remove MANE Select exons from a SpliceAI annotation file")
    parser.add_argument("-i", "--input", required=True, help="Input SpliceAI annotation file")
    parser.add_argument("-g", "--gff3", help="GFF3 containing MANE Select transcripts (use to bypass DB mode)")
    parser.add_argument("--db_host", help="Core DB host for MANE exons (required if no --gff3)")
    parser.add_argument("--db_port", type=int, help="Core DB port for MANE exons (required if no --gff3)")
    parser.add_argument("--db_user", help="Core DB user for MANE exons (required if no --gff3)")
    parser.add_argument("--db_password", default="", help="Core DB password for MANE exons (optional; defaults to empty)")
    parser.add_argument("--db_name", help="Core DB name for MANE exons (required if no --gff3)")
    parser.add_argument("-o", "--output", required=True, help="Filtered annotation output file")
    args = parser.parse_args()

    if args.gff3:
        gff_path = args.gff3
        print(f"[filter_annotation_file] Loading MANE Select exons from {gff_path}", file=sys.stderr)
        mane_transcripts, mane_exons = load_mane_select_exons(gff_path)
    else:
        missing = [flag for flag, val in [
            ("--db_host", args.db_host),
            ("--db_port", args.db_port),
            ("--db_user", args.db_user),
            ("--db_name", args.db_name),
        ] if val in (None, "")]
        if missing:
            parser.error(f"DB mode requires {' '.join(missing)}")
        print(f"[filter_annotation_file] Loading MANE Select exons from DB {args.db_name} ({args.db_host}:{args.db_port})", file=sys.stderr)
        mane_transcripts, mane_exons = load_mane_select_exons_db(
            args.db_host, args.db_port, args.db_user, args.db_password, args.db_name
        )
    print(f"[filter_annotation_file] Loaded {len(mane_transcripts)} MANE Select transcripts and {len(mane_exons)} exons", file=sys.stderr)

    print(f"[filter_annotation_file] Filtering {args.input} -> {args.output}", file=sys.stderr)
    stats = filter_annotation(args.input, mane_exons, args.output)
    print(f"[filter_annotation_file] Genes in: {stats['genes_in']} | Genes out: {stats['genes_out']} | Dropped empty: {stats['genes_dropped_empty']}", file=sys.stderr)
    print(f"[filter_annotation_file] Exons in: {stats['exons_in']} | Removed: {stats['exons_removed']} | Exons out: {stats['exons_out']}", file=sys.stderr)


if __name__ == "__main__":
    main()
