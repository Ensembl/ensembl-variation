#!/usr/bin/env python3

"""
Filter a SpliceAI gene annotation file by removing exons that appear in a previous SpliceAI
annotation file, matching by gene and coordinate.

Inputs:
  - SpliceAI annotation file generated by spliceai_annotation_file.py (to be filtered)
  - Previous SpliceAI annotation file whose exons should be removed from the input

Behaviour:
  - Exons present for the same gene in the previous annotation are dropped; genes with no remaining exons are discarded.
  - Transcript span is recalculated from remaining exons.

Output:
  - A filtered annotation file in the same format as the input.
"""

import argparse
import sys
from typing import Dict, List, Set, Tuple


def parse_annotation_line(line: str) -> Tuple[str, str, str, int, int, List[int], List[int]]:
    parts = line.rstrip("\n").split("\t")
    if len(parts) < 7:
        raise ValueError("Line does not have 7 columns")
    name, chrom, strand, tx_start, tx_end, exon_starts_raw, exon_ends_raw = parts[:7]
    exon_starts = [int(x) for x in exon_starts_raw.split(",") if x]
    exon_ends = [int(x) for x in exon_ends_raw.split(",") if x]
    if len(exon_starts) != len(exon_ends):
        raise ValueError("Mismatched exon start/end counts")
    return name, chrom, strand, int(tx_start), int(tx_end), exon_starts, exon_ends


def load_prev_annotation_exons(annotation_path: str) -> Tuple[Set[str], Dict[str, Set[Tuple[str, int, int]]]]:
    genes = set()
    exons_by_gene: Dict[str, Set[Tuple[str, int, int]]] = {}

    with open(annotation_path, "r") as handle:
        for line in handle:
            if not line or line.startswith("#"):
                continue
            try:
                name, chrom, _strand, _tx_start, _tx_end, exon_starts, exon_ends = parse_annotation_line(line)
            except ValueError as e:
                print(f"[filter_annotation_file] Skipping previous annotation line due to parse error: {e} | line={line.strip()}", file=sys.stderr)
                continue
            genes.add(name)
            gene_exons = exons_by_gene.setdefault(name, set())
            for s, e in zip(exon_starts, exon_ends):
                gene_exons.add((chrom, s, e))

    return genes, exons_by_gene


def filter_annotation(annotation_path: str, prev_exons_by_gene: Dict[str, Set[Tuple[str, int, int]]], output_path: str) -> Dict[str, int]:
    stats = {
        "genes_in": 0,
        "genes_out": 0,
        "exons_in": 0,
        "exons_removed": 0,
        "exons_out": 0,
        "genes_dropped_empty": 0,
    }
    with open(annotation_path, "r") as handle, open(output_path, "w") as out:
        for line in handle:
            if line.startswith("#"):
                out.write(line)
                continue
            if not line.strip():
                continue
            stats["genes_in"] += 1
            try:
                name, chrom, strand, tx_start, tx_end, exon_starts, exon_ends = parse_annotation_line(line)
            except ValueError as e:
                print(f"[filter_annotation_file] Skipping line due to parse error: {e} | line={line.strip()}", file=sys.stderr)
                continue

            stats["exons_in"] += len(exon_starts)
            kept_starts = []
            kept_ends = []
            prev_exons = prev_exons_by_gene.get(name, set())
            for s, e in zip(exon_starts, exon_ends):
                if (chrom, s, e) in prev_exons:
                    stats["exons_removed"] += 1
                    continue
                kept_starts.append(s)
                kept_ends.append(e)

            if not kept_starts:
                stats["genes_dropped_empty"] += 1
                continue

            tx_start_new = min(kept_starts)
            tx_end_new = max(kept_ends)
            stats["exons_out"] += len(kept_starts)
            stats["genes_out"] += 1

            exon_start_field = ",".join(str(x) for x in kept_starts) + ","
            exon_end_field = ",".join(str(x) for x in kept_ends) + ","
            out.write(f"{name}\t{chrom}\t{strand}\t{tx_start_new}\t{tx_end_new}\t{exon_start_field}\t{exon_end_field}\n")

    return stats


def main():
    parser = argparse.ArgumentParser(description="Remove MANE Select exons from a SpliceAI annotation file")
    parser.add_argument("-i", "--input", required=True, help="Input SpliceAI annotation file")
    parser.add_argument("-p", "--prev_annotation", required=True, help="Previous SpliceAI annotation file whose exons will be removed from the input")
    parser.add_argument("-o", "--output", required=True, help="Filtered annotation output file")
    args = parser.parse_args()

    prev_path = args.prev_annotation
    print(f"[filter_annotation_file] Loading previous annotation exons from {prev_path}", file=sys.stderr)
    prev_genes, prev_exons_by_gene = load_prev_annotation_exons(prev_path)
    prev_exons_total = sum(len(v) for v in prev_exons_by_gene.values())
    print(f"[filter_annotation_file] Loaded {len(prev_genes)} previous annotation genes and {prev_exons_total} exons", file=sys.stderr)

    print(f"[filter_annotation_file] Filtering {args.input} -> {args.output}", file=sys.stderr)
    stats = filter_annotation(args.input, prev_exons_by_gene, args.output)
    print(f"[filter_annotation_file] Genes in: {stats['genes_in']} | Genes out: {stats['genes_out']} | Dropped empty: {stats['genes_dropped_empty']}", file=sys.stderr)
    print(f"[filter_annotation_file] Exons in: {stats['exons_in']} | Removed: {stats['exons_removed']} | Exons out: {stats['exons_out']}", file=sys.stderr)


if __name__ == "__main__":
    main()
