#!/usr/bin/env perl

=head1 LICENSE

Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
Copyright [2016-2018] EMBL-European Bioinformatics Institute

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

=cut


=head1 CONTACT

 Please email comments or questions to the public Ensembl
 developers list at <http://lists.ensembl.org/mailman/listinfo/dev>.

 Questions may also be sent to the Ensembl help desk at
 <http://www.ensembl.org/Help/Contact>.

=cut

## collect variant synonyms & load to db
##  - initially from PharmGKB database

use strict;
use warnings;
use HTTP::Tiny;
use Getopt::Long;
use DBI qw(:sql_types);

use Bio::EnsEMBL::Registry;
use Bio::EnsEMBL::Variation::Source;

our $DEBUG = 0;

my ($data_file, $registry_file, $species, $source_name, $clean, $source_version, $source_url, $source_description, $host,
   $port, $user, $pass, $db_name);

GetOptions ("data_file=s"          => \$data_file,
            "species=s"            => \$species,
            "source_name=s"        => \$source_name,
            "source_url=s"         => \$source_url,
            "source_version=s"     => \$source_version,
            "source_description=s" => \$source_description,
            "registry=s"           => \$registry_file,            
            "host=s"               => \$host,
            "port=s"               => \$port,
            "user=s"               => \$user,
            "pass=s"               => \$pass,
            "db_name=s"            => \$db_name,
            "clean"                => \$clean 
            );

usage() unless defined $registry_file && defined $source_name; 

$species ||= 'homo_sapiens';


my $reg = 'Bio::EnsEMBL::Registry';
$reg->load_all($registry_file);
my $dba = $reg->get_DBAdaptor($species, 'variation'); 

## include failed variants to avoid missing any links
$dba->include_failed_variations(1);


## collect synonyms by source
if($source_name eq 'PharmGKB'){
  my $source = get_source($species, $dba, $source_name, $source_version, $source_url, $source_description );

  my $synonyms;

  ## collect data files if not already available
  $data_file = download_PharmGKB() unless $data_file;

  ## extract synonyms from file
  $synonyms  = extract_PharmGKB($data_file);
  
  ## add synonyms to the database
  import_synonyms($synonyms, $source, $dba, $species); 
}

elsif($source_name eq 'dbSNP'){
  ### import synonyms from production database ### Access directly database because this database doesn't have adaptors 
  my $prod_dbc = Bio::EnsEMBL::DBSQL::DBConnection->new
    ( '-host'    => $host,
      '-port'    => $port, 
      '-user'    => $user,
      '-pass'    => $pass,
      '-dbname'  => $db_name, 
      '-driver'  =>  'mysql' 
    ); 

  my $synonyms_output = query_synonyms_data($prod_dbc, '*', 'human_synonym'); 

  my %data; # synonym_name => {rs_name} & {source_id} 

  # get data from human_synonym table (in production db) 
  foreach my $result (@{$synonyms_output}){  
    $data{$result->[2]}{rs_name} = $result->[1]; 
    $data{$result->[2]}{source_id} = $result->[4]; 
  }
 
  # get all available sources from production database  
  my $sources = get_all_sources($dba, $prod_dbc);

  import_synonyms_all_sources($sources, $dba, $species, \%data);  
} 

elsif($source_name eq 'UniProt'){
  # download UniProt file if it's not provided  
  $data_file = download_UniProt() unless $data_file; 
 
  my $result = parse_uniprot($data_file); 

  # Source UniProt 
  my %source_uniprot = (
  "UniProt" => {
    description => "Variants with protein annotation imported from Uniprot",
    url => "http://www.uniprot.org/",
    set => "ph_uniprot",
    type => "Variation",
    status => 'germline',
  }, 
  ); 

  # get source info 
  $source_description = $source_uniprot{$source_name}->{description}; 
  $source_url = $source_uniprot{$source_name}->{url}; 
  my $set = $source_uniprot{$source_name}->{set}; 
  my $object_type = $source_uniprot{$source_name}->{type}; 
  my $source_status = $source_uniprot{$source_name}->{status}; 

  # get source and returns source_id 
  my $source = get_or_add_source($source_name,$source_description,$source_url,$source_status,$dba); 

  my @ids; 
  my %synonym;
  my @phenotypes; 
  if (exists($result->{'synonyms'})) {
    %synonym = %{$result->{'synonyms'}};
    # To get all the ids of the source (Uniprot)
    @ids = keys(%synonym);
  }
  # not used right now 
  if (exists($result->{'phenotypes'})) {
    @phenotypes = @{$result->{'phenotypes'}};
  } 
  
  if (scalar @ids == 0) {
    @ids = map {$_->{'id'}} @phenotypes;
  }
  my $variation_ids = $object_type =~ /Variation/ ? get_dbIDs(\@ids,$dba) : {}; 

  # Add the synonyms
    my $variation_set_id = add_set_uniprot($dba,$set,$source_description);
    add_synonyms_uniprot(\%synonym,$variation_ids,$source,$variation_set_id,$dba); 

}

else{
    die "data source : $source_name not supported\n";
} 


=head2 download_PharmGKB

collect current export from PharmGKB site

=cut 

sub download_PharmGKB{

  my $http     = HTTP::Tiny->new();
  my $response = $http->get('https://api.pharmgkb.org/v1/download/file/data/rsid.zip');
  die "Failed to pick up file\n" unless $response->{success};

  open my $out, ">rsid.zip" ||die "Failed to write data locally : $!\n";
  print $out  $response->{content};

  eval{
    `unzip rsid.zip`
  };
  die "Failed to unzip data :$@\n" unless $@ eq '';

  return "rsid.tsv";
}

=head2 download_UniProt

collect current export from UniProt site

=cut 

sub download_UniProt{

  my $http     = HTTP::Tiny->new();
  my $response = $http->get('https://www.uniprot.org/docs/humsavar.txt');
  die "Failed to pick up file\n" unless $response->{success};

  open my $out, ">humsavar.txt" ||die "Failed to write data locally : $!\n";
  print $out  $response->{content}; 

  return "humsavar.txt";
}

=head2 parse_uniprot

parse UniProt file 

=cut 

sub parse_uniprot {
  my $infile = shift;
  
  my %synonym;
  my @phenotypes;
  
  # Open the input file for reading
  if($infile =~ /gz$/) {
    open (IN, "zcat $infile |") or die ("Could not open $infile for reading");
  }
  else {
    open(IN,'<',$infile) or die ("Could not open $infile for reading");
  }
  
  # Read through the file and parse out the desired fields
  while (<IN>) {
    chomp;
    
    # A regexp to catch the meta information in the header. Just echo this to the stdout for logging purposes
    if ($_ =~ m/^\s*(Description|Name|Release)\:/) {
      print STDOUT $_ . "\n";
    }
    
    # Main regexp to extract relevant variation information
    if ($_ =~ m/^(\S+)\s+\S+\s+(VAR\_\d+)\s+\w\.\S+\s+(Disease|Polymorphism|Unclassified)\s+(\-|rs\d*)\s*(.*)$/) {
      
      # Get the data that was caught by the regexp
      my $gene = $1;
      my $uniprot_id = $2;
      my $rs_id = $4;
      my $phenotype = $5;
      
      # If no rsId was given, will attempt to get one by looking up the Uniprot id in the synonym table
      if ($rs_id ne '-') {
        push(@{$synonym{$rs_id}},$uniprot_id);
      }
      #else {
      #  $rs_id = $uniprot_id;
      #}
      
      #$phenotype ||= '-';
      
      ## Try to further split the phenotype into a short name, description and possibly MIM id
      #if ($phenotype ne '-') {
      #  my $description;
      #  my $name;
      #  my $mim_id;
      #  
      #  ($description,$mim_id) = $phenotype =~ m/^([^\[]+)(?:\[(MIM\:.+?)\])?$/;
      #  ($description,$name) = $description =~ m/^(.+?)\s*(?:\((.+?)\))?\s*$/;
      #  
      #  $mim_id &&= join(",MIM:",split(",",$mim_id));
      #  $mim_id =~ s/\s//g if (defined($mim_id));
      #
      #  push(
      #    @phenotypes,
      #    {
      #      "id"              => $rs_id,
      #      "associated_gene" => $gene,
      #      "description"     => $description,
      #      "name"            => $name,
      #      "variation_names" => $rs_id,
      #      "study"           => $mim_id,
      #      "study_type"      => 'GWAS'
      #    }
      #  );
      #}
    }
  }
  close(IN);
  
  #my %result = ('synonyms' => \%synonym, 'phenotypes' => \@phenotypes);
  my %result = ('synonyms' => \%synonym);
  return \%result;
}

sub get_dbIDs {
  my $rs_ids = shift;
  my $db_adaptor = shift;
  
  my $id_stmt = qq{
    SELECT
      DISTINCT
      v.variation_id,
      v.name
    FROM
      variation v,
      variation_feature vf
      
    WHERE
      v.name = ? AND
      v.variation_id=vf.variation_id
    LIMIT 1
  };
  my $syn_stmt = qq{
    SELECT
      DISTINCT
      v.variation_id,
      v.name
    FROM
      variation_feature vf,
      variation_synonym vs JOIN
      variation v ON vs.variation_id = v.variation_id
    WHERE
      vs.name = ? AND
      v.variation_id=vf.variation_id
    LIMIT 1
  };
  my $id_sth = $db_adaptor->dbc->prepare($id_stmt);
  my $syn_sth = $db_adaptor->dbc->prepare($syn_stmt);
  
  my %mapping;
  
  foreach my $rs_id (@{$rs_ids}) {
    $id_sth->bind_param(1,$rs_id,SQL_VARCHAR);
    $id_sth->execute();
    my ($var_id,$var_name);
    $id_sth->bind_columns(\$var_id,\$var_name);
    $id_sth->fetch();
    
    # If we couldn't find the rs_id, look in the synonym table
    if (!defined($var_id)) {
      $syn_sth->bind_param(1,$rs_id,SQL_VARCHAR);
      $syn_sth->execute();
      $syn_sth->bind_columns(\$var_id,\$var_name);
      $syn_sth->fetch();
    }
    warn "$rs_id - no mapping found in variation db\n" unless $var_id ;  
    if($var_id){
      warn "$rs_id - found!!\n"; 
    }
    $mapping{$rs_id} = [$var_id,$var_name] if $var_id && $var_name;
  }
  
  return \%mapping;
} 

sub get_or_add_source {
  my $source_name = shift;
  my $source_description = shift;
  my $source_url    = shift;
  my $source_status = shift;
  my $db_adaptor    = shift;

  my $stmt = qq{
    SELECT
      source_id
    FROM
      source
    WHERE
      name = '$source_name'
    LIMIT 1
  };
  my $sth = $db_adaptor->dbc->prepare($stmt);
  $sth->execute();
  my $source_id;
  $sth->bind_columns(\$source_id);
  $sth->fetch();
  
  if (!defined($source_id)) {
    $stmt = qq{
      INSERT INTO
        source (
          name,
          description,
          url,
          somatic_status,
          version
        )
      VALUES (
        '$source_name',
        '$source_description',
        '$source_url',
        '$source_status',
        '$source_version'
      )
    };
    $db_adaptor->dbc->do($stmt);
    $source_id = $db_adaptor->dbc->db_handle->{'mysql_insertid'};
 
  }
  else {
    $stmt = qq{
      UPDATE
        source 
      SET name=?,
        description=?,
        url=?,
        version=?
      WHERE
        source_id=?
    };
    my $update_source_sth =$db_adaptor->dbc->prepare($stmt);
    $update_source_sth->execute($source_name,$source_description,$source_url,$source_version,$source_id);
  }

  return $source_id;
}
 
sub add_set_uniprot {  
  my $db_adaptor = shift;
  my $set_name = shift; 
  my $set_description = shift;

  # check if UniProt already exists 
  my $stmt = qq{
    SELECT
      variation_set_id
    FROM
      variation_set
    WHERE
      name = '$set_name'
    LIMIT 1
  };
  my $sth = $db_adaptor->dbc->prepare($stmt);
  $sth->execute();
  my $variation_set_id;
  $sth->bind_columns(\$variation_set_id);
  $sth->fetch();

  if (!defined($variation_set_id)) {  
    my $stmt_attrib = qq{
      SELECT
        attrib_id
      FROM
        attrib
      WHERE
        value = '$set_name'
      LIMIT 1
    };
    my $sth_attrib = $db_adaptor->dbc->prepare($stmt_attrib);
    $sth_attrib->execute();
    my $attrib_id;
    $sth_attrib->bind_columns(\$attrib_id);
    $sth_attrib->fetch();

    my $ins_stmt = qq{
      INSERT IGNORE INTO
        variation_set (
        name,
        description,
        short_name_attrib_id
        )
      VALUES (
        '$set_name',
        '$set_description',
        '$attrib_id' 
      )
    };

    $db_adaptor->dbc->do($ins_stmt); 
    $variation_set_id = $db_adaptor->dbc->db_handle->{'mysql_insertid'};
 
  } 
  
  return $variation_set_id; 
}

sub add_synonyms_uniprot {
  my $synonyms = shift;
  my $variation_ids = shift;
  my $source_id = shift;
  my $variation_set_id = shift; 
  my $db_adaptor = shift;

  # If we actually didn't get any synonyms, just return
  return if (!defined($synonyms) || !scalar(keys(%{$synonyms})));
  
  # Some prepeared statements needed for inserting the synonyms into database
  my $ins_stmt = qq{
    INSERT IGNORE INTO
      variation_synonym (
      variation_id,
      source_id,
      name
      )
    VALUES (
      ?,
      $source_id,
      ?
    )
  };

  my $stmt_update = qq{
    UPDATE
      variation_feature 
    SET 
      variation_set_id = CONCAT(variation_set_id,',$variation_set_id')  
    WHERE
      variation_id=?
  }; 

  print "SQL: $stmt_update\n"; 

  my $ins_sth = $db_adaptor->dbc->prepare($ins_stmt);
 
  my $update_source_sth =$db_adaptor->dbc->prepare($stmt_update); 

  my $alt_count = 0;
  my $variation_count = 0;
  
  foreach my $rs_id (keys %{$variation_ids}) {
    
    my $var_id = $variation_ids->{$rs_id}[0]; 

    # If we have a variation id, we can proceed
    if (defined($var_id)) {
      $update_source_sth->execute($var_id); 
      
      $variation_count++;
      
      $ins_sth->bind_param(1,$var_id,SQL_INTEGER);
      
      # Handle all synonym ids for this rs_id
      while (my $alt_id = shift(@{$synonyms->{$rs_id}})) {
      
        # Add the id as synonym, if it is already present, it will just be ignored
        $ins_sth->bind_param(2,$alt_id,SQL_VARCHAR);
        $ins_sth->execute();
        $alt_count++;
      }
    }
  }

}

=head2 extract_PharmGKB

extract data from PharmGKB file

=cut

sub extract_PharmGKB{

  my $data_file = shift;

  my %synonyms;

  open my $rslist, $data_file ||die "Failed to open synonym list to load: $!\n";
  while(<$rslist>){
    next if/RSID/;

    my @a = split/\t/;
    $synonyms{$a[0]} = $a[3];
  }
  return \%synonyms;
}

=head2 import_synonyms

import synonyms from refhash and source object;

=cut
sub import_synonyms{

  my $synonyms = shift;
  my $source   = shift;
  my $dba      = shift;
  my $species  = shift;

  my $variation_adaptor = $dba->get_VariationAdaptor($species, 'variation', );

  foreach my $var_name (keys %{$synonyms}){

    my $var = $variation_adaptor->fetch_by_name($var_name);
    unless($var){
      warn "variant $var_name not found\n";
      next;
    }
    $var->add_synonym($source->name(), $synonyms->{$var_name});
    $variation_adaptor->store_synonyms($var);
  }
}

=head2 import_synonyms_all_sources

import all synonyms from production database  

=cut
sub import_synonyms_all_sources{

  my $sources           = shift;  
  my $dest_db           = shift; 
  my $species           = shift; 
  my $data              = shift;

  my $variation_adaptor = $dest_db->get_VariationAdaptor($species, 'variation');  

  foreach my $synonym_name (keys %{$data}){ 
    my $var_name = $data->{$synonym_name}->{rs_name}; 
    my $var = $variation_adaptor->fetch_by_name($var_name); 

    unless($var){
      warn "variant $var_name not found\n";
      next; 
    }
  
    my $source_id = $data->{$synonym_name}->{source_id};
    my $source = $sources->{$source_id}; 
    $var->add_synonym($source->name(), $synonym_name);
    $variation_adaptor->store_synonyms($var); 

  } 
} 

=head2 get_source

get or add source object

=cut

sub get_source{

  my $species     = shift;
  my $dba         = shift;
  my $source_name = shift;
  my $version     = shift;
  my $url         = shift;
  my $description = shift;

  my $source_adaptor = $dba->get_SourceAdaptor('human', 'variation', );
  my $source = $source_adaptor->fetch_by_name($source_name);

  if (defined $source){
    ## do we need to update the version of an existing source?
    if(defined $version){ 
      $source->version($version);
      $source_adaptor->update_version($source);   
    }
  }
  else{
    ## update enter new source
    print "Source information not held for $source_name - adding supplied info\n" unless defined $source ;
    $source = Bio::EnsEMBL::Variation::Source->new
       (-name        => $source_name,
        -url         => $url         || undef,
        -version     => $version     || undef,
        -description => $description || undef,
        -data_types  => ['variation_synonym']
      );
    eval{$source_adaptor->store($source);} ; die "ERROR storing source: $@\n" unless $@ eq ''; 
  }
  return $source;
}

=head2 get_all_sources

get sources object 

=cut

sub get_all_sources{

  my $dest_db = shift;
  my $prod_dbc = shift; 

  # my %source_names; # hash with source id and corresponding source name 
  my %source_list; 

  my $source_adaptor = $dest_db->get_SourceAdaptor('human', 'variation'); 

  my $source_output = query_synonyms_data($prod_dbc, 'source_id,name,version,description,url', 'source');  

  foreach my $result_from_source (@{$source_output}){  
    # my $source_id = $result_from_source->[0]; 
    my $source_name = $result_from_source->[1]; 
    my $source = $source_adaptor->fetch_by_name($source_name);

    if(!defined($source)){    
      # get info for source  
      $source = Bio::EnsEMBL::Variation::Source->new
         (-name        => $source_name, 
          -url         => $result_from_source->[4],
          -version     => $result_from_source->[2],
          -description => $result_from_source->[3], 
          -data_types  => ['variation_synonym']
        );

      eval{$source_adaptor->store($source);} ; die "ERROR storing source: $@\n" unless $@ eq ''; 
    } 
    $source_list{$result_from_source->[0]} = $source; 
  } 

  return \%source_list; 
} 

=head2 query_synonyms_data 

fetch data from production database   

=cut
sub query_synonyms_data{

  my $prod_dbc = shift;
  my $params     = shift; 
  my $table_name = shift;

  my $statement = $prod_dbc->prepare("SELECT $params FROM $table_name");  
  $statement->execute(); 
  my $source_output = $statement->fetchall_arrayref();  
  $statement->finish(); 

  return $source_output; 
} 

sub usage{

  die "\nUsage : import_variant_synonyms -registry [registry file] -source_name [name]
\n\tOptions:
\t         -data_file          [name of file to load]
\t         -source_version     [version]
\t         -source_url         [url]
\t         -source_description [longer description]
\t         -species            [species]      - defaults to human
\t         -clean                             - remove old data\n\n";
}
