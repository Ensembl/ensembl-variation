README.md:[![GitHub](https://img.shields.io/github/license/Ensembl/ensembl-variation.svg)](https://github.com/Ensembl/ensembl-variation/blob/release/109/LICENSE)
README.md:[![Build Status](https://travis-ci.org/Ensembl/ensembl-variation.png?branch=release/109)](https://travis-ci.org/Ensembl/ensembl-variation)
README.md:[![Coverage Status](https://coveralls.io/repos/github/Ensembl/ensembl-variation/badge.svg?branch=release/109)](https://coveralls.io/github/Ensembl/ensembl-variation?branch=release/109)
README.md:[travis]: https://travis-ci.org/Ensembl/ensembl-variation
README.md:[coveralls]: https://coveralls.io/r/Ensembl/ensembl-variation
README.md:git clone https://github.com/Ensembl/ensembl-variation.git
LICENSE:      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
LICENSE:      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
LICENSE:      cross-claim or counterclaim in a lawsuit) alleging that the Work
LICENSE:          wherever such third-party notices normally appear. The contents
LICENSE:      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
LICENSE:      identification within third-party archives.
LICENSE:   Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
LICENSE:Copyright [2016-2022] EMBL-European Bioinformatics Institute
LICENSE:       http://www.apache.org/licenses/LICENSE-2.0
schema/intro_for_schema_description.txt:<h1>Ensembl Variation - Schema documentation</h1>
schema/intro_for_schema_description.txt:This document gives a high-level description of the tables that
schema/intro_for_schema_description.txt:      This document refers to version <span style="font-weight:bold;font-size:11pt;color:#000">####DB_VERSION####</span> of the Ensembl
schema/intro_for_schema_description.txt:  <div style="float:left;margin-left:5px">
schema/intro_for_schema_description.txt:    <a href="variation-database-schema.pdf">
schema/structuralvariation_API_diagram.graphml:<?xml version="1.0" encoding="UTF-8" standalone="no"?>
schema/structuralvariation_API_diagram.graphml:<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:java="http://www.yworks.com/xml/yfiles-common/1.0/java" xmlns:sys="http://www.yworks.com/xml/yfiles-common/markup/primitives/2.0" xmlns:x="http://www.yworks.com/xml/yfiles-common/markup/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:y="http://www.yworks.com/xml/graphml" xmlns:yed="http://www.yworks.com/xml/yed/3" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://www.yworks.com/xml/schema/graphml/1.1/ygraphml.xsd">
schema/structuralvariation_API_diagram.graphml:  <!--Created by yEd 3.14.4-->
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="-0.5" nodeRatioX="-0.5" nodeRatioY="-0.5" offsetX="4.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="38.0" width="180.4000000000001" x="-237.5095517742314" y="721.7942155541673"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">0..*<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="30.0" x="-381.1912778242589" y="594.8583770312871"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">0..*<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="38.0" width="279.48930876701047" x="-287.0542061577367" y="33.56017862049879"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="30" fontStyle="bold" hasBackgroundColor="false" hasLineColor="false" height="37.515625" modelName="custom" textColor="#000000" visible="true" width="300.7041015625" x="-23.90418932831477" y="0.2421875">Supporting evidence<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4205059418740705" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="121.23164753030426" x="-297.85567063608704" y="89.47490026998332"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="329.751953125" x="-26.664044442289537" y="-13.171875">get_all_SupportingStructuralVariants<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.6400647845329468" nodeRatioY="-0.5" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="30.0" x="-608.0588332276113" y="186.67594600666797"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="30.0" x="-143.59402987794437" y="302.19164796747197"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="30.0" x="-349.03072821462376" y="140.92594600666797"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="61.31306440903052" width="921.6400591790914" x="-698.0598764604806" y="-361.4134526177942"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="35" fontStyle="bold" hasBackgroundColor="false" hasLineColor="false" height="43.1015625" modelName="custom" textColor="#000000" visible="true" width="1062.06640625" x="13.06846354166646" y="14.211501909030517">EnsEMBL Variation API Overview - StructuralVariation centered<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.35547531707123414" labelRatioY="0.5" nodeRatioX="0.5" nodeRatioY="0.5" offsetX="0.0" offsetY="-4.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="44.009765625" x="-2.6703746829801958" y="1.828125">slice<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="30.0" x="-396.2396777268873" y="808.0780122033165"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">0..*<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="275.4504484656628" x="-285.03477600706276" y="759.7942155541673"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="317.505859375" x="-19.265260710483176" y="1.828125">get_all_StructuralVariationFeatures<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="38.0" width="180.4000000000001" x="-237.5095517742314" y="506.407345470029"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="216.8678955796825" x="-255.74349956407258" y="544.407345470029"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="248.619140625" x="-15.085430458465567" y="1.828125">get_all_PhenotypeFeatures<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="30.0" x="-130.37310839278803" y="249.65215725828483"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1PhenotypeFeature.html]]></data>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="81.40023860009498" width="382.8994332403564" x="-338.75926839440956" y="594.8583770312871"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.43443211495617734" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.396139051583422" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1SupportingStructuralVariation.html]]></data>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.40259594275802935" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="1.1102230246251565E-16" nodeRatioY="0.19060870889921944" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="1.1102230246251565E-16" nodeRatioY="0.4031502037313206" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1StructuralVariation.html]]></data>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="90.10000000000005" width="346.90804123711314" x="-706.959470048819" y="88.19026892333443"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/index.html]]></data>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="38.0" width="269.80567304576306" x="-698.0598764604806" y="-308.92579027061936"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/core-api/index.html]]></data>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="0.5" nodeRatioX="-0.5" nodeRatioY="0.5" offsetX="4.0" offsetY="-4.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1StructuralVariationFeature.html]]></data>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="88.30234375000026" width="413.7042188206186" x="-354.16166118454066" y="800.041952280637"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.5" offsetX="0.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.34642419979557615" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/core-api/classBio_1_1EnsEMBL_1_1Slice.html]]></data>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.5" offsetX="0.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="22" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="28.578125" modelName="custom" textColor="#FFFFFF" visible="true" width="293.8134765625" x="4.999023437499545" y="39.137938574488885">(e.g. chromosome:1:250-250)<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.5" labelRatioY="0.5" nodeRatioX="0.5" nodeRatioY="0.38691635330044327" offsetX="-4.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1Study.html]]></data>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="114.49319471894034" width="488.649207307913" x="-391.63415542818785" y="304.10220983721155"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="1.1102230246251565E-16" nodeRatioY="-0.4344321149561766" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.38452815931224593" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="1.1102230246251565E-16" nodeRatioY="0.16266279098162773" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="14.03515625">0..*<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.5" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="38.0" width="93.87288676288665" x="-194.2459951556748" y="220.34739861180134"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="30.0" x="-451.63415542818785" y="365.1393321798214"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="45.69921875" x="-7.849609375" y="-0.96484375">0..1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="30.0" x="-14.034096832228897" y="140.92594600666797"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">0..*<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="45.0" x="-663.7599150936896" y="994.2559278862387"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="0.0" nodeRatioX="0.5" nodeRatioY="0.0" offsetX="10.521907619201102" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="45.0" x="-663.7599150936896" y="1036.0187595013595"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="0.0" nodeRatioX="0.5" nodeRatioY="0.0" offsetX="10.521907619201102" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="45.0" x="-663.7599150936896" y="1077.7815911164803"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="0.0" nodeRatioX="0.5" nodeRatioY="0.0" offsetX="10.521907619201102" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="13.549476288659775" x="-299.756113796881" y="1036.0187595013595"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="13.549476288659775" x="-245.29523132265422" y="1036.0187595013595"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.47810238670550653" labelRatioY="0.0" nodeRatioX="0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="13.549476288659775" x="-299.756113796881" y="1077.7815911164803"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="13.549476288659775" x="-245.29523132265422" y="1077.7815911164803"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.47810238670550653" labelRatioY="0.0" nodeRatioX="0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="45.0" x="-290.29523132265433" y="994.2559278862387"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="0.0" nodeRatioX="0.5" nodeRatioY="0.0" offsetX="8.947152000052029" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="167.43227344946808" width="735.3993220393754" x="-675.8567644032975" y="952.6665475802207"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="-0.5" nodeRatioX="-0.5" nodeRatioY="-0.5" offsetX="4.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.5" nodeRatioY="0.5" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="45.69921875" x="-7.849609375" y="-0.96484375">0..1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1StructuralVariationSample.html]]></data>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="81.40023860009498" width="432.88086986711033" x="-365.95080227714476" y="-148.38342746241366"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="-5.551115123125783E-17" nodeRatioY="-0.5" offsetX="0.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="-5.551115123125783E-17" nodeRatioY="0.3933805187107151" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="38.0" width="125.37961076604563" x="-212.20017272661238" y="-228.96393862424776"/>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="279.48930876701047" x="-289.25502172709486" y="-190.96393862424776"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="316.392578125" x="-19.19771029246084" y="1.828125">get_all_StructuralVariationSamples<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="30.0" x="-522.2507047787786" y="49.80459184000091"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="30.0" x="89.44899915293678" y="-148.38342746241366"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">0..*<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="30.0" x="-413.3095304134242" y="-148.38342746241366"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">0..*<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="47.86270184660759" x="-171.24090269753515" y="258.34739861180134"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="51.802734375" x="-3.143227609137057" y="1.828125">study<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="45.69921875" x="-7.849609375" y="-0.96484375">0..1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="44.009765625" x="-2.6703746829803094" y="1.828125">slice<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="30.0" x="-526.9147963511437" y="186.67594600666797"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Geometry height="30.0" width="30.0" x="-438.6305183193952" y="186.67594600666797"/>
schema/structuralvariation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/structuralvariation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/structuralvariation_API_diagram.graphml:          <y:Path sx="-2.0723946788777994" sy="23.532354299578287" tx="0.0" ty="0.0">
schema/structuralvariation_API_diagram.graphml:            <y:Point x="-535.5778441091402" y="635.5584963313346"/>
schema/structuralvariation_API_diagram.graphml:          <y:Path sx="-17.89602100134431" sy="22.572363133256488" tx="1.2137026237484747" ty="-17.164869736513026">
schema/structuralvariation_API_diagram.graphml:          <y:Path sx="-84.43033992847506" sy="8.77879594899133" tx="0.0" ty="0.0">
schema/structuralvariation_API_diagram.graphml:            <y:Point x="-617.9357893587375" y="837.4767680479766"/>
schema/structuralvariation_API_diagram.graphml:          <y:Path sx="93.22862675381789" sy="6.8174927286208" tx="-7.390873049130448" ty="-18.58779680669761">
schema/structuralvariation_API_diagram.graphml:            <y:Point x="-450.00027337070003" y="361.3488071966817"/>
schema/structuralvariation_API_diagram.graphml:            <y:Point x="-445.39560561306683" y="361.3488071966817"/>
schema/structuralvariation_API_diagram.graphml:          <y:Path sx="-122.29103161966407" sy="4.217905162242204" tx="0.0" ty="0.0">
schema/structuralvariation_API_diagram.graphml:          <y:Path sx="124.34689793085676" sy="17.53630348639939" tx="-11.072608071649142" ty="1.943347584504636">
schema/structuralvariation_API_diagram.graphml:            <y:Point x="-533.5054494302624" y="-107.68330816236617"/>
schema/structuralvariation_API_diagram.graphml:            <y:Point x="284.85271434105783" y="-107.68330816236617"/>
Binary file schema/database-schema-print.pdf matches
Binary file schema/database-schema.pdf matches
schema/variation_API_diagram.graphml:<?xml version="1.0" encoding="UTF-8" standalone="no"?>
schema/variation_API_diagram.graphml:<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:java="http://www.yworks.com/xml/yfiles-common/1.0/java" xmlns:sys="http://www.yworks.com/xml/yfiles-common/markup/primitives/2.0" xmlns:x="http://www.yworks.com/xml/yfiles-common/markup/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:y="http://www.yworks.com/xml/graphml" xmlns:yed="http://www.yworks.com/xml/yed/3" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://www.yworks.com/xml/schema/graphml/1.1/ygraphml.xsd">
schema/variation_API_diagram.graphml:  <!--Created by yEd 3.14.2-->
schema/variation_API_diagram.graphml:          <y:Geometry height="325.4824484536083" width="417.1875000000001" x="1714.1963491732079" y="-7.720177899484753"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="-0.5" nodeRatioX="-0.5" nodeRatioY="-0.5" offsetX="4.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="-0.5" nodeRatioX="-0.5" nodeRatioY="-0.5" offsetX="4.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">0..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">0..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">0..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">0..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">1..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">1..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="377.5546875" x="-1.77734375" y="-2.3125021414377898">get_all_RegulatoryFeatureVariationAlleles<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.4122181868018913" nodeRatioX="0.0" nodeRatioY="-0.5" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="300.81640625" x="-1.358694533934795" y="-2.3125021414377898">get_all_TranscriptVariationAlleles<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.4122181868018913" nodeRatioX="0.0" nodeRatioY="-0.5" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">1..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">1..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.4122181868018914" nodeRatioX="0.0" nodeRatioY="0.5" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="30" fontStyle="bold" hasBackgroundColor="false" hasLineColor="false" height="37.515625" modelName="custom" textColor="#000000" visible="true" width="84.0390625" x="-6.680606119223626" y="0.2421875">Allele<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4205059418740705" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="132.974609375" x="-8.068482649507132" y="1.828125">get_all_Alleles<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">1..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="265.30859375" x="-16.098094181275087" y="1.828125">get_all_PopulationGenotypes<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="238.599609375" x="-14.47747669626392" y="1.828125">get_all_SampleGenotypes<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="30" fontStyle="bold" hasBackgroundColor="false" hasLineColor="false" height="37.515625" modelName="custom" textColor="#000000" visible="true" width="142.3544921875" x="-11.316336276440325" y="0.2421875">Genotype<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4205059418740705" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">0..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:Geometry height="61.31306440903052" width="921.6400591790914" x="138.47598281786975" y="-45.996090654734985"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="35" fontStyle="bold" hasBackgroundColor="false" hasLineColor="false" height="43.1015625" modelName="custom" textColor="#000000" visible="true" width="896.75634765625" x="12.441855761420697" y="9.10575095451523">EnsEMBL Variation API Overview - Variation centered<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="-4.996003610813204E-16" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="44.009765625" x="-2.6703746829803094" y="1.828125">slice<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="86.24609375" x="-5.2331427351462025" y="1.828125">transcript<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">1..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">1..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">1..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="166.32421875" x="-10.092032452546619" y="1.828125">regulatory_feature<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="231.919921875" x="-14.072174188129566" y="1.828125">get_all_VariationFeatures<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="248.619140625" x="-15.08543045846568" y="1.828125">get_all_PhenotypeFeatures<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="0.0" nodeRatioX="-0.23284227227667542" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="45.69921875" x="-7.849609375" y="-0.96484375">0..1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">1..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="0.0" nodeRatioX="-0.23284227227667542" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">1..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="17.90380859375" x="6.048095703125" y="-0.96484375">1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1PhenotypeFeature.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.43443211495617734" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.20588779337904672" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.4411879640829439" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1Allele.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.40259594275802935" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.2143020363721485" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.5" offsetX="0.0" offsetY="-4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1SampleGenotype.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1PopulationGenotype.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1Variation.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1Population.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.5" offsetX="0.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.3709766275546451" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/funcgen-api/classBio_1_1EnsEMBL_1_1Funcgen_1_1RegulatoryFeature.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.5" offsetX="0.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="22" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="28.578125" modelName="custom" textColor="#FFFFFF" visible="true" width="293.8134765625" x="8.616625120811818" y="46.21426883215236">(e.g. chromosome:1:200-300)<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="-1.1102230246251565E-16" nodeRatioY="0.40547692290741455" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/index.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/core-api/index.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="0.5" nodeRatioX="-0.5" nodeRatioY="0.5" offsetX="4.0" offsetY="-4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/funcgen-api/index.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1VariationFeature.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.5" offsetX="0.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.34642419979557615" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1TranscriptVariation.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.5" offsetX="0.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.34642419979557615" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/core-api/classBio_1_1EnsEMBL_1_1Slice.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.5" offsetX="0.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="22" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="28.578125" modelName="custom" textColor="#FFFFFF" visible="true" width="293.8134765625" x="4.999023437499545" y="39.13793857448891">(e.g. chromosome:1:250-250)<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.5" labelRatioY="0.5" nodeRatioX="0.5" nodeRatioY="0.38691635330044327" offsetX="-4.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/core-api/classBio_1_1EnsEMBL_1_1Transcript.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.5" offsetX="0.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="-7.771561172376096E-16" nodeRatioY="0.41499062991632285" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1TranscriptVariationAllele.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.5" offsetX="0.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.16934033305317642" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.393789488599637" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1OverlapConsequence.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.5" offsetX="0.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="-7.216449660063518E-16" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.393789488599637" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1RegulatoryFeatureVariation.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.5" offsetX="0.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.34642419979557615" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1RegulatoryFeatureVariationAllele.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="0.0" nodeRatioY="-0.5" offsetX="0.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="0.0" nodeRatioY="0.34642419979557615" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="0.0" nodeRatioX="0.5" nodeRatioY="0.0" offsetX="10.521907619201102" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="0.0" nodeRatioX="0.5" nodeRatioY="0.0" offsetX="10.521907619201102" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="0.0" nodeRatioX="0.5" nodeRatioY="0.0" offsetX="10.521907619201102" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.47810238670550653" labelRatioY="0.0" nodeRatioX="0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.47810238670550653" labelRatioY="0.0" nodeRatioX="0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="0.0" nodeRatioX="0.5" nodeRatioY="0.0" offsetX="8.947152000052029" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.5" labelRatioY="-0.5" nodeRatioX="-0.5" nodeRatioY="-0.5" offsetX="4.0" offsetY="4.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="44.009765625" x="-2.6703746829803094" y="1.828125">slice<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="45.69921875" x="-7.849609375" y="-0.96484375">0..1<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:      <data key="d4"><![CDATA[http://www.ensembl.org/info/docs/Doxygen/variation-api/classBio_1_1EnsEMBL_1_1Variation_1_1Publication.html]]></data>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.5" nodeRatioX="2.220446049250313E-16" nodeRatioY="-0.39226139119977765" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.5" nodeRatioX="2.220446049250313E-16" nodeRatioY="0.38824383198268764" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">1..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="21.834581121106055">0..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="-0.24426875055091152" nodeRatioX="0.0" nodeRatioY="0.5" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="25" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="31.9296875" modelName="custom" textColor="#000000" visible="true" width="41.5244140625" x="-5.76220703125" y="-0.96484375">0..*<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="0.0" labelRatioY="0.0" nodeRatioX="0.0" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:NodeLabel alignment="center" autoSizePolicy="content" fontFamily="Arial" fontSize="20" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="26.34375" modelName="custom" textColor="#0D737F" visible="true" width="181.900390625" x="-11.037145757333633" y="1.828125">get_all_Publications<y:LabelModel>
schema/variation_API_diagram.graphml:              <y:SmartNodeLabelModelParameter labelRatioX="-0.4393231332851424" labelRatioY="0.0" nodeRatioX="-0.5" nodeRatioY="0.0" offsetX="0.0" offsetY="0.0" upX="0.0" upY="-1.0"/>
schema/variation_API_diagram.graphml:          <y:Path sx="44.67624411096972" sy="-16.192268824971222" tx="0.0" ty="0.0">
schema/variation_API_diagram.graphml:          <y:Path sx="-73.11835787279495" sy="-27.230737220790047" tx="0.0" ty="0.0">
schema/variation_API_diagram.graphml:          <y:Path sx="-61.83588364599086" sy="24.16720092353978" tx="0.0" ty="0.0">
schema/variation_API_diagram.graphml:          <y:Path sx="-80.90169942010402" sy="12.511118449313244" tx="0.0" ty="0.0">
schema/variation_API_diagram.graphml:          <y:Path sx="0.0" sy="0.0" tx="-125.46173478397395" ty="11.728427950432518">
schema/variation_API_diagram.graphml:          <y:Path sx="79.90416167320564" sy="-14.166960953606804" tx="0.0" ty="0.0"/>
schema/variation_API_diagram.graphml:          <y:Path sx="0.0" sy="0.0" tx="-115.60334969080623" ty="-10.696930227621209">
schema/variation_API_diagram.graphml:          <y:Path sx="-46.48814512298463" sy="-10.646927210064177" tx="0.0" ty="0.0">
Binary file schema/database-schema.mwb matches
travisci/get_dependencies.sh:if [ ! -f v335_base.tar.gz ]; then
travisci/get_dependencies.sh:  tar xzf v335_base.tar.gz && rm -rf v335_base.tar.gz kent-335_base/java kent-335_base/python
travisci/get_dependencies.sh:if [ ! -d Bio-HTS ]; then
travisci/get_dependencies.sh:  git clone --branch release/v2.11 --depth 1 https://github.com/Ensembl/Bio-HTS.git
travisci/build_c.sh:export MACHTYPE=$(uname -m)
travisci/build_c.sh:export MYSQLINC=`mysql_config --include | sed -e 's/^-I//g'`
travisci/build_c.sh:export MYSQLLIBS=`mysql_config --libs`
travisci/build_c.sh:cd kent-335_base/src/lib
travisci/build_c.sh:echo 'CFLAGS="-fPIC"' > ../inc/localEnvironment.mk
travisci/api_build_run_last_hour.py:                          float((datetime.fromtimestamp(time.time()) - datetime.strptime(x['finished_at'],'%Y-%m-%dT%H:%M:%SZ')).total_seconds())/3600 < 1.0)
travisci/harness.sh:export PERL5LIB=$PWD/bioperl-live:$PWD/ensembl-test/modules:$PWD/ensembl/modules:$PWD/ensembl-hive/modules:$PWD/modules:$PWD/scripts/import/:$PWD/ensembl-io/modules:$PWD/ensembl-funcgen/modules
travisci/harness.sh:  PERL5OPT='-MDevel::Cover=+ignore,bioperl,+ignore,ensembl-test,+ignore,ensembl,+ignore,ensembl-hive,+ignore,ensembl-io,+ignore,ensembl-funcgen' perl $PWD/ensembl-test/scripts/runtests.pl -verbose $PWD/modules/t $SKIP_TESTS
travisci/harness.sh:  perl $PWD/ensembl-test/scripts/runtests.pl $PWD/modules/t $SKIP_TESTS
travisci/harness.sh:if [ $rt -eq 0 ]; then
travisci/harness.sh:    cover --nosummary -report coveralls
travisci/trigger-dependent-build.sh:endpoint=https://api.travis-ci.com
travisci/trigger-dependent-build.sh:    curl -s -X GET -H "Authorization: token $AUTH_TOKEN" -H "Travis-API-Version: 3" https://api.travis-ci.com/repo/$1 | python3 -c "import sys, json; print(json.load(sys.stdin)['id'])"
travisci/trigger-dependent-build.sh:  curl -s $endpoint$1 \
travisci/trigger-dependent-build.sh:       -H "Authorization: token $AUTH_TOKEN" \
travisci/trigger-dependent-build.sh:       -H 'Content-Type: application/json' \
travisci/trigger-dependent-build.sh:       -H 'Travis-API-Version: 3' \
travisci/trigger-dependent-build.sh:             -d "{\"env_var\":{\"name\":\"$2\",\"value\":\"$3\",\"public\":true}}" |
travisci/trigger-dependent-build.sh:sp="/-\|"
travisci/trigger-dependent-build.sh:    if travis_api /repo/$dep_repo/builds?build.event_type=api | python3 travisci/api_build_run_last_hour.py | grep -q "True"; then
travisci/trigger-dependent-build.sh:	echo "Detected recent API-triggered build (run in the last hour) ... skip."
travisci/trigger-dependent-build.sh:    echo "----------------------------------"
travisci/trigger-dependent-build.sh:    echo "----------------------------------"
travisci/trigger-dependent-build.sh:    dep_repo_main_build_request_id=`travis_api /repo/$dep_repo/requests -H 'Accept: application/json' -X POST -d "$body" | python3 -c "import sys, json; print(json.load(sys.stdin)['request']['id'])"`
travisci/trigger-dependent-build.sh:    until travis_api /repo/$dep_repo/request/$dep_repo_main_build_request_id | grep -q '"result": "approved"'; do
travisci/trigger-dependent-build.sh:	if [ $i -eq 100 ]
travisci/trigger-dependent-build.sh:    dep_repo_main_build_id=`travis_api /repo/$dep_repo/request/$dep_repo_main_build_request_id | python3 -c "import sys, json; print(json.load(sys.stdin)['builds'][0]['id'])"`
travisci/trigger-dependent-build.sh:    until travis_api /build/$dep_repo_main_build_id | grep -q '"state": "started"'; do
travisci/trigger-dependent-build.sh:	if [ $i -eq 100 ]
travisci/trigger-dependent-build.sh:    # manually. We can do this either through the API, or by going to Settings ->
travisci/trigger-dependent-build.sh:    #   travis_api /settings/env_vars/$env_var_id?repository_id=$dep_repo_id -X DELETE
docker/sift.Dockerfile:# Linux/x86_64 is required -- emulated in ARM platforms (e.g. newer Mac models)
docker/sift.Dockerfile:FROM --platform=linux/x86_64 ubuntu:20.04
docker/sift.Dockerfile:ARG blast_version=ncbi-blast-2.12.0+
docker/sift.Dockerfile:RUN apt-get update && apt-get -y install \
docker/sift.Dockerfile:  && rm -rf /var/lib/apt/lists/*
docker/sift.Dockerfile:ENV BLAST_TAR $blast_version-x64-linux.tar.gz
docker/sift.Dockerfile:RUN BLAST_VERSION=$( echo $blast_version | grep -o "[0-9].*[0-9]" ) && \
docker/sift.Dockerfile:RUN wget https://s3.amazonaws.com/sift-public/nsSNV/$TAR && \
docker/sift.Dockerfile:    tar -xzvf $TAR && \
docker/sift.Dockerfile:RUN sed -Ei "s|(setenv NCBI) .*|\1 $BLAST_BIN|g" SIFT_for_submitting_*.csh
docker/sift.Dockerfile:RUN sed -Ei "s|(setenv SIFT_DIR) .*|\1 $SIFT_DIR|g" SIFT_for_submitting_*.csh
docker/sift.Dockerfile:RUN sed -Ei "s|(setenv BLIMPS_DIR) .*|\1 $BLIMPS_DIR|g" SIFT_for_submitting_*.csh
docker/sift.Dockerfile:RUN sed -Ei 's|\$NCBI/||g' $seqs_chosen
docker/sift.Dockerfile:RUN sed -Ei 's|.*(set tmpdir =).*|\1 "."|g' $seqs_chosen
docker/sift.Dockerfile:# RUN sed -Ei 's|(.*rm \$pid\.TEMP\*)|#\1|g' $seqs_chosen
docker/sift.Dockerfile:RUN sed -Ei 's|(.*limit cputime.*)|#\1|g' $seqs_chosen # avoid CPU time limit
docker/sift.Dockerfile:RUN sed -Ei 's|(set median_threshold = )2.75;|\1$3|g' $seqs_chosen
docker/sift.Dockerfile:RUN sed -i '/exiting/{n;s/exit (-1)/#exit (-1)/}' $seqs_chosen
docker/polyphen2.Dockerfile:# Linux/x86_64 is required -- emulated in ARM platforms (e.g. newer Mac models)
docker/polyphen2.Dockerfile:FROM --platform=linux/x86_64 bioperl/bioperl
docker/polyphen2.Dockerfile:ARG pph2_version=polyphen-2.2.3r407
docker/polyphen2.Dockerfile:ARG blast_version=ncbi-blast-2.12.0+
docker/polyphen2.Dockerfile:RUN apt-get update && apt-get install -y \
docker/polyphen2.Dockerfile:  build-essential \
docker/polyphen2.Dockerfile:  default-jre \
docker/polyphen2.Dockerfile:  libscalar-list-utils-perl \
docker/polyphen2.Dockerfile:  libxml-simple-perl \
docker/polyphen2.Dockerfile:  libdbd-sqlite3-perl \
docker/polyphen2.Dockerfile:  libcgi-pm-perl \
docker/polyphen2.Dockerfile:  && rm -rf /var/lib/apt/lists/*
docker/polyphen2.Dockerfile:# Download PolyPhen-2
docker/polyphen2.Dockerfile:#RUN apt-get install -y curl
docker/polyphen2.Dockerfile:ENV BLAST_TAR $blast_version-x64-linux.tar.gz
docker/polyphen2.Dockerfile:RUN BLAST_VERSION=$( echo $blast_version | grep -o "[0-9].*[0-9]" ) && \
docker/polyphen2.Dockerfile:# Build PolyPhen-2
docker/polyphen2.Dockerfile:RUN apt-get update && apt-get install -y unzip && \
docker/polyphen2.Dockerfile:    apt-get install unzip && rm -rf /var/lib/apt/lists/* && rm ~/.wgetrc && \
docker/polyphen2.Dockerfile:# Move data directories to /opt/pph2/data and symlink as expected by PolyPhen-2
docker/polyphen2.Dockerfile:# Polyphen-2 data can thus be mounted with a single bind mount, e.g.:
docker/polyphen2.Dockerfile:#   docker run -v ${HOME}/pph2_data:/opt/pph2/data -ti pph2
docker/polyphen2.Dockerfile:    ln -s data/* .
scripts/import/import_affymetrix_chip.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_affymetrix_chip.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_affymetrix_chip.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_affymetrix_chip.pl:my $usage = "Usage:\n\timport_illumina_chip.pl -input [Affymetrix annotation file] -chip_name [Affymetrix chip name] 
scripts/import/import_affymetrix_chip.pl:-description [Affymetrix chip desc] -version [chip version] -chip_url [chip url (optional)]  -short_name [Variation set short name] 
scripts/import/import_affymetrix_chip.pl:-registry [Path to the registry file] -species [Species name] -debug [debug mode]\n";
scripts/import/import_affymetrix_chip.pl:die "\nError - no registry \n\n $usage"    unless defined $registry_file;
scripts/import/import_affymetrix_chip.pl:die "\nError - no species \n\n $usage"     unless defined $species;
scripts/import/import_affymetrix_chip.pl:die "\nError - no chip_name \n\n $usage"   unless defined $chip_name;
scripts/import/import_affymetrix_chip.pl:die "\nError - no description \n\n $usage" unless defined $chip_desc;
scripts/import/import_affymetrix_chip.pl:die "\nError - no input file \n\n $usage"  unless defined $infile;
scripts/import/import_affymetrix_chip.pl:die "\nError - no short name \n\n $usage"  unless defined $short_name;
scripts/import/import_affymetrix_chip.pl:$registry->load_all($registry_file);
scripts/import/import_affymetrix_chip.pl:my $slice_adaptor = $registry->get_adaptor($species, 'core', 'slice');
scripts/import/import_affymetrix_chip.pl:my $var_adaptor   = $registry->get_adaptor($species, 'variation', 'variation');
scripts/import/import_affymetrix_chip.pl:my $dbh = $var_adaptor->dbc->db_handle;
scripts/import/import_affymetrix_chip.pl:      # 1 - Add a variation entry
scripts/import/import_affymetrix_chip.pl:      # 2 - Check alleles (flip ?) => check reference using location
scripts/import/import_affymetrix_chip.pl:      my $seq_region_id = $seq_region_ids->{$data{'CHROMOSOME'}};
scripts/import/import_affymetrix_chip.pl:      # 3 - Add alleles
scripts/import/import_affymetrix_chip.pl:        # 4 - Add VF if alleles and location OK (QC ?) 
scripts/import/import_affymetrix_chip.pl:        # 5 - Failed variants
scripts/import/import_affymetrix_chip.pl:  if ($dbh->selectrow_arrayref(qq{SELECT source_id FROM source WHERE name='$chip_name';})) {
scripts/import/import_affymetrix_chip.pl:    $dbh->do(qq{UPDATE IGNORE source SET description='$chip_desc',url='$chip_url',version=$version where name='$chip_name';});
scripts/import/import_affymetrix_chip.pl:    $dbh->do(qq{INSERT INTO source (name,description,url,version,type) VALUES ('$chip_name','$chip_desc','$chip_url',$version,'chip');});
scripts/import/import_affymetrix_chip.pl:  my @source_id = @{$dbh->selectrow_arrayref(qq{SELECT source_id FROM source WHERE name='$chip_name';})};
scripts/import/import_affymetrix_chip.pl:  my $var_name = ($data->{'DBSNP_RS_ID'} =~ /^rs\d+$/) ? $data->{'DBSNP_RS_ID'} : $data->{'CUST_SNPID'};
scripts/import/import_affymetrix_chip.pl:  $var = get_variant_by_name($data->{'CUST_SNPID'}) if (!$var && $var_name ne $data->{'CUST_SNPID'});
scripts/import/import_affymetrix_chip.pl:  return ($var) ? [$var->dbID,$var->name] : [undef,undef];
scripts/import/import_affymetrix_chip.pl:  my $var = $var_adaptor->fetch_by_name($name);
scripts/import/import_affymetrix_chip.pl:  my $sth = $dbh->prepare(qq{SELECT attrib_id FROM attrib WHERE value="SNV"});
scripts/import/import_affymetrix_chip.pl:  $sth->execute()|| die "Problem getting class attrib ID\n";
scripts/import/import_affymetrix_chip.pl:  my $res = $sth->fetchall_arrayref();
scripts/import/import_affymetrix_chip.pl:  return (defined($res)) ? $res->[0]->[0] : 2;
scripts/import/import_affymetrix_chip.pl:  A/T/C/G/- expected for chips
scripts/import/import_affymetrix_chip.pl:  my $allele_code_ext_sth = $dbh->prepare(qq{SELECT allele_code_id, allele FROM allele_code});
scripts/import/import_affymetrix_chip.pl:  $allele_code_ext_sth->execute()|| die "Problem getting codes\n";
scripts/import/import_affymetrix_chip.pl:  my $al_data = $allele_code_ext_sth->fetchall_arrayref();
scripts/import/import_affymetrix_chip.pl:    $code{$l->[1]} = $l->[0];
scripts/import/import_affymetrix_chip.pl:  my $seq_region_ids_ext_sth = $dbh->prepare(qq{SELECT seq_region_id, name FROM seq_region});
scripts/import/import_affymetrix_chip.pl:  $seq_region_ids_ext_sth->execute() || die "Error extracting seq_region_ids\n";
scripts/import/import_affymetrix_chip.pl:  my $data = $seq_region_ids_ext_sth->fetchall_arrayref();
scripts/import/import_affymetrix_chip.pl:  unless(defined $data->[0]->[0]){die "No seq region ids available\n";} 
scripts/import/import_affymetrix_chip.pl:    $seq_region_ids{$l->[1]} = $l->[0];
scripts/import/import_affymetrix_chip.pl:    my $chr     = $data_row->{'CHROMOSOME'};
scripts/import/import_affymetrix_chip.pl:    my $start   = $data_row->{'PHYSICAL_POSITION'};
scripts/import/import_affymetrix_chip.pl:    my @alleles = ($data_row->{'ALLELE_A'}, $data_row->{'ALLELE_B'});
scripts/import/import_affymetrix_chip.pl:    my $seq_region_id = $seq_region_ids->{$chr};
scripts/import/import_affymetrix_chip.pl:    my $var_id_chrom_pos_ext_sth = $dbh->prepare(qq{SELECT 
scripts/import/import_affymetrix_chip.pl:    $var_id_chrom_pos_ext_sth->execute($start,$seq_region_id) || die "Error extracting var by location for $start,$chr,$allele_string\n";
scripts/import/import_affymetrix_chip.pl:    my $data = $var_id_chrom_pos_ext_sth->fetchall_arrayref();
scripts/import/import_affymetrix_chip.pl:    return [undef,undef] unless defined $data->[0]->[0];
scripts/import/import_affymetrix_chip.pl:    debug("check_by_location: Name: $data->[0]->[1] | Alleles: $data->[0]->[2] | Strand: $data->[0]->[3]") if ($debug);
scripts/import/import_affymetrix_chip.pl:    my $check_allele = $data->[0]->[2];
scripts/import/import_affymetrix_chip.pl:      if( $same == 0 && $data->[0]->[3] eq "-1"){
scripts/import/import_affymetrix_chip.pl:      debug("check_by_location: Existing variant found: $data->[0]->[2]") if ($debug);
scripts/import/import_affymetrix_chip.pl:      return [$data->[0]->[0],$data->[0]->[1]];
scripts/import/import_affymetrix_chip.pl:      debug("check_by_location: Strand & allele string incompatibile! See: $allele_string (data) vs $check_allele (ref)  | $data->[0]->[1] & $data->[0]->[2] (Strand $data->[0]->[3])") if ($debug);
scripts/import/import_affymetrix_chip.pl:  my $chr      = $data->{'CHROMOSOME'};
scripts/import/import_affymetrix_chip.pl:  my $position = $data->{'PHYSICAL_POSITION'};
scripts/import/import_affymetrix_chip.pl:  my @alleles  = ($data->{'ALLELE_A'},$data->{'ALLELE_B'});
scripts/import/import_affymetrix_chip.pl:  my $slice = $slice_adaptor->fetch_by_region('chromosome', $chr, $position, $position, 1);
scripts/import/import_affymetrix_chip.pl:  my $ref_allele = $slice->seq;
scripts/import/import_affymetrix_chip.pl:  $dbh->do(qq{INSERT INTO variation (name,source_id,class_attrib_id) VALUES ('$name', $source_id, $class_attrib_id);});
scripts/import/import_affymetrix_chip.pl:  my $var_id = $dbh->{'mysql_insertid'};
scripts/import/import_affymetrix_chip.pl:  $dbh->do(qq{INSERT INTO variation_synonym (variation_id,name,source_id) VALUES ($var_id, '$syn_name', $source_id);});
scripts/import/import_affymetrix_chip.pl:    @alleles_list = ($data->{'ALLELE_A'},$data->{'ALLELE_B'});
scripts/import/import_affymetrix_chip.pl:  @alleles_list = map{ $al_codes->{$_} } @alleles_list;
scripts/import/import_affymetrix_chip.pl:    $dbh->do(qq{INSERT INTO allele (variation_id,allele_code_id) VALUES ($var_id, $al_id);});
scripts/import/import_affymetrix_chip.pl:  $dbh->do(qq{ INSERT INTO variation_feature (
scripts/import/import_affymetrix_chip.pl:  $dbh->do(qq{ INSERT INTO failed_variation (variation_id,failed_description_id) VALUES ($var_id,$failed_id)});
scripts/import/import_affymetrix_chip.pl:  $dbh->do(qq{ UPDATE variation SET display=0 WHERE variation_id=$var_id});
scripts/import/import_affymetrix_chip.pl:  $dbh->do(qq{ UPDATE variation_feature SET display=0 WHERE variation_id=$var_id});
scripts/import/import_affymetrix_chip.pl:  my $sth1 = $dbh->prepare(qq{ SELECT vs.variation_set_id
scripts/import/import_affymetrix_chip.pl:  $sth1->execute($short_name) || die "Error extracting variation set ID from the short name $short_name\n";
scripts/import/import_affymetrix_chip.pl:  my $data = $sth1->fetchall_arrayref();
scripts/import/import_affymetrix_chip.pl:  if (defined $data->[0]->[0]) {
scripts/import/import_affymetrix_chip.pl:    return $data->[0]->[0];
scripts/import/import_affymetrix_chip.pl:  $dbh->do(qq{ INSERT INTO variation_set_variation (variation_id,variation_set_id) VALUES ($var_id,$var_set_id) }); 
scripts/import/compress_genotypes_by_region_from_file.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/compress_genotypes_by_region_from_file.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/compress_genotypes_by_region_from_file.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/compress_genotypes_by_region_from_file.pl:  Use this script to re-import files dumped by
scripts/import/compress_genotypes_by_region_from_file.pl:  ensembl-variation/scripts/export/dump_compressed_genotypes.pl
scripts/import/compress_genotypes_by_region_from_file.pl:use constant MAX_SHORT => 2**16 -1;
scripts/import/compress_genotypes_by_region_from_file.pl:usage('-TMP_DIR argument is required') if(!$TMP_DIR);
scripts/import/compress_genotypes_by_region_from_file.pl:usage('-TMP_FILE argument is required') if(!$TMP_FILE);
scripts/import/compress_genotypes_by_region_from_file.pl:usage('-species argument is required') if(!$species);
scripts/import/compress_genotypes_by_region_from_file.pl:$reg->load_all( $registry_file );
scripts/import/compress_genotypes_by_region_from_file.pl:$reg->set_reconnect_when_lost();
scripts/import/compress_genotypes_by_region_from_file.pl:my $vdba = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/compress_genotypes_by_region_from_file.pl:my $dbVar = $vdba->dbc;
scripts/import/compress_genotypes_by_region_from_file.pl:      my $dbVar_write = $vdba->dbc->db_handle;
scripts/import/compress_genotypes_by_region_from_file.pl:    next if (defined $genotypes->{$sample_id}->{region_end} && $seq_region_start == $genotypes->{$sample_id}->{region_end}); #same variation and individual but different genotype !!!
scripts/import/compress_genotypes_by_region_from_file.pl:    if (!defined $genotypes->{$sample_id}->{region_start}){
scripts/import/compress_genotypes_by_region_from_file.pl:      $genotypes->{$sample_id}->{region_start} = $seq_region_start;
scripts/import/compress_genotypes_by_region_from_file.pl:      $genotypes->{$sample_id}->{region_end} = $seq_region_end;
scripts/import/compress_genotypes_by_region_from_file.pl:    if ((abs($genotypes->{$sample_id}->{region_start} - $seq_region_start) > DISTANCE()) || (abs($seq_region_start - $genotypes->{$sample_id}->{region_end}) > MAX_SHORT)){
scripts/import/compress_genotypes_by_region_from_file.pl:      delete $genotypes->{$sample_id}; #and remove the printed entry
scripts/import/compress_genotypes_by_region_from_file.pl:      $genotypes->{$sample_id}->{region_start} = $seq_region_start;
scripts/import/compress_genotypes_by_region_from_file.pl:    if ($seq_region_start != $genotypes->{$sample_id}->{region_start}){					
scripts/import/compress_genotypes_by_region_from_file.pl:      $blob = pack ("w",$seq_region_start - $genotypes->{$sample_id}->{region_end} - 1);
scripts/import/compress_genotypes_by_region_from_file.pl:      $genotypes->{$sample_id}->{genotypes} .= escape($blob) .escape(pack("w", $variation_id)). escape(pack("w", $genotype_code));
scripts/import/compress_genotypes_by_region_from_file.pl:      $genotypes->{$sample_id}->{genotypes} = escape(pack("w", $variation_id)).escape(pack("w", $genotype_code));
scripts/import/compress_genotypes_by_region_from_file.pl:    $genotypes->{$sample_id}->{region_end} = $seq_region_start;    #to avoid nasty effects of indels coordinates
scripts/import/compress_genotypes_by_region_from_file.pl:      print FH join("\t",$sample_id,$seq_region_id, $genotypes->{$sample_id}->{region_start}, $genotypes->{$sample_id}->{region_end}, 1, $genotypes->{$sample_id}->{genotypes}) . "\n";
scripts/import/compress_genotypes_by_region_from_file.pl:    print FH join("\t",$sample_id,$seq_region_id, $genotypes->{$sample_id}->{region_start}, $genotypes->{$sample_id}->{region_end}, 1, $genotypes->{$sample_id}->{genotypes}) . "\n";
scripts/import/compress_genotypes_by_region_from_file.pl:	while(-e $lock_file) {
scripts/import/compress_genotypes_by_region_from_file.pl:  #$dbVar->do(qq{LOAD DATA INFILE "$TMP_DIR/$dump_file" INTO TABLE compressed_genotype_region});
scripts/import/remove_cosmic_or_hgmd.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/remove_cosmic_or_hgmd.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/remove_cosmic_or_hgmd.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/remove_cosmic_or_hgmd.pl:# Deletes all COSMIC or HGMD-PUBLIC data from a variation database
scripts/import/remove_cosmic_or_hgmd.pl:    print "Usage: $0 --registry <reg_file> --source <source_name> --help\n";
scripts/import/remove_cosmic_or_hgmd.pl:    print "\nDeletes all COSMIC or HGMD-PUBLIC data from an Ensembl variation database\n";
scripts/import/remove_cosmic_or_hgmd.pl:$source_name = 'HGMD-PUBLIC' if ($source_name =~ /hgmd/i);
scripts/import/remove_cosmic_or_hgmd.pl:$registry->load_all($registry_file);
scripts/import/remove_cosmic_or_hgmd.pl:my $dbh = $registry->get_adaptor(
scripts/import/remove_cosmic_or_hgmd.pl:)->dbc->db_handle;
scripts/import/remove_cosmic_or_hgmd.pl:my $get_source_sth = $dbh->prepare(qq{
scripts/import/remove_cosmic_or_hgmd.pl:$get_source_sth->execute;
scripts/import/remove_cosmic_or_hgmd.pl:my ($source_id) = $get_source_sth->fetchrow_array;
scripts/import/remove_cosmic_or_hgmd.pl:# failed_variation - variation_id
scripts/import/remove_cosmic_or_hgmd.pl:$dbh->do(qq{
scripts/import/remove_cosmic_or_hgmd.pl:print "- 'failed_variation' entries deleted\n";
scripts/import/remove_cosmic_or_hgmd.pl:my $tv_del_sth = $dbh->prepare(qq[ SELECT vf.variation_feature_id from variation_feature vf
scripts/import/remove_cosmic_or_hgmd.pl:$tv_del_sth->execute() || die "Error selecting variation feature from $source_name\n";
scripts/import/remove_cosmic_or_hgmd.pl:my $tv_to_del = $tv_del_sth->fetchall_arrayref();
scripts/import/remove_cosmic_or_hgmd.pl:  my $vf_id_del = $to_del->[0];
scripts/import/remove_cosmic_or_hgmd.pl:  my $del_vf_sth = $dbh->prepare(qq[ DELETE FROM variation_feature WHERE variation_feature_id = $vf_id_del ]);
scripts/import/remove_cosmic_or_hgmd.pl:  my $del_sth = $dbh->prepare(qq[ DELETE FROM transcript_variation WHERE variation_feature_id = $vf_id_del ]);
scripts/import/remove_cosmic_or_hgmd.pl:  my $del_mtmp_sth = $dbh->prepare(qq[ DELETE FROM MTMP_transcript_variation WHERE variation_feature_id = $vf_id_del ]);
scripts/import/remove_cosmic_or_hgmd.pl:  $del_vf_sth->execute() || die "Could not delete entry with variation_feature_id = $vf_id_del from variation_feature\n";
scripts/import/remove_cosmic_or_hgmd.pl:  $del_sth->execute() || die "Could not delete entry with variation_feature_id = $vf_id_del from transcript_variation\n";
scripts/import/remove_cosmic_or_hgmd.pl:  $del_mtmp_sth->execute() || die "Could not delete entry with variation_feature_id = $vf_id_del from MTMP_transcript_variation\n";
scripts/import/remove_cosmic_or_hgmd.pl:print "- 'variation_feature', 'transcript_variation' and 'MTMP_transcript_variation' entries deleted\n";
scripts/import/remove_cosmic_or_hgmd.pl:$dbh->do(qq{
scripts/import/remove_cosmic_or_hgmd.pl:print "- 'phenotype_feature_attrib' entries deleted\n";
scripts/import/remove_cosmic_or_hgmd.pl:$dbh->do(qq{
scripts/import/remove_cosmic_or_hgmd.pl:print "- 'phenotype_feature' entries deleted\n";
scripts/import/remove_cosmic_or_hgmd.pl:# variation_set_variation - variation_id
scripts/import/remove_cosmic_or_hgmd.pl:$dbh->do(qq{
scripts/import/remove_cosmic_or_hgmd.pl:print "- 'variation_set_variation' entries deleted\n";
scripts/import/remove_cosmic_or_hgmd.pl:$dbh->do(qq{
scripts/import/remove_cosmic_or_hgmd.pl:print "- 'variation_synonym' entries deleted\n";
scripts/import/remove_cosmic_or_hgmd.pl:$dbh->do(qq{
scripts/import/remove_cosmic_or_hgmd.pl:print "- 'variation' entries deleted\n";
scripts/import/import_human_ontology_terms.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_human_ontology_terms.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_human_ontology_terms.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_human_ontology_terms.pl:$reg->load_all($registry_file);
scripts/import/import_human_ontology_terms.pl:my $dba = $reg->get_DBAdaptor($species,'variation');
scripts/import/import_human_ontology_terms.pl:my $all_phenos = get_all_phenos($dba->dbc->db_handle );
scripts/import/import_human_ontology_terms.pl:my $non_matched_phenos = get_termless_phenos($dba->dbc->db_handle);
scripts/import/import_human_ontology_terms.pl:  my $non_matched_phenos = get_termless_phenos($dba->dbc->db_handle);
scripts/import/import_human_ontology_terms.pl:    my $search_term = $phenos->{$id};
scripts/import/import_human_ontology_terms.pl:      next if length($search_term) == length($phenos->{$id});
scripts/import/import_human_ontology_terms.pl:      print "Seeking $search_term from $phenos->{$id}\n";
scripts/import/import_human_ontology_terms.pl:    foreach my $doc (@{$ontol_data->{response}->{docs}}){ 
scripts/import/import_human_ontology_terms.pl:        next unless $doc->{ontology_prefix} =~/EFO|Orphanet|ORDO|HP/;
scripts/import/import_human_ontology_terms.pl:        next unless $doc->{ontology_prefix} =~/VT/;
scripts/import/import_human_ontology_terms.pl:      push @terms, iri2acc($doc->{iri});
scripts/import/import_human_ontology_terms.pl:    my $desc = $phenos->{$id};
scripts/import/import_human_ontology_terms.pl:  my $pheno_adaptor = $reg->get_adaptor($species,'variation', 'Phenotype');
scripts/import/import_human_ontology_terms.pl:    my $pheno = $pheno_adaptor->fetch_by_dbID( $id );
scripts/import/import_human_ontology_terms.pl:    foreach my $accession (@{$terms->{$id}->{terms}}){
scripts/import/import_human_ontology_terms.pl:      print $out "$id\t$accession\t$terms->{$id}->{type}\t" . $pheno->description() ."\n";
scripts/import/import_human_ontology_terms.pl:      $pheno->add_ontology_accession({ accession      => $accession, 
scripts/import/import_human_ontology_terms.pl:                                       mapping_source => $terms->{$id}->{type},
scripts/import/import_human_ontology_terms.pl:    $pheno_adaptor->store_ontology_accessions($pheno);
scripts/import/import_human_ontology_terms.pl:  my $desc_ext_sth = $dbh->prepare(qq [ select phenotype_id, description from phenotype ]);
scripts/import/import_human_ontology_terms.pl:  $desc_ext_sth->execute()||die "Problem extracting all phenotype descriptions\n";
scripts/import/import_human_ontology_terms.pl:  my $data = $desc_ext_sth->fetchall_arrayref();
scripts/import/import_human_ontology_terms.pl:   $pheno{$l->[0]} = $l->[1];
scripts/import/import_human_ontology_terms.pl:  my $desc_ext_sth =   $dbh->prepare(qq [ select phenotype_id, description
scripts/import/import_human_ontology_terms.pl:  $desc_ext_sth->execute()||die "Problem extracting termless phenotype descriptions\n";
scripts/import/import_human_ontology_terms.pl:  my $data = $desc_ext_sth->fetchall_arrayref();
scripts/import/import_human_ontology_terms.pl:   $pheno{$l->[0]} = $l->[1];
scripts/import/import_human_ontology_terms.pl:    next unless $annot->{confidence} eq 'HIGH';
scripts/import/import_human_ontology_terms.pl:    foreach my $term (@{$annot->{semanticTags}} ){
scripts/import/import_human_ontology_terms.pl:      print $out "$term\t$annot->{confidence}\t$desc\n";
scripts/import/import_human_ontology_terms.pl:    next unless $annot->{derivedFrom}->{provenance}->{source}->{name} eq 'eva-clinvar';
scripts/import/import_human_ontology_terms.pl:      next unless $annot->{confidence} eq $confLevel;
scripts/import/import_human_ontology_terms.pl:    next unless grep(/EFO|Orphanet|ORDO|HP/, @{$annot->{semanticTags}});
scripts/import/import_human_ontology_terms.pl:    foreach my $term (@{$annot->{semanticTags}} ){
scripts/import/import_human_ontology_terms.pl:      print $out "$term\t$annot->{confidence}\t$desc\tEVA\n";
scripts/import/import_human_ontology_terms.pl:  my $http = HTTP::Tiny->new();
scripts/import/import_human_ontology_terms.pl:  my $response = $http->get($request, {
scripts/import/import_human_ontology_terms.pl:        headers => { 'Content-type' => 'application/xml' }
scripts/import/import_human_ontology_terms.pl:  unless ($response->{success}){
scripts/import/import_human_ontology_terms.pl:  return JSON->new->decode($response->{content} );
scripts/import/import_human_ontology_terms.pl:  my $http = HTTP::Tiny->new();
scripts/import/import_human_ontology_terms.pl:  my $response = $http->get($request, {
scripts/import/import_human_ontology_terms.pl:      headers => { 'Content-type' => 'application/xml' }
scripts/import/import_human_ontology_terms.pl:  unless ($response->{success}){
scripts/import/import_human_ontology_terms.pl: return JSON->new->decode($response->{content} );
scripts/import/import_clinvar_xml:Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_clinvar_xml:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_clinvar_xml:     http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_clinvar_xml:  - parse ClinVar XML and import data for dbSNP or dbVar variants
scripts/import/import_clinvar_xml:  - add the short variant data if ClinVar is releasing ahead of dbSNP
scripts/import/import_clinvar_xml:  - only import ClinVar records for structural variants already in ensembl
scripts/import/import_clinvar_xml:  - use the positions of the features held in ensembl where possible
scripts/import/import_clinvar_xml:  - attribs entered
scripts/import/import_clinvar_xml:  - review_status    = Status
scripts/import/import_clinvar_xml:  - external_id      = Acc
scripts/import/import_clinvar_xml:  - clinvar_clin_sig = Desc
scripts/import/import_clinvar_xml:  - risk_allele      = HGVS allele (dbSNP variants only)
scripts/import/import_clinvar_xml:die "File not found: $data_file\n" unless -e $data_file;
scripts/import/import_clinvar_xml:$reg->load_all($registry_file);
scripts/import/import_clinvar_xml:my $dba = $reg->get_DBAdaptor('homo_sapiens','variation');
scripts/import/import_clinvar_xml:$dba->include_failed_variations(1);
scripts/import/import_clinvar_xml:my $dbh = $dba->dbc;
scripts/import/import_clinvar_xml:$dbh->reconnect_when_lost(1);
scripts/import/import_clinvar_xml:my $variation_adaptor     = $dba->get_VariationAdaptor('human', 'variation', );
scripts/import/import_clinvar_xml:my $var_feat_adaptor      = $dba->get_VariationFeatureAdaptor('human', 'variation', );
scripts/import/import_clinvar_xml:my $tva                   = $dba->get_TranscriptVariationAdaptor('human', 'variation', );
scripts/import/import_clinvar_xml:my $structvar_adaptor     = $dba->get_StructuralVariationAdaptor('human', 'variation', );
scripts/import/import_clinvar_xml:my $attrib_adaptor        = $dba->get_AttributeAdaptor();
scripts/import/import_clinvar_xml:my $pheno_feat_adaptor    = $reg->get_adaptor('homo_sapiens', 'variation', 'phenotypefeature');
scripts/import/import_clinvar_xml:my $phenotype_adaptor     = $reg->get_adaptor('homo_sapiens', 'variation', 'phenotype');
scripts/import/import_clinvar_xml:my $slice_adaptor         = $reg->get_adaptor('homo_sapiens', 'core', 'slice');
scripts/import/import_clinvar_xml:$slice_adaptor->dbc->reconnect_when_lost(1);
scripts/import/import_clinvar_xml:## pre-load submitter ids - shortcutting the API for speed
scripts/import/import_clinvar_xml:## handle incomplete runs - takes list of ClinVar RC accessions 
scripts/import/import_clinvar_xml:my $reader = XML::LibXML::Reader->new(IO => $data_file_fh);
scripts/import/import_clinvar_xml:while($reader->read) {
scripts/import/import_clinvar_xml:  next unless $reader->nodeType == XML_READER_TYPE_ELEMENT;
scripts/import/import_clinvar_xml:  next unless $reader->name eq 'ReleaseSet' || $reader->name eq 'ClinVarSet';
scripts/import/import_clinvar_xml:  if ($reader->name eq 'ReleaseSet') {
scripts/import/import_clinvar_xml:    my $releaseDate = $reader->getAttribute('Dated'); #2019-04-04
scripts/import/import_clinvar_xml:      $versionDate->parse($releaseDate);
scripts/import/import_clinvar_xml:    my $xml = $reader->readOuterXml;
scripts/import/import_clinvar_xml:    my $conv = XML::Hash::XS->new(utf8 => 0, encoding => 'utf-8');
scripts/import/import_clinvar_xml:    my $set  = $conv->xml2hash($xml, encoding => 'latin1'); #nice encoding of special char
scripts/import/import_clinvar_xml:    $record{Acc} = get_accession($set->{ReferenceClinVarAssertion}->{ClinVarAccession});
scripts/import/import_clinvar_xml:    $record{Desc} = get_clinsig ($set->{ReferenceClinVarAssertion}->{ClinicalSignificance});
scripts/import/import_clinvar_xml:    $record{Status} = $set->{ReferenceClinVarAssertion}->{ClinicalSignificance}->{ReviewStatus};
scripts/import/import_clinvar_xml:    $record{DateLastEvaluated} =  $set->{ReferenceClinVarAssertion}->{ClinicalSignificance}->{DateLastEvaluated};
scripts/import/import_clinvar_xml:    $record{inheritance_type} = get_inheritance($set->{ReferenceClinVarAssertion}->{AttributeSet});
scripts/import/import_clinvar_xml:    ($record{disease}, $record{ontology_accession}) = get_disease($set->{ReferenceClinVarAssertion}->{TraitSet}->{Trait}, $record{Acc});
scripts/import/import_clinvar_xml:    $record{citations} = get_citations($set->{ReferenceClinVarAssertion}->{ObservedIn}, "ObservedData");
scripts/import/import_clinvar_xml:    my $extra_citations = get_citations($set->{ClinVarAssertion}, "ClinicalSignificance");
scripts/import/import_clinvar_xml:    print "WARNING: Found GenotypeSet(type: $set->{ReferenceClinVarAssertion}->{GenotypeSet}->{Type}) found for $record{Acc}.\n" if defined $set->{ReferenceClinVarAssertion}->{GenotypeSet};
scripts/import/import_clinvar_xml:    if (! defined $set->{ReferenceClinVarAssertion}->{MeasureSet} ||
scripts/import/import_clinvar_xml:      !defined $set->{ReferenceClinVarAssertion}->{MeasureSet}->{Type}){
scripts/import/import_clinvar_xml:    if ( $set->{ReferenceClinVarAssertion}->{MeasureSet}->{Type} ne "Variant" &&
scripts/import/import_clinvar_xml:      $set->{ReferenceClinVarAssertion}->{MeasureSet}->{Type} ne $haplotype_type ) {
scripts/import/import_clinvar_xml:        print "WARNING: Unsupported MeasureSet Type found for $record{Acc}: $set->{ReferenceClinVarAssertion}->{MeasureSet}->{Type} .\n";
scripts/import/import_clinvar_xml:    $record{clinvar_variant_id} = $set->{ReferenceClinVarAssertion}->{MeasureSet}->{Acc};
scripts/import/import_clinvar_xml:    $record{feature_info} = get_feature($set->{ReferenceClinVarAssertion}->{MeasureSet}->{Measure}, $record{Acc},$set->{ReferenceClinVarAssertion}->{MeasureSet}->{Type});
scripts/import/import_clinvar_xml:    $record{submitters} = get_submitters($set->{ClinVarAssertion}, $record{feature_info});
scripts/import/import_clinvar_xml:      if( defined $record{feature_info}->{dbVar} && $record{feature_info}->{dbVar}->[0] =~/\d+/ ){
scripts/import/import_clinvar_xml:        warn "Importing SV :  $record{feature_info}->{dbVar}->[0]\n" if $DEBUG == 1;
scripts/import/import_clinvar_xml:      if( exists $record{feature_info}->{dbSNP} && $record{feature_info}->{dbSNP}->[0] =~/\d+/ ){
scripts/import/import_clinvar_xml:         print "Importing Var :  $record{feature_info}->{dbSNP}->[0] ($record{Acc})\n" if $DEBUG == 1;
scripts/import/import_clinvar_xml:    	$message .= " rs: $record{feature_info}->{dbSNP} "        if defined $record{feature_info}->{dbSNP} ;
scripts/import/import_clinvar_xml:    	$message .= " on chr: $record{feature_info}->{Chr} "      if defined $record{feature_info}->{Chr} ;
scripts/import/import_clinvar_xml:    	$message .= " with HGVS: $record{feature_info}->{hgvs_g}" if defined $record{feature_info}->{hgvs_g} ;
scripts/import/import_clinvar_xml:      'name' => 'All phenotype/disease-associated variants'},
scripts/import/import_clinvar_xml:      'desc' => 'Variants described by ClinVar as being probable-pathogenic, pathogenic, drug-response or histocompatibility',
scripts/import/import_clinvar_xml:  my $set_ext_sth = $dbh->prepare(qq[ select variation_set_id
scripts/import/import_clinvar_xml:  my $set_ins_sth = $dbh->prepare(qq[ insert into variation_set
scripts/import/import_clinvar_xml:  my $set_del_sth = $dbh->prepare(qq[ delete from variation_set_variation where variation_set_id = ?]);
scripts/import/import_clinvar_xml:  $set_ext_sth->execute( $set);
scripts/import/import_clinvar_xml:  my $set_id = $set_ext_sth->fetchall_arrayref();
scripts/import/import_clinvar_xml:  if (defined $set_id->[0]->[0] ){
scripts/import/import_clinvar_xml:    $set_del_sth->execute($set_id->[0]->[0]) if defined $clean;
scripts/import/import_clinvar_xml:    return $set_id->[0]->[0] ;
scripts/import/import_clinvar_xml:  $set_ins_sth->execute( $data->{$set}->{name}, $data->{$set}->{desc}, $attrib_id );
scripts/import/import_clinvar_xml:  $set_id = $dbh->db_handle->last_insert_id(undef, undef, qw(variation_set set_id))|| die "no insert id for set $set\n";
scripts/import/import_clinvar_xml:  my $accession =  $ClinVarAccession->{Acc} .".".  $ClinVarAccession->{Version} ;
scripts/import/import_clinvar_xml:  if ($ClinicalSignificance->{Description} =~/conflict/){
scripts/import/import_clinvar_xml:    ## Description = 'conflicting data from submitters' - the values are in the explanation
scripts/import/import_clinvar_xml:    defined $ClinicalSignificance->{Explanation} ?
scripts/import/import_clinvar_xml:    $desc = "\L$ClinicalSignificance->{Explanation}->[0]" :
scripts/import/import_clinvar_xml:    $desc = "\L$ClinicalSignificance->{Description}";
scripts/import/import_clinvar_xml:- mode of inheritance attribute holds somatic status
scripts/import/import_clinvar_xml:    next unless defined $attribute->{Attribute} &&
scripts/import/import_clinvar_xml:                      $attribute->{Attribute}->{Type} eq 'ModeOfInheritance';
scripts/import/import_clinvar_xml:    $moi = $attribute->{Attribute}->{content};
scripts/import/import_clinvar_xml:- get variant/ structural variant info + location on required assembly
scripts/import/import_clinvar_xml:- inlude OMIM ids and HGVS for short variants 
scripts/import/import_clinvar_xml:      warn "Multiple measures for $accession - not loading\n";
scripts/import/import_clinvar_xml:    if(defined $measure->{XRef}){
scripts/import/import_clinvar_xml:      my $xref_set = to_array($measure->{XRef});
scripts/import/import_clinvar_xml:        if (defined $xref->{Type}) {
scripts/import/import_clinvar_xml:          #save eg: measure_id(15437) -> xref_db(OMIM) -> type(Allelic variant) -> id(612779.003)
scripts/import/import_clinvar_xml:          push @{$feature{measureXrefs}{$measure->{ID}}{$xref->{DB}}{$xref->{Type}} }, $xref->{ID} ;
scripts/import/import_clinvar_xml:          $xref->{DB} eq 'dbVar' ?
scripts/import/import_clinvar_xml:          push @{$feature{$xref->{DB}}},$xref->{ID} :
scripts/import/import_clinvar_xml:          push @{$feature{measureXrefs}{$measure->{ID}}{$xref->{DB}} }, $xref->{ID} ;
scripts/import/import_clinvar_xml:      if (defined $feature{measureXrefs}{$measure->{ID}}{$omimstr} &&
scripts/import/import_clinvar_xml:          defined $feature{measureXrefs}{$measure->{ID}}{$omimstr}{'Allelic variant'}) {
scripts/import/import_clinvar_xml:          if (defined $feature{measureXrefs}{$measure->{ID}}{'dbSNP'}) {
scripts/import/import_clinvar_xml:            foreach my $allele (@{$feature{measureXrefs}{$measure->{ID}}{$omimstr}{'Allelic variant'}}){
scripts/import/import_clinvar_xml:              foreach my $tmpRS (@{$feature{measureXrefs}{$measure->{ID}}{'dbSNP'}{'rs'}}){
scripts/import/import_clinvar_xml:            $feature{measureXrefs}{$measure->{ID}}{OmimAllele2dbSNP} = \%tmpAllelicID unless $type eq $haplotype_type;
scripts/import/import_clinvar_xml:            warn "Multiple OMIM Allelic variant xrefs for $accession! \n" if scalar @{$feature{measureXrefs}{$measure->{ID}}{$omimstr}{'Allelic variant'}} > 1;
scripts/import/import_clinvar_xml:            $feature{$omimstr} = $feature{measureXrefs}{$measure->{ID}}{$omimstr}{'Allelic variant'}->[0];
scripts/import/import_clinvar_xml:      push @{$feature{'haplo'}{'rs'}}, @{$feature{measureXrefs}{$measure->{ID}}{'dbSNP'}{'rs'}} if $type eq $haplotype_type && defined $feature{measureXrefs}{$measure->{ID}}{'dbSNP'};
scripts/import/import_clinvar_xml:    next unless defined $measure->{SequenceLocation};
scripts/import/import_clinvar_xml:    my $seqLocs = to_array($measure->{SequenceLocation});
scripts/import/import_clinvar_xml:      next unless $loc->{Assembly} eq $assembly;
scripts/import/import_clinvar_xml:      $feature{Chr}    = $loc->{Chr} ; 
scripts/import/import_clinvar_xml:      $feature{start}  = $loc->{start} ; 
scripts/import/import_clinvar_xml:      $feature{end}    = $loc->{stop} ; 
scripts/import/import_clinvar_xml:      $feature{measureXrefs}{$measure->{ID}}{Chr}   = $loc->{Chr}    if $type eq $haplotype_type;
scripts/import/import_clinvar_xml:      $feature{measureXrefs}{$measure->{ID}}{start} = $loc->{start}  if $type eq $haplotype_type;
scripts/import/import_clinvar_xml:      $feature{measureXrefs}{$measure->{ID}}{end}   = $loc->{stop}   if $type eq $haplotype_type;
scripts/import/import_clinvar_xml:    $feature{canonicalSPDI} = $measure->{CanonicalSPDI} if defined $measure->{CanonicalSPDI};
scripts/import/import_clinvar_xml:    ## HGVS genomic - used for allele extraction for novel variants 
scripts/import/import_clinvar_xml:    my $attrib_set = to_array($measure->{AttributeSet});
scripts/import/import_clinvar_xml:      next unless (defined $attrib->{Attribute}->{integerValue} &&
scripts/import/import_clinvar_xml:                           $attrib->{Attribute}->{integerValue} == $assembly_number );
scripts/import/import_clinvar_xml:      next unless (defined $attrib->{Attribute}->{Type} &&
scripts/import/import_clinvar_xml:                           $attrib->{Attribute}->{Type} =~ /HGVS,\s+genomic,\s+top\s+level/ );
scripts/import/import_clinvar_xml:      $feature{hgvs_g} =  $attrib->{Attribute}->{Change};
scripts/import/import_clinvar_xml:      $feature{measureXrefs}{$measure->{ID}}{hgvs_g} = $attrib->{Attribute}->{Change} if $type eq $haplotype_type;
scripts/import/import_clinvar_xml:    if(defined $measure->{MeasureRelationship}){
scripts/import/import_clinvar_xml:      my $meas_rels = to_array($measure->{MeasureRelationship});
scripts/import/import_clinvar_xml:        push @genes, $meas->{Symbol}->{ElementValue}->{content} if $meas->{Symbol}->{ElementValue}->{content} =~ /\w/;
scripts/import/import_clinvar_xml:      $feature{measureXrefs}{$measure->{ID}}{gene} = $feature{gene} if $type eq $haplotype_type;
scripts/import/import_clinvar_xml:    warn "multiple rsIDs for same measure ($measure->{ID}) in RCV ($accession), rsIDs: ".join(",",@{$feature{measureXrefs}{$measure->{ID}}{dbSNP}{rs}} )."\n" if (defined $feature{measureXrefs}{$measure->{ID}}{dbSNP} && scalar @{$feature{measureXrefs}{$measure->{ID}}{dbSNP}{rs}} >1 );
scripts/import/import_clinvar_xml:    if (defined $feature{'haplo'} && defined $feature{measureXrefs}{$measure->{ID}}{'dbSNP'} ){
scripts/import/import_clinvar_xml:      foreach my $rsID (@{$feature{measureXrefs}{$measure->{ID}}{'dbSNP'}{'rs'}}){
scripts/import/import_clinvar_xml:        #check if the existing record has same values as the latest measure set: {measureXrefs}{$measure->{ID}
scripts/import/import_clinvar_xml:             $feature{$varID}{Chr} != $feature{measureXrefs}{$measure->{ID}}{Chr} ||
scripts/import/import_clinvar_xml:             $feature{$varID}{start} != $feature{measureXrefs}{$measure->{ID}}{start} ||
scripts/import/import_clinvar_xml:             $feature{$varID}{end} != $feature{measureXrefs}{$measure->{ID}}{end} ||
scripts/import/import_clinvar_xml:             $feature{$varID}{hgvs_g} != $feature{measureXrefs}{$measure->{ID}}{hgvs_g}) ){
scripts/import/import_clinvar_xml:          @{$feature{$varID}}{qw/Chr start end hgvs_g gene/} = @{$feature{measureXrefs}{$measure->{ID}}}{qw/Chr start end hgvs_g gene/};
scripts/import/import_clinvar_xml:- extract prefered disease name & ontology terms
scripts/import/import_clinvar_xml:- only take first disease but report if more are present
scripts/import/import_clinvar_xml:    next if defined $disease; ## How should multi-disease assertions be handled? - log to monitor
scripts/import/import_clinvar_xml:    my $names = to_array($trait->{Name});
scripts/import/import_clinvar_xml:      next unless $name->{ElementValue}->{Type} eq "Preferred";
scripts/import/import_clinvar_xml:      $disease =  $name->{ElementValue}->{content};
scripts/import/import_clinvar_xml:      my $xrefs = to_array($name->{XRef});
scripts/import/import_clinvar_xml:        next unless $xref->{DB};
scripts/import/import_clinvar_xml:        push(@ontology_accs, $xref->{ID})
scripts/import/import_clinvar_xml:          if $xref->{DB} eq "Human Phenotype Ontology";
scripts/import/import_clinvar_xml:        push(@ontology_accs, 'Orphanet:' .$xref->{ID})
scripts/import/import_clinvar_xml:          if $xref->{DB} eq "Orphanet";
scripts/import/import_clinvar_xml:- extract any pubmed ids supporting this ascertation
scripts/import/import_clinvar_xml:    my $observed_data = to_array($observed_in->{$label});
scripts/import/import_clinvar_xml:      if ($obs->{Citation}){
scripts/import/import_clinvar_xml:        my $citations = to_array($obs->{Citation});
scripts/import/import_clinvar_xml:          my $ids = to_array($cit->{ID});
scripts/import/import_clinvar_xml:            push @citations, $id->{content} if $id->{Source} && $id->{Source} eq 'PubMed';
scripts/import/import_clinvar_xml:- extract any submitters of assertations from the ClinVar release
scripts/import/import_clinvar_xml:    push @submitters, $assert->{ClinVarSubmissionID}->{submitter};
scripts/import/import_clinvar_xml:    next unless $assert->{ClinVarSubmissionID}->{submitter} eq $omimstr;
scripts/import/import_clinvar_xml:    if (defined $assert->{ExternalID} && $assert->{ExternalID}->{DB} eq $omimstr) {
scripts/import/import_clinvar_xml:      my $omimAlleleID = $assert->{ExternalID}->{ID};
scripts/import/import_clinvar_xml:      warn "OMIM submitter with ExternalID BUT not for variation type, assertion(", $assert->{ClinVarAccession}->{Acc}, ") id type(",$assert->{ExternalID}->{Type} ,")!!\n" if $DEBUG == 1 &&  $assert->{ExternalID}->{Type} ne 'Allelic variant';
scripts/import/import_clinvar_xml:      foreach my $tmpMeasure (keys %{$mainXrefs->{'measureXrefs'}}) {
scripts/import/import_clinvar_xml:        if (defined $mainXrefs->{'measureXrefs'}{$tmpMeasure} &&
scripts/import/import_clinvar_xml:            defined $mainXrefs->{'measureXrefs'}{$tmpMeasure}{'OmimAllele2dbSNP'} &&
scripts/import/import_clinvar_xml:            defined $mainXrefs->{'measureXrefs'}{$tmpMeasure}{'OmimAllele2dbSNP'}{$omimAlleleID}) {
scripts/import/import_clinvar_xml:          if (scalar @{$mainXrefs->{'measureXrefs'}{$tmpMeasure}{'OmimAllele2dbSNP'}{$omimAlleleID}} > 1) {
scripts/import/import_clinvar_xml:            warn "multiple rsIDs for same OMIM allelic variant id in same measure: $tmpMeasure, rs:", join(",", @{$mainXrefs->{'measureXrefs'}{$tmpMeasure}{'OmimAllele2dbSNP'}{$omimAlleleID}}), "!\n";
scripts/import/import_clinvar_xml:          $mainXrefs->{$omimstr} ||= $omimAlleleID;
scripts/import/import_clinvar_xml:          $mainXrefs->{'MIM'} = (split/\./, $omimAlleleID)[0] unless defined $mainXrefs->{'MIM'};
scripts/import/import_clinvar_xml:          $mainXrefs->{'dbSNP'} = $mainXrefs->{'measureXrefs'}{$tmpMeasure}{'OmimAllele2dbSNP'}{$omimAlleleID} unless defined $mainXrefs->{'dbSNP'};
scripts/import/import_clinvar_xml:      $mainXrefs->{'MIM'} = (split/\./, $omimAlleleID)[0] unless defined $mainXrefs->{'MIM'};
scripts/import/import_clinvar_xml:      warn "OMIM submitter but no ExternalID, assertion(", $assert->{ClinVarAccession}->{Acc}, ") gene(",$mainXrefs->{gene} ,")!!\n";
scripts/import/import_clinvar_xml:  if (! defined $mainXrefs->{'dbSNP'}){
scripts/import/import_clinvar_xml:    foreach my $tmpMeasure (keys %{$mainXrefs->{'measureXrefs'}}) {
scripts/import/import_clinvar_xml:      push @{$mainXrefs->{'dbSNP'}}, @{$mainXrefs->{'measureXrefs'}{$tmpMeasure}{'dbSNP'}{'rs'}} if defined $mainXrefs->{'measureXrefs'}{$tmpMeasure}{'dbSNP'} && defined $mainXrefs->{'measureXrefs'}{$tmpMeasure}{'dbSNP'}{'rs'};
scripts/import/import_clinvar_xml:    @{$mainXrefs->{'dbSNP'}} = keys {map { $_ => 1 } @{$mainXrefs->{'dbSNP'}} } if defined $mainXrefs->{'dbSNP'};
scripts/import/import_clinvar_xml:- check all required info present & update db with a single ClinVar
scripts/import/import_clinvar_xml:  if(defined $record->{feature_info}->{dbSNP} && !defined $structvar){
scripts/import/import_clinvar_xml:    foreach my $rs (@{ $record->{feature_info}->{dbSNP} }){
scripts/import/import_clinvar_xml:      if (defined $record->{feature_info}->{$rsID}){
scripts/import/import_clinvar_xml:        @{$record->{feature_info}}{qw/hgvs_g Chr start end gene/} = @{$record->{feature_info}->{$rsID}}{qw/hgvs_g Chr start end gene/};
scripts/import/import_clinvar_xml:      print "no variation found for $record->{Acc}, $record->{clinvar_variant_id}\n";
scripts/import/import_clinvar_xml:  elsif(defined $record->{feature_info}->{dbVar} && defined $structvar){
scripts/import/import_clinvar_xml:    warn "Can't import ". $record->{Acc} ." as no dbSNP or location or SV\n";
scripts/import/import_clinvar_xml:  $variation_object->add_evidence_value($phenotype_evidence);
scripts/import/import_clinvar_xml:  $variation_adaptor->update($variation_object);
scripts/import/import_clinvar_xml:  add_synonyms($variation_object, $record->{clinvar_variant_id}, $source);
scripts/import/import_clinvar_xml:  add_synonyms($variation_object, $record->{Acc}, $source);
scripts/import/import_clinvar_xml:  add_synonyms($variation_object, $record->{feature_info}{$omimstr}, $omim_source) if defined $record->{feature_info}{$omimstr};
scripts/import/import_clinvar_xml:  ## deal with non-specified phenos
scripts/import/import_clinvar_xml:  $record->{disease} = $default_pheno unless $record->{disease} =~/\w+/;
scripts/import/import_clinvar_xml:  $record->{disease} = $default_pheno if $record->{disease} eq "not provided";
scripts/import/import_clinvar_xml:  $record->{disease} = $default_pheno if $record->{disease} eq "not specified";
scripts/import/import_clinvar_xml:  my $found = check_known_clinsig($record->{Desc});
scripts/import/import_clinvar_xml:    warn "clin_sig not known: >". $record->{Desc} ."< feature: ". $feature_object->name ."\n";
scripts/import/import_clinvar_xml:  $record->{disease} = decode_text( $record->{disease});
scripts/import/import_clinvar_xml:  $record->{disease} = replace_char( $record->{disease});
scripts/import/import_clinvar_xml:  foreach my $sub (@{$record->{submitters}}){
scripts/import/import_clinvar_xml:    $pheno = get_phenotype($record->{disease}, $record->{ontology_accession});
scripts/import/import_clinvar_xml:    warn "EXCEPTION in fetch of phenotype (RCV: ". $record->{Acc} .", VCV:". $record->{clinvar_variant_id}.") via SQL statement: $@";
scripts/import/import_clinvar_xml:  $attribs{review_status}    = $record->{Status};
scripts/import/import_clinvar_xml:  $attribs{external_id}      = $record->{Acc};
scripts/import/import_clinvar_xml:  $attribs{clinvar_clin_sig} = $record->{Desc} if $record->{Desc} ne ''; #avoids empty entry if explanation is missing for conflicting evidence
scripts/import/import_clinvar_xml:  $attribs{risk_allele}      = $alt_allele if defined $alt_allele && $alt_allele ne "-" && $alt_allele ne '';
scripts/import/import_clinvar_xml:  $attribs{associated_gene}  = $record->{feature_info}->{gene} if defined $record->{feature_info}->{gene};
scripts/import/import_clinvar_xml:  $attribs{MIM}              = $record->{feature_info}->{MIM} if defined $record->{feature_info}->{MIM};
scripts/import/import_clinvar_xml:  $attribs{pubmed_id}        = join(",", @{$record->{citations}}) if $record->{citations} && exists $record->{citations}->[0];
scripts/import/import_clinvar_xml:  $attribs{inheritance_type} = $record->{inheritance_type} if defined $record->{inheritance_type};
scripts/import/import_clinvar_xml:  $attribs{DateLastEvaluated} = $record->{DateLastEvaluated} if defined $record->{DateLastEvaluated};
scripts/import/import_clinvar_xml:  $attribs{variation_names}  = join(",", @{$record->{feature_info}->{haplo}->{$feature_object->name}}) if defined $record->{feature_info}->{haplo} && defined $record->{feature_info}->{haplo}->{$feature_object->name};
scripts/import/import_clinvar_xml:  foreach my $sub (@{$record->{submitters}}){
scripts/import/import_clinvar_xml:    unless ($submitters->{$sub}){
scripts/import/import_clinvar_xml:      $submitters->{$sub} = add_submitter($sub);
scripts/import/import_clinvar_xml:      warn "Added submitter $sub id " . $submitters->{$sub}  ." for sub\n";
scripts/import/import_clinvar_xml:    $submitter_ids{ $submitters->{$sub} } = 1;
scripts/import/import_clinvar_xml:      exists $submitters->{$omimstr} &&
scripts/import/import_clinvar_xml:      exists $submitter_ids{$submitters->{$omimstr}} &&
scripts/import/import_clinvar_xml:      ! defined $omimVarSet{$feature_object->dbID()}){
scripts/import/import_clinvar_xml:    update_variation_set($feature_object->dbID());
scripts/import/import_clinvar_xml:    print "entering phenotype_feature type : $type & object id: ".  $feature_object->dbID() . ", position " .$feature->seq_region_start() . "-".  $feature->seq_region_end() . "\n"
scripts/import/import_clinvar_xml:    my $phenofeat = Bio::EnsEMBL::Variation::PhenotypeFeature->new(
scripts/import/import_clinvar_xml:      -slice          => $feature->slice(),
scripts/import/import_clinvar_xml:      -start          => $feature->seq_region_start(),
scripts/import/import_clinvar_xml:      -strand         => $feature->seq_region_strand(),
scripts/import/import_clinvar_xml:      -end            => $feature->seq_region_end(),
scripts/import/import_clinvar_xml:      -phenotype      => $pheno,
scripts/import/import_clinvar_xml:      -is_significant => 1,
scripts/import/import_clinvar_xml:      -type           => $type,
scripts/import/import_clinvar_xml:      -object         => $feature_object,
scripts/import/import_clinvar_xml:      -source         => $source,
scripts/import/import_clinvar_xml:      -attribs        => \%attribs
scripts/import/import_clinvar_xml:      $pheno_feat_adaptor->store($phenofeat);
scripts/import/import_clinvar_xml:- update variation set variation ph_omim for the new variation
scripts/import/import_clinvar_xml:  my $vsv_ins_sth = $dbh->prepare(qq[ insert ignore into variation_set_variation
scripts/import/import_clinvar_xml:  $vsv_ins_sth->execute( $variation_id, $omim_set_id );
scripts/import/import_clinvar_xml:- update variation_feature evidence and variation_set_id
scripts/import/import_clinvar_xml:  my $vf_upd_sth = $dbh->prepare(qq[
scripts/import/import_clinvar_xml:  if ($omimVarSet{$vf->variation->dbID}) {
scripts/import/import_clinvar_xml:  $new_sets .=",$clinassoc_set_id " if ($clinsig =~ /pathogenic|drug-response|histocompatibility/i && $clinsig !~ /non/);
scripts/import/import_clinvar_xml:  $vf_upd_sth->execute( $new_sets,  $vf->dbID );
scripts/import/import_clinvar_xml: - retrieve existing or enter new phenotype object
scripts/import/import_clinvar_xml:  my $pheno = $phenotype_adaptor->fetch_by_description( $desc )->[0];
scripts/import/import_clinvar_xml:    $pheno = Bio::EnsEMBL::Variation::Phenotype->new(-description => $desc );
scripts/import/import_clinvar_xml:    $pheno->class_attrib_id($non_specified_class_id) if exists $non_specified_pheno{$pheno};
scripts/import/import_clinvar_xml:    $phenotype_adaptor->store($pheno);
scripts/import/import_clinvar_xml:    $pheno->add_ontology_accession({ accession      => $accession,
scripts/import/import_clinvar_xml:    $phenotype_adaptor->store_ontology_accessions($pheno);
scripts/import/import_clinvar_xml: - check if MTMP_transcript_variation exists
scripts/import/import_clinvar_xml:  my $table_sth = $dba->dbc->prepare(qq[ show tables like 'MTMP_transcript_variation' ]);
scripts/import/import_clinvar_xml:  $table_sth->execute() || die ("ERROR: cannot run command to check MTMP_transcript_variation\n");
scripts/import/import_clinvar_xml:  my $check_table = $table_sth->fetchall_arrayref();
scripts/import/import_clinvar_xml:  die "ERROR: MTMP_transcript_variation table does not exist. Create table before ClinVar import\n" if(!$check_table->[0]);
scripts/import/import_clinvar_xml: - retrieve existing ids held for assertation submitters
scripts/import/import_clinvar_xml:  my $submitter_ext_sth = $dba->dbc->prepare(qq[ select submitter_id, description from submitter]);
scripts/import/import_clinvar_xml:  $submitter_ext_sth->execute()||die;
scripts/import/import_clinvar_xml:  my $dat = $submitter_ext_sth->fetchall_arrayref();
scripts/import/import_clinvar_xml:    $submitters{$l->[1]} = $l->[0];
scripts/import/import_clinvar_xml: - add ids for new assertation submitters
scripts/import/import_clinvar_xml:  my $submitter_ins_sth = $dba->dbc->prepare(qq[ INSERT INTO submitter (description) values (?) ]);
scripts/import/import_clinvar_xml:  $submitter_ins_sth->execute($submitter_name);
scripts/import/import_clinvar_xml:  my $submitter_ext_sth = $dba->dbc->prepare(qq[ select submitter_id from submitter where description=?]);
scripts/import/import_clinvar_xml:  $submitter_ext_sth->execute($submitter_name)||die;
scripts/import/import_clinvar_xml:  my $dat = $submitter_ext_sth->fetchall_arrayref();
scripts/import/import_clinvar_xml:  warn "added submitter : $submitter_name & $dat->[0]->[0]\n";
scripts/import/import_clinvar_xml:  return $dat->[0]->[0];
scripts/import/import_clinvar_xml:  - look up or enter variation
scripts/import/import_clinvar_xml:  - returns variation & variation_feature objects & associated allele (from HGVS)
scripts/import/import_clinvar_xml:  $record->{feature_info}->{hgvs_g} |= "";
scripts/import/import_clinvar_xml:  if ($record->{feature_info}->{hgvs_g} !~ /.*:.*/) {
scripts/import/import_clinvar_xml:    defined $record->{feature_info}->{Chr} && $record->{feature_info}->{hgvs_g}  ne "" ?
scripts/import/import_clinvar_xml:      $record->{feature_info}->{hgvs_g} = $record->{feature_info}->{Chr} . ":" . $record->{feature_info}->{hgvs_g} :
scripts/import/import_clinvar_xml:      ($record->{feature_info}->{hgvs_g} = "unknown" . ":" . $record->{feature_info}->{hgvs_g} );
scripts/import/import_clinvar_xml:  print "Seeking $dbSNP ". $record->{feature_info}->{hgvs_g} . " for RCV:". $record->{Acc} ." VCV:". $record->{clinvar_variant_id} ."\n" if $DEBUG ==1;
scripts/import/import_clinvar_xml:    ($ref_allele, $alt_allele) = get_hgvs_alleles( $record->{feature_info}->{hgvs_g} ) unless $record->{feature_info}->{hgvs_g} eq "unknown:" ;
scripts/import/import_clinvar_xml:  warn "Problem finding allele for hgvs ". $record->{feature_info}->{hgvs_g} ." \n" unless $@ eq '';
scripts/import/import_clinvar_xml:    print "Ref + Alt alleles not available for $dbSNP (" . $record->{feature_info}->{hgvs_g} .
scripts/import/import_clinvar_xml:          ") RCV:". $record->{Acc} ." VCV:". $record->{clinvar_variant_id} ."\n";
scripts/import/import_clinvar_xml:    my $var_ob = $variation_adaptor->fetch_by_name($dbSNP);
scripts/import/import_clinvar_xml:      my @features = $var_ob->get_all_VariationFeatures();
scripts/import/import_clinvar_xml:    ## ClinVar can be ahead of dbSNP - is there enough data to create a variation record?
scripts/import/import_clinvar_xml:    if( !defined $record->{feature_info}->{hgvs_g} || !defined $record->{feature_info}->{Chr} ||
scripts/import/import_clinvar_xml:      warn "Not entering new refSNP: $rs_id as no parsable HGVS available for alleles ($record->{feature_info}->{hgvs_g})\n";
scripts/import/import_clinvar_xml:    my ($new_var_ob, $var_feat) = enter_var($record,  $ref_allele, $alt_allele, $rs_id, $record->{inheritance_type});
scripts/import/import_clinvar_xml:  ## no rs id - try to look up based on positon & alleles : shortest allele format
scripts/import/import_clinvar_xml:      defined $record->{feature_info}->{Chr} && defined $record->{feature_info}->{start}) {
scripts/import/import_clinvar_xml:    my $location_str = $record->{feature_info}->{Chr} . ":".
scripts/import/import_clinvar_xml:                    $record->{feature_info}->{start} . ":".
scripts/import/import_clinvar_xml:    my $var_feats = $var_feat_adaptor->fetch_all_by_location_identifier($location_str);
scripts/import/import_clinvar_xml:      return ($var_feats->[0]->variation(), $var_feats, $alt_allele);
scripts/import/import_clinvar_xml:        warn "vf:". $vf->name . " allele string: ". $vf->allele_string . "\n";
scripts/import/import_clinvar_xml:  ## try to match to multi-allelic variants by location
scripts/import/import_clinvar_xml:  - create a variation feature object based on ClinVar canonical SPDI
scripts/import/import_clinvar_xml:  - use the variation feature object to create a location identifier
scripts/import/import_clinvar_xml:  - search using the location identifier for any matching entries in the DB
scripts/import/import_clinvar_xml:  - returns variation & variation_feature objects & associated allele (same as caller)
scripts/import/import_clinvar_xml:  if (defined $record->{feature_info}->{canonicalSPDI} ) {
scripts/import/import_clinvar_xml:    my $spdi_str = $record->{feature_info}->{canonicalSPDI};
scripts/import/import_clinvar_xml:      $var_feat = $var_feat_adaptor->fetch_by_spdi_notation($spdi_str);
scripts/import/import_clinvar_xml:    my $location_identifier = $var_feat->location_identifier();
scripts/import/import_clinvar_xml:    my $vfs_from_db = $var_feat_adaptor->fetch_all_by_location_identifier($location_identifier);
scripts/import/import_clinvar_xml:      return ($vfs_from_db->[0]->variation(), $vfs_from_db);
scripts/import/import_clinvar_xml:        warn "vf:". $vf->name . " allele string: ". $vf->allele_string . "\n";
scripts/import/import_clinvar_xml:  - look up variants at the same location as a ClinVar assertion
scripts/import/import_clinvar_xml:  - only handles single base variants
scripts/import/import_clinvar_xml:  - compare ClinVar allele to variation_feature.allele_string
scripts/import/import_clinvar_xml:  - returns variation & variation_feature objects & associated allele (same as caller)
scripts/import/import_clinvar_xml:  my $location_string = $record->{feature_info}->{Chr} .":" . $record->{feature_info}->{start}."-".$record->{feature_info}->{end};
scripts/import/import_clinvar_xml:  if(!defined $record->{feature_info}->{end} || $record->{feature_info}->{start} != $record->{feature_info}->{end}) {
scripts/import/import_clinvar_xml:   my $slice =  $slice_adaptor->fetch_by_region( 'chromosome',
scripts/import/import_clinvar_xml:                                                  $record->{feature_info}->{Chr},
scripts/import/import_clinvar_xml:                                                  $record->{feature_info}->{start},
scripts/import/import_clinvar_xml:                                                  $record->{feature_info}->{end} );
scripts/import/import_clinvar_xml:  my $var_feats = $var_feat_adaptor->fetch_all_by_Slice($slice);
scripts/import/import_clinvar_xml:     warn "multiple variation_features found for slice $location_string - picking first with matching alleles\n";
scripts/import/import_clinvar_xml:    my @alleles = split/\//, $vf->allele_string;
scripts/import/import_clinvar_xml:        return ($vf->variation(), [$vf], $cv_allele);
scripts/import/import_clinvar_xml:  - ClinVar releases more frequently than dbSNP so may have new data
scripts/import/import_clinvar_xml:  - enter variation, alleles and variation_feature
scripts/import/import_clinvar_xml:  - returns variation & variation_feature objects
scripts/import/import_clinvar_xml:    warn "ERROR: no rs_id for ". $data->{feature_info}->{hgvs_g} ."\n";
scripts/import/import_clinvar_xml:     warn "ERROR: missing alleles for $data->{feature_info}->{hgvs_g} / $dbSNP\n";
scripts/import/import_clinvar_xml:  my $vf_start = $data->{feature_info}->{start};
scripts/import/import_clinvar_xml:  my $vf_end = $data->{feature_info}->{end};
scripts/import/import_clinvar_xml:  ## strand not reported - assumes forward
scripts/import/import_clinvar_xml:  my $slice = $slice_adaptor->fetch_by_region( 'chromosome', $data->{feature_info}->{Chr} );
scripts/import/import_clinvar_xml:  if ($ref_allele eq '-' && $allele_str ne '-/') {
scripts/import/import_clinvar_xml:      $vf_start = $data->{feature_info}->{end} ;
scripts/import/import_clinvar_xml:      $vf_end = $data->{feature_info}->{start} ;
scripts/import/import_clinvar_xml:    } elsif ($data->{feature_info}->{hgvs_g} =~ /\d+dup/){ #old style formated hgvs_g ..3-6dupGAGA
scripts/import/import_clinvar_xml:  } elsif ($allele_str eq '-/' && $data->{feature_info}->{hgvs_g} =~ /\d+dup/){ #new style formated hgvs_g ..3-6dup
scripts/import/import_clinvar_xml:    my $ref_slice = $slice_adaptor->fetch_by_region( 'chromosome', $data->{feature_info}->{Chr},
scripts/import/import_clinvar_xml:              $data->{feature_info}->{start}, $data->{feature_info}->{end});
scripts/import/import_clinvar_xml:    my $ref_seq = $ref_slice->seq();
scripts/import/import_clinvar_xml:    $allele_str = "-/".$ref_seq;
scripts/import/import_clinvar_xml:  } elsif ($alt_allele =~/^$ref_allele/ && $data->{feature_info}->{hgvs_g} =~ m/\[/i ) {
scripts/import/import_clinvar_xml:    # eg. rs1555092425 (11:g.108282799A[5]) -> get_hgvs_alleles produces -> A(1) -> A(5) while correct is: ref AAA(3) -> alt AAAAA(5)
scripts/import/import_clinvar_xml:    my $refSlice = $slice_adaptor->fetch_by_region( 'chromosome', $data->{feature_info}->{Chr},
scripts/import/import_clinvar_xml:                    $vf_start, $vf_start + length($alt_allele) - 1);
scripts/import/import_clinvar_xml:    my @refSeq = split //, $refSlice->seq;
scripts/import/import_clinvar_xml:      print "INFO: skipping variation (duplications) with ref[0] ne alt[0] for $data->{feature_info}->{hgvs_g} \n" ;
scripts/import/import_clinvar_xml:    $ref_allele = substr($refSlice->seq, 0, $i-1);
scripts/import/import_clinvar_xml:  elsif ($allele_str eq '/-' && $data->{feature_info}->{hgvs_g} =~ /\d+_\d+del$/){
scripts/import/import_clinvar_xml:      my ($start, $end) = $data->{feature_info}->{hgvs_g} =~ m/(\d+)_(\d+)del$/i;
scripts/import/import_clinvar_xml:      print "WARNING: HGVS contains different start/end for deletion ($data->{feature_info}->{hgvs_g})\n" if ($start ne $vf_start || $end != $vf_end );
scripts/import/import_clinvar_xml:      my $refSlice = $slice_adaptor->fetch_by_region( 'chromosome', $data->{feature_info}->{Chr},
scripts/import/import_clinvar_xml:      $ref_allele = $refSlice->seq;
scripts/import/import_clinvar_xml:  elsif ($data->{feature_info}->{hgvs_g} =~ /\d+_\d+delins[A-Z]+/i){
scripts/import/import_clinvar_xml:      my ($start, $end, $alt) = $data->{feature_info}->{hgvs_g} =~ m/(\d+)_(\d+)delins([A-Z]+)$/i;
scripts/import/import_clinvar_xml:      print "WARNING: HGVS contains different start/end/alt for delins ($data->{feature_info}->{hgvs_g})\n" if ($start ne $vf_start || $end != $vf_end  || $alt ne $alt_allele);
scripts/import/import_clinvar_xml:      my $refSlice = $slice_adaptor->fetch_by_region( 'chromosome', $data->{feature_info}->{Chr},
scripts/import/import_clinvar_xml:      $ref_allele = $refSlice->seq;
scripts/import/import_clinvar_xml:  # MTMP transcript variation - biotypes to skip
scripts/import/import_clinvar_xml:  my $var = Bio::EnsEMBL::Variation::Variation->new
scripts/import/import_clinvar_xml:    ( -name              => $dbSNP,
scripts/import/import_clinvar_xml:      -source            => $source,
scripts/import/import_clinvar_xml:      -is_somatic        => $somatic,
scripts/import/import_clinvar_xml:      -adaptor           => $variation_adaptor,
scripts/import/import_clinvar_xml:      -class_SO_term     => $so_term,
scripts/import/import_clinvar_xml:  $variation_adaptor->store($var);
scripts/import/import_clinvar_xml:  my $vf = Bio::EnsEMBL::Variation::VariationFeature->new
scripts/import/import_clinvar_xml:    (-start           => $vf_start,
scripts/import/import_clinvar_xml:     -end             => $vf_end,
scripts/import/import_clinvar_xml:     -strand          => 1,
scripts/import/import_clinvar_xml:     -slice           => $slice,
scripts/import/import_clinvar_xml:     -variation_name  => $dbSNP,
scripts/import/import_clinvar_xml:     -map_weight      => 1,
scripts/import/import_clinvar_xml:     -allele_string   => $allele_str,
scripts/import/import_clinvar_xml:     -variation       => $var,
scripts/import/import_clinvar_xml:     -source          => $source,
scripts/import/import_clinvar_xml:     -is_somatic      => 0,
scripts/import/import_clinvar_xml:     -adaptor         => $var_feat_adaptor,
scripts/import/import_clinvar_xml:     -class_so_term    => $so_term,
scripts/import/import_clinvar_xml:  $var_feat_adaptor->store($vf);
scripts/import/import_clinvar_xml:  my $all_tv = $vf->get_all_TranscriptVariations();
scripts/import/import_clinvar_xml:    next unless overlap($vf->start, $vf->end, $tv->transcript->start - 0, $tv->transcript->end + 0);
scripts/import/import_clinvar_xml:    my $write_biotype = $biotypes_to_skip{$tv->transcript->biotype} ? 0 : 1;
scripts/import/import_clinvar_xml:    my $write_mane = $tv->transcript->is_mane ? 1 : 0;
scripts/import/import_clinvar_xml:    $tva->store($tv, $mtmp);
scripts/import/import_clinvar_xml:  my $vf_dbid = $vf->dbID;
scripts/import/import_clinvar_xml:    my $vf_sth = $dba->dbc()->prepare($update_vf_smt);
scripts/import/import_clinvar_xml:    $vf_sth->execute('intergenic_variant', $vf->dbID) || die "Error updating consequence_types to default in table variation_feature\n";
scripts/import/import_clinvar_xml:  my $sth_len = $dbh->prepare($stmt_len);
scripts/import/import_clinvar_xml:  $sth_len->execute();
scripts/import/import_clinvar_xml:  my $tv_sth    = $dba->dbc()->prepare(qq[ SELECT variation_feature_id, GROUP_CONCAT(DISTINCT(consequence_types))
scripts/import/import_clinvar_xml:  $tv_sth->execute($vf_dbid) || die "Error selecting consequence_types from transcript_variation\n";
scripts/import/import_clinvar_xml:  my $data_tv = $tv_sth->fetchall_arrayref();
scripts/import/import_clinvar_xml:  if (defined $data_tv->[0]->[0]) {
scripts/import/import_clinvar_xml:    my $update_vf_sth = $dba->dbc()->prepare($update_vf_smt);
scripts/import/import_clinvar_xml:    $update_vf_sth->execute($data_tv->[0]->[1], $data_tv->[0]->[0]) || die "Error updating consequence_types in table variation_feature\n";
scripts/import/import_clinvar_xml:  - get structural variant record to use in phenotype feature
scripts/import/import_clinvar_xml:  - new data is not entered
scripts/import/import_clinvar_xml:  - returns variation & variation_feature objects
scripts/import/import_clinvar_xml:  my @ids = sort @{$record->{feature_info}->{dbVar}};
scripts/import/import_clinvar_xml:  my $struct_var_ob = $structvar_adaptor->fetch_by_name($dbvar);
scripts/import/import_clinvar_xml:    print "Not entering SV: $record->{feature_info}->{dbVar}->[0] as not in db \n";
scripts/import/import_clinvar_xml:  my @features = $struct_var_ob->get_all_StructuralVariationFeatures();
scripts/import/import_clinvar_xml:  - retrieve source object
scripts/import/import_clinvar_xml:  my $file = shift;  ##/path_to_file/ClinVarFullRelease_2016-10.xml
scripts/import/import_clinvar_xml:  # The file name can include the full path - remove everything until file name
scripts/import/import_clinvar_xml:  $version =~ s/.*ClinVarFullRelease_|.xml|.gz|-//g;
scripts/import/import_clinvar_xml:  my $source_adaptor  = $reg->get_adaptor('homo_sapiens', 'variation', 'source');
scripts/import/import_clinvar_xml:    my $source = $source_adaptor->fetch_by_name( $source_name );
scripts/import/import_clinvar_xml:    $source->version($version);
scripts/import/import_clinvar_xml:    $source_adaptor->update_version($source);
scripts/import/import_clinvar_xml:  - updates source object in db
scripts/import/import_clinvar_xml:  my $source_adaptor  = $reg->get_adaptor('homo_sapiens', 'variation', 'source');
scripts/import/import_clinvar_xml:  $source_adaptor->update_version($source);
scripts/import/import_clinvar_xml:  if ($synonym_source->name eq 'ClinVar') {
scripts/import/import_clinvar_xml:  ## multiple rs id can be attached to the same ClinVar id - usually identical duplicates
scripts/import/import_clinvar_xml:  my $syn_ins_sth = $dba->dbc->prepare(qq[ insert ignore into variation_synonym  
scripts/import/import_clinvar_xml:  $syn_ins_sth->execute($var->dbID(), $synonym_source->dbID(), $synonym_accession);
scripts/import/import_clinvar_xml:  my $attrib_id = $attrib_adaptor->attrib_id_for_type_value($type, $value);
scripts/import/import_clinvar_xml:  my $phenfeatat_del_sth = $dba->dbc->do(qq[ delete from phenotype_feature_attrib where phenotype_feature_id in
scripts/import/import_clinvar_xml:  my $phenfeat_del_sth   = $dba->dbc->do(qq[ delete from phenotype_feature where source_id in (select source_id from source where name ='ClinVar') ]);
scripts/import/import_clinvar_xml:  my $var_syn_sel_sth    = $dba->dbc()->prepare(qq[ select allele_synonym_id from allele_synonym where variation_id in
scripts/import/import_clinvar_xml:  $var_syn_sel_sth->execute() || die "Error selecting allele synonyms to be removed\n";
scripts/import/import_clinvar_xml:  my $data = $var_syn_sel_sth->fetchall_arrayref();
scripts/import/import_clinvar_xml:    my $allele_syn_id = $allele_syn->[0];
scripts/import/import_clinvar_xml:    my $allele_syn_delete_sth = $dba->dbc()->prepare(qq[ delete from allele_synonym where allele_synonym_id = $allele_syn_id ]);
scripts/import/import_clinvar_xml:    $allele_syn_delete_sth->execute() || die "Could not delete entry id $allele_syn_id from allele_synonym\n";
scripts/import/import_clinvar_xml:  my $tv_del_sth = $dba->dbc()->prepare(qq[ select vf.variation_feature_id from variation_feature vf
scripts/import/import_clinvar_xml:  $tv_del_sth->execute() || die "Error selecting variation feature from ClinVar\n";
scripts/import/import_clinvar_xml:  my $tv_to_del = $tv_del_sth->fetchall_arrayref();
scripts/import/import_clinvar_xml:    my $vf_id_del = $to_del->[0];
scripts/import/import_clinvar_xml:    my $del_vf_sth = $dba->dbc()->prepare(qq[ delete from variation_feature where variation_feature_id = $vf_id_del ]);
scripts/import/import_clinvar_xml:    my $del_sth = $dba->dbc()->prepare(qq[ delete from transcript_variation where variation_feature_id = $vf_id_del ]);
scripts/import/import_clinvar_xml:    my $del_mtmp_sth = $dba->dbc()->prepare(qq[ delete from MTMP_transcript_variation where variation_feature_id = $vf_id_del ]);
scripts/import/import_clinvar_xml:    $del_vf_sth->execute() || die "Could not delete entry with variation_feature_id = $vf_id_del from variation_feature\n";
scripts/import/import_clinvar_xml:    $del_sth->execute() || die "Could not delete entry with variation_feature_id = $vf_id_del from transcript_variation\n";
scripts/import/import_clinvar_xml:    $del_mtmp_sth->execute() || die "Could not delete entry with variation_feature_id = $vf_id_del from MTMP_transcript_variation\n";
scripts/import/import_clinvar_xml:    my $var_recs_del_sth    = $dba->dbc->do(qq[ delete from $table where variation_id in
scripts/import/import_clinvar_xml:  my $var_del_sth        = $dba->dbc->do(qq[ delete from variation where source_id in (select source_id from source where name ='ClinVar'); ]);
scripts/import/import_clinvar_xml:  my $synonym_del_sth    = $dba->dbc->do(qq[ delete from variation_synonym where source_id in (select source_id from source where name ='OMIM' ) ]);
scripts/import/import_clinvar_xml:  my $var_updt_sth       = $dba->dbc->do(qq[ update variation set clinical_significance=NULL ]);
scripts/import/import_clinvar_xml:  my $var_feat_updt_sth  = $dba->dbc->do(qq[ update variation_feature set clinical_significance=NULL ]);
scripts/import/import_clinvar_xml:    die "\n\tUsage: import_clinvar_xml -data_file [ClinVar xml] -registry [registry file] -assembly [GRCh37/GRCh38]
scripts/import/import_clinvar_xml:\t\toptions: -structvar  (only import ClinVar statuses for structural variations)
scripts/import/import_clinvar_xml:\t\toptions: -clean      ( delete old phenotype_feature, phenotype_feature_attrib, variation(ClinVar), variation_feature (ClinVar), transcript_variation (ClinVar), variation_set_variation (sets: ClinVar, OMIM, All phenotypes set ), clinical_significance and synonym data)
scripts/import/import_clinvar_xml:\t\toptions: -done_file  (tsv file containing RCVs to be skipped, expected format: header and 2nd column containing RCVs)
scripts/import/import_mouse_phenotype_data.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_mouse_phenotype_data.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_mouse_phenotype_data.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_mouse_phenotype_data.pl:usage() if ($config->{help});
scripts/import/import_mouse_phenotype_data.pl:die ("MGI_MRK_Coord.rpt file (--coord_file) is required") unless (defined($config->{coord_file}));
scripts/import/import_mouse_phenotype_data.pl:die ("A working directory (--working_dir) is required") unless (defined($config->{working_dir}));
scripts/import/import_mouse_phenotype_data.pl:my $variation_credentials = defined($config->{host}) && defined($config->{port}) && defined($config->{dbname}) && defined($config->{user}) && defined($config->{pass});
scripts/import/import_mouse_phenotype_data.pl:my $core_credentials      = defined($config->{chost}) && defined($config->{port}) && defined($config->{cdbname});
scripts/import/import_mouse_phenotype_data.pl:my $registry = defined($config->{registry});
scripts/import/import_mouse_phenotype_data.pl:die ("Database credentials or a registry file are required (try --help)") unless (($variation_credentials && $core_credentials) || $registry);
scripts/import/import_mouse_phenotype_data.pl:die ("Variation database credentials (--host, --dbname, --user, --pass, --port) are required") if (!$variation_credentials && !$registry);
scripts/import/import_mouse_phenotype_data.pl:die ("Core database credentials (--chost, --cdbname, --cport) are required") if (!$core_credentials && !$registry);
scripts/import/import_mouse_phenotype_data.pl:$config->{urls} = {
scripts/import/import_mouse_phenotype_data.pl:  impc => '/mi/impc/solr/genotype-phenotype',
scripts/import/import_mouse_phenotype_data.pl:  mgi => '/mi/impc/solr/mgi-phenotype',
scripts/import/import_mouse_phenotype_data.pl:  if ($config->{registry}) {
scripts/import/import_mouse_phenotype_data.pl:    $registry->load_all($config->{registry});
scripts/import/import_mouse_phenotype_data.pl:    $gene_adaptor       = $registry->get_adaptor($species, 'core', 'gene');
scripts/import/import_mouse_phenotype_data.pl:    $phenotype_adaptor  = $registry->get_adaptor($species, 'variation', 'phenotype');
scripts/import/import_mouse_phenotype_data.pl:    $individual_adaptor = $registry->get_adaptor($species, 'variation', 'individual');
scripts/import/import_mouse_phenotype_data.pl:    my $vdba            = $registry->get_DBAdaptor($species, 'variation');
scripts/import/import_mouse_phenotype_data.pl:    $dbh                = $vdba->dbc->db_handle;
scripts/import/import_mouse_phenotype_data.pl:        -host => $config->{host},
scripts/import/import_mouse_phenotype_data.pl:        -user => $config->{user},
scripts/import/import_mouse_phenotype_data.pl:        -pass => $config->{pass},
scripts/import/import_mouse_phenotype_data.pl:        -port => $config->{port},
scripts/import/import_mouse_phenotype_data.pl:        -dbname => $config->{dbname},
scripts/import/import_mouse_phenotype_data.pl:        ) or die("Could not get a database adaptor for $config->{dbname} on $config->{host}:$config->{port}");
scripts/import/import_mouse_phenotype_data.pl:        -host => $config->{chost},
scripts/import/import_mouse_phenotype_data.pl:        -user => 'ensro',
scripts/import/import_mouse_phenotype_data.pl:        -pass => '',
scripts/import/import_mouse_phenotype_data.pl:        -port => $config->{cport},
scripts/import/import_mouse_phenotype_data.pl:        -dbname => $config->{cdbname},
scripts/import/import_mouse_phenotype_data.pl:        ) or die("Could not get a database adaptor for $config->{cdbname} on $config->{chost}:$config->{cport}");
scripts/import/import_mouse_phenotype_data.pl:    $gene_adaptor       = $core_db_adaptor->get_GeneAdaptor;
scripts/import/import_mouse_phenotype_data.pl:    $individual_adaptor = $db_adaptor->get_IndividualAdaptor;
scripts/import/import_mouse_phenotype_data.pl:    $phenotype_adaptor  = $db_adaptor->get_PhenotypeAdaptor;
scripts/import/import_mouse_phenotype_data.pl:    my $dbname = $config->{dbname};
scripts/import/import_mouse_phenotype_data.pl:    my $host   = $config->{host};
scripts/import/import_mouse_phenotype_data.pl:    my $port   = $config->{port};
scripts/import/import_mouse_phenotype_data.pl:    my $user   = $config->{user};
scripts/import/import_mouse_phenotype_data.pl:    my $pass   = $config->{pass};
scripts/import/import_mouse_phenotype_data.pl:    $dbh = DBI->connect("DBI:mysql:database=$dbname;host=$host;port=$port;user=$user;password=$pass", {RaiseError => 1});
scripts/import/import_mouse_phenotype_data.pl:  $config->{gene_adaptor}       = $gene_adaptor;
scripts/import/import_mouse_phenotype_data.pl:  $config->{phenotype_adaptor}  = $phenotype_adaptor;
scripts/import/import_mouse_phenotype_data.pl:  $config->{individual_adaptor} = $individual_adaptor;
scripts/import/import_mouse_phenotype_data.pl:  $config->{dbh} = $dbh;
scripts/import/import_mouse_phenotype_data.pl:  my $dbh = $config->{dbh};
scripts/import/import_mouse_phenotype_data.pl:  $dbh->do(qq{CREATE TABLE IF NOT EXISTS TMP_phenotype_feature LIKE phenotype_feature;}) or die $dbh->errstr;
scripts/import/import_mouse_phenotype_data.pl:  $dbh->do(qq{TRUNCATE TABLE TMP_phenotype_feature;}) or die $dbh->errstr;
scripts/import/import_mouse_phenotype_data.pl:  $dbh->do(qq{INSERT INTO TMP_phenotype_feature SELECT * FROM phenotype_feature;}) or die $dbh->errstr;
scripts/import/import_mouse_phenotype_data.pl:  $dbh->do(qq{CREATE TABLE IF NOT EXISTS TMP_phenotype_feature_attrib LIKE phenotype_feature_attrib;}) or die $dbh->errstr;
scripts/import/import_mouse_phenotype_data.pl:  $dbh->do(qq{TRUNCATE TABLE TMP_phenotype_feature_attrib;}) or die $dbh->errstr;
scripts/import/import_mouse_phenotype_data.pl:  $dbh->do(qq{INSERT INTO TMP_phenotype_feature_attrib SELECT * FROM phenotype_feature_attrib;}) or die $dbh->errstr;
scripts/import/import_mouse_phenotype_data.pl:  my $dbh = $config->{dbh};
scripts/import/import_mouse_phenotype_data.pl:  # create backup tables for: individual, phenotype_feature_attrib, phenotype, phenotype_feature --> not needed,
scripts/import/import_mouse_phenotype_data.pl:  # if something goes wrong, tables are available on ens-livemirror
scripts/import/import_mouse_phenotype_data.pl:  my $phenotype_file = $config->{"$data_source\_phenotype_file"};
scripts/import/import_mouse_phenotype_data.pl:  my $fh = FileHandle->new($phenotype_file, 'r');
scripts/import/import_mouse_phenotype_data.pl:        $source_names->{$value} = 1;
scripts/import/import_mouse_phenotype_data.pl:        $source_names->{$value} = 1;
scripts/import/import_mouse_phenotype_data.pl:  $fh->close();
scripts/import/import_mouse_phenotype_data.pl:    my $sth = $dbh->prepare($stmt);
scripts/import/import_mouse_phenotype_data.pl:    $sth->execute();
scripts/import/import_mouse_phenotype_data.pl:    $sth->bind_columns(\$source_id);
scripts/import/import_mouse_phenotype_data.pl:    $sth->fetch();
scripts/import/import_mouse_phenotype_data.pl:      $source_name2id->{$source_name} = $source_id;  
scripts/import/import_mouse_phenotype_data.pl:    $sth->finish();
scripts/import/import_mouse_phenotype_data.pl:  my $version = $config->{version};
scripts/import/import_mouse_phenotype_data.pl:    $dbh->do(qq{UPDATE source SET version=$version WHERE name='$source_name';}) or die $dbh->errstr;
scripts/import/import_mouse_phenotype_data.pl:  $dbh->do(qq{ DELETE pfa FROM phenotype_feature_attrib pfa JOIN phenotype_feature pf ON pfa.phenotype_feature_id = pf.phenotype_feature_id AND pf.source_id IN ($source_ids);} );
scripts/import/import_mouse_phenotype_data.pl:  $dbh->do(qq{ DELETE FROM phenotype_feature WHERE source_id IN ($source_ids);} );
scripts/import/import_mouse_phenotype_data.pl:  my $http = HTTP::Tiny->new();
scripts/import/import_mouse_phenotype_data.pl:  my $response = $http->get($url, {
scripts/import/import_mouse_phenotype_data.pl:    headers => { 'Content-type' => 'application/json' }
scripts/import/import_mouse_phenotype_data.pl:  my $hash = decode_json($response->{content});
scripts/import/import_mouse_phenotype_data.pl:  my $data_release_date = $hash->{data_release_date};
scripts/import/import_mouse_phenotype_data.pl:  my ($date, $month, $year) = split(' ', $hash->{data_release_date}) ;
scripts/import/import_mouse_phenotype_data.pl:  my $month_number = $months->{$month}; 
scripts/import/import_mouse_phenotype_data.pl:  $config->{version} = $version;
scripts/import/import_mouse_phenotype_data.pl:  my $working_dir = $config->{working_dir};
scripts/import/import_mouse_phenotype_data.pl:  my $url = $config->{urls}->{$data_source};
scripts/import/import_mouse_phenotype_data.pl:  $config->{"$data_source\_phenotype_file"} = $phenotype_file;
scripts/import/import_mouse_phenotype_data.pl:  my $fh = FileHandle->new($phenotype_file, 'w');
scripts/import/import_mouse_phenotype_data.pl:  my $http = HTTP::Tiny->new();
scripts/import/import_mouse_phenotype_data.pl:    my $response = $http->get($server.$ext, {
scripts/import/import_mouse_phenotype_data.pl:      headers => { 'Content-type' => 'application/json' }
scripts/import/import_mouse_phenotype_data.pl:    my $hash = decode_json($response->{content});
scripts/import/import_mouse_phenotype_data.pl:    $rows = scalar @{$hash->{response}->{docs}};
scripts/import/import_mouse_phenotype_data.pl:    my $response = $http->get($server.$ext, {
scripts/import/import_mouse_phenotype_data.pl:      headers => { 'Content-type' => 'application/json' }
scripts/import/import_mouse_phenotype_data.pl:    die "Failed!\n" unless $response->{success};
scripts/import/import_mouse_phenotype_data.pl:    if (length $response->{content}) {
scripts/import/import_mouse_phenotype_data.pl:      my $hash = decode_json($response->{content});
scripts/import/import_mouse_phenotype_data.pl:      foreach my $result (@{$hash->{response}->{docs}}) {
scripts/import/import_mouse_phenotype_data.pl:          my $value = $result->{$key};
scripts/import/import_mouse_phenotype_data.pl:  $fh->close();
scripts/import/import_mouse_phenotype_data.pl:  my $phenotype_file = $config->{"$data_source\_phenotype_file"};
scripts/import/import_mouse_phenotype_data.pl:  my $fh = FileHandle->new($phenotype_file, 'r');
scripts/import/import_mouse_phenotype_data.pl:        $mp_term_names->{$value} = 1;
scripts/import/import_mouse_phenotype_data.pl:  $fh->close();
scripts/import/import_mouse_phenotype_data.pl:  my $dbh = $config->{dbh};
scripts/import/import_mouse_phenotype_data.pl:  my $sth = $dbh->prepare($stmt);
scripts/import/import_mouse_phenotype_data.pl:  $sth->execute();
scripts/import/import_mouse_phenotype_data.pl:  $sth->bind_columns(\$description);
scripts/import/import_mouse_phenotype_data.pl:  while ($sth->fetch()) {
scripts/import/import_mouse_phenotype_data.pl:    $phenotype_descriptions->{$description} = 1;
scripts/import/import_mouse_phenotype_data.pl:  $sth->finish();
scripts/import/import_mouse_phenotype_data.pl:  $sth = $dbh->prepare($sql);
scripts/import/import_mouse_phenotype_data.pl:    if (!$phenotype_descriptions->{$description}) {
scripts/import/import_mouse_phenotype_data.pl:      $sth->bind_param(1, $description, SQL_VARCHAR);
scripts/import/import_mouse_phenotype_data.pl:      $sth->execute();
scripts/import/import_mouse_phenotype_data.pl:  $sth->finish();
scripts/import/import_mouse_phenotype_data.pl:  my $dbh                = $config->{dbh};
scripts/import/import_mouse_phenotype_data.pl:  my $individual_adaptor = $config->{individual_adaptor};
scripts/import/import_mouse_phenotype_data.pl:  my $phenotype_adaptor  = $config->{phenotype_adaptor};
scripts/import/import_mouse_phenotype_data.pl:  my $marker_coords      = $config->{marker_coords};
scripts/import/import_mouse_phenotype_data.pl:  $pf_ins_sth          = $dbh->prepare($pf_ins_sth);
scripts/import/import_mouse_phenotype_data.pl:  $attrib_ins_sth      = $dbh->prepare($attrib_ins_sth);
scripts/import/import_mouse_phenotype_data.pl:  $attrib_ins_cast_sth = $dbh->prepare($attrib_ins_cast_sth);
scripts/import/import_mouse_phenotype_data.pl:  my $phenotype_file = $config->{"$data_source\_phenotype_file"};
scripts/import/import_mouse_phenotype_data.pl:  my $fh = FileHandle->new($phenotype_file, 'r');
scripts/import/import_mouse_phenotype_data.pl:      $hash->{$key} = $value;
scripts/import/import_mouse_phenotype_data.pl:      $attribs->{$value} = $hash->{$value};
scripts/import/import_mouse_phenotype_data.pl:    my $marker_accession_id = $hash->{marker_accession_id};
scripts/import/import_mouse_phenotype_data.pl:    my $phenotypes = $phenotype_adaptor->fetch_by_description($hash->{mp_term_name});
scripts/import/import_mouse_phenotype_data.pl:    if (! $hash->{mp_term_name}) {
scripts/import/import_mouse_phenotype_data.pl:      die("No phenotype description for term: ", $hash->{mp_term_name});
scripts/import/import_mouse_phenotype_data.pl:    my $phenotype_id      = $phenotype->dbID();
scripts/import/import_mouse_phenotype_data.pl:      $source_id = source($config, $hash->{resource_name}, $hash->{resource_fullname});
scripts/import/import_mouse_phenotype_data.pl:      $source_id = source($config, $hash->{project_name}, $hash->{project_fullname});
scripts/import/import_mouse_phenotype_data.pl:    my $pf_data           = $marker_coords->{$marker_accession_id};
scripts/import/import_mouse_phenotype_data.pl:    my $type              = $pf_data->{type};
scripts/import/import_mouse_phenotype_data.pl:    my $seq_region_id     = $pf_data->{seq_region_id};
scripts/import/import_mouse_phenotype_data.pl:    my $seq_region_start  = $pf_data->{seq_region_start};
scripts/import/import_mouse_phenotype_data.pl:    my $seq_region_end    = $pf_data->{seq_region_end};
scripts/import/import_mouse_phenotype_data.pl:    my $seq_region_strand = $pf_data->{seq_region_strand};
scripts/import/import_mouse_phenotype_data.pl:    my $strain_name       = $hash->{strain_name};
scripts/import/import_mouse_phenotype_data.pl:    my $gender            = $hash->{sex};
scripts/import/import_mouse_phenotype_data.pl:      my $strains = $individual_adaptor->fetch_all_by_name($strain_name);
scripts/import/import_mouse_phenotype_data.pl:        if (lc $strain->gender ne $gender) {
scripts/import/import_mouse_phenotype_data.pl:          $strain_id = $strain->dbID();
scripts/import/import_mouse_phenotype_data.pl:          if (lc $strain->gender eq $gender) {
scripts/import/import_mouse_phenotype_data.pl:          $strain_id = $unique[0]->dbID();
scripts/import/import_mouse_phenotype_data.pl:            -name => $strain_name,
scripts/import/import_mouse_phenotype_data.pl:            -gender => $gender, 
scripts/import/import_mouse_phenotype_data.pl:            -individual_type_id => 1, 
scripts/import/import_mouse_phenotype_data.pl:        $individual_adaptor->store($individual);
scripts/import/import_mouse_phenotype_data.pl:        $strain_id = $individual_adaptor->last_insert_id();
scripts/import/import_mouse_phenotype_data.pl:    $attribs->{associated_gene} = $hash->{marker_symbol};
scripts/import/import_mouse_phenotype_data.pl:      $attribs->{strain_id} = $strain_id;
scripts/import/import_mouse_phenotype_data.pl:    if ($hash->{p_value}) {
scripts/import/import_mouse_phenotype_data.pl:      $attribs->{p_value} = convert_p_value($hash->{p_value});
scripts/import/import_mouse_phenotype_data.pl:    $attribs->{external_id} = $hash->{mp_term_id};
scripts/import/import_mouse_phenotype_data.pl:    if ($pf_data->{object_id}) {
scripts/import/import_mouse_phenotype_data.pl:      @object_ids = split(';', $pf_data->{object_id});
scripts/import/import_mouse_phenotype_data.pl:      if ($hash->{resource_name} && $hash->{resource_name} eq 'MGP') {
scripts/import/import_mouse_phenotype_data.pl:        if ($attribs->{p_value} && ($attribs->{p_value} <= 0.0001)) {
scripts/import/import_mouse_phenotype_data.pl:        my $key = join('-', ($phenotype_id, $source_id, $object_id, $strain_id));
scripts/import/import_mouse_phenotype_data.pl:        unless ($already_inserted->{$key}) {			
scripts/import/import_mouse_phenotype_data.pl:          $pf_ins_sth->bind_param(1,$phenotype_id,SQL_INTEGER);
scripts/import/import_mouse_phenotype_data.pl:          $pf_ins_sth->bind_param(2,$source_id,SQL_INTEGER);
scripts/import/import_mouse_phenotype_data.pl:          $pf_ins_sth->bind_param(3,$type,SQL_VARCHAR);
scripts/import/import_mouse_phenotype_data.pl:          $pf_ins_sth->bind_param(4,$object_id,SQL_VARCHAR);
scripts/import/import_mouse_phenotype_data.pl:          $pf_ins_sth->bind_param(5,$is_significant,SQL_INTEGER);
scripts/import/import_mouse_phenotype_data.pl:          $pf_ins_sth->bind_param(6,$seq_region_id,SQL_INTEGER);
scripts/import/import_mouse_phenotype_data.pl:          $pf_ins_sth->bind_param(7,$seq_region_start,SQL_INTEGER);
scripts/import/import_mouse_phenotype_data.pl:          $pf_ins_sth->bind_param(8,$seq_region_end,SQL_INTEGER);
scripts/import/import_mouse_phenotype_data.pl:          $pf_ins_sth->bind_param(9,$seq_region_strand,SQL_INTEGER);
scripts/import/import_mouse_phenotype_data.pl:          $pf_ins_sth->execute();
scripts/import/import_mouse_phenotype_data.pl:          $already_inserted->{$key} = 1;
scripts/import/import_mouse_phenotype_data.pl:          my $pf_id = $dbh->{'mysql_insertid'};
scripts/import/import_mouse_phenotype_data.pl:          foreach my $attrib_type(grep {defined($attribs->{$_}) && $attribs->{$_} ne ''} @attrib_types) {
scripts/import/import_mouse_phenotype_data.pl:            my $value = $attribs->{$attrib_type};
scripts/import/import_mouse_phenotype_data.pl:            $sth->bind_param(1,$pf_id,SQL_INTEGER);
scripts/import/import_mouse_phenotype_data.pl:            $sth->bind_param(2,$value,SQL_VARCHAR);
scripts/import/import_mouse_phenotype_data.pl:            $sth->bind_param(3,$attrib_type,SQL_VARCHAR);
scripts/import/import_mouse_phenotype_data.pl:            $sth->execute();
scripts/import/import_mouse_phenotype_data.pl:  $fh->close();
scripts/import/import_mouse_phenotype_data.pl:  my $gene_adaptor = $config->{gene_adaptor};
scripts/import/import_mouse_phenotype_data.pl:  my $phenotype_file = $config->{"$data_source\_phenotype_file"};
scripts/import/import_mouse_phenotype_data.pl:  my $fh = FileHandle->new($phenotype_file, 'r');
scripts/import/import_mouse_phenotype_data.pl:      $hash->{$key} = $value;
scripts/import/import_mouse_phenotype_data.pl:      $column_headers->{$key} = 1;
scripts/import/import_mouse_phenotype_data.pl:    $markers->{$hash->{marker_accession_id}} = 1;
scripts/import/import_mouse_phenotype_data.pl:  $fh->close();
scripts/import/import_mouse_phenotype_data.pl:  my $coord_file = $config->{coord_file};	
scripts/import/import_mouse_phenotype_data.pl:  $fh = FileHandle->new($coord_file, 'r');
scripts/import/import_mouse_phenotype_data.pl:  my $marker_coords = $config->{marker_coords} || {};
scripts/import/import_mouse_phenotype_data.pl:        $header->{$column_number} = $column_name;
scripts/import/import_mouse_phenotype_data.pl:      unless ($header->{'1.'} eq 'MGI Marker Accession ID') { die 'Header in MGI_MRK_Coord.rpt has changed.'};
scripts/import/import_mouse_phenotype_data.pl:      unless ($header->{'6.'} eq 'Chromosome') { die 'Header in MGI_MRK_Coord.rpt has changed.'};
scripts/import/import_mouse_phenotype_data.pl:      unless ($header->{'7.'} eq 'Start Coordinate') { die 'Header in MGI_MRK_Coord.rpt has changed.'};
scripts/import/import_mouse_phenotype_data.pl:      unless ($header->{'8.'} eq 'End Coordinate') { die 'Header in MGI_MRK_Coord.rpt has changed.'};
scripts/import/import_mouse_phenotype_data.pl:      unless ($header->{'9.'} eq 'Strand') { die 'Header in MGI_MRK_Coord.rpt has changed.'};
scripts/import/import_mouse_phenotype_data.pl:    if ($markers->{$marker_acc}) {
scripts/import/import_mouse_phenotype_data.pl:      unless ($marker_coords->{$marker_acc}) {
scripts/import/import_mouse_phenotype_data.pl:        my $genes = $gene_adaptor->fetch_all_by_external_name($marker_acc);
scripts/import/import_mouse_phenotype_data.pl:            $unique_seq_region_id->{$gene->slice->get_seq_region_id} = 1;
scripts/import/import_mouse_phenotype_data.pl:        $marker_coords->{$marker_acc}->{type} = $marker_type;
scripts/import/import_mouse_phenotype_data.pl:        $marker_coords->{$marker_acc}->{object_id} = join(";", map {$_->stable_id} @$genes);
scripts/import/import_mouse_phenotype_data.pl:        $marker_coords->{$marker_acc}->{chromosome} = $chromosome;
scripts/import/import_mouse_phenotype_data.pl:        $marker_coords->{$marker_acc}->{seq_region_id} = $genes->[0]->slice->get_seq_region_id;
scripts/import/import_mouse_phenotype_data.pl:        $marker_coords->{$marker_acc}->{seq_region_start} = $start_coord;
scripts/import/import_mouse_phenotype_data.pl:        $marker_coords->{$marker_acc}->{seq_region_end} = $end_coord;
scripts/import/import_mouse_phenotype_data.pl:        $marker_coords->{$marker_acc}->{seq_region_strand} = ($strand eq '+') ? 1 : -1;
scripts/import/import_mouse_phenotype_data.pl:  $fh->close();
scripts/import/import_mouse_phenotype_data.pl:  $config->{marker_coords} = $marker_coords;
scripts/import/import_mouse_phenotype_data.pl:    # If a range format is found (e.g. 10^-2 > p > 10^-3)
scripts/import/import_mouse_phenotype_data.pl:    if ($pval =~ /^\d+\^(-\d+)/) {
scripts/import/import_mouse_phenotype_data.pl:      $sci_pval = "1.00e$1"; # e.g 10^-2 > p > 10^-3 => 1.00e-2
scripts/import/import_mouse_phenotype_data.pl:      #$sci_pval = sprintf("%.2e",$pval); # e.g. 0.002 => 2,30e-3
scripts/import/import_mouse_phenotype_data.pl:    if ($pval =~ /^(\d+)(e-?\d+)/) {
scripts/import/import_mouse_phenotype_data.pl:    if ($pval =~ /^(\d+\.\d{1})(e-?\d+)/) {
scripts/import/import_mouse_phenotype_data.pl:    if ($pval =~ /^(\d+\.\d+e-?)(\d{1})$/) {
scripts/import/import_mouse_phenotype_data.pl:  my $dbh = $config->{dbh};
scripts/import/import_mouse_phenotype_data.pl:  my $sth = $dbh->prepare(qq{ SELECT code FROM attrib_type });
scripts/import/import_mouse_phenotype_data.pl:  $sth->execute();
scripts/import/import_mouse_phenotype_data.pl:  $sth->bind_columns(\$attrib_type);
scripts/import/import_mouse_phenotype_data.pl:  push @tmp_types, $attrib_type while $sth->fetch();
scripts/import/import_mouse_phenotype_data.pl:  $sth->finish;
scripts/import/import_mouse_phenotype_data.pl:  my $dbh = $config->{dbh};
scripts/import/import_mouse_phenotype_data.pl:  my $sth = $dbh->prepare($stmt);
scripts/import/import_mouse_phenotype_data.pl:  $sth->execute();
scripts/import/import_mouse_phenotype_data.pl:  $sth->bind_columns(\$source_id);
scripts/import/import_mouse_phenotype_data.pl:  $sth->fetch();
scripts/import/import_mouse_phenotype_data.pl:    $stmt = $dbh->prepare($stmt);
scripts/import/import_mouse_phenotype_data.pl:    $stmt->execute();
scripts/import/import_mouse_phenotype_data.pl:    $source_id = $dbh->{'mysql_insertid'};
scripts/import/import_mouse_phenotype_data.pl:    $stmt->finish();
scripts/import/import_mouse_phenotype_data.pl:    my $version = $config->{version};
scripts/import/import_mouse_phenotype_data.pl:      $dbh->do(qq{UPDATE source SET version=$version WHERE name='$source_name';}) or die $dbh->errstr;
scripts/import/import_mouse_phenotype_data.pl:  -help               Print this message
scripts/import/import_mouse_phenotype_data.pl:  -host      Variation database host name (Required)
scripts/import/import_mouse_phenotype_data.pl:  -dbname    Variation database name (Required)
scripts/import/import_mouse_phenotype_data.pl:  -user      Variation database user (Required)
scripts/import/import_mouse_phenotype_data.pl:  -pass      Variation database password (Required)
scripts/import/import_mouse_phenotype_data.pl:  -port      Variation database port (Default: 3306)
scripts/import/import_mouse_phenotype_data.pl:  -chost     Core database host name (Required for gene-type sources)
scripts/import/import_mouse_phenotype_data.pl:  -cdbname   Core database name (Required for gene-type sources)
scripts/import/import_mouse_phenotype_data.pl:  -cuser     Core database user (Required for gene-type sources)
scripts/import/import_mouse_phenotype_data.pl:  -cpass     Core database password (Default: )
scripts/import/import_mouse_phenotype_data.pl:  -cport     Core database port (Default: 3306)
scripts/import/import_mouse_phenotype_data.pl:  -registry  Location of registry file with database connections to mouse variation and core databases
scripts/import/import_mouse_phenotype_data.pl:  -coord_file      Location of MGI_MRK_Coord.rpt file (Reguired)
scripts/import/import_mouse_phenotype_data.pl:  -working_dir     Location of a directory to save temporary results
scripts/import/calc_genotypes.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/calc_genotypes.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/calc_genotypes.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/calc_genotypes.pl:between two genetic markers under the assumption of Hardy-Weinberg equilibrium.
scripts/import/calc_genotypes.pl:    -------------------
scripts/import/calc_genotypes.pl:recombination occurs (1 - theta) whereas pair Ab/aB arises in the presence of recombination
scripts/import/calc_genotypes.pl:  while(theta-thetaprev > CONVERGENCE_CRITERIA) 
scripts/import/calc_genotypes.pl:    prAB=(nAB + (1-theta)*cells[4])/N;
scripts/import/calc_genotypes.pl:    prab=(nab + (1-theta)*cells[4])/N;
scripts/import/calc_genotypes.pl:i.e., D = prAB - frq(A)*frq(B), r^2 = D^2/(frq(A)*frq(B)*frq(a)*frq(b)),
scripts/import/calc_genotypes.pl:# locus chr position person-id genotype variation_feature_id population_id
scripts/import/calc_genotypes.pl:my $seq_region_id_previous = -1;
scripts/import/calc_genotypes.pl:my $last_position = -1;
scripts/import/calc_genotypes.pl:    $last_position = -1;
scripts/import/calc_genotypes.pl:  while ( @positions_ordered && (abs($positions_ordered[0]-$position) > WINDOW_SIZE())){
scripts/import/calc_genotypes.pl:  $additional_info{$locus}->{position} = $position;
scripts/import/calc_genotypes.pl:  $additional_info{$locus}->{variation_feature_id} = $variation_feature_id;
scripts/import/calc_genotypes.pl:  $additional_info{$locus}->{seq_region_end} = $seq_region_end;
scripts/import/calc_genotypes.pl:  $additional_info{$locus}->{population_id} = $population_id;
scripts/import/calc_genotypes.pl:  my $locus1 = $snps_ordered->{$position};
scripts/import/calc_genotypes.pl:  my $seq_region_start = $additional_info->{$locus1}->{position};
scripts/import/calc_genotypes.pl:    $locus2 = $snps_ordered->{$position2};
scripts/import/calc_genotypes.pl:    $seq_region_end = $additional_info->{$locus2}->{seq_region_end};
scripts/import/calc_genotypes.pl:    my $stats_hash = &calculate_pairwise_stats( $genotypes->{$snps_ordered->{$position}},
scripts/import/calc_genotypes.pl:						$genotypes->{$snps_ordered->{$position2}} );
scripts/import/calc_genotypes.pl:    next unless ($stats_hash->{'r2'} >= 0.05 && $stats_hash->{'N'} >= 40); #cut-off in 5% and at least 20 individuals genotyped
scripts/import/calc_genotypes.pl:		  $additional_info->{$locus1}->{variation_feature_id},
scripts/import/calc_genotypes.pl:		  $additional_info->{$locus2}->{variation_feature_id},
scripts/import/calc_genotypes.pl:		  $additional_info->{$locus1}->{population_id},
scripts/import/calc_genotypes.pl:		  $stats_hash->{'r2'}, 
scripts/import/calc_genotypes.pl:		  abs($stats_hash->{'d_prime'}),
scripts/import/calc_genotypes.pl:		  $stats_hash->{'N'}),"\n";	
scripts/import/calc_genotypes.pl:      $people{$g->{'personid'}} = $g->{'genotype'};
scripts/import/calc_genotypes.pl:      if( exists $people{$h->{'personid'}} ) {
scripts/import/calc_genotypes.pl:	my $hg = $h->{'genotype'};
scripts/import/calc_genotypes.pl:	$people{$h->{'personid'}} .= $hg;
scripts/import/calc_genotypes.pl:    my $ld_cache_key = join( "-", $nab,$naB, $nAb, $nAB, $AaBb );
scripts/import/calc_genotypes.pl:    while( abs($theta-$thetaprev) > 0.0001 ) {	
scripts/import/calc_genotypes.pl:	  # $pAB = ($nAB + (1-$theta)*$AaBb)/$N;
scripts/import/calc_genotypes.pl:	  # $pab = ($nab + (1-$theta)*$AaBb)/$N;
scripts/import/calc_genotypes.pl:		    (($nAB + (1-$theta)*$AaBb)*($nab + (1-$theta)*$AaBb) + 
scripts/import/calc_genotypes.pl:    # my $D  = $pAB - ($f_A*$f_B);
scripts/import/calc_genotypes.pl:      $D  = ($nAB+(1-$theta)*$AaBb)/$N - ($f_A*$f_B);
scripts/import/calc_genotypes.pl:      $r2 = $D*$D/($f_A*$f_B*(1-$f_A)*(1-$f_B)); 
scripts/import/calc_genotypes.pl:	$Dmax = $f_A*$f_B if ($f_A*$f_B < ((1-$f_A)*(1-$f_B)));
scripts/import/calc_genotypes.pl:	$Dmax = (1-$f_A)*(1-$f_B) if ($f_A*$f_B >= ((1-$f_A)*(1-$f_B)));	
scripts/import/calc_genotypes.pl:	$Dmax = $f_A*(1-$f_B) if ($f_A*(1-$f_B) < (1-$f_A)*$f_B);
scripts/import/calc_genotypes.pl:	$Dmax = (1-$f_A)*$f_B if ($f_A*(1-$f_B) >= (1-$f_A)*$f_B);
scripts/import/import_hgmd.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_hgmd.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_hgmd.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_hgmd.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/import_hgmd.pl:my $vdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/import_hgmd.pl:my $dbh = $vdb->dbc->db_handle;
scripts/import/import_hgmd.pl:my $select_source_sth = $dbh->prepare(qq{
scripts/import/import_hgmd.pl:  SELECT source_id FROM source WHERE name='HGMD-PUBLIC';
scripts/import/import_hgmd.pl:$select_source_sth->execute();
scripts/import/import_hgmd.pl:my $source_id = ($select_source_sth->fetchrow_array)[0];
scripts/import/import_hgmd.pl:die ("HGMD tables not found in the database!\nBe sure you ran the script 'map_hgmd_coord.pl' before running the current script.\n") if ($dbh->do(qq{show tables like "$var_table";}) != 1);
scripts/import/import_hgmd.pl:  my $select_vh_sth = $dbh->prepare(qq{
scripts/import/import_hgmd.pl:  my $insert_v_sth = $dbh->prepare(qq{
scripts/import/import_hgmd.pl:  my $select_v_sth = $dbh->prepare(qq{
scripts/import/import_hgmd.pl:  my $update_vh_sth = $dbh->prepare(qq{
scripts/import/import_hgmd.pl:  my $select_not_existing_sth = $dbh->prepare(qq{
scripts/import/import_hgmd.pl:  if ($dbh->do(qq{show columns from $var_table like 'new_var_id';}) != 1){
scripts/import/import_hgmd.pl:    $dbh->do(qq{ALTER TABLE $var_table ADD COLUMN new_var_id int(10);});
scripts/import/import_hgmd.pl:    $dbh->do(qq{ALTER TABLE $var_table ADD INDEX new_var_idx (new_var_id);});
scripts/import/import_hgmd.pl:  $select_vh_sth->execute();
scripts/import/import_hgmd.pl:  while (my @res = $select_vh_sth->fetchrow_array) {
scripts/import/import_hgmd.pl:    $insert_v_sth->execute($res[0],$source_id, $res[1]);
scripts/import/import_hgmd.pl:    $select_v_sth->execute($res[0],$source_id);
scripts/import/import_hgmd.pl:    my $new_id = ($select_v_sth->fetchrow_array)[0];
scripts/import/import_hgmd.pl:      $update_vh_sth->execute($new_id,$res[0]);
scripts/import/import_hgmd.pl:  $select_not_existing_sth->execute($source_id);
scripts/import/import_hgmd.pl:  while (my @res = $select_not_existing_sth->fetchrow_array) {
scripts/import/import_hgmd.pl:  my $insert_vf_sth = $dbh->prepare(qq{
scripts/import/import_hgmd.pl:  $insert_vf_sth->execute($source_id);
scripts/import/import_hgmd.pl:  my $select_phe_sth = $dbh->prepare(qq{
scripts/import/import_hgmd.pl:  $select_phe_sth->execute();
scripts/import/import_hgmd.pl:  my $phenotype_id = ($select_phe_sth->fetchrow_array)[0];
scripts/import/import_hgmd.pl:    $dbh->do(qq{INSERT INTO phenotype (name,description,class_attrib_id)
scripts/import/import_hgmd.pl:    $phenotype_id = $dbh->{'mysql_insertid'};
scripts/import/import_hgmd.pl:  my $insert_pf_sth = $dbh->prepare(qq{
scripts/import/import_hgmd.pl:  $insert_pf_sth->execute($phenotype_id,$source_id);
scripts/import/import_hgmd.pl:  my $select_attr_sth = $dbh->prepare(qq{
scripts/import/import_hgmd.pl:  $select_attr_sth->execute();
scripts/import/import_hgmd.pl:  my $attrib_type_id = ($select_attr_sth->fetchrow_array)[0];
scripts/import/import_hgmd.pl:  die("Variation annotation - Can't find an attribute type ID for 'associated_gene in the table attrib_type'") if (!defined($attrib_type_id));
scripts/import/import_hgmd.pl:  my $insert_pfa_sth = $dbh->prepare(qq{
scripts/import/import_hgmd.pl:  $insert_pfa_sth->execute($attrib_type_id);
scripts/import/import_hgmd.pl:	my $update_vf_sth = $dbh->prepare(qq{
scripts/import/import_hgmd.pl:	$update_vf_sth->execute($source_id);
scripts/import/import_hgmd.pl:	my $update_pf_sth = $dbh->prepare(qq{
scripts/import/import_hgmd.pl:	$update_pf_sth->execute($source_id);
scripts/import/import_hgmd.pl:  my $variation_set_ids = $dbh->selectrow_arrayref(qq{SELECT v.variation_set_id
scripts/import/import_hgmd.pl:    return $variation_set_ids->[0];
scripts/import/import_hgmd.pl:  my $aa = $vdb->get_AttributeAdaptor();
scripts/import/import_hgmd.pl:  my $attrib_id = $aa->attrib_id_for_type_value($type, $value);
scripts/import/import_hgmd.pl:  my $sth2 = $dbh->prepare($insert_set_stmt);
scripts/import/import_hgmd.pl:  $sth2->bind_param(1,$hgmd_set_id,SQL_INTEGER);
scripts/import/import_hgmd.pl:  $sth2->bind_param(2,$source_id,SQL_INTEGER);
scripts/import/import_hgmd.pl:  $sth2->execute();
scripts/import/clinvar_post_process.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/clinvar_post_process.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/clinvar_post_process.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/clinvar_post_process.pl:### post-processing of clinvar import
scripts/import/clinvar_post_process.pl:$registry->load_all($registry_file);
scripts/import/clinvar_post_process.pl:my $db_adaptor = $registry->get_DBAdaptor('homo_sapiens','variation') 
scripts/import/clinvar_post_process.pl:my $slice_adaptor = $registry->get_adaptor('homo_sapiens','core', 'slice')
scripts/import/clinvar_post_process.pl:my $dbh = $db_adaptor->dbc;
scripts/import/clinvar_post_process.pl:    #get ClinVar - source_id
scripts/import/clinvar_post_process.pl:    my $source_id_sth = $dbh->prepare(qq[ SELECT source_id
scripts/import/clinvar_post_process.pl:    my $variant_ext_sth = $dbh->prepare(qq[SELECT vf.variation_id, vf.variation_name,
scripts/import/clinvar_post_process.pl:    my $failed_set_ext_sth = $dbh->prepare(qq[ SELECT variation_set_id
scripts/import/clinvar_post_process.pl:    my $insert_failed_var_sth = $dbh->prepare(qq[INSERT IGNORE INTO failed_variation(variation_id, failed_description_id)
scripts/import/clinvar_post_process.pl:    my $insert_failed_var_set_var_sth = $dbh->prepare(qq[INSERT IGNORE INTO variation_set_variation (variation_id, variation_set_id)
scripts/import/clinvar_post_process.pl:    my $update_failed_var_feat_sth = $dbh->prepare(qq[UPDATE variation_feature
scripts/import/clinvar_post_process.pl:    $source_id_sth->execute($SOURCENAME);
scripts/import/clinvar_post_process.pl:    my $source_id =  $source_id_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:    $variant_ext_sth-> execute($source_id->[0]->[0]);
scripts/import/clinvar_post_process.pl:    my $var_feat_list =  $variant_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:    $failed_set_ext_sth->execute( "fail_all");
scripts/import/clinvar_post_process.pl:    my $set_id = $failed_set_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:        my %var = ( "start"       =>  $l->[3],
scripts/import/clinvar_post_process.pl:                    "end"         =>  $l->[4],
scripts/import/clinvar_post_process.pl:                    "strand"      =>  $l->[5],
scripts/import/clinvar_post_process.pl:                    "seqreg_name" =>  $l->[7],
scripts/import/clinvar_post_process.pl:                    "allele"      =>  $l->[9],
scripts/import/clinvar_post_process.pl:                    "source"      =>  $l->[6],
scripts/import/clinvar_post_process.pl:                    "name"        =>  $l->[1],
scripts/import/clinvar_post_process.pl:                    "id"          =>  $l->[0],
scripts/import/clinvar_post_process.pl:              $insert_failed_var_sth->execute($var{id}, $fail);
scripts/import/clinvar_post_process.pl:            $insert_failed_var_set_var_sth->execute($var{id}, $set_id->[0]->[0]);
scripts/import/clinvar_post_process.pl:            $update_failed_var_feat_sth->execute($set_id->[0]->[0], $var{id});
scripts/import/clinvar_post_process.pl:    # Extract reference sequence to run ref checks [ compliments for reverse strand multi-mappers]
scripts/import/clinvar_post_process.pl:    ## Type 2: None of the variant alleles match the reference allele - is ref base in agreement?
scripts/import/clinvar_post_process.pl:    my $exp_ref = (split/\//, $var->{allele} )[0] ;
scripts/import/clinvar_post_process.pl:    my $ref = (split/\//, $var->{allele} )[0];
scripts/import/clinvar_post_process.pl:    my $match_coord_length = check_variant_size( $var->{start}, $var->{end}, $ref);
scripts/import/clinvar_post_process.pl:    ## Type 14 resolve ambiguities before reference check - flag variants & alleles as fails
scripts/import/clinvar_post_process.pl:    my $is_ambiguous = check_for_ambiguous_alleles( $var->{allele} );
scripts/import/clinvar_post_process.pl:    ## Type 13 Alleles contain non-nucleotide characters
scripts/import/clinvar_post_process.pl:    my $is_illegal = check_illegal_characters( $var->{allele} );
scripts/import/clinvar_post_process.pl:    push @fail, 13  if(defined $is_illegal->[0]) ;
scripts/import/clinvar_post_process.pl:    my $clinvar_ext_sth = $dbh->prepare(qq[ select variation.variation_id, phenotype_feature_attrib.value
scripts/import/clinvar_post_process.pl:    my $var_upd_sth = $dbh->prepare(qq[ update variation
scripts/import/clinvar_post_process.pl:    my $varf_upd_sth = $dbh->prepare(qq[ update variation_feature
scripts/import/clinvar_post_process.pl:    $clinvar_ext_sth->execute( $SOURCENAME );
scripts/import/clinvar_post_process.pl:    my $var_list = $clinvar_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:        ## save ids to make 2 variation_sets - 'All' and 'Clinically significant'
scripts/import/clinvar_post_process.pl:	$assoc{$l->[0]}{A} = 1;
scripts/import/clinvar_post_process.pl:	$assoc{$l->[0]}{C} = 1  if $l->[1] =~ /pathogenic|drug-response|histocompatibility/i && $l->[1] !~ /non/;
scripts/import/clinvar_post_process.pl:      $l->[1]  =~ s/\//\,/ ; # convert 'pathogenic/likely pathogenic' to 'pathogenic,likely pathogenic'
scripts/import/clinvar_post_process.pl:      $l->[1]  =~ s/\;\s+/\,/g ; # convert 'uncertain significance; risk factor' to 'uncertain significance,risk factor'
scripts/import/clinvar_post_process.pl:      $l->[1]  =~ s/\,\s+/\,/g ; # convert 'likely benign, other' to 'likely benign,other' or 'benign, association, risk factor' to 'benign,association,risk factor'
scripts/import/clinvar_post_process.pl:      $l->[1]  =~ s/conflicting interpretations of pathogenicity/uncertain significance/g;
scripts/import/clinvar_post_process.pl:      $l->[1]  =~ s/association not found/other/g;
scripts/import/clinvar_post_process.pl:	push @{$class{$l->[0]}}, $l->[1];
scripts/import/clinvar_post_process.pl:        $var_upd_sth->execute($statuses, $var);
scripts/import/clinvar_post_process.pl:        $varf_upd_sth->execute($statuses, $var);
scripts/import/clinvar_post_process.pl:    my $vsv_ins_sth = $dbh->prepare(qq[ insert into variation_set_variation
scripts/import/clinvar_post_process.pl:	$vsv_ins_sth->execute( $var, $all_set_id );
scripts/import/clinvar_post_process.pl:	$vsv_ins_sth->execute( $var, $clin_set_id ) 
scripts/import/clinvar_post_process.pl:	    if defined $variation_ids->{$var}{C} && $variation_ids->{$var}{C} == 1;
scripts/import/clinvar_post_process.pl:	    'desc' => 'Variants described by ClinVar as being probable-pathogenic, pathogenic, drug-response or histocompatibility',
scripts/import/clinvar_post_process.pl:    my $attrib_ext_sth = $dbh->prepare(qq[ select attrib_id from attrib 
scripts/import/clinvar_post_process.pl:    my $set_ext_sth = $dbh->prepare(qq[ select variation_set_id 
scripts/import/clinvar_post_process.pl:    my $set_ins_sth = $dbh->prepare(qq[ insert into variation_set 
scripts/import/clinvar_post_process.pl:    my $set_del_sth = $dbh->prepare(qq[ delete from variation_set_variation where variation_set_id = ?]);
scripts/import/clinvar_post_process.pl:    $set_ext_sth->execute( $set);
scripts/import/clinvar_post_process.pl:    my $set_id = $set_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:    if (defined $set_id->[0]->[0] ){
scripts/import/clinvar_post_process.pl:	$set_del_sth->execute($set_id->[0]->[0]);
scripts/import/clinvar_post_process.pl:	return $set_id->[0]->[0] ;
scripts/import/clinvar_post_process.pl:    $attrib_ext_sth->execute( $set);
scripts/import/clinvar_post_process.pl:    my $attrib_id = $attrib_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:    die "Exiting: attrib not available for $set\n" unless defined $attrib_id->[0]->[0];
scripts/import/clinvar_post_process.pl:    $set_ins_sth->execute( $data->{$set}->{name}, $data->{$set}->{desc}, $attrib_id->[0]->[0] ); 
scripts/import/clinvar_post_process.pl:    $set_id = $dbh->db_handle->last_insert_id(undef, undef, qw(variation_set set_id))|| die "no insert id for set $set\n";
scripts/import/clinvar_post_process.pl:    my $pheno_ext_sth = $dbh->prepare(qq[ select phenotype_id, description from phenotype ]);
scripts/import/clinvar_post_process.pl:    $pheno_ext_sth->execute()||die;
scripts/import/clinvar_post_process.pl:    my $ph =  $pheno_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:	warn "Phenotype id:$l->[0] has no description\n" unless defined $l->[1];
scripts/import/clinvar_post_process.pl:	my $full = $l->[1];
scripts/import/clinvar_post_process.pl:	$l->[1] =~ s/\w+|\-|\,|\(|\)|\s+|\/|\.|\;|\+|\'|\:|\@|\*|\%//g;
scripts/import/clinvar_post_process.pl:	warn "Phenotype : $full (id:$l->[0]) looks suspect\n" if(length($l->[1]) >0);
scripts/import/clinvar_post_process.pl:   my $var_count_ext_sth   = $dbh->prepare(qq[ select count(*) from variation 
scripts/import/clinvar_post_process.pl:   my $varf_count_ext_sth  = $dbh->prepare(qq[ select count(*) from variation_feature 
scripts/import/clinvar_post_process.pl:   my $set_count_ext_sth   = $dbh->prepare(qq[ select count(*) from variation_set, variation_set_variation
scripts/import/clinvar_post_process.pl:   my $pheno_count_ext_sth = $dbh->prepare(qq[ select count(*) from phenotype_feature, source 
scripts/import/clinvar_post_process.pl:   my $featless_count_ext_sth = $dbh->prepare(qq[ select count(*) from phenotype 
scripts/import/clinvar_post_process.pl:   my $class_ext_sth       = $dbh->prepare(qq[ select attrib.value 
scripts/import/clinvar_post_process.pl:   my $class_count_ext_sth = $dbh->prepare(qq[ select clinical_significance, count(*) 
scripts/import/clinvar_post_process.pl:  my $pheno_attrib_ext_sth = $dbh->prepare(qq[ SELECT a.code, count(*)
scripts/import/clinvar_post_process.pl:  my $omim_set_ext_sth = $dbh->prepare(qq[ SELECT count(*)
scripts/import/clinvar_post_process.pl:   $pheno_count_ext_sth->execute( $SOURCENAME )||die;
scripts/import/clinvar_post_process.pl:   my $ph =  $pheno_count_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:   warn "$ph->[0]->[0] phenotype_feature entries from ClinVar\n";
scripts/import/clinvar_post_process.pl:   $var_count_ext_sth->execute()||die;
scripts/import/clinvar_post_process.pl:   my $var =  $var_count_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:   warn "$var->[0]->[0] variation entries with ClinVar statuses\n";
scripts/import/clinvar_post_process.pl:   $varf_count_ext_sth->execute()||die;
scripts/import/clinvar_post_process.pl:   my $varf =  $varf_count_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:   warn "$varf->[0]->[0] variation_feature entries with ClinVar statuses\n";
scripts/import/clinvar_post_process.pl:       $set_count_ext_sth->execute($set)||die;
scripts/import/clinvar_post_process.pl:       my $set_count =  $set_count_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:       warn "$set_count->[0]->[0] variation entries in $set set\n";
scripts/import/clinvar_post_process.pl:   $featless_count_ext_sth->execute()||die;
scripts/import/clinvar_post_process.pl:   my $featless =  $featless_count_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:   warn "$featless->[0]->[0] phenotype entries have no phenotype features\n";
scripts/import/clinvar_post_process.pl:   $class_count_ext_sth->execute()||die;
scripts/import/clinvar_post_process.pl:   my $class_num = $class_count_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:       warn "$l->[1]\t$l->[0]\n";
scripts/import/clinvar_post_process.pl:       $class_count{$l->[0]} = $l->[1];
scripts/import/clinvar_post_process.pl:   $class_ext_sth->execute()||die;
scripts/import/clinvar_post_process.pl:   my $classes = $class_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:       warn "\nNo variants with class: $l->[0]\n"  unless defined  $class_count{$l->[0]} ;
scripts/import/clinvar_post_process.pl:   $omim_set_ext_sth->execute( "ph_omim"); #get OMIM set id
scripts/import/clinvar_post_process.pl:   my $omim_set_count = $omim_set_ext_sth->fetchrow_array();
scripts/import/clinvar_post_process.pl:   $pheno_attrib_ext_sth->execute()||die;
scripts/import/clinvar_post_process.pl:   my $rows = $pheno_attrib_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:    my $pheno_ext_sth   = $dbh->prepare(qq[ select phenotype_id from phenotype where description = "ClinVar: phenotype not specified" ]);
scripts/import/clinvar_post_process.pl:    my $pheno_attrib_del_sth   = $dbh->prepare(qq[ delete from phenotype_feature_attrib 
scripts/import/clinvar_post_process.pl:    my $pheno_feature_del_sth   = $dbh->prepare(qq[ delete from phenotype_feature  
scripts/import/clinvar_post_process.pl:    #my $pheno_del_sth   = $dbh->prepare(qq[  delete from phenotype where phenotype_id = ?  ]);
scripts/import/clinvar_post_process.pl:    $pheno_ext_sth->execute()||die;
scripts/import/clinvar_post_process.pl:    my $id =  $pheno_ext_sth->fetchall_arrayref();
scripts/import/clinvar_post_process.pl:    die "Error - 2 phenotypes called . - not cleaning up\n"  if defined $id->[1]->[0] ;
scripts/import/clinvar_post_process.pl:    die "Error - no phenotypes called . - not cleaning up\n"  unless defined $id->[0]->[0] ;
scripts/import/clinvar_post_process.pl:    $pheno_attrib_del_sth->execute( $SOURCENAME,  $id->[0]->[0] )||die ;
scripts/import/clinvar_post_process.pl:    $pheno_feature_del_sth->execute( $SOURCENAME,  $id->[0]->[0] )||die ;
scripts/import/repeats_filter.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/repeats_filter.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/repeats_filter.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/repeats_filter.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/repeats_filter.pl:my $cdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/repeats_filter.pl:my $vdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/repeats_filter.pl:print "core_db is ",$cdb->dbc->dbname, " and var_db is ",$vdb->dbc->dbname," and seq_region_id is $seq_region_id\n";
scripts/import/repeats_filter.pl:my $dbCore = $cdb->dbc->db_handle;
scripts/import/repeats_filter.pl:my $dbVar = $vdb->dbc->db_handle;
scripts/import/repeats_filter.pl:my $slice_adaptor = $cdb->get_SliceAdaptor();
scripts/import/repeats_filter.pl:  my $sthv = $dbVar->prepare(qq{select variation_name,seq_region_start
scripts/import/repeats_filter.pl:  $sthv->execute();
scripts/import/repeats_filter.pl:  $sthv->bind_columns(\$variation_name,\$seq_start);
scripts/import/repeats_filter.pl:  while($sthv->fetch()) {
scripts/import/repeats_filter.pl:  my $slice = $slice_adaptor->fetch_by_seq_region_id($seq_region_id);
scripts/import/repeats_filter.pl:  my $end = $start + $slice_size -1;
scripts/import/repeats_filter.pl:  $end = $slice->length if($end > $slice->length);
scripts/import/repeats_filter.pl:  while ($start <= $slice->length) {
scripts/import/repeats_filter.pl:    my $sub_slice = $slice->sub_Slice($start,$end);
scripts/import/repeats_filter.pl:    my @variation_features = @{$sub_slice->get_all_VariationFeatures};
scripts/import/repeats_filter.pl:      if ($rec_name{$vf->variation_name}) {
scripts/import/repeats_filter.pl:    my %rec_starts = map {$_->start, $_->variation_name}  @vfs;
scripts/import/repeats_filter.pl:    my $repeat_masked_slice = $sub_slice->get_repeatmasked_seq();
scripts/import/repeats_filter.pl:    my $dna = $repeat_masked_slice->seq();
scripts/import/repeats_filter.pl:    #warn `ps -p $$ -o vsz |tail -1`;
scripts/import/repeats_filter.pl:      if ($dnas[$var_start-1] eq 'N') {
scripts/import/repeats_filter.pl:    $end = $start + $slice_size -1;
scripts/import/repeats_filter.pl:    $end = $slice->length if($end > $slice->length);
scripts/import/import_illumina_chip.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_illumina_chip.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_illumina_chip.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_illumina_chip.pl:my $usage = "Usage:\n\timport_illumina_chip.pl -input [Illumina annotation file] -chip_name [Illumina chip name] 
scripts/import/import_illumina_chip.pl:-description [Illumina chip desc] -version [chip version] -chip_url [chip url (optional)]  -short_name [Variation set short name] -registry [Path to the registry file] 
scripts/import/import_illumina_chip.pl:-species [Species name] -debug [debug mode]\n";
scripts/import/import_illumina_chip.pl:die "\nError - no registry \n\n $usage"    unless defined $registry_file;
scripts/import/import_illumina_chip.pl:die "\nError - no species \n\n $usage"     unless defined $species;
scripts/import/import_illumina_chip.pl:die "\nError - no chip_name \n\n $usage"   unless defined $chip_name;
scripts/import/import_illumina_chip.pl:die "\nError - no description \n\n $usage" unless defined $chip_desc;
scripts/import/import_illumina_chip.pl:die "\nError - no input file \n\n $usage"  unless defined $infile;
scripts/import/import_illumina_chip.pl:die "\nError - no short name \n\n $usage"  unless defined $short_name;
scripts/import/import_illumina_chip.pl:$registry->load_all($registry_file);
scripts/import/import_illumina_chip.pl:my $slice_adaptor = $registry->get_adaptor($species, 'core', 'slice');
scripts/import/import_illumina_chip.pl:my $var_adaptor   = $registry->get_adaptor($species, 'variation', 'variation');
scripts/import/import_illumina_chip.pl:my $dbh = $var_adaptor->dbc->db_handle;
scripts/import/import_illumina_chip.pl:      # 1 - Add a variation entry
scripts/import/import_illumina_chip.pl:      # 2 - Check alleles (flip ?) => check reference using location
scripts/import/import_illumina_chip.pl:      my $seq_region_id = $seq_region_ids->{$data{'CHR'}};
scripts/import/import_illumina_chip.pl:      # 3 - Add alleles
scripts/import/import_illumina_chip.pl:        # 4 - Add VF if alleles and location OK (QC ?) 
scripts/import/import_illumina_chip.pl:        # 5 - Failed variants
scripts/import/import_illumina_chip.pl:  if ($dbh->selectrow_arrayref(qq{SELECT source_id FROM source WHERE name='$chip_name';})) {
scripts/import/import_illumina_chip.pl:    $dbh->do(qq{UPDATE IGNORE source SET description='$chip_desc',url='$chip_url',version=$version where name='$chip_name';});
scripts/import/import_illumina_chip.pl:    $dbh->do(qq{INSERT INTO source (name,description,url,version,type) VALUES ('$chip_name','$chip_desc','$chip_url',$version,'chip');});
scripts/import/import_illumina_chip.pl:  my @source_id = @{$dbh->selectrow_arrayref(qq{SELECT source_id FROM source WHERE name='$chip_name';})};
scripts/import/import_illumina_chip.pl:  my $var_name = ($data->{SOURCE} =~ /^rs\d+$/) ? $data->{SOURCE} : $data->{NAME};
scripts/import/import_illumina_chip.pl:  $var = get_variant_by_name($data->{NAME}) if (!$var && $var_name ne $data->{NAME});
scripts/import/import_illumina_chip.pl:  return ($var) ? [$var->dbID,$var->name] : [undef,undef];
scripts/import/import_illumina_chip.pl:  my $var = $var_adaptor->fetch_by_name($name);
scripts/import/import_illumina_chip.pl:  my $sth = $dbh->prepare(qq{SELECT attrib_id FROM attrib WHERE value="SNV"});
scripts/import/import_illumina_chip.pl:  $sth->execute()|| die "Problem getting class attrib ID\n";
scripts/import/import_illumina_chip.pl:  my $res = $sth->fetchall_arrayref();
scripts/import/import_illumina_chip.pl:  return (defined($res)) ? $res->[0]->[0] : 2;
scripts/import/import_illumina_chip.pl:  A/T/C/G/- expected for chips
scripts/import/import_illumina_chip.pl:  my $allele_code_ext_sth = $dbh->prepare(qq{SELECT allele_code_id, allele FROM allele_code});
scripts/import/import_illumina_chip.pl:  $allele_code_ext_sth->execute()|| die "Problem getting codes\n";
scripts/import/import_illumina_chip.pl:  my $al_data = $allele_code_ext_sth->fetchall_arrayref();
scripts/import/import_illumina_chip.pl:    $code{$l->[1]} = $l->[0];
scripts/import/import_illumina_chip.pl:  my $seq_region_ids_ext_sth = $dbh->prepare(qq{SELECT seq_region_id, name FROM seq_region});
scripts/import/import_illumina_chip.pl:  $seq_region_ids_ext_sth->execute() ||die "Error extracting seq_region_ids\n";
scripts/import/import_illumina_chip.pl:  my $data = $seq_region_ids_ext_sth->fetchall_arrayref();
scripts/import/import_illumina_chip.pl:  unless(defined $data->[0]->[0]){die "No seq region ids available\n";} 
scripts/import/import_illumina_chip.pl:    $seq_region_ids{$l->[1]} = $l->[0];
scripts/import/import_illumina_chip.pl:    my $seq_region_id = $seq_region_ids->{$chr};
scripts/import/import_illumina_chip.pl:    my $var_id_chrom_pos_ext_sth = $dbh->prepare(qq{SELECT 
scripts/import/import_illumina_chip.pl:    $var_id_chrom_pos_ext_sth->execute($start,$seq_region_id) || die "Error extracting var by location for $start,$chr,$allele\n";
scripts/import/import_illumina_chip.pl:    my $data = $var_id_chrom_pos_ext_sth->fetchall_arrayref();
scripts/import/import_illumina_chip.pl:    return [undef,undef] unless defined $data->[0]->[0];
scripts/import/import_illumina_chip.pl:    debug("check_by_location: Name: $data->[0]->[1] | Alleles: $data->[0]->[2] | Strand: $data->[0]->[3]") if ($debug);
scripts/import/import_illumina_chip.pl:    my $check_allele = $data->[0]->[2];
scripts/import/import_illumina_chip.pl:        if ($data->[0]->[3] eq "-1" ){
scripts/import/import_illumina_chip.pl:        elsif ($data->[0]->[3] eq "1" ) {
scripts/import/import_illumina_chip.pl:      debug("check_by_location: Existing variant found: $data->[0]->[2]") if ($debug);
scripts/import/import_illumina_chip.pl:      return [$data->[0]->[0],$data->[0]->[1]];
scripts/import/import_illumina_chip.pl:      debug("check_by_location: Strand & allele string incompatibile! See: $allele (data) vs $check_allele (ref)  | $data->[0]->[1] & $data->[0]->[2] (Strand $data->[0]->[3])") if ($debug);
scripts/import/import_illumina_chip.pl:  my $slice = $slice_adaptor->fetch_by_region('chromosome', $chr, $position, $position);
scripts/import/import_illumina_chip.pl:  my $ref_allele = $slice->seq;
scripts/import/import_illumina_chip.pl:  $dbh->do(qq{INSERT INTO variation (name,source_id,class_attrib_id) VALUES ('$name', $source_id, $class_attrib_id);});
scripts/import/import_illumina_chip.pl:  my $var_id = $dbh->{'mysql_insertid'};
scripts/import/import_illumina_chip.pl:  $dbh->do(qq{INSERT INTO variation_synonym (variation_id,name,source_id) VALUES ($var_id, '$syn_name', $source_id);});
scripts/import/import_illumina_chip.pl:  $alleles = $data->{'SNP'} unless ($alleles && $alleles ne '');
scripts/import/import_illumina_chip.pl:  @alleles_list = map{ $al_codes->{$_} } @alleles_list;
scripts/import/import_illumina_chip.pl:    $dbh->do(qq{INSERT INTO allele (variation_id,allele_code_id) VALUES ($var_id, $al_id);});
scripts/import/import_illumina_chip.pl:  $dbh->do(qq{ INSERT INTO variation_feature (
scripts/import/import_illumina_chip.pl:  $dbh->do(qq{ INSERT INTO failed_variation (variation_id,failed_description_id) VALUES ($var_id,$failed_id)});
scripts/import/import_illumina_chip.pl:  $dbh->do(qq{ UPDATE variation SET display=0 WHERE variation_id=$var_id});
scripts/import/import_illumina_chip.pl:  $dbh->do(qq{ UPDATE variation_feature SET display=0 WHERE variation_id=$var_id});
scripts/import/import_illumina_chip.pl:  my $sth1 = $dbh->prepare(qq{ SELECT vs.variation_set_id
scripts/import/import_illumina_chip.pl:  $sth1->execute($short_name) || die "Error extracting variation set ID from the short name $short_name\n";
scripts/import/import_illumina_chip.pl:  my $data = $sth1->fetchall_arrayref();
scripts/import/import_illumina_chip.pl:  if (defined $data->[0]->[0]) {
scripts/import/import_illumina_chip.pl:    return $data->[0]->[0];
scripts/import/import_illumina_chip.pl:  $dbh->do(qq{ INSERT INTO variation_set_variation (variation_id,variation_set_id) VALUES ($var_id,$var_set_id) }); 
scripts/import/get_cancer_gene_census.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/get_cancer_gene_census.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/get_cancer_gene_census.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/get_cancer_gene_census.pl:usage('-input_file argument is required') if (!$input_file);
scripts/import/get_cancer_gene_census.pl:usage('-output_file argument is required') if (!$output_file);
scripts/import/get_cancer_gene_census.pl:$registry->load_all( $registry_file );
scripts/import/get_cancer_gene_census.pl:my $ga = $registry->get_adaptor($species,'core','gene');
scripts/import/get_cancer_gene_census.pl:my $ota = $registry->get_adaptor( 'Multi', 'Ontology', 'OntologyTerm' );
scripts/import/get_cancer_gene_census.pl:  my $source = $json_hash->{'sourceID'};
scripts/import/get_cancer_gene_census.pl:  my $type          = $json_hash->{'type'};
scripts/import/get_cancer_gene_census.pl:  my $gene_symbol   = $json_hash->{'target'}{'gene_info'}{'symbol'};
scripts/import/get_cancer_gene_census.pl:  my $pmids         = parse_publications($json_hash->{'literature'}{'references'});
scripts/import/get_cancer_gene_census.pl:  my $phenotype_url = $json_hash->{'unique_association_fields'}{'disease_uri'};
scripts/import/get_cancer_gene_census.pl:  my $genes = $ga->fetch_all_by_external_name($gene_symbol, 'HGNC');		
scripts/import/get_cancer_gene_census.pl:  @$genes = grep {$_->stable_id !~ /^LRG_/} @$genes;
scripts/import/get_cancer_gene_census.pl:    my $gene_id = $json_hash->{'target'}{'id'};
scripts/import/get_cancer_gene_census.pl:    my $gene_id = $gene->stable_id;
scripts/import/get_cancer_gene_census.pl:  my $term = $ota->fetch_by_accession($id);
scripts/import/get_cancer_gene_census.pl:  $phenotype = $term->name if ($term);
scripts/import/get_cancer_gene_census.pl:    my $pub_id = $pub->{'lit_id'};
scripts/import/get_cancer_gene_census.pl:  Usage: perl get_go-imp_data.pl [OPTION]
scripts/import/get_cancer_gene_census.pl:  Fetch and store the GO-IMP data into a tabulated text file. This file will be used to import the data in the Variation
scripts/import/get_cancer_gene_census.pl:  database, using the script "import_phenotype_data.pl" with the option "-source go-imp"
scripts/import/get_cancer_gene_census.pl:      -help              Print this message
scripts/import/get_cancer_gene_census.pl:      -species       Species from which you want to get the data. (optional)
scripts/import/get_cancer_gene_census.pl:      -input_file    Path and name of the input text file. (Required)
scripts/import/get_cancer_gene_census.pl:      -output_file   Path and name of the output text file. (Required)
scripts/import/get_cancer_gene_census.pl:      -registry      Path to the registry file. (optional)
scripts/import/DBH.pm:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/DBH.pm:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/DBH.pm:     http://www.apache.org/licenses/LICENSE-2.0
scripts/import/DBH.pm:  $self->dbh(DBI->connect($dsn, $user, $pass,$opts));
scripts/import/DBH.pm:    $self->$type($value);
scripts/import/DBH.pm:  $self->user($user);
scripts/import/DBH.pm:  $self->pass($pass);
scripts/import/DBH.pm:  return $self->{'dbh'} = shift if(@_);
scripts/import/DBH.pm:  return $self->{'dbh'};
scripts/import/DBH.pm:  return $self->{'hostname'} = shift if(@_);
scripts/import/DBH.pm:  return $self->{'hostname'};
scripts/import/DBH.pm:  return $self->{'user'} = shift if(@_);
scripts/import/DBH.pm:  return $self->{'user'};
scripts/import/DBH.pm:  return $self->{'port'} = shift if(@_);
scripts/import/DBH.pm:  return $self->{'port'};
scripts/import/DBH.pm:  return $self->{'password'} = shift if(@_);
scripts/import/DBH.pm:  return $self->{'password'};
scripts/import/DBH.pm:  return $self->{'dbname'} = shift if(@_);
scripts/import/DBH.pm:  return $self->{'dbname'};
scripts/import/DBH.pm:  $self->dbh()->$method(@_);
scripts/import/import_decipher.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_decipher.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_decipher.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_decipher.pl:usage('-species argument is required')    if (!$species);
scripts/import/import_decipher.pl:usage('-input_file argument is required') if (!$input_file);
scripts/import/import_decipher.pl:usage('-version argument is required')    if (!$version);
scripts/import/import_decipher.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/import_decipher.pl:my $cdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/import_decipher.pl:my $vdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation_private');
scripts/import/import_decipher.pl:my $dbCore = $cdb->dbc->db_handle;
scripts/import/import_decipher.pl:my $dbVar = $vdb->dbc->db_handle;
scripts/import/import_decipher.pl:my $csa = Bio::EnsEMBL::Registry->get_adaptor($species, "core", "coordsystem");
scripts/import/import_decipher.pl:our $default_cs = $csa->fetch_by_name("chromosome");
scripts/import/import_decipher.pl:my $cs_attr_type_sth = $dbVar->prepare(qq{ SELECT attrib_type_id FROM attrib_type WHERE code='clinvar_clin_sig'});
scripts/import/import_decipher.pl:$cs_attr_type_sth->execute;
scripts/import/import_decipher.pl:my $cs_attr_type_id = ($cs_attr_type_sth->fetchrow_array)[0];
scripts/import/import_decipher.pl:$cs_attr_type_sth->finish;
scripts/import/import_decipher.pl:my $inheritance_attrib_type_id = ($dbVar->selectall_arrayref($stmt))->[0][0];
scripts/import/import_decipher.pl:my $phenotype_attrib_id = ($dbVar->selectall_arrayref($stmt))->[0][0];
scripts/import/import_decipher.pl:# run the mapping sub-routine if the data needs mapping
scripts/import/import_decipher.pl:  $dbVar->do("DROP TABLE IF EXISTS $temp_table;");
scripts/import/import_decipher.pl:  if (($dbVar->selectrow_arrayref(qq{SELECT count(*) FROM $temp_table WHERE (outer_start=0 AND start=0 AND inner_start=0) OR (inner_end=0 AND end=0 AND outer_end=0);}))->[0] != 0) {
scripts/import/import_decipher.pl:    $dbVar->do(qq{UPDATE $temp_table SET outer_start=outer_end, start=end, inner_start=inner_end WHERE outer_start=0 AND start=0 AND inner_start=0});
scripts/import/import_decipher.pl:    $dbVar->do(qq{UPDATE $temp_table SET outer_end=outer_start, end=start, inner_end=inner_start WHERE outer_end=0 AND end=0 AND inner_end=0});
scripts/import/import_decipher.pl:    $dbVar->do(qq{UPDATE $temp_table SET $coord = NULL WHERE $coord = 0;});
scripts/import/import_decipher.pl:  $dbVar->do(qq{UPDATE $temp_table SET start=outer_start, end=inner_start, 
scripts/import/import_decipher.pl:  if ($dbVar->selectrow_arrayref(qq{SELECT source_id FROM source WHERE name='$name';})) {
scripts/import/import_decipher.pl:    $dbVar->do(qq{UPDATE IGNORE source SET description='$desc',url='$url',version=$version where name='$name';});
scripts/import/import_decipher.pl:    $dbVar->do(qq{INSERT INTO source (name,description,url,version) VALUES ('$name','$desc','$url',$version);});
scripts/import/import_decipher.pl:  my @source_id = @{$dbVar->selectrow_arrayref(qq{SELECT source_id FROM source WHERE name='$name';})};
scripts/import/import_decipher.pl:  $dbVar->do($stmt);
scripts/import/import_decipher.pl:  $dbVar->do($pp_stmt);
scripts/import/import_decipher.pl:  $dbVar->do($stmt);
scripts/import/import_decipher.pl:  $dbVar->do($stmt);
scripts/import/import_decipher.pl:  my $rows_inds = $dbVar->selectall_arrayref($stmt);
scripts/import/import_decipher.pl:    my $sample = $row->[0];
scripts/import/import_decipher.pl:    $dbVar->do(qq{ INSERT IGNORE INTO individual (name,description,gender,individual_type_id) VALUES ('$sample','Subject from DECIPHER','$gender',$itype_val)});
scripts/import/import_decipher.pl:  my $rows_samples = $dbVar->selectall_arrayref($stmt);
scripts/import/import_decipher.pl:    my $sample = $row->[0];
scripts/import/import_decipher.pl:    $dbVar->do(qq{ INSERT IGNORE INTO sample (name,description,individual_id) SELECT '$sample','Sample from DECIPHER',individual_id FROM individual WHERE name='$sample'});
scripts/import/import_decipher.pl:  $dbVar->do($stmt);
scripts/import/import_decipher.pl:  if (($dbVar->selectall_arrayref($stmt))->[0][0] == 0) {
scripts/import/import_decipher.pl:  my $rows = $dbVar->selectall_arrayref($stmt);
scripts/import/import_decipher.pl:    my $phenotype = $row->[0];
scripts/import/import_decipher.pl:    $dbVar->do(qq{ INSERT IGNORE INTO phenotype (description, class_attrib_id) VALUES ('$phenotype', $phenotype_attrib_id)});
scripts/import/import_decipher.pl:  $dbVar->do($stmt);
scripts/import/import_decipher.pl:  $dbVar->do($stmt);
scripts/import/import_decipher.pl:  #$dbVar->do(qq{DROP TABLE $temp_table;});
scripts/import/import_decipher.pl:  my $sa = Bio::EnsEMBL::Registry->get_adaptor($species, 'core', 'slice');
scripts/import/import_decipher.pl:    if ($info->{'phenotype'}) {
scripts/import/import_decipher.pl:      my @phenotypes = keys(%{$info->{'phenotype'}});
scripts/import/import_decipher.pl:        $info->{'phenotype'} = $phe;
scripts/import/import_decipher.pl:  $info->{chr}         = $data[0];
scripts/import/import_decipher.pl:  $info->{start}       = $data[1]+1;
scripts/import/import_decipher.pl:  $info->{end}         = $data[2];
scripts/import/import_decipher.pl:  $info->{subject}     = $data[3];
scripts/import/import_decipher.pl:  $info->{strand}      = ($data[5] eq '+') ? 1 : -1;
scripts/import/import_decipher.pl:  $info->{chr} =~ s/chr//i;
scripts/import/import_decipher.pl:  $info->{chr} = 'MT' if ($info->{chr} eq 'M');
scripts/import/import_decipher.pl:  return if ($json_text->{'variant_type'} ne $long_variant_type);
scripts/import/import_decipher.pl:  $info->{SO_term}     = ($json_text->{'mean_ratio'} > 0) ? 'duplication' : 'deletion';
scripts/import/import_decipher.pl:  $info->{inheritance} = $json_text->{'inheritance'};
scripts/import/import_decipher.pl:  $info->{clin_sign}   = lc($json_text->{'pathogenicity'}) if ($json_text->{'pathogenicity'});
scripts/import/import_decipher.pl:  $info->{ID}          = "DEC".$info->{subject}."_".$info->{chr}."_".$info->{start}."_".$info->{end};
scripts/import/import_decipher.pl:  foreach my $phe (@{$json_text->{phenotypes}}) {
scripts/import/import_decipher.pl:    my $p_name = $phe->{name};
scripts/import/import_decipher.pl:    $info->{phenotype}{$p_name} = 1;
scripts/import/import_decipher.pl:  debug(localtime()."\t - Add temporary unique keys in $sv_table, $svf_table and $svs_table tables");
scripts/import/import_decipher.pl:  if ($dbVar->do(qq{SHOW KEYS FROM $sv_table WHERE Key_name='name_key';}) < 1){
scripts/import/import_decipher.pl:    $dbVar->do(qq{ALTER TABLE $sv_table ADD CONSTRAINT UNIQUE KEY `name_key` (`variation_name`)});
scripts/import/import_decipher.pl:  if ($dbVar->do(qq{SHOW KEYS FROM $svf_table WHERE Key_name='name_coord_key';}) < 1){
scripts/import/import_decipher.pl:    $dbVar->do(qq{ALTER TABLE $svf_table ADD CONSTRAINT  UNIQUE KEY
scripts/import/import_decipher.pl:  if ($dbVar->do(qq{SHOW KEYS FROM $svf_table WHERE Key_name='name_key';}) < 1){
scripts/import/import_decipher.pl:    $dbVar->do(qq{ALTER TABLE $svf_table ADD KEY `name_key` (`variation_name`)});
scripts/import/import_decipher.pl:  if ($dbVar->do(qq{SHOW KEYS FROM $svs_table WHERE Key_name='sv_id_key';}) < 1){
scripts/import/import_decipher.pl:    $dbVar->do(qq{ALTER TABLE $svs_table ADD CONSTRAINT  UNIQUE KEY `sv_id_key` (`structural_variation_id`,`sample_id`)});
scripts/import/import_decipher.pl:  debug(localtime()."\t - Add temporary unique keys in the individual table");
scripts/import/import_decipher.pl:  if ($dbVar->do(qq{SHOW KEYS FROM individual WHERE Key_name='name_key';}) < 1){
scripts/import/import_decipher.pl:    $dbVar->do(qq{ALTER TABLE individual ADD KEY `name_key` (`name`)});
scripts/import/import_decipher.pl:  debug(localtime()."\t - Add temporary unique keys in the sample table");
scripts/import/import_decipher.pl:  if ($dbVar->do(qq{SHOW KEYS FROM sample WHERE Key_name='name_key';}) < 1){
scripts/import/import_decipher.pl:    $dbVar->do(qq{ALTER TABLE sample ADD KEY `name_key` (`name`)});
scripts/import/import_decipher.pl:  debug(localtime()."\t - Add temporary columns in the $sv_table table");
scripts/import/import_decipher.pl:  if ($dbVar->do(qq{show columns from $sv_table like '$tmp_sv_col';}) != 1){
scripts/import/import_decipher.pl:    $dbVar->do(qq{ALTER TABLE $sv_table ADD COLUMN $tmp_sv_col varchar(255);});
scripts/import/import_decipher.pl:  $dbVar->do($stmt);
scripts/import/import_decipher.pl:  $dbVar->do($stmt_s);                         
scripts/import/import_decipher.pl:  $dbVar->do($stmt_e);
scripts/import/import_decipher.pl:  my $max_length_ref = $dbVar->selectall_arrayref(qq{
scripts/import/import_decipher.pl:    SELECT MAX(seq_region_end - seq_region_start + 1) FROM $svf_table
scripts/import/import_decipher.pl:  my $max_length = $max_length_ref->[0][0];
scripts/import/import_decipher.pl:  my $cs = $default_cs->dbID;
scripts/import/import_decipher.pl:  $dbVar->do(qq{DELETE FROM meta_coord where table_name = '$svf_table';});
scripts/import/import_decipher.pl:  $dbVar->do(qq{INSERT INTO meta_coord(table_name, coord_system_id, max_length) VALUES ('$svf_table', $cs, $max_length);});
scripts/import/import_decipher.pl:  $dbVar->do(qq{ALTER TABLE $svf_table DROP KEY name_coord_key});
scripts/import/import_decipher.pl:  $dbVar->do(qq{ALTER TABLE $svf_table DROP KEY name_key});
scripts/import/import_decipher.pl:  debug(localtime()."\t - Table $svf_table: cleaned");
scripts/import/import_decipher.pl:  $dbVar->do(qq{ALTER TABLE $svs_table DROP KEY sv_id_key});
scripts/import/import_decipher.pl:  debug(localtime()."\t - Table $svs_table: cleaned");
scripts/import/import_decipher.pl:  $dbVar->do(qq{ALTER TABLE individual DROP KEY name_key});
scripts/import/import_decipher.pl:  debug(localtime()."\t - Table individual: cleaned");
scripts/import/import_decipher.pl:  $dbVar->do(qq{ALTER TABLE sample DROP KEY name_key});
scripts/import/import_decipher.pl:  debug(localtime()."\t - Table sample: cleaned");
scripts/import/import_decipher.pl:  $dbVar->do(qq{ALTER TABLE $sv_table DROP KEY name_key});
scripts/import/import_decipher.pl:  my $sth1 = $dbVar->prepare(qq{ SELECT count(*) FROM $sv_table WHERE source_id=$source_id AND class_attrib_id=0});
scripts/import/import_decipher.pl:  $sth1->execute();
scripts/import/import_decipher.pl:  my $sv_count = ($sth1->fetchrow_array)[0];
scripts/import/import_decipher.pl:  $sth1->finish;
scripts/import/import_decipher.pl:    $dbVar->do(qq{ALTER TABLE $sv_table DROP COLUMN $tmp_sv_col});
scripts/import/import_decipher.pl:  debug(localtime()."\t - Table $sv_table: cleaned") if ($sv_flag == 0);
scripts/import/import_decipher.pl:  $info->{phenotype} = decode_text($info->{phenotype}); 
scripts/import/import_decipher.pl:  my @row = ($info->{ID},
scripts/import/import_decipher.pl:             $info->{SO_term},
scripts/import/import_decipher.pl:             $info->{chr}, 
scripts/import/import_decipher.pl:             $info->{outer_start}, 
scripts/import/import_decipher.pl:             $info->{start}, 
scripts/import/import_decipher.pl:             $info->{inner_start}, 
scripts/import/import_decipher.pl:             $info->{inner_end}, 
scripts/import/import_decipher.pl:             $info->{end}, 
scripts/import/import_decipher.pl:             $info->{outer_end},
scripts/import/import_decipher.pl:             $info->{strand}, 
scripts/import/import_decipher.pl:             $info->{inheritance},
scripts/import/import_decipher.pl:             $info->{phenotype},
scripts/import/import_decipher.pl:             $info->{subject},
scripts/import/import_decipher.pl:             $info->{is_failed},
scripts/import/import_decipher.pl:             $info->{clin_sign}
scripts/import/import_decipher.pl:  my $attr_list_sth = $dbVar->prepare(qq{ SELECT attrib_id,value FROM attrib WHERE attrib_type_id=$type_id});
scripts/import/import_decipher.pl:  $attr_list_sth->execute;
scripts/import/import_decipher.pl:  while(my @row = $attr_list_sth->fetchrow_array) {
scripts/import/import_decipher.pl:Options -
scripts/import/import_decipher.pl:  -species         : species name (required)
scripts/import/import_decipher.pl:  -target_assembly : assembly version to map to (optional)
scripts/import/import_decipher.pl:  -tmpdir          : (optional)
scripts/import/import_decipher.pl:  -tmpfile         : (optional)
scripts/import/import_decipher.pl:  -input_file      : file containing DGVa data dump (required if no input_dir)
scripts/import/import_decipher.pl:  -input_dir       : directory containing DGVa data dump (required if no input_file)
scripts/import/import_decipher.pl:  -version         : version number of the data (required)
scripts/import/import_decipher.pl:  -registry        : registry file (optional)
scripts/import/import_decipher.pl:  -debug           : flag to keep the $temp_table table (optional)
scripts/import/dump_strain_wrapper.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dump_strain_wrapper.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dump_strain_wrapper.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dump_strain_wrapper.pl:Bio::EnsEMBL::Registry->load_registry_from_db( -host => 'ens-staging',
scripts/import/dump_strain_wrapper.pl:                                               -db_version => $new_db_version,
scripts/import/dump_strain_wrapper.pl:                                               -user => 'ensro',
scripts/import/dump_strain_wrapper.pl:my $memory = "'select[mem>4000] rusage[mem=4000]' -M4000000";
scripts/import/dump_strain_wrapper.pl:$memory = "'select[mem>5000] rusage[mem=5000]' -M5000000" if ($species eq 'human');
scripts/import/dump_strain_wrapper.pl:my $dbCore = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/dump_strain_wrapper.pl:my $slice_adaptor = $dbCore->get_SliceAdaptor();
scripts/import/dump_strain_wrapper.pl:my $slices = $slice_adaptor->fetch_all('chromosome');
scripts/import/dump_strain_wrapper.pl:my $call = "bsub -q $queue -R$memory  -o $dump_dir/out_dump_strain_$species\_$new_db_version -J dump_strain_$species'[1-" . @{$slices} . "]' ./dump_strain_seq.pl -dump_file \"$dump_dir/$dump_file\" -species $species -new_db_version $new_db_version";
scripts/import/dump_strain_wrapper.pl:$call = "bsub  -o finish_dump.txt -w 'done(dump_strain_" . $species . ")' -J waiting_process gzip $dump_dir/$dump_file*";
scripts/import/dump_strain_wrapper.pl:    -dump_file <filename>    file where you want to dump the resequencing data
scripts/import/dump_strain_wrapper.pl:    -dump_dir <path>         path of the dump_file
scripts/import/dump_strain_wrapper.pl:    -species   <species>     species you want to dump data (default = mouse)
scripts/import/dump_strain_wrapper.pl:    -new_db_version <version number>  release version number, such as 56
scripts/import/import_vcf.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_vcf.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_vcf.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_vcf.pl:import_vcf.pl - imports variations from a VCF file into an Ensembl variation DB
scripts/import/import_vcf.pl:use constant MAX_SHORT => 2**16 -1;
scripts/import/import_vcf.pl:# open cross-process pipes for fork comms
scripts/import/import_vcf.pl:CHILD->autoflush(1);
scripts/import/import_vcf.pl:PARENT->autoflush(1);
scripts/import/import_vcf.pl:$config->{start_time} = [gettimeofday];
scripts/import/import_vcf.pl:if(defined($config->{fork})) {
scripts/import/import_vcf.pl:  die "ERROR: Could not find input file\n" unless defined($config->{input_file}) && -e $config->{input_file};
scripts/import/import_vcf.pl:  die "ERROR: Input file is not bgzipped, cannot fork\n" unless $config->{input_file} =~ /\.gz$/;
scripts/import/import_vcf.pl:  die "ERROR: Tabix index file ".$config->{input_file}.".tbi not found, cannot fork\n" unless $config->{input_file}.'.tbi';
scripts/import/import_vcf.pl:my $elapsed = tv_interval($config->{start_time}, [gettimeofday]);
scripts/import/import_vcf.pl:  # get command-line options
scripts/import/import_vcf.pl:  # die if we can't parse arguments - better to get user to sort out their command line
scripts/import/import_vcf.pl:  ) or die "ERROR: Failed to parse command line arguments - check the documentation!\n";
scripts/import/import_vcf.pl:  if(defined($config->{help}) || !$args) {
scripts/import/import_vcf.pl:  if (defined($config->{ind_prefix})) {
scripts/import/import_vcf.pl:    $config->{sample_prefix} = $config->{ind_prefix};
scripts/import/import_vcf.pl:    warning('--ind_prefix is deprecated. The content has been copied to --sample_prefix. Please update your script and use --sample_prefix');  
scripts/import/import_vcf.pl:  read_config_from_file($config, $config->{config}) if defined $config->{config};
scripts/import/import_vcf.pl:  if(defined($config->{recover})) {
scripts/import/import_vcf.pl:    delete $config->{recover};
scripts/import/import_vcf.pl:  $config->{session_id} = md5_hex(join '|', (map {$_." ".$config->{$_}} sort keys %$config));
scripts/import/import_vcf.pl:  debug($config, "Session ID is ", $config->{session_id});
scripts/import/import_vcf.pl:  $config->{recover} = 1 if $recover;
scripts/import/import_vcf.pl:  die("ERROR: Cannot run in test mode using forks\n") if defined($config->{fork}) and defined($config->{test});
scripts/import/import_vcf.pl:  die("ERROR: Cannot manually recover using forks\n") if defined($config->{fork}) and (defined($config->{recover_point}) || defined($config->{recover_pos}));
scripts/import/import_vcf.pl:  if(defined $config->{recover}) {
scripts/import/import_vcf.pl:    open IN, (join '/', ($ENV{HOME}, '.import_vcf', $config->{session_id})) or die "ERROR: Could not recover session with ID ".$config->{session_id}."\n";
scripts/import/import_vcf.pl:    ($config->{recover_point}, $config->{pid}) = split ' ', $a;
scripts/import/import_vcf.pl:    die "ERROR: Cannot recover - session with ID ".$config->{session_id}." has been flagged as finished" if $config->{recover_point} eq 'FINISHED';
scripts/import/import_vcf.pl:    debug($config, "Found recover point ", $config->{recover_point}, " for session ID ", $config->{session_id}, " PID ", $config->{pid});
scripts/import/import_vcf.pl:  die "ERROR: Cannot import Mastermind data without the chromosome synonyms file\n" if($config->{source} eq 'Mastermind' && !$config->{chr_synonyms});
scripts/import/import_vcf.pl:  $config->{species}         ||= "human";
scripts/import/import_vcf.pl:  $config->{port}            ||= 3306;
scripts/import/import_vcf.pl:  $config->{format}            = 'vcf';
scripts/import/import_vcf.pl:  $config->{ind_prefix}      ||= '';
scripts/import/import_vcf.pl:  $config->{pop_prefix}      ||= '';
scripts/import/import_vcf.pl:  $config->{coord_system}    ||= 'chromosome';
scripts/import/import_vcf.pl:  $config->{progress_update} ||= 100;
scripts/import/import_vcf.pl:  $config->{pid}             ||= $$;
scripts/import/import_vcf.pl:  $config->{somatic}         ||= 0;
scripts/import/import_vcf.pl:  if(defined($config->{remap})) {
scripts/import/import_vcf.pl:    die "ERROR: remap argument incorrect - must be of format --remap [from_assembly],[to_assembly]" unless $config->{remap} =~ /^\S+?\,\S+?$/;
scripts/import/import_vcf.pl:    $config->{remap} = [split(',', $config->{remap})];
scripts/import/import_vcf.pl:  #$config->{no_recover} = 1 if defined($config->{fork});
scripts/import/import_vcf.pl:  if(defined($config->{tables})) {
scripts/import/import_vcf.pl:    $tables->{$_} = 0 foreach keys %$tables;
scripts/import/import_vcf.pl:    foreach my $table(split /\,/, $config->{tables}) {
scripts/import/import_vcf.pl:      $tables->{$table} = 1 if defined($tables->{$table});
scripts/import/import_vcf.pl:  if(defined($config->{add_tables})) {
scripts/import/import_vcf.pl:    foreach my $table(split /\,/, $config->{add_tables}) {
scripts/import/import_vcf.pl:      $tables->{$table} = 1 if defined($tables->{$table});
scripts/import/import_vcf.pl:  if(defined($config->{skip_tables})) {
scripts/import/import_vcf.pl:    foreach my $table(split /\,/, $config->{skip_tables}) {
scripts/import/import_vcf.pl:      $tables->{$table} = 0 if (exists $tables->{$table});
scripts/import/import_vcf.pl:  $tables->{$_} = 1 for qw/source meta_coord/;
scripts/import/import_vcf.pl:  $tables->{sample_genotype_multiple_bp} = 1 if defined($config->{mart_genotypes});
scripts/import/import_vcf.pl:  if($tables->{sample}) {
scripts/import/import_vcf.pl:    $tables->{$_} = 1 for qw/population sample sample_population/;
scripts/import/import_vcf.pl:  if($tables->{allele} || $tables->{population_genotype}) {
scripts/import/import_vcf.pl:    $tables->{$_} = 1 for qw/population sample/;
scripts/import/import_vcf.pl:  if($tables->{compressed_genotype_region} || $tables->{sample_genotype_multiple_bp} || $tables->{compressed_genotype_var}) {
scripts/import/import_vcf.pl:    $tables->{$_} = 1 for qw/population sample sample_population variation variation_synonym variation_feature/;
scripts/import/import_vcf.pl:  if($tables->{population_genotype} || $tables->{compressed_genotype_region} || $tables->{compressed_genotype_var}) {
scripts/import/import_vcf.pl:    $tables->{$_} = 1 for qw/genotype_code variation variation_synonym variation_feature/;
scripts/import/import_vcf.pl:  if($tables->{allele} || $tables->{genotype_code}) {
scripts/import/import_vcf.pl:    $tables->{$_} = 1 for qw/allele_code variation variation_synonym variation_feature/;
scripts/import/import_vcf.pl:  if(defined $config->{only_existing}) {
scripts/import/import_vcf.pl:    $tables->{$_} = 0 for qw/source variation variation_synonym variation_feature/;
scripts/import/import_vcf.pl:  die "ERROR: no tables left included\n" unless grep {$tables->{$_}} keys %$tables;
scripts/import/import_vcf.pl:  $config->{tables} = $tables;
scripts/import/import_vcf.pl:  die "ERROR: tmpdir not specified\n" if !defined $config->{tmpdir} && $tables->{compressed_genotype_region};
scripts/import/import_vcf.pl:  $config->{tmpfile} ||= 'compress.txt';
scripts/import/import_vcf.pl:  $ImportUtils::TMP_DIR  = $config->{tmpdir};
scripts/import/import_vcf.pl:  $ImportUtils::TMP_FILE = $config->{tmpfile};
scripts/import/import_vcf.pl:  $config->{reg} = 'Bio::EnsEMBL::Registry';
scripts/import/import_vcf.pl:  $config->{vep}->{chunk_size}        ||= 50000;
scripts/import/import_vcf.pl:  $config->{vep}->{cache_region_size} ||= 1000000;
scripts/import/import_vcf.pl:  $config->{vep}->{compress}          ||= 'zcat';
scripts/import/import_vcf.pl:  $config->{vep}->{terms}               = 'SO';
scripts/import/import_vcf.pl:  $config->{vep}->{tr_cache}            = {};
scripts/import/import_vcf.pl:  $config->{vep}->{rf_cache}            = {};
scripts/import/import_vcf.pl:  $config->{vep}->{quiet}               = 1;
scripts/import/import_vcf.pl:  $config->{vep}->{original}            = 1;
scripts/import/import_vcf.pl:  $config->{vep}->{no_progress}         = 1;
scripts/import/import_vcf.pl:  $config->{buffer_size}              ||= 100;
scripts/import/import_vcf.pl:  $config->{vep}->{species}             = $config->{species};
scripts/import/import_vcf.pl:  if(defined($config->{cache})) {
scripts/import/import_vcf.pl:    die("ERROR: Could not find cache directory ".$config->{cache}) unless -e $config->{cache};    
scripts/import/import_vcf.pl:    $config->{vep}->{dir}             = $config->{cache};
scripts/import/import_vcf.pl:    $config->{vep}->{cache}           = 1;
scripts/import/import_vcf.pl:    $config->{vep}->{offline}         = 1;
scripts/import/import_vcf.pl:  if(defined($config->{fasta})) {
scripts/import/import_vcf.pl:    die "ERROR: Specified FASTA file/directory not found" unless -e $config->{fasta};
scripts/import/import_vcf.pl:          # special case for in-between (insert) coordinates
scripts/import/import_vcf.pl:          return '' if($self->start() == $self->end() + 1);
scripts/import/import_vcf.pl:          if(defined($config->{fasta_db})) {
scripts/import/import_vcf.pl:            $seq = $config->{fasta_db}->seq($self->seq_region_name, $self->start => $self->end);
scripts/import/import_vcf.pl:            reverse_comp(\$seq) if $self->strand < 0;
scripts/import/import_vcf.pl:            return $self->{'seq'} if($self->{'seq'});
scripts/import/import_vcf.pl:            if($self->adaptor()) {
scripts/import/import_vcf.pl:              my $seqAdaptor = $self->adaptor()->db()->get_SequenceAdaptor();
scripts/import/import_vcf.pl:              return ${$seqAdaptor->fetch_by_Slice_start_end_strand($self,1,undef,1)};
scripts/import/import_vcf.pl:          $seq ||= 'N' x $self->length();
scripts/import/import_vcf.pl:    $Bio::EnsEMBL::Slice::config = $config->{vep};
scripts/import/import_vcf.pl:    $config->{vep}->{coord_system} = Bio::EnsEMBL::CoordSystem->new(
scripts/import/import_vcf.pl:      -NAME => 'chromosome',
scripts/import/import_vcf.pl:      -RANK => 1,
scripts/import/import_vcf.pl:    $config->{vep}->{fasta_db} = Bio::DB::Fasta->new($config->{fasta});
scripts/import/import_vcf.pl:  $width -= 12;
scripts/import/import_vcf.pl:  $config->{terminal_width} = $width;
scripts/import/import_vcf.pl:    $key =~ s/^\-//g;
scripts/import/import_vcf.pl:    if(defined($config->{$key}) && ref($config->{$key}) eq 'ARRAY') {
scripts/import/import_vcf.pl:      push @{$config->{$key}}, @split;
scripts/import/import_vcf.pl:      $config->{$key} ||= $split[0];
scripts/import/import_vcf.pl:  debug($config, "Read configuration from $file") unless defined($config->{quiet});
scripts/import/import_vcf.pl:# main sub-routine does most of the code execution
scripts/import/import_vcf.pl:  if(defined($config->{sql}) && !defined($config->{recover})) {
scripts/import/import_vcf.pl:    sql_populate($config, $config->{sql});
scripts/import/import_vcf.pl:    if(defined($config->{test})) {
scripts/import/import_vcf.pl:      my $sth = $config->{dbVar}->prepare(qq{
scripts/import/import_vcf.pl:      $sth->execute('schema_version', $config->{reg}->software_version);
scripts/import/import_vcf.pl:      $sth->finish();
scripts/import/import_vcf.pl:  if(defined($config->{recover})) {
scripts/import/import_vcf.pl:  backup($config) if defined($config->{backup}) || defined($config->{move});
scripts/import/import_vcf.pl:  debug($config, "Running in test mode - will read first ", $config->{test}, " lines of input") if defined($config->{test});
scripts/import/import_vcf.pl:  $config->{seq_region_ids} = get_seq_region_ids($config);
scripts/import/import_vcf.pl:  if(!scalar keys %{$config->{seq_region_ids}}) {
scripts/import/import_vcf.pl:    $config->{seq_region_ids} = get_seq_region_ids($config);
scripts/import/import_vcf.pl:  die("ERROR: seq_region not populated\n") unless scalar keys %{$config->{seq_region_ids}};
scripts/import/import_vcf.pl:  if(defined($config->{chr_synonyms})) {
scripts/import/import_vcf.pl:    $config->{chr_synonyms_list} = read_chr_synonyms($config, $config->{source});
scripts/import/import_vcf.pl:  die("ERROR: no source specified\n") if !(defined $config->{source}) && !defined($config->{only_existing});
scripts/import/import_vcf.pl:  $config->{source_id} = get_source_id($config) unless defined($config->{only_existing});
scripts/import/import_vcf.pl:  if($config->{tables}->{population} && $config->{source} ne 'Mastermind') {
scripts/import/import_vcf.pl:    die("ERROR: no population specified\n") unless defined $config->{population} || defined $config->{panel};
scripts/import/import_vcf.pl:    $config->{populations} = population($config);
scripts/import/import_vcf.pl:  if(defined $config->{disable_keys}) {
scripts/import/import_vcf.pl:    foreach my $table(qw(allele population_genotype)) {#grep {$config->{tables}->{$_}} keys %$config->{tables}) {
scripts/import/import_vcf.pl:      $config->{dbVar}->do(qq{ALTER TABLE $table DISABLE KEYS;});
scripts/import/import_vcf.pl:  if(defined($config->{forked})) {
scripts/import/import_vcf.pl:    $config->{in_file_handle} = get_input_file_handle($config);
scripts/import/import_vcf.pl:  $config->{pedigree} = pedigree($config) if defined($config->{pedigree});
scripts/import/import_vcf.pl:  my $in_file_handle = $config->{in_file_handle};
scripts/import/import_vcf.pl:    $data->{line} = $_;
scripts/import/import_vcf.pl:      if(defined($config->{forked})) {
scripts/import/import_vcf.pl:        open TMP, '> '.$ENV{HOME}.'/.import_vcf/'.$config->{pid};
scripts/import/import_vcf.pl:      $config->{prev_time} ||= [gettimeofday];
scripts/import/import_vcf.pl:      if(defined($config->{recover_point}) || defined($config->{recover_pos})) {
scripts/import/import_vcf.pl:        $config->{skipped}->{already_processed}++;
scripts/import/import_vcf.pl:        if(defined($config->{recover_point}) && md5_hex($data->{line}) eq $config->{recover_point}) {
scripts/import/import_vcf.pl:          delete $config->{recover_point};
scripts/import/import_vcf.pl:          $config->{recover_check} = 1;
scripts/import/import_vcf.pl:            $config->{skipped}->{already_processed},
scripts/import/import_vcf.pl:        if(defined($config->{recover_pos})) {
scripts/import/import_vcf.pl:          my $rpos = $config->{recover_pos};
scripts/import/import_vcf.pl:            if($data->{line} =~ /^$chr\s+$pos\s+/) {
scripts/import/import_vcf.pl:              delete $config->{recover_pos};
scripts/import/import_vcf.pl:              $config->{recover_check} = 1;
scripts/import/import_vcf.pl:                $config->{skipped}->{already_processed},
scripts/import/import_vcf.pl:          elsif($data->{line} =~ /^\w+?\s+$rpos\s+/) {
scripts/import/import_vcf.pl:            delete $config->{recover_pos};
scripts/import/import_vcf.pl:            $config->{recover_check} = 1;
scripts/import/import_vcf.pl:              $config->{skipped}->{already_processed},
scripts/import/import_vcf.pl:      $data->{$_} = $split[$headers{$_}] for keys %headers;
scripts/import/import_vcf.pl:        debug($config, "WARNING: Skipped last $last_skipped variants. The last skipped variant is $data->{'#CHROM'} amd $data->{POS}. Are you sure this is running OK? Maybe --gp is enabled when it shouldn't be, or vice versa?");
scripts/import/import_vcf.pl:      # skip non-variant lines
scripts/import/import_vcf.pl:      if($data->{ALT} eq '.') {
scripts/import/import_vcf.pl:        $config->{skipped}->{non_variant}++;
scripts/import/import_vcf.pl:      foreach my $chunk(split /\;/, $data->{INFO}) {
scripts/import/import_vcf.pl:      $data->{info} = \%info;
scripts/import/import_vcf.pl:      #next if defined($config->{chrom_regexp}) && $data->{'#CHROM'} !~ m/$chrom_regexp/;
scripts/import/import_vcf.pl:      ($data->{tmp_vf}) = @{parse_line($config, $data->{line})};
scripts/import/import_vcf.pl:      if(!defined($data->{tmp_vf})) {
scripts/import/import_vcf.pl:        $config->{skipped}->{could_not_parse}++;
scripts/import/import_vcf.pl:      if(defined($config->{remap})) {
scripts/import/import_vcf.pl:        my $success = remap($config, $data->{tmp_vf});
scripts/import/import_vcf.pl:          $config->{skipped}->{unable_to_remap}++;
scripts/import/import_vcf.pl:      my $chromosome = $data->{tmp_vf}->{chr};
scripts/import/import_vcf.pl:      if(defined $config->{remove_prefix}) {
scripts/import/import_vcf.pl:        my $prefix = $config->{remove_prefix};
scripts/import/import_vcf.pl:      if(defined($config->{chr_synonyms_list})) {
scripts/import/import_vcf.pl:        $chromosome = $config->{chr_synonyms_list}->{$data->{tmp_vf}->{chr}};
scripts/import/import_vcf.pl:      if(!defined($config->{seq_region_ids}->{$chromosome})) {
scripts/import/import_vcf.pl:        $config->{skipped}->{missing_seq_region}++;
scripts/import/import_vcf.pl:      $data->{tmp_vf}->{seq_region_id} = $config->{seq_region_ids}->{$chromosome};
scripts/import/import_vcf.pl:      next unless $data->{tmp_vf}->isa('Bio::EnsEMBL::Variation::VariationFeature');
scripts/import/import_vcf.pl:      if(defined($config->{ss_ids})) {
scripts/import/import_vcf.pl:        my ($ss_id) = grep {$_ =~ /^\d+$/} split(/\;/, $data->{ID});
scripts/import/import_vcf.pl:          $data->{SS_ID} = $ss_id;  
scripts/import/import_vcf.pl:      if($data->{ID} =~ /\;/) {
scripts/import/import_vcf.pl:        my @ids = split(';', $data->{ID});
scripts/import/import_vcf.pl:        my @rs_ids = sort {(split("rs", $a))[-1] <=> (split("rs", $b))[-1]} grep {/^rs/} @ids;
scripts/import/import_vcf.pl:        if(defined($config->{ss_ids}) && defined($data->{SS_ID})) {
scripts/import/import_vcf.pl:          $data->{ID} = 'ss'.$data->{SS_ID};
scripts/import/import_vcf.pl:          $data->{synonyms} = grep {$_ ne $data->{SS_ID}} @ids;
scripts/import/import_vcf.pl:          $data->{ID} = $primary_id;
scripts/import/import_vcf.pl:          $data->{synonyms} = \@ids if scalar @ids;
scripts/import/import_vcf.pl:      elsif(defined($config->{ss_ids}) && defined($data->{SS_ID})) {
scripts/import/import_vcf.pl:        $data->{ID} = 'ss'.$data->{SS_ID};
scripts/import/import_vcf.pl:      if($config->{source} eq 'Mastermind') {
scripts/import/import_vcf.pl:        $var_name = $data->{info}->{HGVSG};
scripts/import/import_vcf.pl:        # Mastermid - skip variants bigger than 50bp
scripts/import/import_vcf.pl:        if(length($data->{ALT}) > 50 || length($data->{REF}) > 50) {
scripts/import/import_vcf.pl:      if(length($data->{ALT}) > 50000 || length($data->{REF}) > 50000) {
scripts/import/import_vcf.pl:        print "SKIP : $data->{ID}, Length is greater than 50,000\n";
scripts/import/import_vcf.pl:      if(!defined($data->{ID}) || $data->{ID} eq '.' || defined($config->{create_name})) {
scripts/import/import_vcf.pl:        $data->{ID} =
scripts/import/import_vcf.pl:          ($config->{var_prefix} ? $config->{var_prefix} : 'tmp').
scripts/import/import_vcf.pl:          '_'.$data->{'#CHROM'}.'_'.$data->{POS}.'_'.$data->{REF}.'_'.$data->{ALT};
scripts/import/import_vcf.pl:        $data->{made_up_name} = 1;
scripts/import/import_vcf.pl:      if($config->{source} eq 'Mastermind') {
scripts/import/import_vcf.pl:        $data->{ID} = $var_name;
scripts/import/import_vcf.pl:      $data->{tmp_vf}->{variation_name} = $data->{ID};
scripts/import/import_vcf.pl:      $data->{genotypes} = get_genotypes($config, $data, \@split);
scripts/import/import_vcf.pl:      $data->{variation} = variation($config, $data);
scripts/import/import_vcf.pl:      get_all_consequences($config->{vep}, [$data->{tmp_vf}]) if $config->{tables}->{transcript_variation};
scripts/import/import_vcf.pl:      $data->{vf} = variation_feature($config, $data);
scripts/import/import_vcf.pl:      variation_synonym($config, $data) if $config->{tables}->{variation_synonym} && $data->{synonyms};
scripts/import/import_vcf.pl:      $_->{variation} = $data->{variation} for @{$data->{genotypes}};
scripts/import/import_vcf.pl:      if(!defined($data->{variation}->{dbID}) && !defined($config->{test})) {
scripts/import/import_vcf.pl:        $config->{skipped}->{var_not_present}++;
scripts/import/import_vcf.pl:      transcript_variation($config, [$data->{tmp_vf}]) if $config->{tables}->{transcript_variation} && defined($data->{tmp_vf}->dbID);
scripts/import/import_vcf.pl:      allele($config, $data) if $config->{tables}->{allele};
scripts/import/import_vcf.pl:      population_genotype($config, $data) if $config->{tables}->{population_genotype};
scripts/import/import_vcf.pl:      sample_genotype($config, $data) if $config->{tables}->{compressed_genotype_var} || defined($config->{mart_genotypes});
scripts/import/import_vcf.pl:      if($config->{tables}->{compressed_genotype_region} && @{$data->{genotypes}} && !defined($config->{test})) {
scripts/import/import_vcf.pl:        my $vf = $data->{vf};
scripts/import/import_vcf.pl:        $vf->{seq_region_id} = $vf->slice->get_seq_region_id if !defined($vf->{seq_region_id});
scripts/import/import_vcf.pl:        if(defined($vf->{seq_region_id}) && defined($vf->{start})) {
scripts/import/import_vcf.pl:          foreach my $gt(@{$data->{genotypes}}) {
scripts/import/import_vcf.pl:            my $sample_id = $gt->sample->dbID;
scripts/import/import_vcf.pl:            next if $gt->genotype_string =~ /\./;
scripts/import/import_vcf.pl:            if (!defined $genotypes->{$sample_id}->{region_start}){
scripts/import/import_vcf.pl:              $genotypes->{$sample_id}->{region_start} = $vf->{start};
scripts/import/import_vcf.pl:              $genotypes->{$sample_id}->{region_end} = $vf->{end};
scripts/import/import_vcf.pl:              defined($genotypes->{$sample_id}->{genotypes}) &&
scripts/import/import_vcf.pl:                (abs($genotypes->{$sample_id}->{region_start} - $vf->{start}) > DISTANCE()) ||
scripts/import/import_vcf.pl:                (abs($vf->{start} - $genotypes->{$sample_id}->{region_end}) > MAX_SHORT) ||
scripts/import/import_vcf.pl:                (defined($prev_seq_region) && $vf->{seq_region_id} != $prev_seq_region) ||
scripts/import/import_vcf.pl:                ($vf->{start} - $genotypes->{$sample_id}->{region_end} - 1 < 0)
scripts/import/import_vcf.pl:              delete $genotypes->{$sample_id}; #and remove the printed entry
scripts/import/import_vcf.pl:              $genotypes->{$sample_id}->{region_start} = $vf->{start};
scripts/import/import_vcf.pl:            if ($vf->{start} != $genotypes->{$sample_id}->{region_start}){
scripts/import/import_vcf.pl:              my $blob = pack ("w",$vf->{start} - $genotypes->{$sample_id}->{region_end} - 1);
scripts/import/import_vcf.pl:              $genotypes->{$sample_id}->{genotypes} .=
scripts/import/import_vcf.pl:                escape(pack("w", $data->{variation}->dbID || 0)).
scripts/import/import_vcf.pl:                escape(pack("w", $config->{samplegenotype_adaptor}->_genotype_code($gt->genotype, $gt->phased)));
scripts/import/import_vcf.pl:              $genotypes->{$sample_id}->{genotypes} =
scripts/import/import_vcf.pl:                escape(pack("w", $data->{variation}->dbID || 0)).
scripts/import/import_vcf.pl:                escape(pack("w", $config->{samplegenotype_adaptor}->_genotype_code($gt->genotype, $gt->phased)));
scripts/import/import_vcf.pl:            $genotypes->{$sample_id}->{region_end} = $vf->{start};
scripts/import/import_vcf.pl:      $prev_seq_region = $data->{vf}->{seq_region_id};
scripts/import/import_vcf.pl:      last if defined($config->{test}) && $var_counter == $config->{test};
scripts/import/import_vcf.pl:      if(defined($config->{forked})) {
scripts/import/import_vcf.pl:        debug($config, "Processed $var_counter lines (".$config->{forked}.")");
scripts/import/import_vcf.pl:        store_session($config, md5_hex($data->{line})) if $var_counter % $config->{progress_update} == 0;
scripts/import/import_vcf.pl:      elsif($var_counter % $config->{progress_update} == 0) {
scripts/import/import_vcf.pl:        store_session($config, md5_hex($data->{line})) unless defined($config->{no_recover});
scripts/import/import_vcf.pl:  progress($config, $var_counter) unless defined($config->{forked});
scripts/import/import_vcf.pl:  print_file($config,$genotypes, $prev_seq_region) if $config->{tables}->{compressed_genotype_region} && $var_counter;
scripts/import/import_vcf.pl:  transcript_variation($config, \@vf_buffer) if @vf_buffer and $config->{tables}->{transcript_variation};
scripts/import/import_vcf.pl:  # re-enable keys if requested
scripts/import/import_vcf.pl:  if(defined $config->{disable_keys}) {
scripts/import/import_vcf.pl:    debug($config, "Re-enabling keys");
scripts/import/import_vcf.pl:    foreach my $table(qw(allele population_genotype)) {#grep {$config->{tables}->{$_}} keys %{$config->{tables}}) {
scripts/import/import_vcf.pl:      $config->{dbVar}->do(qq{ALTER TABLE $table ENABLE KEYS;})
scripts/import/import_vcf.pl:  if(defined($config->{recover_point}) || defined($config->{recover_pos})) {
scripts/import/import_vcf.pl:    if(defined($config->{forked})) {
scripts/import/import_vcf.pl:      debug($config, "WARNING: Could not find recovery point ".(defined($config->{recover_point}) ? $config->{recover_point} : $config->{recover_pos})." for session ".$config->{session_id}.(defined($config->{forked}) ? " (".$config->{forked} : "")." in input file");
scripts/import/import_vcf.pl:  my $max_length = (sort {$a <=> $b} map {length($_)} (keys %{$config->{skipped}}, keys %{$config->{rows_added}}))[-1];
scripts/import/import_vcf.pl:  debug($config, (defined($config->{test}) ? "(TEST) " : "")."Rows added:");
scripts/import/import_vcf.pl:  for my $key(sort keys %{$config->{rows_added}}) {
scripts/import/import_vcf.pl:    debug($config, (defined($config->{forked}) ? "STATS\t" : "").$key.(' ' x (($max_length - length($key)) + 4)).$config->{rows_added}->{$key});
scripts/import/import_vcf.pl:  for my $key(sort keys %{$config->{skipped}}) {
scripts/import/import_vcf.pl:    debug($config, (defined($config->{forked}) ? "SKIPPED\t" : "").$key.(' ' x (($max_length - length($key)) + 4)).$config->{skipped}->{$key});
scripts/import/import_vcf.pl:  debug($config, "Finished!".(defined($config->{forked}) ? " (".$config->{forked}.")" : ""));
scripts/import/import_vcf.pl:  die "ERROR: tabix does not seem to be in your path - required for forking\n" unless `which tabix 2>&1` =~ /tabix$/;
scripts/import/import_vcf.pl:  my $filepath = $config->{input_file};
scripts/import/import_vcf.pl:    my $remote_test = `tabix $filepath 1:1-1 2>&1`;
scripts/import/import_vcf.pl:      debug($config, "Downloaded tabix index file for remote annotation file $filepath") unless defined($config->{quiet});
scripts/import/import_vcf.pl:  open TMP, "tabix -l ".$config->{input_file}." | ";
scripts/import/import_vcf.pl:  if(scalar @chrs < $config->{fork}) {
scripts/import/import_vcf.pl:    open TMP, "zcat ".$config->{input_file}." | ";
scripts/import/import_vcf.pl:    my $size = (scalar @chrs == 1 ? int(($max_pos{$chrs[0]} - $min_pos{$chrs[0]} + 1) / $config->{fork}) : 10000000);
scripts/import/import_vcf.pl:    while(scalar @new_chrs < $config->{fork}) {
scripts/import/import_vcf.pl:          push @new_chrs, $chr.':'.$i.'-'.(($i + $size) - 1);
scripts/import/import_vcf.pl:    1 while $string =~ s/^(-?\d+)(\d\d\d)/$1,$2/;
scripts/import/import_vcf.pl:  debug($config, "Done - found $string variants across ".(scalar @chrs)." chromosomal regions");
scripts/import/import_vcf.pl:  if(defined($config->{recover})) {
scripts/import/import_vcf.pl:      if(open IN, (join '/', ($ENV{HOME}, '.import_vcf', md5_hex($config->{session_id}.$chr)))) {
scripts/import/import_vcf.pl:    debug($config, "Found ".(scalar @chrs - scalar @new_chrs)." finished forks");
scripts/import/import_vcf.pl:      my $fork = (split /\(|\)/)[-2];
scripts/import/import_vcf.pl:        push @forked_pids, $split[-1];
scripts/import/import_vcf.pl:        #my ($q, $n) = ($config->{quiet}, $config->{no_progress});
scripts/import/import_vcf.pl:        #delete $config->{quiet};
scripts/import/import_vcf.pl:        #delete $config->{no_progress};
scripts/import/import_vcf.pl:        progress($config, $c, scalar keys %in_progress) if $c % $config->{progress_update} == 0;
scripts/import/import_vcf.pl:        #($config->{quiet}, $config->{no_progress}) = ($q, $n);
scripts/import/import_vcf.pl:        $config->{rows_added}->{$split[-2]} += $split[-1];
scripts/import/import_vcf.pl:        $config->{skipped}->{$split[-2]} += $split[-1];
scripts/import/import_vcf.pl:      elsif(!/^\d{4}\-\d{2}\-\d{2}/ && /\S+/) {
scripts/import/import_vcf.pl:    delete $config->{quiet};
scripts/import/import_vcf.pl:    delete $config->{no_progress};
scripts/import/import_vcf.pl:    my $max_length = (sort {$a <=> $b} map {length($_)} (keys %{$config->{skipped}}, keys %{$config->{rows_added}}))[-1];
scripts/import/import_vcf.pl:    for my $key(sort keys %{$config->{rows_added}}) {
scripts/import/import_vcf.pl:      print $key.(' ' x (($max_length - length($key)) + 4)).$config->{rows_added}->{$key}."\n";
scripts/import/import_vcf.pl:    for my $key(sort keys %{$config->{skipped}}) {
scripts/import/import_vcf.pl:      print $key.(' ' x (($max_length - length($key)) + 4)).$config->{skipped}->{$key}."\n";
scripts/import/import_vcf.pl:      delete $config->{backup} if defined($config->{backup});
scripts/import/import_vcf.pl:      delete $config->{move} if defined($config->{move});
scripts/import/import_vcf.pl:      delete $config->{sql} if defined($config->{sql});
scripts/import/import_vcf.pl:        while(!-e $ENV{HOME}.'/.import_vcf/'.$pid) {
scripts/import/import_vcf.pl:      if(scalar @pids == $config->{fork}) {
scripts/import/import_vcf.pl:        #debug($config, "Max processes (".$config->{fork}.") reached - waiting...");
scripts/import/import_vcf.pl:      $config->{forked} = $chr;
scripts/import/import_vcf.pl:      $config->{session_id} = md5_hex($config->{session_id}.$chr);
scripts/import/import_vcf.pl:      debug($config, "Session ID is ", $config->{session_id});
scripts/import/import_vcf.pl:      if(defined $config->{recover}) {
scripts/import/import_vcf.pl:        if(open IN, (join '/', ($ENV{HOME}, '.import_vcf', $config->{session_id}))) {
scripts/import/import_vcf.pl:          ($config->{recover_point}, $config->{pid}) = split ' ', $a;
scripts/import/import_vcf.pl:          if($config->{recover_point} eq 'FINISHED') {
scripts/import/import_vcf.pl:          delete $config->{recover_point};
scripts/import/import_vcf.pl:          delete $config->{recover_pos};
scripts/import/import_vcf.pl:      my $in_file_handle = FileHandle->new;
scripts/import/import_vcf.pl:      $in_file_handle->open("tabix -h ".$config->{input_file}." $chr | ");
scripts/import/import_vcf.pl:      $config->{in_file_handle} = $in_file_handle;
scripts/import/import_vcf.pl:      $config->{pid} = $$;
scripts/import/import_vcf.pl:      $in_file_handle->close();
scripts/import/import_vcf.pl:  unlink(join '/', ($ENV{HOME}, '.import_vcf', md5_hex($config->{session_id}.$_))) for @chrs;
scripts/import/import_vcf.pl:  if(defined($config->{database})) {
scripts/import/import_vcf.pl:    $config->{dbVar} = DBI->connect( sprintf("DBI:mysql(RaiseError=>1):host=%s;port=%s;db=%s", $config->{host}, $config->{port}, $config->{database}), $config->{user}, $config->{password} );
scripts/import/import_vcf.pl:    if(defined($config->{host}) && defined($config->{user})) {
scripts/import/import_vcf.pl:      $reg->load_registry_from_db(-host => $config->{host}, -port => $config->{port}, -user => $config->{user}, -pass => $config->{password});
scripts/import/import_vcf.pl:      if(-e $config->{registry}) {
scripts/import/import_vcf.pl:        $reg->load_all($config->{registry});
scripts/import/import_vcf.pl:        die "ERROR: could not read from registry file ".$config->{registry}."\n";
scripts/import/import_vcf.pl:    my $vdba = $reg->get_DBAdaptor($config->{species},'variation')
scripts/import/import_vcf.pl:      || usage( "Cannot find variation db for ".$config->{species}." in ".$config->{registry_file} );
scripts/import/import_vcf.pl:    $config->{dbVar} = $vdba->dbc->db_handle;
scripts/import/import_vcf.pl:    debug($config, "Connected to database ", $vdba->dbc->dbname, " on ", $vdba->dbc->host, " as user ", $vdba->dbc->username);
scripts/import/import_vcf.pl:    $config->{$type.'_adaptor'} = $config->{reg}->get_adaptor($config->{species}, "variation", $type);
scripts/import/import_vcf.pl:    die("ERROR: Could not get $type adaptor\n") unless defined($config->{$type.'_adaptor'});
scripts/import/import_vcf.pl:  $config->{populationgenotype_adaptor}->{_allele_adaptor} = $config->{allele_adaptor};
scripts/import/import_vcf.pl:  $config->{variation_adaptor}->db->include_failed_variations(1);
scripts/import/import_vcf.pl:  if((defined($config->{tables}->{transcript_variation}) && $config->{tables}->{transcript_variation}) || defined($config->{remap})) {
scripts/import/import_vcf.pl:    $config->{slice_adaptor} = $config->{reg}->get_adaptor($config->{species}, "core", "slice");
scripts/import/import_vcf.pl:    die("ERROR: Could not get slice adaptor\n") unless defined($config->{slice_adaptor});
scripts/import/import_vcf.pl:    $config->{vep}->{sa} = $config->{slice_adaptor};
scripts/import/import_vcf.pl:    $config->{vep}->{tva} = $config->{transcriptvariation_adaptor};
scripts/import/import_vcf.pl:  if(defined($config->{input_file})) {
scripts/import/import_vcf.pl:    die("ERROR: Could not find input file ", $config->{input_file}, "\n") unless -e $config->{input_file};
scripts/import/import_vcf.pl:    if ($config->{input_file} =~ /\.gz$/){
scripts/import/import_vcf.pl:      $in_file_handle->open("zcat ". $config->{input_file} . "  2>&1 | " ) or die("ERROR: Could not read from input file ", $config->{input_file}, "\n");
scripts/import/import_vcf.pl:    elsif ($config->{input_file} =~ /\.vcf$/){
scripts/import/import_vcf.pl:      $in_file_handle->open( $config->{input_file} ) or die("ERROR: Could not read from input file ", $config->{input_file}, "\n");
scripts/import/import_vcf.pl:      die "ERROR: Not sure how to handle file type of ", $config->{input_file}, "\n";
scripts/import/import_vcf.pl:    debug($config, "Reading from file ", $config->{input_file});
scripts/import/import_vcf.pl:  # no file specified - try to read data off command line
scripts/import/import_vcf.pl:  if(defined($config->{test})) {
scripts/import/import_vcf.pl:        $config->{dbVar}->do($command) or warn $config->{dbVar}->errstr;
scripts/import/import_vcf.pl:  if(defined($config->{move})) {    
scripts/import/import_vcf.pl:    foreach my $table(grep {$config->{tables}->{$_}} keys %{$config->{tables}}) {
scripts/import/import_vcf.pl:      debug($config, (defined($config->{test}) ? "(TEST) " : "")."Renaming $table to $table\_$pid");
scripts/import/import_vcf.pl:      if(!defined($config->{test})) {
scripts/import/import_vcf.pl:        $config->{dbVar}->do(qq{RENAME TABLE $table TO $table\_$pid});
scripts/import/import_vcf.pl:        $config->{dbVar}->do(qq{CREATE TABLE $table LIKE $table\_$pid});
scripts/import/import_vcf.pl:    foreach my $table(grep {$config->{tables}->{$_}} keys %{$config->{tables}}) {
scripts/import/import_vcf.pl:      debug($config, (defined($config->{test}) ? "(TEST) " : "")."Backing up table $table as $table\_$pid");
scripts/import/import_vcf.pl:      if(!defined($config->{test})) {
scripts/import/import_vcf.pl:        $config->{dbVar}->do(qq{CREATE TABLE $table\_$pid LIKE $table});
scripts/import/import_vcf.pl:        $config->{dbVar}->do(qq{INSERT INTO $table\_$pid SELECT * FROM $table});
scripts/import/import_vcf.pl:  my $sth = $config->{dbVar}->prepare(q{ SELECT COUNT(*) FROM attrib });
scripts/import/import_vcf.pl:  $sth->execute();
scripts/import/import_vcf.pl:  $sth->bind_columns(\$count);
scripts/import/import_vcf.pl:  $sth->fetch;
scripts/import/import_vcf.pl:  $sth->finish;
scripts/import/import_vcf.pl:  if(!-e $script) {
scripts/import/import_vcf.pl:  my $installed_version = Bio::EnsEMBL::Registry->software_version;
scripts/import/import_vcf.pl:  my $dbh = DBI->connect('DBI:mysql:;host=ensembldb.ensembl.org;port=5306', 'anonymous');
scripts/import/import_vcf.pl:  $sth = $dbh->prepare(qq{
scripts/import/import_vcf.pl:  $sth->execute('homo_sapiens_variation_'.$installed_version.'_%');
scripts/import/import_vcf.pl:  $sth->bind_columns(\$db_name);
scripts/import/import_vcf.pl:  $sth->fetch;
scripts/import/import_vcf.pl:  $sth->finish;
scripts/import/import_vcf.pl:    $sth->execute('homo_sapiens_variation_'.($installed_version - 1).'_%');
scripts/import/import_vcf.pl:    $sth->bind_columns(\$db_name);
scripts/import/import_vcf.pl:    $sth->fetch;
scripts/import/import_vcf.pl:    $sth->finish;
scripts/import/import_vcf.pl:      debug($config, "WARNING: Could not find database of version $installed_version or ".($installed_version - 1)." on ensembldb.ensembl.org; can't populate attrib tables");
scripts/import/import_vcf.pl:  if(system(sprintf('perl %s --config Bio::EnsEMBL::Variation::Utils::Config --host ensembldb.ensembl.org --user anonymous --port 5306 --db %s > /tmp/attribs.sql', $script, $db_name))  == 0) {
scripts/import/import_vcf.pl:  my $cdba = $config->{reg}->get_DBAdaptor($config->{species},'core') or return {};
scripts/import/import_vcf.pl:  my $dbh  = $cdba->dbc->db_handle;
scripts/import/import_vcf.pl:  my $sth = $dbh->prepare(q{
scripts/import/import_vcf.pl:  $sth->execute($config->{coord_system});
scripts/import/import_vcf.pl:  $sth->bind_columns(\$sr, \$cs, \$name);
scripts/import/import_vcf.pl:  my $vsth = $config->{dbVar}->prepare(q{
scripts/import/import_vcf.pl:  $vsth->execute($sr, $cs, $name) while $sth->fetch();
scripts/import/import_vcf.pl:  $vsth->finish();
scripts/import/import_vcf.pl:  $sth->finish();
scripts/import/import_vcf.pl:  if($config->{tables}->{sample}) {
scripts/import/import_vcf.pl:      $config->{first_sample_col} = $headers{FORMAT} + 1;
scripts/import/import_vcf.pl:      splice(@split, 0, $config->{first_sample_col});
scripts/import/import_vcf.pl:      $config->{samples} = samples($config, \@split);
scripts/import/import_vcf.pl:      delete $config->{tables}->{$_} foreach qw(compressed_genotype_region compressed_genotype_var);
scripts/import/import_vcf.pl:  if(!-e $dir) {
scripts/import/import_vcf.pl:    system('mkdir -p '.$dir);
scripts/import/import_vcf.pl:  my $file = join '/', ($dir, $config->{session_id});
scripts/import/import_vcf.pl:    print SESSION $point." ".$config->{pid};
scripts/import/import_vcf.pl:    debug($config, "WARNING: Could not write to session recover file $file - you will not be able to recover this session");
scripts/import/import_vcf.pl:    $config->{no_recover} = 1;
scripts/import/import_vcf.pl:  my $dbVar = $config->{dbVar};
scripts/import/import_vcf.pl:  my $sth = $dbVar->prepare(qq{SELECT seq_region_id, name FROM seq_region});
scripts/import/import_vcf.pl:  $sth->execute;
scripts/import/import_vcf.pl:  $sth->bind_columns(\$seq_region_id, \$chr_name);
scripts/import/import_vcf.pl:    $seq_region_ids{$chr_name} = $seq_region_id while $sth->fetch;
scripts/import/import_vcf.pl:  $sth->finish;
scripts/import/import_vcf.pl:  if(defined($config->{test})) {
scripts/import/import_vcf.pl:# gets source_id - retrieves if name already exists, otherwise inserts
scripts/import/import_vcf.pl:  my $dbVar  = $config->{dbVar};
scripts/import/import_vcf.pl:  my $source = $config->{source};
scripts/import/import_vcf.pl:  my $desc   = $config->{source_description};
scripts/import/import_vcf.pl:  my $version = $config->{version};
scripts/import/import_vcf.pl:  my $sth = $dbVar->prepare(qq{select source_id from source where name = ?});
scripts/import/import_vcf.pl:  $sth->execute($source);
scripts/import/import_vcf.pl:  $sth->bind_columns(\$source_id);
scripts/import/import_vcf.pl:  $sth->fetch;
scripts/import/import_vcf.pl:  $sth->finish;
scripts/import/import_vcf.pl:    if(defined($config->{test})) {
scripts/import/import_vcf.pl:      $sth = $dbVar->prepare(qq{insert into source(name, version, description) values(?,?,?)});
scripts/import/import_vcf.pl:      $sth->execute($source, $version, $desc);
scripts/import/import_vcf.pl:      $sth->finish();
scripts/import/import_vcf.pl:      $source_id = $dbVar->last_insert_id(undef, undef, qw(source source_id));
scripts/import/import_vcf.pl:    $config->{rows_added}->{source}++;
scripts/import/import_vcf.pl:# gets population objects - retrieves if already exists, otherwise inserts relevant entries
scripts/import/import_vcf.pl:  if(defined($config->{panel})) {
scripts/import/import_vcf.pl:    open PANEL, $config->{panel} or die "ERROR: Could not read from panel file ".$config->{panel}."\n";
scripts/import/import_vcf.pl:      $sample = $config->{sample_prefix}.$sample;
scripts/import/import_vcf.pl:      # make all samples a member of top-level population if specified
scripts/import/import_vcf.pl:      push @split, $config->{population} if defined($config->{population});
scripts/import/import_vcf.pl:        $pop = $config->{pop_prefix}.$pop;
scripts/import/import_vcf.pl:        $pop_samples->{$pop}->{$sample} = 1; 
scripts/import/import_vcf.pl:        $sample_pops->{$sample}->{$pop} = 1;
scripts/import/import_vcf.pl:    $config->{sample_pops} = $sample_pops;
scripts/import/import_vcf.pl:    $config->{pop_samples} = $pop_samples;
scripts/import/import_vcf.pl:    if(defined($config->{test})) {
scripts/import/import_vcf.pl:      debug($config, "(TEST) $_\t".(scalar keys %{$pop_samples->{$_}})) for keys %$pop_samples;
scripts/import/import_vcf.pl:  elsif(defined $config->{population}) {
scripts/import/import_vcf.pl:    push @pops, $config->{pop_prefix}.$config->{population};
scripts/import/import_vcf.pl:  die "ERROR: Population name not specified - use --population [population] or --panel [panel_file]\n" unless scalar @pops;
scripts/import/import_vcf.pl:  my $pa = $config->{population_adaptor};
scripts/import/import_vcf.pl:  if(defined($config->{gmaf})) {
scripts/import/import_vcf.pl:    die "ERROR: Population specified using --gmaf (".$config->{gmaf}." is not one of those to be added; use \"--gmaf ALL\" to calculate GMAF from all samples in the file\n" unless grep {$config->{gmaf} eq 'ALL' or $config->{gmaf} eq $_ or $config->{pop_prefix}.$config->{gmaf} eq $_} @pops;
scripts/import/import_vcf.pl:    my $pop = $pa->fetch_by_name($pop_name); 
scripts/import/import_vcf.pl:      $pop = Bio::EnsEMBL::Variation::Population->new(
scripts/import/import_vcf.pl:        -name    => $pop_name,
scripts/import/import_vcf.pl:        -adaptor => $pa,
scripts/import/import_vcf.pl:      if(defined($config->{test})) {
scripts/import/import_vcf.pl:        $pa->store($pop);
scripts/import/import_vcf.pl:      $config->{rows_added}->{sample}++;
scripts/import/import_vcf.pl:      $config->{rows_added}->{population}++;
scripts/import/import_vcf.pl:  my $file = $config->{pedigree};
scripts/import/import_vcf.pl:    $_ = $config->{ind_prefix}.$_ for ($ind, $dad, $mum);
scripts/import/import_vcf.pl:    $ped->{$ind}->{gender} = defined($sex) ? ($genders{$sex} || 'Unknown') : 'Unknown';
scripts/import/import_vcf.pl:    $ped->{$ind}->{father} = $dad if defined($dad) && $dad;
scripts/import/import_vcf.pl:    $ped->{$ind}->{mother} = $mum if defined($mum) && $mum;
scripts/import/import_vcf.pl:  my $sample_adpt = $config->{sample_adaptor};
scripts/import/import_vcf.pl:  my $ia = $config->{individual_adaptor};  
scripts/import/import_vcf.pl:  # populate %ind_pops hash if it doesn't exist (this will happen when using --population but no panel file)
scripts/import/import_vcf.pl:  if(!exists($config->{sample_pops})) {
scripts/import/import_vcf.pl:    my %sample_pops = map { $config->{sample_prefix}.$_ => {$config->{pop_prefix}.$config->{population} => 1} } @$split_ref;
scripts/import/import_vcf.pl:    $config->{sample_pops} = \%sample_pops;
scripts/import/import_vcf.pl:  if(!exists($config->{pop_samples})) {
scripts/import/import_vcf.pl:    $pop_samples{$config->{pop_prefix}.$config->{population}}->{$config->{sample_prefix}.$_} = 1 for @$split_ref;
scripts/import/import_vcf.pl:    $config->{pop_samples} = \%pop_samples;
scripts/import/import_vcf.pl:  my @sorted = grep {defined $config->{sample_pops}->{$config->{sample_prefix}.$_}} @$split_ref;
scripts/import/import_vcf.pl:  if(defined($config->{pedigree}) && ref($config->{pedigree}) eq 'HASH') {
scripts/import/import_vcf.pl:        defined($config->{pedigree}->{$config->{sample_prefix}.$a}->{father}) +
scripts/import/import_vcf.pl:        defined($config->{pedigree}->{$config->{sample_prefix}.$a}->{mother})
scripts/import/import_vcf.pl:        defined($config->{pedigree}->{$config->{sample_prefix}.$b}->{father}) +
scripts/import/import_vcf.pl:        defined($config->{pedigree}->{$config->{sample_prefix}.$b}->{mother})
scripts/import/import_vcf.pl:  my %pop_objs = map {$_->name => $_} @{$config->{populations}};
scripts/import/import_vcf.pl:    $sample_name = $config->{sample_prefix}.$sample_name;
scripts/import/import_vcf.pl:    my $samples = $sample_adpt->fetch_all_by_name($sample_name);
scripts/import/import_vcf.pl:      $sample = $samples->[0];
scripts/import/import_vcf.pl:      $sample = Bio::EnsEMBL::Variation::Sample->new(
scripts/import/import_vcf.pl:        -name            => $sample_name,
scripts/import/import_vcf.pl:        -adaptor         => $sample_adpt,
scripts/import/import_vcf.pl:        -display         => 'UNDISPLAYABLE',
scripts/import/import_vcf.pl:        -individual      => Bio::EnsEMBL::Variation::Individual->new(
scripts/import/import_vcf.pl:          -type_individual => 'outbred',
scripts/import/import_vcf.pl:          -adaptor         => $ia,
scripts/import/import_vcf.pl:      $sample->{populations} = [map {$pop_objs{$_}} keys %{$config->{sample_pops}->{$sample_name}}];
scripts/import/import_vcf.pl:      if(defined($config->{pedigree}) && ref($config->{pedigree}) eq 'HASH' && (my $ped = $config->{pedigree}->{$sample_name})) {
scripts/import/import_vcf.pl:        $sample->individual->{gender}            = $ped->{gender} if defined($ped->{gender});
scripts/import/import_vcf.pl:        $sample->individual->{father_individual} = $sample_objs{$ped->{father}} if defined($ped->{father});
scripts/import/import_vcf.pl:        $sample->individual->{mother_individual} = $sample_objs{$ped->{mother}} if defined($ped->{mother});
scripts/import/import_vcf.pl:      if($config->{tables}->{sample}) {
scripts/import/import_vcf.pl:        if(defined($config->{test})) {
scripts/import/import_vcf.pl:          $sample_adpt->store($sample);
scripts/import/import_vcf.pl:        $config->{rows_added}->{sample}++;
scripts/import/import_vcf.pl:        $config->{rows_added}->{sample_population} += scalar @{$sample->{populations}};
scripts/import/import_vcf.pl:# gets variation object - retrieves if already exists, otherwise creates and writes to DB
scripts/import/import_vcf.pl:  my $var_id = $data->{ID};
scripts/import/import_vcf.pl:  my $var = $config->{variation_adaptor}->fetch_by_name($var_id);
scripts/import/import_vcf.pl:  my $vf = $data->{tmp_vf};
scripts/import/import_vcf.pl:  my $so_term  = SO_variation_class($vf->allele_string, 1);
scripts/import/import_vcf.pl:  my $class_id = $config->{attribute_adaptor}->attrib_id_for_type_value('SO_term', $so_term);
scripts/import/import_vcf.pl:  if(!defined($var) && !defined($config->{only_existing})) {
scripts/import/import_vcf.pl:    $var = Bio::EnsEMBL::Variation::Variation->new_fast({
scripts/import/import_vcf.pl:      _source_id       => $config->{source_id},
scripts/import/import_vcf.pl:      is_somatic       => $config->{somatic},
scripts/import/import_vcf.pl:    if (defined $data->{info}->{AA}) {
scripts/import/import_vcf.pl:      $var->{ancestral_allele} = $data->{info}->{AA} eq '.' ? undef : uc($data->{info}->{AA});
scripts/import/import_vcf.pl:    $var->{class_attrib_id} = $class_id;
scripts/import/import_vcf.pl:    #$config->{variation_adaptor}->store($var);
scripts/import/import_vcf.pl:  $vf->{variation} = $var;
scripts/import/import_vcf.pl:  my $dbVar = $config->{dbVar};
scripts/import/import_vcf.pl:  my $var_id = $data->{variation}->dbID;
scripts/import/import_vcf.pl:  my $sth = $dbVar->prepare(qq{
scripts/import/import_vcf.pl:  foreach my $synonym(@{$data->{synonyms}}) {
scripts/import/import_vcf.pl:    if(defined($config->{test})) {
scripts/import/import_vcf.pl:      debug($config, "(TEST) Adding ", $synonym, " to variation_synonym as synonym for ", $data->{variation}->dbID);
scripts/import/import_vcf.pl:      $sth->execute(
scripts/import/import_vcf.pl:        $data->{variation}->dbID,
scripts/import/import_vcf.pl:        $config->{source_id},
scripts/import/import_vcf.pl:    $config->{rows_added}->{variation_synonym}++;
scripts/import/import_vcf.pl:  $sth->finish;
scripts/import/import_vcf.pl:  my $dbVar = $config->{dbVar};
scripts/import/import_vcf.pl:  my $vf = $data->{tmp_vf};
scripts/import/import_vcf.pl:  my @new_alleles = split /\//, $vf->allele_string;
scripts/import/import_vcf.pl:  @new_alleles = grep {$_ ne 'N'} @new_alleles if defined($config->{skip_n});
scripts/import/import_vcf.pl:  my $vfa = $config->{variationfeature_adaptor};
scripts/import/import_vcf.pl:  my $var_in_db = defined($data->{variation}->{dbID}) ? 1 : 0;
scripts/import/import_vcf.pl:  my $chromosome = $vf->{chr};
scripts/import/import_vcf.pl:  $chromosome = $config->{chr_synonyms_list}->{$vf->{chr}} if $config->{chr_synonyms};
scripts/import/import_vcf.pl:  $existing_vfs = $vfa->fetch_all_by_Variation($data->{variation}) if($var_in_db && !defined($config->{no_merge}));
scripts/import/import_vcf.pl:    (count_common_alleles($vf->allele_string, $b->allele_string) <=> count_common_alleles($vf->allele_string, $a->allele_string)) ||
scripts/import/import_vcf.pl:    ($a->map_weight <=> $b->map_weight) ||
scripts/import/import_vcf.pl:    ($b->source_name eq 'dbSNP') <=> ($a->source_name eq 'dbSNP') ||
scripts/import/import_vcf.pl:    (split 'rs', $a->variation_name)[-1] <=> (split 'rs', $b->variation_name)[-1]
scripts/import/import_vcf.pl:    my @existing_alleles = split /\//, $existing_vf->allele_string;
scripts/import/import_vcf.pl:    if($existing_vf->seq_region_strand < 0) {
scripts/import/import_vcf.pl:      next if defined $config->{only_existing};
scripts/import/import_vcf.pl:      next if grep {$_ =~ /\-/} keys %combined_alleles && !defined ($config->{merge_all_types}) ;
scripts/import/import_vcf.pl:        $existing_vf->allele_string.
scripts/import/import_vcf.pl:      if(defined($config->{test})) {
scripts/import/import_vcf.pl:        debug($config, "(TEST) Changing allele_string for ", $existing_vf->variation_name, " from ", $existing_vf->allele_string, " to $new_allele_string");
scripts/import/import_vcf.pl:        my $sth = $dbVar->prepare(qq{
scripts/import/import_vcf.pl:        $sth->execute($new_allele_string, $existing_vf->dbID);
scripts/import/import_vcf.pl:        $sth->finish;
scripts/import/import_vcf.pl:      $existing_vf->{allele_string} = $new_allele_string;
scripts/import/import_vcf.pl:      $config->{rows_added}->{variation_feature_allele_string_merged}++;
scripts/import/import_vcf.pl:    if($existing_vf->variation_name ne $data->{ID} and !defined($config->{only_existing}) and !$added_synonym and !defined($data->{made_up_name})) {
scripts/import/import_vcf.pl:      if(defined($config->{test})) {
scripts/import/import_vcf.pl:        debug($config, "(TEST) Adding ", $data->{ID}, " to variation_synonym as synonym for ", $existing_vf->variation_name);
scripts/import/import_vcf.pl:        my $sth = $dbVar->prepare(qq{
scripts/import/import_vcf.pl:        $sth->execute(
scripts/import/import_vcf.pl:          $existing_vf->{_variation_id} || $existing_vf->variation->dbID,
scripts/import/import_vcf.pl:          $config->{source_id},
scripts/import/import_vcf.pl:          $data->{ID}
scripts/import/import_vcf.pl:        $sth->finish;
scripts/import/import_vcf.pl:      $config->{rows_added}->{variation_synonym}++;
scripts/import/import_vcf.pl:    $data->{variation} = $existing_vf->variation;
scripts/import/import_vcf.pl:    if(defined($config->{gmaf}) && !defined($data->{variation}->minor_allele_frequency)) {
scripts/import/import_vcf.pl:      add_gmaf($config, $data, $data->{variation});
scripts/import/import_vcf.pl:      if(defined($config->{test})) {
scripts/import/import_vcf.pl:        debug($config, "(TEST) Updating variation ", $data->{variation}->name, " with GMAF data");
scripts/import/import_vcf.pl:        $config->{variation_adaptor}->update($data->{variation});
scripts/import/import_vcf.pl:  if(!defined($vf->{dbID}) && !defined($config->{only_existing})) {
scripts/import/import_vcf.pl:    add_gmaf($config, $data, $data->{variation}) if defined($config->{gmaf});
scripts/import/import_vcf.pl:    if(defined($config->{test})) {
scripts/import/import_vcf.pl:      debug($config, "(TEST) Writing variation object named ", $data->{variation}->name) unless defined($data->{variation}->dbID);
scripts/import/import_vcf.pl:      $config->{variation_adaptor}->store($data->{variation}) unless defined($data->{variation}->{dbID});
scripts/import/import_vcf.pl:    $config->{rows_added}->{variation}++;
scripts/import/import_vcf.pl:    my $so_term = SO_variation_class($vf->{allele_string}, 1);
scripts/import/import_vcf.pl:    $vf->{_source_id}      = $config->{source_id};
scripts/import/import_vcf.pl:    $vf->{is_somatic}      = $config->{somatic};
scripts/import/import_vcf.pl:    $vf->{class_attrib_id} = $config->{attribute_adaptor}->attrib_id_for_type_value('SO_term', $so_term);
scripts/import/import_vcf.pl:    if(defined($config->{test})) {
scripts/import/import_vcf.pl:      debug($config, "(TEST) Writing variation_feature object named ", $vf->variation_name);
scripts/import/import_vcf.pl:      $vfa->store($vf);
scripts/import/import_vcf.pl:    $config->{meta_coord}->{variation_feature} = $vf->{end} - $vf->{start} + 1 if
scripts/import/import_vcf.pl:      !defined($config->{meta_coord}->{variation_feature}) or
scripts/import/import_vcf.pl:      $vf->{end} - $vf->{start} + 1 > $config->{meta_coord}->{variation_feature};
scripts/import/import_vcf.pl:    $config->{rows_added}->{variation_feature}++;
scripts/import/import_vcf.pl:  my $slice = $config->{slice_adaptor}->fetch_by_region('chromosome', $vf->{chr}, undef, undef, undef, $config->{remap}->[0]);
scripts/import/import_vcf.pl:  my ($s, $e) = ($vf->{start}, $vf->{end});
scripts/import/import_vcf.pl:    -START => $s,
scripts/import/import_vcf.pl:    -END => $e,
scripts/import/import_vcf.pl:    -STRAND => 1,
scripts/import/import_vcf.pl:    -SLICE => $slice,
scripts/import/import_vcf.pl:    @segments = @{$feat->feature_Slice->project('chromosome',$config->{remap}->[1])};
scripts/import/import_vcf.pl:  my @slices_newdb_newasm = map { $_->to_Slice }  @segments;
scripts/import/import_vcf.pl:  @slices_newdb_newasm = sort { $a->start <=> $b->start } @slices_newdb_newasm;
scripts/import/import_vcf.pl:    $new_start = $slices_newdb_newasm[0]->start + 1;
scripts/import/import_vcf.pl:    $new_end = $slices_newdb_newasm[-1]->end - 1;
scripts/import/import_vcf.pl:    $new_start = $slices_newdb_newasm[0]->start;
scripts/import/import_vcf.pl:    $new_end = $slices_newdb_newasm[-1]->end;
scripts/import/import_vcf.pl:  $vf->{start} = $new_start;
scripts/import/import_vcf.pl:  $vf->{end} = $new_end;
scripts/import/import_vcf.pl:  $vf->{seq_region_strand} = $slices_newdb_newasm[0]->strand;
scripts/import/import_vcf.pl:  $config->{meta_coord}->{transcript_variation} = undef;
scripts/import/import_vcf.pl:    my $dbID = $vf->dbID;
scripts/import/import_vcf.pl:    delete $vf->{dbID};
scripts/import/import_vcf.pl:    foreach my $tv(@{$vf->get_all_TranscriptVariations}) {
scripts/import/import_vcf.pl:      $vf->{dbID} ||= $dbID;
scripts/import/import_vcf.pl:      if(defined($config->{test})) {
scripts/import/import_vcf.pl:        debug($config, "(TEST) Writing transcript_variation object for variation ", $vf->variation_name, ", transcript ", $tv->transcript->stable_id);
scripts/import/import_vcf.pl:        $config->{transcriptvariation_adaptor}->store($tv);
scripts/import/import_vcf.pl:      $config->{rows_added}->{transcript_variation}++;
scripts/import/import_vcf.pl:  my @alleles = split /\//, ($data->{vf} || $data->{tmp_vf})->allele_string;
scripts/import/import_vcf.pl:  for my $i(9..((scalar @$split) - 1)) {
scripts/import/import_vcf.pl:    my $gt = (split /\:/, $split->[$i])[0];
scripts/import/import_vcf.pl:    push @genotypes, Bio::EnsEMBL::Variation::SampleGenotype->new_fast({
scripts/import/import_vcf.pl:      variation => $data->{variation},
scripts/import/import_vcf.pl:      sample => $config->{samples}->[$i-9],
scripts/import/import_vcf.pl:      subsnp => defined($data->{SS_ID}) ? $data->{SS_ID} : undef,
scripts/import/import_vcf.pl:  my @alleles = split /\//, $data->{tmp_vf}->allele_string;
scripts/import/import_vcf.pl:  if(defined($data->{genotypes})) {
scripts/import/import_vcf.pl:      map {@{$_->{genotype}}}
scripts/import/import_vcf.pl:        $config->{gmaf} eq 'ALL' ||
scripts/import/import_vcf.pl:        $config->{pop_samples}->{$config->{gmaf}}->{$_->{sample}->{name}} ||
scripts/import/import_vcf.pl:        $config->{pop_samples}->{$config->{pop_prefix}.$config->{gmaf}}->{$_->{sample}->{name}}
scripts/import/import_vcf.pl:      @{$data->{genotypes}};
scripts/import/import_vcf.pl:      $var->{minor_allele} = (sort {$freqs{$a} <=> $freqs{$b}} keys %freqs)[0];
scripts/import/import_vcf.pl:      $var->{minor_allele_frequency} = (sort {$a <=> $b} values %freqs)[0];
scripts/import/import_vcf.pl:      $var->{minor_allele_count} = (sort {$a <=> $b} values %counts)[0];
scripts/import/import_vcf.pl:  my @alleles = split /\//, $data->{vf}->{allele_string};
scripts/import/import_vcf.pl:  foreach my $pop(@{$config->{populations}}) {
scripts/import/import_vcf.pl:    my $pop_name = $pop->{name};
scripts/import/import_vcf.pl:    if(defined($data->{genotypes})) {
scripts/import/import_vcf.pl:        map {@{$_->{genotype}}}
scripts/import/import_vcf.pl:        grep {$config->{pop_samples}->{$pop_name}->{$_->{sample}->{name}}}
scripts/import/import_vcf.pl:        @{$data->{genotypes}};
scripts/import/import_vcf.pl:      my $allele = Bio::EnsEMBL::Variation::Allele->new_fast({
scripts/import/import_vcf.pl:        variation  => $data->{variation}
scripts/import/import_vcf.pl:      if(defined($config->{test})) {
scripts/import/import_vcf.pl:        debug($config, "(TEST) Writing allele object for variation ", $data->{variation}->name, ", allele ", $alleles[$i], ", population ", $pop_name, " freq ", (@freqs ? $freqs[$i] : "?"));
scripts/import/import_vcf.pl:        #$config->{allele_adaptor}->store($allele);
scripts/import/import_vcf.pl:  if(defined($config->{recover_check})) {
scripts/import/import_vcf.pl:    my $db_alleles = $data->{variation}->get_all_Alleles;
scripts/import/import_vcf.pl:          $a->allele eq $b->allele and
scripts/import/import_vcf.pl:          (defined $b->{_population_id} or defined $b->population) and
scripts/import/import_vcf.pl:          $a->population->dbID eq (defined($b->{_population_id}) ? $b->{_population_id} : $b->population->dbID) and
scripts/import/import_vcf.pl:              (defined($a->count) && defined($b->count) && $a->count == $b->count) or
scripts/import/import_vcf.pl:              (!defined($a->count) && !defined($b->count))
scripts/import/import_vcf.pl:              (defined($a->frequency) && defined($b->frequency) && substr($a->frequency, 0, 4) == substr($b->frequency, 0, 4)) or
scripts/import/import_vcf.pl:              (!defined($a->frequency) && !defined($b->frequency))
scripts/import/import_vcf.pl:    delete $config->{recover_check} if scalar @objs == scalar @final_objs;
scripts/import/import_vcf.pl:    $config->{allele_adaptor}->store_multiple(\@objs) unless defined($config->{test});
scripts/import/import_vcf.pl:    $config->{rows_added}->{allele} += scalar @objs;
scripts/import/import_vcf.pl:  foreach my $pop(@{$config->{populations}}) {
scripts/import/import_vcf.pl:    my $pop_name = $pop->{name};
scripts/import/import_vcf.pl:    if(defined($data->{genotypes})) {
scripts/import/import_vcf.pl:        map {join '|', sort @{$_->{genotype}}}
scripts/import/import_vcf.pl:        grep {$config->{pop_samples}->{$pop_name}->{$_->{sample}->{name}}}
scripts/import/import_vcf.pl:        @{$data->{genotypes}};
scripts/import/import_vcf.pl:      my $popgt = Bio::EnsEMBL::Variation::PopulationGenotype->new_fast({
scripts/import/import_vcf.pl:        variation => $data->{variation},
scripts/import/import_vcf.pl:      if(defined($config->{test})) {
scripts/import/import_vcf.pl:        debug($config, "(TEST) Writing population_genotype object for variation ", $data->{variation}->name, ", genotype ", $gt_string, ", population ", $pop_name, " freq ", ($freqs{$gt_string} || "?"));
scripts/import/import_vcf.pl:        #$config->{populationgenotype_adaptor}->store($popgt);
scripts/import/import_vcf.pl:  if(defined($config->{recover_check})) {
scripts/import/import_vcf.pl:    my $db_popgts = $data->{variation}->get_all_PopulationGenotypes;
scripts/import/import_vcf.pl:          $a->genotype_string eq $b->genotype_string and
scripts/import/import_vcf.pl:          (defined $b->{_population_id} or defined $b->population) and
scripts/import/import_vcf.pl:          $a->population->dbID eq (defined $b->{_population_id} ? $b->{_population_id} : $b->population->dbID) and
scripts/import/import_vcf.pl:              (defined($a->count) && defined($b->count) && $a->count == $b->count) or
scripts/import/import_vcf.pl:              (!defined($a->count) && !defined($b->count))
scripts/import/import_vcf.pl:              (defined($a->frequency) && defined($b->frequency) && substr($a->frequency, 0, 4) == substr($b->frequency, 0, 4)) or
scripts/import/import_vcf.pl:              (!defined($a->frequency) && !defined($b->frequency))
scripts/import/import_vcf.pl:    delete $config->{recover_check} if scalar @objs == scalar @final_objs;
scripts/import/import_vcf.pl:  $config->{populationgenotype_adaptor}->store_multiple(\@objs) unless defined($config->{test});
scripts/import/import_vcf.pl:  #$config->{populationgenotype_adaptor}->store_to_file_handle($_, $fh) for @objs;
scripts/import/import_vcf.pl:  $config->{rows_added}->{population_genotype} += scalar @objs;
scripts/import/import_vcf.pl:  my @gts = grep {$_->genotype_string !~ /\./} @{$data->{genotypes}};
scripts/import/import_vcf.pl:  if(defined($config->{test})) {
scripts/import/import_vcf.pl:    return unless scalar keys %{$data->{variation}};
scripts/import/import_vcf.pl:    debug($config, "(TEST) Writing ", scalar @gts, " genotype objects for variation ", $data->{variation}->name);
scripts/import/import_vcf.pl:    if(defined($config->{recover_check})) {
scripts/import/import_vcf.pl:      my $db_gts = $data->{variation}->get_all_SampleGenotypes;
scripts/import/import_vcf.pl:            $a->genotype_string eq $b->genotype_string and
scripts/import/import_vcf.pl:            defined $b->sample and
scripts/import/import_vcf.pl:            $a->sample->dbID eq $b->sample->dbID
scripts/import/import_vcf.pl:      delete $config->{recover_check} if scalar @gts == scalar @final_objs;
scripts/import/import_vcf.pl:    if($config->{tables}->{compressed_genotype_var}) {
scripts/import/import_vcf.pl:      my $rows_added = $config->{samplegenotype_adaptor}->store(\@gts);
scripts/import/import_vcf.pl:      $config->{rows_added}->{compressed_genotype_var} += $rows_added;
scripts/import/import_vcf.pl:    if($config->{mart_genotypes}) {
scripts/import/import_vcf.pl:      my $table = $data->{vf}->{allele_string} =~ /^[ACGTN](\/[ACGTN])+$/ ? 'tmp_sample_genotype_single_bp' : 'sample_genotype_multiple_bp';
scripts/import/import_vcf.pl:      my $rows_added = $config->{samplegenotype_adaptor}->store_uncompressed(\@gts, $table);
scripts/import/import_vcf.pl:      $config->{rows_added}->{$table} += $rows_added;
scripts/import/import_vcf.pl:  $config->{rows_added}->{sample_genotype} += scalar @gts;
scripts/import/import_vcf.pl:  return unless scalar keys %{$config->{meta_coord}};
scripts/import/import_vcf.pl:  my $csa = $config->{reg}->get_adaptor($config->{species}, "core", "coordsystem");
scripts/import/import_vcf.pl:  my $cs = $csa->fetch_by_name($config->{coord_system});
scripts/import/import_vcf.pl:  my $qsth = $config->{dbVar}->prepare(q{
scripts/import/import_vcf.pl:  my $usth = $config->{dbVar}->prepare(q{
scripts/import/import_vcf.pl:  my $isth = $config->{dbVar}->prepare(q{
scripts/import/import_vcf.pl:  foreach my $table(keys %{$config->{meta_coord}}) {
scripts/import/import_vcf.pl:    $qsth->execute($table, $cs->dbID);
scripts/import/import_vcf.pl:    $qsth->bind_columns(\$existing_length);
scripts/import/import_vcf.pl:    $qsth->fetch();
scripts/import/import_vcf.pl:      if(defined($config->{meta_coord}->{$table}) and $existing_length < $config->{meta_coord}->{$table}) {
scripts/import/import_vcf.pl:        if(defined($config->{test})) {
scripts/import/import_vcf.pl:          $usth->execute($config->{meta_coord}->{$table}, $table, $cs->dbID);
scripts/import/import_vcf.pl:      if(defined($config->{test})) {
scripts/import/import_vcf.pl:        $isth->execute($table, $cs->dbID, $config->{meta_coord}->{$table});
scripts/import/import_vcf.pl:  $qsth->finish;
scripts/import/import_vcf.pl:  $usth->finish;
scripts/import/import_vcf.pl:  $isth->finish;
scripts/import/import_vcf.pl:  return $config->{tmpdir}."/$table\_".$config->{pid}.".txt";
scripts/import/import_vcf.pl:  if(!defined($config->{handles}->{$table})) {
scripts/import/import_vcf.pl:    my $file_handle = FileHandle->new("> ".get_tmp_file_name($config, $table));
scripts/import/import_vcf.pl:    $config->{handles}->{$table} = $file_handle;
scripts/import/import_vcf.pl:  return $config->{handles}->{$table};
scripts/import/import_vcf.pl:  $config->{handles}->{$table}->close if defined($config->{handles}->{$table});
scripts/import/import_vcf.pl:  return unless -e $file;
scripts/import/import_vcf.pl:  while(-e $lock_file) {
scripts/import/import_vcf.pl:        (defined($config->{forked}) ? $config->{forked}." " : "").
scripts/import/import_vcf.pl:  $config->{meta_coord}->{$table} = DISTANCE + 1 if $table eq 'compressed_genotype_region';
scripts/import/import_vcf.pl:  if(defined($config->{test})) {
scripts/import/import_vcf.pl:    if(-e $file) {
scripts/import/import_vcf.pl:      my $call = "mv $file ".$config->{tmpdir}."/".$config->{tmpfile};
scripts/import/import_vcf.pl:      my @columns = $config->{$adaptors{$table}.'_adaptor'}->_write_columns;
scripts/import/import_vcf.pl:      load($config->{dbVar},($table, @columns));
scripts/import/import_vcf.pl:  if(defined($config->{test})) {
scripts/import/import_vcf.pl:          $genotypes->{$sample_id}->{region_start},
scripts/import/import_vcf.pl:          $genotypes->{$sample_id}->{region_end},
scripts/import/import_vcf.pl:          $genotypes->{$sample_id}->{genotypes}) . "\n";
scripts/import/import_vcf.pl:        $config->{rows_added}->{compressed_genotype_region}++;
scripts/import/import_vcf.pl:        $genotypes->{$sample_id}->{region_start},
scripts/import/import_vcf.pl:        $genotypes->{$sample_id}->{region_end},
scripts/import/import_vcf.pl:        $genotypes->{$sample_id}->{genotypes}) . "\n";
scripts/import/import_vcf.pl:      $config->{rows_added}->{compressed_genotype_region}++;
scripts/import/import_vcf.pl:# Mastermind - read chromosome synonyms file
scripts/import/import_vcf.pl:  my $seq_region = $config->{seq_region_ids};
scripts/import/import_vcf.pl:  my $file = $config->{chr_synonyms};
scripts/import/import_vcf.pl:    if($seq_region->{$chr1} && $chr2 =~ /^NC/ && $source eq 'Mastermind') {
scripts/import/import_vcf.pl:    elsif($seq_region->{$chr2} && $chr1 =~ /^NC/ && $source eq 'Mastermind') {
scripts/import/import_vcf.pl:    elsif($seq_region->{$chr1} && $source eq 'EVA') {
scripts/import/import_vcf.pl:    elsif($seq_region->{$chr2} && $source eq 'EVA') {
scripts/import/import_vcf.pl:-h | --help           Display this message and quit
scripts/import/import_vcf.pl:-i | --input_file     Input file - if not specified, attempts to read from STDIN
scripts/import/import_vcf.pl:--tmpdir              Temporary directory to write genotype dump file. Required if
scripts/import/import_vcf.pl:--tmpfile             Name for temporary file [default: compress.txt]
scripts/import/import_vcf.pl:--config              Specify a config file containing preset arguments
scripts/import/import_vcf.pl:--test [n]            Run in test mode on first n lines of file. No database writes
scripts/import/import_vcf.pl:--no_progress         Disable progress output
scripts/import/import_vcf.pl:--quiet               Don't print any status messages
scripts/import/import_vcf.pl:--progress_update [n] Update the progress status after each n variants. This also
scripts/import/import_vcf.pl:                      output with progress messages, add --no_progress
scripts/import/import_vcf.pl:--recover             Attempt to recover an incomplete session. Sessions are
scripts/import/import_vcf.pl:--recover_pos         Force recover from chromosomal position. Given as either
scripts/import/import_vcf.pl:--recover_point       Force recover from a position in the file given by the md5 hash
scripts/import/import_vcf.pl:--no_recover          Disable session recovery - this will result in a slight speed
scripts/import/import_vcf.pl:--version             Usually the date of import in the format YYYYMMDAY
scripts/import/import_vcf.pl:--species             Species to use [default: "human"]
scripts/import/import_vcf.pl:--source              Name of source [required]
scripts/import/import_vcf.pl:--source_description  Description of source [optional]
scripts/import/import_vcf.pl:--chr_synonyms        File that contains the chromosome synonyms. Only needed for
scripts/import/import_vcf.pl:--population          Name of population for all samples in file
scripts/import/import_vcf.pl:--panel               Panel file containing sample population membership. One or
scripts/import/import_vcf.pl:                      more of --population or --panel is required. Frequencies are
scripts/import/import_vcf.pl:--pedigree            Pedigree file containing family relationships and sample
scripts/import/import_vcf.pl:--gmaf [ALL|pop]      Add global allele frequency data. "--gmaf ALL" uses all
scripts/import/import_vcf.pl:--somatic             Indicate the data in this VCF is somatic (will not be merged
scripts/import/import_vcf.pl:                      with germline, and vice versa if --somatic not used)
scripts/import/import_vcf.pl:--sample_prefix       Prefix added to sample names [default: not used]
scripts/import/import_vcf.pl:--pop_prefix          Prefix added to population names [default: not used]
scripts/import/import_vcf.pl:--var_prefix          Prefix added to constructed variation names [default: not used]
scripts/import/import_vcf.pl:--create_name         Always create a new variation name i.e. don't use ID column.
scripts/import/import_vcf.pl:--remove_prefix       Removes prefix from the input chromosome name.
scripts/import/import_vcf.pl:--merge_all_types     Merges all types including indels, if not used indels 
scripts/import/import_vcf.pl:--chrom_regexp        Limit processing to CHROM columns matching regexp
scripts/import/import_vcf.pl:--flank               Size of flanking sequence [default: 200]
scripts/import/import_vcf.pl:--gp                  Use GP tag from INFO column to get coords
scripts/import/import_vcf.pl:--tables              Comma-separated list of tables to include when writing to DB.
scripts/import/import_vcf.pl:--add_tables          Comma-separated list of tables to add to default list. Use to
scripts/import/import_vcf.pl:--skip_tables         Comma-separated list of tables to exclude when writing to DB.
scripts/import/import_vcf.pl:                      Takes precedence over --tables (i.e. any tables named in --tables
scripts/import/import_vcf.pl:                      and --skip_tables will be skipped)
scripts/import/import_vcf.pl:--mart_genotypes      Use this flag to populate the uncompressed genotype tables. These
scripts/import/import_vcf.pl:--only_existing       Only write to tables when an existing variant is found. Existing
scripts/import/import_vcf.pl:--skip_n              When comparing to existing variations, set this flag to ignore N
scripts/import/import_vcf.pl:-r | --registry       Registry file to use defines DB connections. Defining a registry
scripts/import/import_vcf.pl:-d | --db_host        Manually define database host
scripts/import/import_vcf.pl:-u | --user           Database username
scripts/import/import_vcf.pl:--password            Database password
scripts/import/import_vcf.pl:--sql                 Specify SQL file to create tables. Usually found in the
scripts/import/import_vcf.pl:                      ensembl-variation CVS checkout, as sql/tables.sql
scripts/import/import_vcf.pl:--coord_system        If the seq_region table is not populated, by default the script
scripts/import/import_vcf.pl:--backup              Backup all affected tables before import
scripts/import/import_vcf.pl:--move                Move all affected tables to backed up names and replace with
scripts/import/import_vcf.pl:--fork [n]            Fork off n simultaneous processes, each dealing with one
scripts/import/import_vcf.pl:                      scanned up front and the chromosomes sub-divided into regions.
scripts/import/import_vcf.pl:     ($time[5] + 1900)."-".
scripts/import/import_vcf.pl:      $time[4]."-".
scripts/import/import_vcf.pl:  return if defined($config->{quiet});
scripts/import/import_vcf.pl:  if(defined $config->{forked}) {
scripts/import/import_vcf.pl:    print PARENT $time." - ".$text.($text =~ /\n$/ ? "" : "\n");
scripts/import/import_vcf.pl:    print $time." - ".$text.($text =~ /\n$/ ? "" : "\n");
scripts/import/import_vcf.pl:  return if defined($config->{no_progress});
scripts/import/import_vcf.pl:  $config->{prev_time} ||= $config->{start_time};
scripts/import/import_vcf.pl:  my $prev_elapsed = tv_interval($config->{prev_time}, [gettimeofday]);
scripts/import/import_vcf.pl:  my $total_elapsed = tv_interval($config->{start_time}, [gettimeofday]);
scripts/import/import_vcf.pl:  my $prev_pm = $config->{progress_update} / ($prev_elapsed / 60);
scripts/import/import_vcf.pl:  printf("\r%s - Processed %8i variants (%8.2f per min / %8.2f per min overall ) ( %2i process%2s )", getTime, $count, $prev_pm, $total_pm, $proc, ($proc > 1 ? 'es' : '  '));
scripts/import/import_vcf.pl:  $config->{prev_time} = [gettimeofday];
scripts/import/import_vcf.pl:  if(defined $config->{forked}) {
scripts/import/import_cosmic.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_cosmic.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_cosmic.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_cosmic.pl:      $0 --import <input_file> --registry <reg_file> --version <cosmic_version>
scripts/import/import_cosmic.pl:      $0 --import <input_file_1> --registry <reg_file> --version <cosmic_version> --index 1
scripts/import/import_cosmic.pl:      $0 --import <input_file_2> --registry <reg_file> --version <cosmic_version> --index 2
scripts/import/import_cosmic.pl:      $0 --import <input_file_3> --registry <reg_file> --version <cosmic_version> --index 3
scripts/import/import_cosmic.pl:      $0 --registry <reg_file> --version <cosmic_version>\n";
scripts/import/import_cosmic.pl:$registry->load_all($registry_file);
scripts/import/import_cosmic.pl:my $dbh = $registry->get_adaptor(
scripts/import/import_cosmic.pl:)->dbc;
scripts/import/import_cosmic.pl:my $dbVar = $dbh->db_handle;
scripts/import/import_cosmic.pl:  my $sth = $dbVar->prepare("SHOW TABLES LIKE '$temp_table_prefix%';");
scripts/import/import_cosmic.pl:  my $rc = $sth->execute();
scripts/import/import_cosmic.pl:  while ( my $table = $sth->fetchrow_array) {
scripts/import/import_cosmic.pl:    $main_table =~ s/[0-9]+$//;
scripts/import/import_cosmic.pl:    $dbVar->do("INSERT INTO $main_table SELECT * FROM $table;");
scripts/import/import_cosmic.pl:  $sth->finish();
scripts/import/import_cosmic.pl:        "  - $temp_table_prefix\n" .
scripts/import/import_cosmic.pl:        "  - $temp_phen_table_prefix\n" .
scripts/import/import_cosmic.pl:        "  - $temp_varSyn_table_prefix\n";
scripts/import/import_cosmic.pl:my $dba = $registry->get_DBAdaptor('homo_sapiens','variation');
scripts/import/import_cosmic.pl:my $variation_adaptor = $dba->get_VariationAdaptor('human', 'variation', );
scripts/import/import_cosmic.pl:my $var_feat_adaptor = $dba->get_VariationFeatureAdaptor('human', 'variation', );
scripts/import/import_cosmic.pl:my $source_adaptor  = $dba->get_SourceAdaptor('homo_sapiens', 'variation',);
scripts/import/import_cosmic.pl:# my $source_adaptor  = $reg->get_adaptor('homo_sapiens', 'variation', 'source');
scripts/import/import_cosmic.pl:my $attrib_adaptor = $dba->get_AttributeAdaptor('homo_sapiens', 'variation',);
scripts/import/import_cosmic.pl:my $tva = $dba->get_TranscriptVariationAdaptor('human', 'variation', );
scripts/import/import_cosmic.pl:my $dbc = $registry->get_DBAdaptor('homo_sapiens','core');
scripts/import/import_cosmic.pl:my $slice_adaptor = $dbc->get_SliceAdaptor('human', 'core', );
scripts/import/import_cosmic.pl:my $source_obj = $source_adaptor->fetch_by_name($source_name);
scripts/import/import_cosmic.pl:my $variation_set_pheno = get_variation_set_id("All phenotype/disease-associated variants"); #All phenotype/disease variants
scripts/import/import_cosmic.pl:  $dbVar->do("DROP TABLE IF EXISTS $table;");
scripts/import/import_cosmic.pl:  $dbVar->do("ALTER TABLE $temp_table ADD PRIMARY KEY (name, seq_region_id, seq_region_start, seq_region_end);");
scripts/import/import_cosmic.pl:  $dbVar->do("ALTER TABLE $temp_phen_table ADD PRIMARY KEY (name, phenotype_id);");
scripts/import/import_cosmic.pl:  $dbVar->do("ALTER TABLE $temp_varSyn_table ADD PRIMARY KEY (name, old_name);");
scripts/import/import_cosmic.pl:my $cosmic_ins_sth = $dbh->prepare($cosmic_ins_stmt);
scripts/import/import_cosmic.pl:my $cosmic_phe_ins_sth = $dbh->prepare($cosmic_phe_ins_stmt);
scripts/import/import_cosmic.pl:my $cosmic_syn_ins_sth = $dbh->prepare($cosmic_syn_ins_stmt);
scripts/import/import_cosmic.pl:my $csvP = Text::CSV->new({ sep_char => ',' });
scripts/import/import_cosmic.pl:  if (!$csvP->parse($_)){
scripts/import/import_cosmic.pl:  my @line = $csvP->fields();
scripts/import/import_cosmic.pl:  # 1,100001572,100001572,COSV63379341,COSN6400737,"liver","Substitution - intronic"
scripts/import/import_cosmic.pl:  my $seq_region_id = $seq_region_ids->{$chr};
scripts/import/import_cosmic.pl:  my $class_attrib_id = $class_attrib_ids->{$class};
scripts/import/import_cosmic.pl:  $cosmic_ins_sth->bind_param(1,$cosv_id,SQL_VARCHAR);
scripts/import/import_cosmic.pl:  $cosmic_ins_sth->bind_param(2,$seq_region_id,SQL_INTEGER);
scripts/import/import_cosmic.pl:    $cosmic_ins_sth->bind_param(3,$end,SQL_INTEGER);
scripts/import/import_cosmic.pl:    $cosmic_ins_sth->bind_param(4,$start,SQL_INTEGER);
scripts/import/import_cosmic.pl:    $cosmic_ins_sth->bind_param(3,$start,SQL_INTEGER);
scripts/import/import_cosmic.pl:    $cosmic_ins_sth->bind_param(4,$end,SQL_INTEGER);
scripts/import/import_cosmic.pl:  $cosmic_ins_sth->bind_param(5,$class_attrib_id,SQL_INTEGER);
scripts/import/import_cosmic.pl:  $cosmic_ins_sth->execute();
scripts/import/import_cosmic.pl:    $cosmic_syn_ins_sth->bind_param(1,$cosv_id,SQL_VARCHAR);
scripts/import/import_cosmic.pl:    $cosmic_syn_ins_sth->bind_param(2,$cosmic_id,SQL_VARCHAR);
scripts/import/import_cosmic.pl:    $cosmic_syn_ins_sth->execute();
scripts/import/import_cosmic.pl:    my $phenotype_id = $phenotype_ids->{$phenotype};
scripts/import/import_cosmic.pl:    $cosmic_phe_ins_sth->bind_param(1,$cosv_id,SQL_VARCHAR);
scripts/import/import_cosmic.pl:    $cosmic_phe_ins_sth->bind_param(2,$phenotype_id,SQL_INTEGER);
scripts/import/import_cosmic.pl:    $cosmic_phe_ins_sth->execute();
scripts/import/import_cosmic.pl:$cosmic_ins_sth->finish();
scripts/import/import_cosmic.pl:$cosmic_phe_ins_sth->finish();
scripts/import/import_cosmic.pl:$cosmic_syn_ins_sth->finish();
scripts/import/import_cosmic.pl:  my $get_class_attrib_ids_sth = $dbh->prepare(
scripts/import/import_cosmic.pl:  $get_class_attrib_ids_sth->execute;
scripts/import/import_cosmic.pl:  while (my ($value, $attrib_id) = $get_class_attrib_ids_sth->fetchrow_array) {
scripts/import/import_cosmic.pl:  $get_class_attrib_ids_sth->finish();
scripts/import/import_cosmic.pl:  my $sth = $dbh->prepare(
scripts/import/import_cosmic.pl:  $sth->execute;
scripts/import/import_cosmic.pl:  $sth->bind_columns(\$id, \$name);
scripts/import/import_cosmic.pl:  $seq_region_ids{$name} = $id while $sth->fetch();
scripts/import/import_cosmic.pl:  $sth->finish;
scripts/import/import_cosmic.pl:  my $sth = $dbh->prepare(
scripts/import/import_cosmic.pl:  $sth->execute;
scripts/import/import_cosmic.pl:  $sth->bind_columns(\$id, \$desc);
scripts/import/import_cosmic.pl:  $phenotype_ids{$desc} = $id while $sth->fetch();
scripts/import/import_cosmic.pl:  $sth->finish;
scripts/import/import_cosmic.pl:  if ($dbVar->selectrow_arrayref(qq{SELECT source_id FROM source WHERE name="$source_name";})) {
scripts/import/import_cosmic.pl:    $dbVar->do(qq{UPDATE IGNORE source SET version=$version where name="$source_name";});
scripts/import/import_cosmic.pl:    $dbVar->do(qq{INSERT INTO source (name,description,url,version,somatic_status,data_types) VALUES ("$source_name",'Somatic mutations found in human cancers from the COSMIC project - Public version','https://cancer.sanger.ac.uk/cosmic/',$version,'somatic','variation,variation_synonym,phenotype_feature');});
scripts/import/import_cosmic.pl:  my @source_id = @{$dbVar->selectrow_arrayref(qq{SELECT source_id FROM source WHERE name="$source_name";})};
scripts/import/import_cosmic.pl:  my $aid = $dbVar->selectrow_arrayref(qq{
scripts/import/import_cosmic.pl:  if (!$aid->[0]){
scripts/import/import_cosmic.pl:    return $aid->[0];
scripts/import/import_cosmic.pl:  $dbVar->do(qq{INSERT IGNORE INTO phenotype (description, class_attrib_id)
scripts/import/import_cosmic.pl:  my $phenotype_id = $dbVar->selectrow_arrayref(qq{SELECT phenotype_id FROM phenotype WHERE description="$phenotype"});
scripts/import/import_cosmic.pl:  $phenotype_ids->{$phenotype} = $phenotype_id->[0];
scripts/import/import_cosmic.pl:  return $phenotype_id->[0];
scripts/import/import_cosmic.pl:  my $variation_set_ids = $dbVar->selectrow_arrayref(qq{SELECT variation_set_id FROM variation_set WHERE name LIKE '$type%'});
scripts/import/import_cosmic.pl:    return $variation_set_ids->[0];
scripts/import/import_cosmic.pl:  # MTMP transcript variation - biotypes to skip
scripts/import/import_cosmic.pl:  my $sth_get_var = $dbh->prepare($stmt_get_var);
scripts/import/import_cosmic.pl:  $sth_get_var->execute();
scripts/import/import_cosmic.pl:  my $data_var = $sth_get_var->fetchall_arrayref();
scripts/import/import_cosmic.pl:    my $so_term = $attrib_adaptor->attrib_value_for_id($var_tmp->[4]);
scripts/import/import_cosmic.pl:    my $var = Bio::EnsEMBL::Variation::Variation->new
scripts/import/import_cosmic.pl:      ( -name              => $var_tmp->[0],
scripts/import/import_cosmic.pl:        -source            => $source_obj,
scripts/import/import_cosmic.pl:        -is_somatic        => 1,
scripts/import/import_cosmic.pl:        -adaptor           => $variation_adaptor,
scripts/import/import_cosmic.pl:        -class_SO_term     => $so_term,
scripts/import/import_cosmic.pl:        -evidence          => \@evidence_list,
scripts/import/import_cosmic.pl:    if($var_tmp->[0] eq 'COSV67297583') {
scripts/import/import_cosmic.pl:      my $tmp_var = $variation_adaptor->fetch_by_name($var_tmp->[0]);
scripts/import/import_cosmic.pl:    $variation_adaptor->store($var) unless $skip_var;
scripts/import/import_cosmic.pl:    # my $slice = $slice_adaptor->fetch_by_dbID($var_tmp->[1]);
scripts/import/import_cosmic.pl:    my $sth_seq_region = $dbh->prepare(qq{ SELECT name from seq_region WHERE seq_region_id = ?
scripts/import/import_cosmic.pl:    $sth_seq_region->execute($var_tmp->[1]);
scripts/import/import_cosmic.pl:    my $seq_region_data = $sth_seq_region->fetchall_arrayref();
scripts/import/import_cosmic.pl:    my $seq_region_name = $seq_region_data->[0]->[0];
scripts/import/import_cosmic.pl:    my $slice = $slice_adaptor->fetch_by_region('chromosome', $seq_region_name);
scripts/import/import_cosmic.pl:    my $vf = Bio::EnsEMBL::Variation::VariationFeature->new
scripts/import/import_cosmic.pl:      (-start           => $var_tmp->[2],
scripts/import/import_cosmic.pl:       -end             => $var_tmp->[3],
scripts/import/import_cosmic.pl:       -strand          => 1,
scripts/import/import_cosmic.pl:       -slice           => $slice,
scripts/import/import_cosmic.pl:       -variation_name  => $var_tmp->[0],
scripts/import/import_cosmic.pl:       -map_weight      => 1,
scripts/import/import_cosmic.pl:       -allele_string   => $allele,
scripts/import/import_cosmic.pl:       -variation       => $var,
scripts/import/import_cosmic.pl:       -source          => $source_obj,
scripts/import/import_cosmic.pl:       -class_SO_term   => $so_term,
scripts/import/import_cosmic.pl:       -is_somatic      => 1,
scripts/import/import_cosmic.pl:       -adaptor         => $var_feat_adaptor,
scripts/import/import_cosmic.pl:       -evidence        => \@evidence_list,
scripts/import/import_cosmic.pl:    $var_feat_adaptor->store($vf);
scripts/import/import_cosmic.pl:    my $all_tv = $vf->get_all_TranscriptVariations();
scripts/import/import_cosmic.pl:      next unless overlap($vf->start, $vf->end, $tv->transcript->start - 0, $tv->transcript->end + 0);
scripts/import/import_cosmic.pl:      my $write_biotype = $biotypes_to_skip{$tv->transcript->biotype} ? 0 : 1;
scripts/import/import_cosmic.pl:      my $write_mane = $tv->transcript->is_mane ? 1 : 0;
scripts/import/import_cosmic.pl:      $tva->store($tv, $mtmp);
scripts/import/import_cosmic.pl:    my $vf_dbid = $vf->dbID;
scripts/import/import_cosmic.pl:      my $vf_sth = $dba->dbc()->prepare($update_vf_smt);
scripts/import/import_cosmic.pl:      $vf_sth->execute('intergenic_variant', $vf->dbID) || die "Error updating consequence_types to default in table variation_feature\n";
scripts/import/import_cosmic.pl:    my $sth_len = $dbh->prepare($stmt_len);
scripts/import/import_cosmic.pl:    $sth_len->execute();
scripts/import/import_cosmic.pl:    my $tv_sth = $dba->dbc()->prepare(qq[ SELECT variation_feature_id, GROUP_CONCAT(DISTINCT(consequence_types))
scripts/import/import_cosmic.pl:    $tv_sth->execute($vf_dbid) || die "Error selecting consequence_types from transcript_variation\n";
scripts/import/import_cosmic.pl:    my $data_tv = $tv_sth->fetchall_arrayref();
scripts/import/import_cosmic.pl:    if (defined $data_tv->[0]->[0]) {
scripts/import/import_cosmic.pl:      my $update_vf_sth = $dba->dbc()->prepare($update_vf_smt);
scripts/import/import_cosmic.pl:      # warn "Inserting variation_feature: $data_tv->[0]->[0], $data_tv->[0]->[1]\n";
scripts/import/import_cosmic.pl:      $update_vf_sth->execute($data_tv->[0]->[1], $data_tv->[0]->[0]) || die "Error updating consequence_types in table variation_feature\n";
scripts/import/import_cosmic.pl:  my $vf_set_upd_sth = $dbh->prepare(qq[ UPDATE variation_feature
scripts/import/import_cosmic.pl:  $vf_set_upd_sth->execute() || die "Error updating variation_set_id in variation_feature\n";
scripts/import/import_cosmic.pl:  my $sth_vs  = $dbh->prepare($stmt_vs);
scripts/import/import_cosmic.pl:  $sth_vs->execute();
scripts/import/import_cosmic.pl:  my $sth_pf  = $dbh->prepare($stmt_pf);
scripts/import/import_cosmic.pl:  $sth_pf->execute($default_strand);
scripts/import/import_cosmic.pl:  my $sth_set  = $dbh->prepare($stmt_set);
scripts/import/import_cosmic.pl:  $sth_set->execute($variation_set_cosmic, $source_id);
scripts/import/calculate_ld_table.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/calculate_ld_table.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/calculate_ld_table.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/calculate_ld_table.pl:`sort -n -k 1 -o $ld_file $ld_file` unless $ld_file =~ /gz$/; #order snps by position
scripts/import/calculate_ld_table.pl:my %individual_information = (); #hash containing relation snps->individuals
scripts/import/calculate_ld_table.pl:	open IN, "gzip -dc $ld_file |";
scripts/import/calculate_ld_table.pl:    @alleles_ordered = sort({$alleles_information->{$b} <=> $alleles_information->{$a}} keys %{$alleles_information});
scripts/import/calculate_ld_table.pl:	    if ($individual_information->{$individual_id}{allele_1} ne $individual_information->{$individual_id}{allele_2}){
scripts/import/calculate_ld_table.pl:		$individual_information->{$individual_id}{genotype} = 'Aa';
scripts/import/calculate_ld_table.pl:		if ($alleles_ordered[0] eq $individual_information->{$individual_id}{allele_1}){
scripts/import/calculate_ld_table.pl:		    $individual_information->{$individual_id}{genotype} = 'AA';
scripts/import/calculate_ld_table.pl:		    $individual_information->{$individual_id}{genotype} = 'aa';
scripts/import/calculate_ld_table.pl:	    print FH $buffer->{ $file };
scripts/import/calculate_ld_table.pl:	$buffer->{ $filename } .= $text;
scripts/import/calculate_ld_table.pl:	if( length( $buffer->{ $filename } ) > 10_000 ) {
scripts/import/calculate_ld_table.pl:	    print FH $buffer->{ $filename };
scripts/import/calculate_ld_table.pl:	    $buffer->{ $filename } = '';
scripts/import/post_process_databases_tables.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/post_process_databases_tables.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/post_process_databases_tables.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/post_process_databases_tables.pl:  print STDERR "> Error! Please give an Ensembl version, using the option '-v' \n";
scripts/import/post_process_databases_tables.pl:  print STDERR "> Error! Please give a database user name, using the option '-user' \n";
scripts/import/post_process_databases_tables.pl:  print STDERR "> Error! Please give a database password, using the option '-pass' \n";
scripts/import/post_process_databases_tables.pl:  print STDERR "> Error! Please give the list of host names where the new databases are stored using the option '-hlist'\n";
scripts/import/post_process_databases_tables.pl:  while (my ($dbname) = $sth_h->fetchrow_array) {
scripts/import/post_process_databases_tables.pl:    next if ($dbname !~ /^[a-z]+_[a-z]+_variation_\d+_\d+$/i);
scripts/import/post_process_databases_tables.pl:    print STDERR "# $s_name - [ $dbname ]\n";
scripts/import/post_process_databases_tables.pl:  $sth_h->finish;
scripts/import/post_process_databases_tables.pl:  my $dbh = DBI->connect($dsn, $user, $pass) or die "Connection failed";
scripts/import/post_process_databases_tables.pl:  my $sth = $dbh->prepare($sql);
scripts/import/post_process_databases_tables.pl:  $sth->execute;
scripts/import/post_process_databases_tables.pl:    $sth->finish;
scripts/import/post_process_databases_tables.pl:    -help       Print this message
scripts/import/post_process_databases_tables.pl:    -v          Ensembl version, e.g. 90 (Required)
scripts/import/post_process_databases_tables.pl:    -user|u     Database login user name (Required)
scripts/import/post_process_databases_tables.pl:    -pass|p     Database user password name (Required)
scripts/import/post_process_databases_tables.pl:    -hlist      The list of host names (with port) where the new databases are stored, separated by a coma,
scripts/import/parallel_read_coverage.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/parallel_read_coverage.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/parallel_read_coverage.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/parallel_read_coverage.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/parallel_read_coverage.pl:my $cdba = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/parallel_read_coverage.pl:my $vdba = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/parallel_read_coverage.pl:my $dbVar = $vdba->dbc->db_handle;
scripts/import/parallel_read_coverage.pl:$chost = $cdba->dbc->host; 
scripts/import/parallel_read_coverage.pl:$cport = $cdba->dbc->port ;
scripts/import/parallel_read_coverage.pl:$cdbname = $cdba->dbc->dbname;
scripts/import/parallel_read_coverage.pl:$vhost = $vdba->dbc->host;
scripts/import/parallel_read_coverage.pl:$vport = $vdba->dbc->port;
scripts/import/parallel_read_coverage.pl:$vdbname = $vdba->dbc->dbname;
scripts/import/parallel_read_coverage.pl:$vpass = $vdba->dbc->password;
scripts/import/parallel_read_coverage.pl:    $call = "bsub -J read_coverage_job_$i -o $TMP_DIR/output_reads_$i.txt -q research /sw/arch/bin/env perl read_coverage.pl -chost $chost -cuser $cuser -cport $cport -cdbname $cdbname -vhost $vhost -vuser $vuser -vpass $vpass -vport $vport -vdbname $vdbname -tmpdir $TMP_DIR -tmpfile read_coverage_$i.txt -maxlevel $max_level -readfile $read_file";
scripts/import/parallel_read_coverage.pl:        $call .= " -indfile $ind_file";
scripts/import/parallel_read_coverage.pl:$call = "bsub -K -w '$bsub_wait_status(read_coverage_job_*)' -J waiting_process sleep 1"; #waits until all reads have succesfully finished
scripts/import/parallel_read_coverage.pl:  my $csa = $dbCore->get_CoordSystemAdaptor();
scripts/import/parallel_read_coverage.pl:  my $cs = $csa->fetch_by_name($csname);
scripts/import/parallel_read_coverage.pl:  my $max_length_ref = $dbVar->selectall_arrayref(qq{SELECT max(seq_region_end - seq_region_start+1) from read_coverage});
scripts/import/parallel_read_coverage.pl:  my $max_length = $max_length_ref->[0][0];
scripts/import/parallel_read_coverage.pl:  my $sth = $dbVar->prepare
scripts/import/parallel_read_coverage.pl:  $sth->execute($table_name, $cs->dbID(), $max_length);
scripts/import/parallel_read_coverage.pl:  $sth->finish();
scripts/import/parallel_read_coverage.pl:    -chost <hostname>    hostname of core Ensembl MySQL database (default = ecs2)
scripts/import/parallel_read_coverage.pl:    -cuser <user>        username of core Ensembl MySQL database (default = ensro)
scripts/import/parallel_read_coverage.pl:    -cpass <pass>        password of core Ensembl MySQL database
scripts/import/parallel_read_coverage.pl:    -cport <port>        TCP port of core Ensembl MySQL database (default = 3364)
scripts/import/parallel_read_coverage.pl:    -cdbname <dbname>    dbname of core Ensembl MySQL database
scripts/import/parallel_read_coverage.pl:    -vhost <hostname>    hostname of variation MySQL database to write to
scripts/import/parallel_read_coverage.pl:    -vuser <user>        username of variation MySQL database to write to (default = ensadmin)
scripts/import/parallel_read_coverage.pl:    -vpass <pass>        password of variation MySQL database to write to
scripts/import/parallel_read_coverage.pl:    -vport <port>        TCP port of variation MySQL database to write to (default = 3306)
scripts/import/parallel_read_coverage.pl:    -vdbname <dbname>    dbname of variation MySQL database to write to
scripts/import/parallel_read_coverage.pl:    -tmpdir <dir>        temp directory to use (with lots of space!)
scripts/import/parallel_read_coverage.pl:    -tmpfile <filename>  name of temp file to use
scripts/import/parallel_read_coverage.pl:    -readdir <dirname>   name of dir with read information
scripts/import/import_decipher_snv.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_decipher_snv.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_decipher_snv.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_decipher_snv.pl:$registry->load_all($registry_file);
scripts/import/import_decipher_snv.pl:my $sa = $registry->get_adaptor('human', 'core', 'slice');
scripts/import/import_decipher_snv.pl:my $dbh = $registry->get_adaptor('human', 'variation_private', 'variation')->dbc->db_handle;
scripts/import/import_decipher_snv.pl:my $attr_type_sth = $dbh->prepare(qq{ SELECT attrib_type_id FROM attrib_type WHERE code='SO_term'});
scripts/import/import_decipher_snv.pl:$attr_type_sth->execute;
scripts/import/import_decipher_snv.pl:my $attr_type_id = ($attr_type_sth->fetchrow_array)[0];
scripts/import/import_decipher_snv.pl:$attr_type_sth->finish;
scripts/import/import_decipher_snv.pl:my $cs_attr_type_sth = $dbh->prepare(qq{ SELECT attrib_type_id FROM attrib_type WHERE code='clinvar_clin_sig'});
scripts/import/import_decipher_snv.pl:$cs_attr_type_sth->execute;
scripts/import/import_decipher_snv.pl:my $cs_attr_type_id = ($cs_attr_type_sth->fetchrow_array)[0];
scripts/import/import_decipher_snv.pl:$cs_attr_type_sth->finish;
scripts/import/import_decipher_snv.pl:my $inheritance_attrib_type_id = ($dbh->selectall_arrayref($stmt))->[0][0];
scripts/import/import_decipher_snv.pl:my $phenotype_attrib_id = ($dbh->selectall_arrayref($stmt))->[0][0];
scripts/import/import_decipher_snv.pl:my $find_existing_var_sth = $dbh->prepare(qq{
scripts/import/import_decipher_snv.pl:my $add_var_sth = $dbh->prepare(qq{
scripts/import/import_decipher_snv.pl:my $find_existing_vf_sth = $dbh->prepare(qq{
scripts/import/import_decipher_snv.pl:my $add_vf_sth = $dbh->prepare(qq{
scripts/import/import_decipher_snv.pl:my $select_phe_sth = $dbh->prepare(qq{
scripts/import/import_decipher_snv.pl:my $add_phe_sth = $dbh->prepare(qq{
scripts/import/import_decipher_snv.pl:my $find_existing_pf_sth = $dbh->prepare(qq{
scripts/import/import_decipher_snv.pl:my $add_pf_sth = $dbh->prepare(qq{
scripts/import/import_decipher_snv.pl:my $add_pfa_sth = $dbh->prepare(qq{
scripts/import/import_decipher_snv.pl:my $add_failed_sth = $dbh->prepare(qq{
scripts/import/import_decipher_snv.pl:  my $slice = $data->{slice};
scripts/import/import_decipher_snv.pl:  my $class_attrib_id = $SO_terms->{$data->{SO_term}};
scripts/import/import_decipher_snv.pl:  my $seq_region_id = $sa->get_seq_region_id($slice);
scripts/import/import_decipher_snv.pl:  my $clin_sign = $data->{clin_sign} if ($clin_sign_types->{$data->{clin_sign}});
scripts/import/import_decipher_snv.pl:  $find_existing_var_sth->execute($data->{ID});
scripts/import/import_decipher_snv.pl:  my $existing_var = $find_existing_var_sth->fetchrow_arrayref;
scripts/import/import_decipher_snv.pl:    $variation_id = $existing_var->[0];
scripts/import/import_decipher_snv.pl:    $add_var_sth->execute($source_id, $data->{ID}, $data->{flipped}, $class_attrib_id, $clin_sign);
scripts/import/import_decipher_snv.pl:    $variation_id = $dbh->last_insert_id(undef, undef, undef, undef);
scripts/import/import_decipher_snv.pl:  if (!$data->{failed}) {
scripts/import/import_decipher_snv.pl:    $find_existing_vf_sth->execute($data->{ID},$seq_region_id, $data->{start}, $data->{end});
scripts/import/import_decipher_snv.pl:    my $existing_vf = $find_existing_vf_sth->fetchrow_arrayref;
scripts/import/import_decipher_snv.pl:      $add_vf_sth->execute(
scripts/import/import_decipher_snv.pl:        $data->{start},
scripts/import/import_decipher_snv.pl:        $data->{end},
scripts/import/import_decipher_snv.pl:        $data->{strand},
scripts/import/import_decipher_snv.pl:        $data->{ID},
scripts/import/import_decipher_snv.pl:        $data->{ref}.'/'.$data->{alt},
scripts/import/import_decipher_snv.pl:    if ($data->{phenotype} && $data->{phenotype} ne '') {
scripts/import/import_decipher_snv.pl:      my @phenotypes = split(/\|/,$data->{phenotype});
scripts/import/import_decipher_snv.pl:      foreach my $phe (keys(%{$data->{phenotype}})) {
scripts/import/import_decipher_snv.pl:        $select_phe_sth->execute($phe);
scripts/import/import_decipher_snv.pl:        my $phe_id = ($select_phe_sth->fetchrow_array)[0];
scripts/import/import_decipher_snv.pl:          $add_phe_sth->execute($phe);
scripts/import/import_decipher_snv.pl:          $phe_id = $dbh->last_insert_id(undef, undef, undef, undef);
scripts/import/import_decipher_snv.pl:        $find_existing_pf_sth->execute($data->{ID},$seq_region_id, $data->{start}, $data->{end}, $phe_id);
scripts/import/import_decipher_snv.pl:        my $existing_pf = $find_existing_pf_sth->fetchrow_arrayref;
scripts/import/import_decipher_snv.pl:          $add_pf_sth->execute(
scripts/import/import_decipher_snv.pl:            $data->{start},
scripts/import/import_decipher_snv.pl:            $data->{end},
scripts/import/import_decipher_snv.pl:            $data->{strand},
scripts/import/import_decipher_snv.pl:            $data->{ID},
scripts/import/import_decipher_snv.pl:          if ($data->{inheritance} && $data->{inheritance} ne '') {
scripts/import/import_decipher_snv.pl:            $add_pfa_sth->execute(
scripts/import/import_decipher_snv.pl:              $data->{inheritance},
scripts/import/import_decipher_snv.pl:              $data->{ID},
scripts/import/import_decipher_snv.pl:    $add_failed_sth->execute($variation_id,$data->{failed});
scripts/import/import_decipher_snv.pl:  my $attr_list_sth = $dbh->prepare(qq{ SELECT attrib_id,value FROM attrib WHERE attrib_type_id=$type_id});
scripts/import/import_decipher_snv.pl:  $attr_list_sth->execute;
scripts/import/import_decipher_snv.pl:  while(my @row = $attr_list_sth->fetchrow_array) {
scripts/import/import_decipher_snv.pl:  if ($dbh->selectrow_arrayref(qq{SELECT source_id FROM source WHERE name='$name';})) {
scripts/import/import_decipher_snv.pl:    $dbh->do(qq{UPDATE IGNORE source SET description='$desc',url='$url',version=$version where name='$name';});
scripts/import/import_decipher_snv.pl:    $dbh->do(qq{INSERT INTO source (name,description,url,version) VALUES ('$name','$desc','$url',$version);});
scripts/import/import_decipher_snv.pl:  my @source_id = @{$dbh->selectrow_arrayref(qq{SELECT source_id FROM source WHERE name='$name';})};
scripts/import/import_decipher_snv.pl:  $info->{chr}         = $data[0];
scripts/import/import_decipher_snv.pl:  $info->{start}       = $data[1]+1;
scripts/import/import_decipher_snv.pl:  $info->{end}         = $data[2];
scripts/import/import_decipher_snv.pl:  $info->{subject}     = $data[3];
scripts/import/import_decipher_snv.pl:  $info->{strand}      = ($data[5] eq '+') ? 1 : -1;
scripts/import/import_decipher_snv.pl:  $info->{chr} =~ s/chr//i;
scripts/import/import_decipher_snv.pl:  $info->{chr} = 'MT' if ($info->{chr} eq 'M');
scripts/import/import_decipher_snv.pl:  return if ($json_text->{'variant_type'} ne $short_variant_type);
scripts/import/import_decipher_snv.pl:  $info->{ref}         = $json_text->{ref_allele};
scripts/import/import_decipher_snv.pl:  $info->{alt}         = $json_text->{alt_allele};
scripts/import/import_decipher_snv.pl:  $info->{inheritance} = $json_text->{inheritance};
scripts/import/import_decipher_snv.pl:  $info->{clin_sign}   = lc($json_text->{pathogenicity}) if ($json_text->{pathogenicity});
scripts/import/import_decipher_snv.pl:  foreach my $phe (@{$json_text->{phenotypes}}) {
scripts/import/import_decipher_snv.pl:    my $p_name = $phe->{name};
scripts/import/import_decipher_snv.pl:    $info->{phenotype}{$p_name} = 1;
scripts/import/import_decipher_snv.pl:  $info->{ID}          = "DEC".$info->{subject}."_".$info->{chr}."_".$info->{start}."_".$info->{end};
scripts/import/import_decipher_snv.pl:  $info->{flipped}     = 0;
scripts/import/import_decipher_snv.pl:  my $slice = $sa->fetch_by_region('chromosome', $info->{chr},$info->{start},$info->{end},1);
scripts/import/import_decipher_snv.pl:  my $seq   = $slice->seq;
scripts/import/import_decipher_snv.pl:  my $ref   = $info->{ref};
scripts/import/import_decipher_snv.pl:  my $alt   = $info->{alt};
scripts/import/import_decipher_snv.pl:    if ($info->{strand} == 1) {
scripts/import/import_decipher_snv.pl:      $info->{failed} = 15; # Mapped position is not compatible with reported alleles
scripts/import/import_decipher_snv.pl:      print STDERR "Variant ".$info->{ID}.": Mapped position is not compatible with reported alleles\n";
scripts/import/import_decipher_snv.pl:        $info->{ref} = $ref;
scripts/import/import_decipher_snv.pl:        $info->{alt} = $alt;
scripts/import/import_decipher_snv.pl:        $info->{flipped} = 1;
scripts/import/import_decipher_snv.pl:        $info->{failed} = 2; # None of the variant alleles match the reference allele
scripts/import/import_decipher_snv.pl:        print STDERR "Variant ".$info->{ID}.": None of the variant alleles match the reference allele\n";
scripts/import/import_decipher_snv.pl:  $info->{slice} = $slice;
scripts/import/import_decipher_snv.pl:  if ($info->{start} == $info->{end}) {
scripts/import/import_decipher_snv.pl:    if (length($info->{ref}) == length($info->{alt})) {
scripts/import/import_decipher_snv.pl:      $info->{SO_term} = 'SNV';
scripts/import/import_decipher_snv.pl:      $info->{SO_term} = 'insertion';
scripts/import/import_decipher_snv.pl:      $info->{start} ++;
scripts/import/import_decipher_snv.pl:    $info->{SO_term} = (length($info->{ref}) > length($info->{alt})) ? 'deletion' : 'indel';
scripts/import/dbSNP/GenericContig.pm:Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dbSNP/GenericContig.pm:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dbSNP/GenericContig.pm:     http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dbSNP/GenericContig.pm:#our $FARM_BINARY = "bsub -R 'select[gpfs]'  ";  ##EBI
scripts/import/dbSNP/GenericContig.pm:  ## mouse - 20/29 failed 4G limit - 5 needed 9.5G
scripts/import/dbSNP/GenericContig.pm:  my $dbSNP = $dbm->dbSNP()->dbc();
scripts/import/dbSNP/GenericContig.pm:  my $dbCore = $dbm->dbCore()->dbc();
scripts/import/dbSNP/GenericContig.pm:  my $dbVar = $dbm->dbVar()->dbc();
scripts/import/dbSNP/GenericContig.pm:  my $dbInt = $dbm->dbInt()->dbc();
scripts/import/dbSNP/GenericContig.pm:  my $snp_dbname = $dbSNP->dbname();
scripts/import/dbSNP/GenericContig.pm:  my $species = $dbm->species();
scripts/import/dbSNP/GenericContig.pm:  my $shared_db = $dbm->dbSNP_shared();
scripts/import/dbSNP/GenericContig.pm:  my $registry_file = $dbm->registryfile();
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:  push @subroutines, 'import_hgvs' if  $self->{'dbm'}->dbCore()->species eq 'human';
scripts/import/dbSNP/GenericContig.pm:  push(@{$self->{'skip_routines'}},('create_coredb',
scripts/import/dbSNP/GenericContig.pm:  push(@{$self->{'skip_routines'}},());
scripts/import/dbSNP/GenericContig.pm:  my $clock = Progress->new();
scripts/import/dbSNP/GenericContig.pm:    if (grep($_ eq $subroutine,@{$self->{'skip_routines'}})) {
scripts/import/dbSNP/GenericContig.pm:    $clock->checkpoint($subroutine);
scripts/import/dbSNP/GenericContig.pm:    print $logh $clock->to_string($subroutine);
scripts/import/dbSNP/GenericContig.pm:    $self->$subroutine($resume);
scripts/import/dbSNP/GenericContig.pm:    print $logh $clock->duration();
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:  my $script = $FARM_PARAMS{$param_key}->{'script'};
scripts/import/dbSNP/GenericContig.pm:  my $max_jobs = $FARM_PARAMS{$param_key}->{'max_concurrent_jobs'};
scripts/import/dbSNP/GenericContig.pm:  my $memory = $FARM_PARAMS{$param_key}->{'memory'};
scripts/import/dbSNP/GenericContig.pm:  my $queue = $FARM_QUEUES[$FARM_PARAMS{$param_key}->{'queue'}];
scripts/import/dbSNP/GenericContig.pm:  my $wait_queue = $FARM_QUEUES[$FARM_PARAMS{$param_key}->{'wait_queue'}];
scripts/import/dbSNP/GenericContig.pm:  my $logfile_prefix = $file_prefix . "_" . $jobname . "-";
scripts/import/dbSNP/GenericContig.pm:  #If just the start was defined, it should be a list of subtasks that should be re-run
scripts/import/dbSNP/GenericContig.pm:      $array_options = qq{[$start-$end]%$max_jobs};
scripts/import/dbSNP/GenericContig.pm:  my $tempfile = $task . "_" . $self->{'tmpfile'};
scripts/import/dbSNP/GenericContig.pm:  my $task_command = qq{perl $self->{'scriptdir'}/$script -species $self->{'species'} -dbSNP_shared $self->{'dbSNP_share_db'} -registry_file $self->{'registry_file'} -task $task -file_prefix $file_prefix -task_management_file $task_manager_file -tempdir $self->{'tmpdir'} -tempfile $tempfile  -source_engine $self->{source_engine} -schema_name $self->{schema_name}} . join(" ",@args);
scripts/import/dbSNP/GenericContig.pm:#  my $bsub_cmd = qq{$FARM_BINARY -R'select[mem>$memory\] rusage[mem=$memory\]' -M$memory_long -q $queue -J'$jobname$array_options' -o $logfile_prefix\%J.%I.out -e $logfile_prefix\%J.%I.err bash $script_wrapper};
scripts/import/dbSNP/GenericContig.pm:my $bsub_cmd = qq{$FARM_BINARY -R'select[mem>$memory\] rusage[mem=$memory\]' -M$memory  -J'$jobname$array_options' -o $logfile_prefix\%J.%I.out -e $logfile_prefix\%J.%I.err bash $script_wrapper}; ### EBI
scripts/import/dbSNP/GenericContig.pm:  my ($jobid) = $submission =~ m/^Job \<([0-9]+)\>/i;
scripts/import/dbSNP/GenericContig.pm:  warn "Need to wait for job id $jobid\nSenfin:$FARM_BINARY -J $jobid\_waiting  -w'ended($jobid)' -K -o $file_prefix\_waiting.out sleep 1\n\n";
scripts/import/dbSNP/GenericContig.pm:  system(qq{$FARM_BINARY -R"select[mem>2000] rusage[mem=2000]" -M2000 -J $jobid\_waiting  -w'ended($jobid)' -K -o $file_prefix\_waiting.out sleep 1});  ###EBI
scripts/import/dbSNP/GenericContig.pm:#  system(qq{$FARM_BINARY -R"select[mem>2000] rusage[mem=2000]" -M2000 -J $jobid\_waiting -q $wait_queue -w'ended($jobid)' -K -o $file_prefix\_waiting.out sleep 1});
scripts/import/dbSNP/GenericContig.pm:    if (-z $errfile) {
scripts/import/dbSNP/GenericContig.pm:      $job_details{$index}->{'generated_error'} = 1;
scripts/import/dbSNP/GenericContig.pm:    $job_details{$index}->{'success'} = 0;
scripts/import/dbSNP/GenericContig.pm:      $job_details{$index}->{'success'} = 1;
scripts/import/dbSNP/GenericContig.pm:      $job_details{$index}->{'fail_reason'} = 'OUT_OF_MEMORY';
scripts/import/dbSNP/GenericContig.pm:      $job_details{$index}->{'fail_reason'} = 'OUT_OF_TIME';
scripts/import/dbSNP/GenericContig.pm:      $job_details{$index}->{'fail_reason'} = 'UNKNOWN';
scripts/import/dbSNP/GenericContig.pm:  if ((my $count = grep(!$job_details{$_}->{'success'},keys(%job_details)))) {
scripts/import/dbSNP/GenericContig.pm:    $message = qq{$count subtasks failed. You should re-run them before proceeding!\n};
scripts/import/dbSNP/GenericContig.pm:  if ((my $count = grep($job_details{$_}->{'generated_error'},keys(%job_details)))) {
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:  #This is a preparation step for re-running a farm job. What we do is to re-submit to a longer queue (if one is available) and request more memory
scripts/import/dbSNP/GenericContig.pm:  my $current_queue = $FARM_QUEUES[$FARM_PARAMS{$param_key}->{'queue'}];
scripts/import/dbSNP/GenericContig.pm:    $FARM_PARAMS{$param_key}->{'queue'}++;
scripts/import/dbSNP/GenericContig.pm:  if ($FARM_PARAMS{$param_key}->{'memory'} < $MAX_FARM_MEMORY) {
scripts/import/dbSNP/GenericContig.pm:    $FARM_PARAMS{$param_key}->{'memory'} = min($MAX_FARM_MEMORY,$FARM_MEMORY_INCREMENT + $FARM_PARAMS{$param_key}->{'memory'});
scripts/import/dbSNP/GenericContig.pm:  return $self->run_on_farm($jobname,$file_prefix . "_submission",$iteration,@args);
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:  my $coredb_name = $self->{'dbCore'}->dbname();
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq{CREATE DATABASE $coredb_name});
scripts/import/dbSNP/GenericContig.pm:  my $csid_ref = $self->{'dbCore'}->selectall_arrayref(qq{SELECT coord_system_id from coord_system WHERE name = 'chromosome' and attrib = 'default_version'});
scripts/import/dbSNP/GenericContig.pm:  if ($csid_ref->[0][0]) {
scripts/import/dbSNP/GenericContig.pm:    $csid = $csid_ref->[0][0];
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq{create table coord_system(coord_system_id int(10) unsigned,species_id int(10) unsigned default 1)});
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq{insert into coord_system(coord_system_id) values($csid)});
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq{RENAME TABLE coord_system TO $coredb_name.coord_system});
scripts/import/dbSNP/GenericContig.pm:    my $dbSNP_db_name = $self->{'snp_dbname'};
scripts/import/dbSNP/GenericContig.pm:    $dbSNP_db_name =~ s/dbSNP\_//; ## remove extra pre-fix on mysql dbs
scripts/import/dbSNP/GenericContig.pm:    my ($species,$tax_id,$version) = $dbSNP_db_name  =~ m/^(.+)?\_([0-9]+)\_([0-9]+)$/;
scripts/import/dbSNP/GenericContig.pm:    $version =  $self->{'dbSNP_version'} unless defined $version;
scripts/import/dbSNP/GenericContig.pm:        $self->{'dbVar'}->do(qq{INSERT IGNORE INTO source (source_id,name,version,description,url,somatic_status, data_types) VALUES (2, "$source_name",$version,"Former variants names imported from dbSNP", "$url", "mixed","variation_synonym")});
scripts/import/dbSNP/GenericContig.pm:        $self->{'dbVar'}->do(qq{INSERT INTO source (source_id,name,version,description,url,somatic_status, data_types) VALUES (1,"$dbname",$version,"Variants (including SNPs and indels) imported from dbSNP", "$url", "mixed","variation")});
scripts/import/dbSNP/GenericContig.pm:    my $source_id = $self->{'dbVar'}->db_handle->last_insert_id(undef, undef, qw(source source_id))|| die "no insert id for source\n";
scripts/import/dbSNP/GenericContig.pm:    if($self->{source_engine} =~/mssql|sqlserver/ ){
scripts/import/dbSNP/GenericContig.pm:    elsif($self->{source_engine} =~/pg|postgreSQL/i ){
scripts/import/dbSNP/GenericContig.pm:    my ($obj_id) = $self->{'dbSNP'}->db_handle->selectrow_array($sql);
scripts/import/dbSNP/GenericContig.pm:        my ($count) = $self->{'dbSNP'}->db_handle->selectrow_array(qq{SELECT COUNT(*) FROM $table});
scripts/import/dbSNP/GenericContig.pm:    return unless $self->table_exists_and_populated('SNPAlleleFreq_TGP');
scripts/import/dbSNP/GenericContig.pm:    my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:    my $shared = $self->{'dbSNP_share_db'};
scripts/import/dbSNP/GenericContig.pm:    dumpSQL($self->{'dbSNP'}, $stmt, $self->{source_engine});
scripts/import/dbSNP/GenericContig.pm:    create_and_load($self->{'dbVar'}, "maf", "snp_id i* not_null", "allele l", "freq f", "count i", "is_minor_allele i");
scripts/import/dbSNP/GenericContig.pm:    # we don't delete the maf temporary table because we need it for post-processing MAFs = 0.5
scripts/import/dbSNP/GenericContig.pm:    return unless $self->table_exists_and_populated('SNPSuspect');
scripts/import/dbSNP/GenericContig.pm:    my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do($var_table_sql);
scripts/import/dbSNP/GenericContig.pm:    dumpSQL($self->{'dbSNP'}, $stmt, $self->{source_engine});
scripts/import/dbSNP/GenericContig.pm:    load($self->{'dbVar'}, "suspect", "snp_id", "reason_code");
scripts/import/dbSNP/GenericContig.pm:    my $fail_rs_ins_sth = $self->{'dbVar'}->prepare($stmt);
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/GenericContig.pm:    my $fail_old_rs_ins_sth = $self->{'dbVar'}->prepare($stmt);
scripts/import/dbSNP/GenericContig.pm:    $fail_rs_ins_sth->execute()||die;
scripts/import/dbSNP/GenericContig.pm:    $fail_old_rs_ins_sth->execute()||die;
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do(qq{DROP TABLE suspect});
scripts/import/dbSNP/GenericContig.pm:- not enough information provided for later QC or annotation
scripts/import/dbSNP/GenericContig.pm:    my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:                             from SNP, $self->{'dbSNP_share_db'}.UniVariation uv, $self->{'dbSNP_share_db'}.SnpClassCode scc
scripts/import/dbSNP/GenericContig.pm:    my $named_ext_sth = $self->{'dbSNP'}->prepare($named_ext_stmt);
scripts/import/dbSNP/GenericContig.pm:    $named_ext_sth->execute();
scripts/import/dbSNP/GenericContig.pm:    my $named_rs_ids = $named_ext_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericContig.pm:    return unless defined $named_rs_ids->[0]->[0]; 
scripts/import/dbSNP/GenericContig.pm:    my $attrib_ext_sth = $self->{'dbVar'}->prepare($attrib_ext_stmt);
scripts/import/dbSNP/GenericContig.pm:    $attrib_ext_sth->execute() || die;
scripts/import/dbSNP/GenericContig.pm:    my $attrib_id = $attrib_ext_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericContig.pm:    die "attribs to be loaded\n\n" unless defined $attrib_id->[0]->[0]; 
scripts/import/dbSNP/GenericContig.pm:    my $var_upd_sth = $self->{'dbVar'}->prepare($var_upd_stmt);
scripts/import/dbSNP/GenericContig.pm:       $var_upd_sth->execute( $attrib_id->[0]->[0], $rs_id->[0]) || die;
scripts/import/dbSNP/GenericContig.pm:    return unless $self->table_exists_and_populated('SNPPubmed');
scripts/import/dbSNP/GenericContig.pm:    my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do(qq[ create table tmp_pubmed (
scripts/import/dbSNP/GenericContig.pm:    my $pubmed_ins_sth = $self->{'dbVar'}->prepare(qq[ insert into tmp_pubmed (snp_id, pubmed_id) values (?,?)]);
scripts/import/dbSNP/GenericContig.pm:    my $sth = $self->{'dbSNP'}->prepare(qq[ SELECT snp_id, pubmed_id from SNPPubmed where pubmed_id is not null ]);
scripts/import/dbSNP/GenericContig.pm:    $sth->execute();
scripts/import/dbSNP/GenericContig.pm:    while (my $l = $sth->fetchrow_arrayref()){
scripts/import/dbSNP/GenericContig.pm:       $pubmed_ins_sth->execute($l->[0], $l->[1]) ||die "Failed to enter pubmed_id for rs: $l->[0], PMID:$l->[1] \n";
scripts/import/dbSNP/GenericContig.pm:    my $pubmed_ext_sth = $self->{'dbVar'}->prepare(qq [ select variation.variation_id, tmp_pubmed.pubmed_id
scripts/import/dbSNP/GenericContig.pm:    my $publication_ext_sth    = $self->{'dbVar'}->prepare(qq[select publication_id from publication where pmid = ?]);
scripts/import/dbSNP/GenericContig.pm:    my $publication_ins_sth    = $self->{'dbVar'}->prepare(qq[insert into publication (pmid ) values (?)]);
scripts/import/dbSNP/GenericContig.pm:    my $citation_ins_sth = $self->{'dbVar'}->prepare(qq[insert into variation_citation ( variation_id, publication_id ) values (?,?)]);
scripts/import/dbSNP/GenericContig.pm:    $pubmed_ext_sth->execute()||die "Failed to extract pubmed data from tmp table\n";;
scripts/import/dbSNP/GenericContig.pm:    my $data2 = $pubmed_ext_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericContig.pm:	next if $done{$l->[0]}{$l->[1]};
scripts/import/dbSNP/GenericContig.pm:	$done{$l->[0]}{$l->[1]} = 1;
scripts/import/dbSNP/GenericContig.pm:	$publication_ext_sth->execute( $l->[1] )||die;
scripts/import/dbSNP/GenericContig.pm:	my $publication_id = $publication_ext_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericContig.pm:	unless ( defined $publication_id->[0]->[0]){
scripts/import/dbSNP/GenericContig.pm:	    $publication_ins_sth->execute( $l->[1]);
scripts/import/dbSNP/GenericContig.pm:	    $publication_ext_sth->execute( $l->[1] )||die;
scripts/import/dbSNP/GenericContig.pm:	    $publication_id = $publication_ext_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericContig.pm:	warn "problem adding new publication $l->[1]\n" unless defined $publication_id->[0]->[0];
scripts/import/dbSNP/GenericContig.pm:	$citation_ins_sth->execute($l->[0], $publication_id->[0]->[0])||die;
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do(qq [ drop table tmp_pubmed ]);
scripts/import/dbSNP/GenericContig.pm:# creating of a link table variation_id --> subsnp_id
scripts/import/dbSNP/GenericContig.pm:  my $resume_at_subsnp_id = -1;
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:     if ($self->{'limit'}) {
scripts/import/dbSNP/GenericContig.pm:       $stmt .= "TOP $self->{'limit'} ";
scripts/import/dbSNP/GenericContig.pm:    if( $self->{source_engine} =~/mssql/ ){
scripts/import/dbSNP/GenericContig.pm:    elsif( $self->{source_engine} =~/postgreSQL/i ){
scripts/import/dbSNP/GenericContig.pm:    if ($self->{'limit'}) {
scripts/import/dbSNP/GenericContig.pm:    dumpSQL($self->{'dbSNP'},$stmt, $self->{source_engine}) unless ($resume_at_subsnp_id > 0);
scripts/import/dbSNP/GenericContig.pm:      $self->{'dbVar'}->do( qq[ALTER TABLE variation add column snp_id int NOT NULL] ) ;
scripts/import/dbSNP/GenericContig.pm:      $self->{'dbVar'}->do( qq[ALTER TABLE variation disable keys]);  
scripts/import/dbSNP/GenericContig.pm:    load( $self->{'dbVar'}, "variation", "source_id", "name", "snp_id" ) unless ($resume_at_subsnp_id > 0);
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do( "ALTER TABLE variation ADD INDEX snpidx( snp_id )" ) unless ($resume_at_subsnp_id > 0);
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do( qq[ALTER TABLE variation enable keys] );
scripts/import/dbSNP/GenericContig.pm:    dumpSQL($self->{'dbSNP'},$stmt, $self->{source_engine});
scripts/import/dbSNP/GenericContig.pm:    load( $self->{'dbVar'}, "subsnp_handle", "subsnp_id", "handle");
scripts/import/dbSNP/GenericContig.pm:    return unless  $self->{'dbm'}->dbCore()->species =~ /homo/i ;
scripts/import/dbSNP/GenericContig.pm:	my $sth = $self->{'dbSNP'}->prepare($stmt);
scripts/import/dbSNP/GenericContig.pm:        $sth->execute();
scripts/import/dbSNP/GenericContig.pm:    $sth->bind_columns(\$snp_id);
scripts/import/dbSNP/GenericContig.pm:    my $up_sth = $self->{'dbVar'}->prepare($stmt);
scripts/import/dbSNP/GenericContig.pm:    while ($sth->fetch()) {
scripts/import/dbSNP/GenericContig.pm:    	$up_sth->execute($snp_id);
scripts/import/dbSNP/GenericContig.pm:    $sth->finish();
scripts/import/dbSNP/GenericContig.pm:    $up_sth->finish();
scripts/import/dbSNP/GenericContig.pm:    ## This is no longer run - ClinVar export has more information
scripts/import/dbSNP/GenericContig.pm:    #$self->clin_sig;
scripts/import/dbSNP/GenericContig.pm:    if($self->{'dbm'}->dbCore()->species =~ /homo/i){
scripts/import/dbSNP/GenericContig.pm:      $self->minor_allele_freq;
scripts/import/dbSNP/GenericContig.pm:      $self->suspect_snps;   
scripts/import/dbSNP/GenericContig.pm:    $self->named_variants;
scripts/import/dbSNP/GenericContig.pm:    my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:   if ($self->{'limit'}) {
scripts/import/dbSNP/GenericContig.pm:     $stmt .= "TOP $self->{'limit'} ";
scripts/import/dbSNP/GenericContig.pm:    if ($self->{'limit'}) {
scripts/import/dbSNP/GenericContig.pm:   dumpSQL($self->{'dbSNP'},$stmt,  $self->{source_engine} ) ; 
scripts/import/dbSNP/GenericContig.pm:   create_and_load( $self->{'dbVar'}, "tmp_var_allele", "subsnp_id i*  not_null unsigned", "refsnp_id v* not_null", "substrand_reversed_flag i", "submitter_handle v* not_null");
scripts/import/dbSNP/GenericContig.pm:  my ($min_id,$max_id) = @{$self->{'dbVar'}->db_handle()->selectall_arrayref($stmt)->[0]};
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do("ALTER TABLE variation_synonym disable keys ");
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq{ALTER TABLE variation_synonym add column substrand_reversed_flag tinyint});
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq{ALTER TABLE variation_synonym add column submitter_handle varchar(25)});
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do( qq{ insert into variation_synonym (variation_id, subsnp_id, source_id, name, substrand_reversed_flag, submitter_handle)
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do("ALTER TABLE variation_synonym enable keys");
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do(qq[ CREATE TABLE subsnp_map
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do( qq[ insert into subsnp_map (variation_id, subsnp_id)  select variation_id, subsnp_id from variation_synonym]);
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do(qq[ CREATE INDEX variation_idx on subsnp_map (variation_id) ]);
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do("ALTER TABLE population ADD column pop_id int");   
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do("ALTER TABLE population ADD column pop_class_id int");   ## hold id of super pop in super pop
scripts/import/dbSNP/GenericContig.pm:  #    - these are super_populations  like 'MULTI-NATIONAL' and 'NORTH/EAST AFRICA & MIDDLE EAST'
scripts/import/dbSNP/GenericContig.pm:    if($self->{source_engine} =~/postgreSQL/i){
scripts/import/dbSNP/GenericContig.pm:		  $self->{'dbSNP_share_db'}.PopClassCode
scripts/import/dbSNP/GenericContig.pm:		  $self->{'dbSNP_share_db'}.PopClassCode
scripts/import/dbSNP/GenericContig.pm:  dumpSQL($self->{'dbSNP'}, $stmt, $self->{source_engine} );
scripts/import/dbSNP/GenericContig.pm:  load($self->{'dbVar'}, 'population', 'name', 'pop_class_id', 'description');
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq{ALTER TABLE population ADD INDEX pop_class_id (pop_class_id)}); 
scripts/import/dbSNP/GenericContig.pm:    if($self->{source_engine} =~/mssql/){
scripts/import/dbSNP/GenericContig.pm:    elsif($self->{source_engine} =~/postgreSQL/i){
scripts/import/dbSNP/GenericContig.pm:	      $self->{'dbSNP_share_db'}.PopClass pc ON p.pop_id = pc.pop_id LEFT JOIN 
scripts/import/dbSNP/GenericContig.pm:    dumpSQL($self->{'dbSNP'}, $stmt,  $self->{source_engine} );
scripts/import/dbSNP/GenericContig.pm:    create_and_load( $self->{'dbVar'}, "tmp_pop", "name", "pop_id i*", "pop_class_id i*", "description l", "line_num i*" );
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do("SET SESSION group_concat_max_len = 10000");
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do(qq{INSERT INTO population (name, pop_id,description)
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do(qq{ALTER TABLE population ADD INDEX pop_id (pop_id)});
scripts/import/dbSNP/GenericContig.pm:     $self->{'dbVar'}->do(qq{INSERT INTO population_structure (super_population_id,sub_population_id)
scripts/import/dbSNP/GenericContig.pm:     $self->{'dbVar'}->do(qq{INSERT INTO population_synonym (population_id,source_id,name)
scripts/import/dbSNP/GenericContig.pm:     $self->{'dbVar'}->do("DROP TABLE tmp_pop");
scripts/import/dbSNP/GenericContig.pm:# pre-e!70 samples were merged on dbSNP ind_id and a submitted name chosen at random
scripts/import/dbSNP/GenericContig.pm:# post-e!70 samples are only merged if they have the same name and ind_id
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:  if ($self->{'dbm'}->dbCore()->species =~ /homo|pan|anoph/i) {
scripts/import/dbSNP/GenericContig.pm:  elsif ($self->{'dbm'}->dbCore()->species =~ /mus/i) {
scripts/import/dbSNP/GenericContig.pm:   $self->{'dbVar'}->do(qq{
scripts/import/dbSNP/GenericContig.pm:    ## get pedigree info - held at dbSNP clustered Individual level 
scripts/import/dbSNP/GenericContig.pm:    my $ped = $self->get_ped_data();
scripts/import/dbSNP/GenericContig.pm:    my ($individuals, $samples) = $self->get_ind_data();
scripts/import/dbSNP/GenericContig.pm:    ## get population ids for pre-loaded populations
scripts/import/dbSNP/GenericContig.pm:    my $pop_ids = $self->get_pop_ids();
scripts/import/dbSNP/GenericContig.pm:    my $ind_ins_sth = $self->{'dbVar'}->prepare(qq[ INSERT INTO individual ( name, description, individual_type_id) values (?,?,?)]);
scripts/import/dbSNP/GenericContig.pm:    my $tmp_ins_sth = $self->{'dbVar'}->prepare(qq[ INSERT INTO tmp_ind (sample_id, submitted_ind_id) values (?,?)]);
scripts/import/dbSNP/GenericContig.pm:    my $pop_ins_sth = $self->{'dbVar'}->prepare(qq[ INSERT INTO sample_population (sample_id, population_id) values (?,?)  ]);
scripts/import/dbSNP/GenericContig.pm:    my $syn_ins_sth = $self->{'dbVar'}->prepare(qq[ INSERT INTO individual_synonym (individual_id,source_id,name)  values (?,?,?)  ]);
scripts/import/dbSNP/GenericContig.pm:    my $sam_ins_sth = $self->{'dbVar'}->prepare(qq[ INSERT INTO sample ( individual_id, name, description) values (?,?,?)]);
scripts/import/dbSNP/GenericContig.pm:    my $ind_gen_upd_sth = $self->{'dbVar'}->prepare(qq[ update individual set gender =? where individual_id = ? ]);
scripts/import/dbSNP/GenericContig.pm:    my $ind_par_upd_sth = $self->{'dbVar'}->prepare(qq[ update individual set father_individual_id =?, mother_individual_id =?  where individual_id = ? ]);
scripts/import/dbSNP/GenericContig.pm:        ## insert individual if novel - using first sample name seen as name
scripts/import/dbSNP/GenericContig.pm:        unless (defined $individual_id{ $samples->{$sam_id}->{ind}} ){
scripts/import/dbSNP/GenericContig.pm:            $ind_ins_sth->execute(  $samples->{$sam_id}->{name}  , $individuals->{ $samples->{$sam_id}->{ind} }->{des}, $individual_type_id );
scripts/import/dbSNP/GenericContig.pm:            $individual_id{ $samples->{$sam_id}->{ind} } =  $self->{'dbVar'}->db_handle->last_insert_id(undef, undef, 'individual', 'individual_id');
scripts/import/dbSNP/GenericContig.pm:            $syn_ins_sth->execute( $individual_id{ $samples->{$sam_id}->{ind} }, 1, $samples->{$sam_id}->{ind} );
scripts/import/dbSNP/GenericContig.pm:        $sam_ins_sth->execute( $individual_id{ $samples->{$sam_id}->{ind} }, $samples->{$sam_id}->{name}, $individuals->{ $samples->{$sam_id}->{ind} }->{des});
scripts/import/dbSNP/GenericContig.pm:        my $ens_sample_id =  $self->{'dbVar'}->db_handle->last_insert_id(undef, undef, 'sample', 'sample_id');
scripts/import/dbSNP/GenericContig.pm:        $tmp_ins_sth->execute($ens_sample_id, $sam_id);
scripts/import/dbSNP/GenericContig.pm:        $pop_ins_sth->execute( $ens_sample_id , $pop_ids->{ $samples->{$sam_id}{pid} } )
scripts/import/dbSNP/GenericContig.pm:            if defined $samples->{$sam_id}{pid};
scripts/import/dbSNP/GenericContig.pm:        $ind_gen_upd_sth->execute( $ped->{$ind}{gender}, $individual_id{$ind})
scripts/import/dbSNP/GenericContig.pm:          if defined $ped->{$ind}{gender} && $ped->{$ind}{gender} =~/ale/;;
scripts/import/dbSNP/GenericContig.pm:	if(defined $ped->{$ind}{father} ){
scripts/import/dbSNP/GenericContig.pm:	    if(defined $individual_id{ $ped->{$ind}{father}}){
scripts/import/dbSNP/GenericContig.pm:		$father_id = $individual_id{ $ped->{$ind}{father} };
scripts/import/dbSNP/GenericContig.pm:		warn "No ensembl id found for father : $ped->{$ind}{father} from child id $ind\n";
scripts/import/dbSNP/GenericContig.pm:	if(defined $ped->{$ind}{mother} ){
scripts/import/dbSNP/GenericContig.pm:	    if(defined $individual_id{ $ped->{$ind}{mother} }){
scripts/import/dbSNP/GenericContig.pm:		$mother_id = $individual_id{ $ped->{$ind}{mother} };
scripts/import/dbSNP/GenericContig.pm:		warn "No ensembl id found for mother : $ped->{$ind}{mother} from child id $ind\n";
scripts/import/dbSNP/GenericContig.pm:        $ind_par_upd_sth->execute( $father_id,
scripts/import/dbSNP/GenericContig.pm:    $self->update_population_size();
scripts/import/dbSNP/GenericContig.pm:    my $all_ped_sth = $self->{'dbSNP'}->prepare(qq[ SELECT ind_id, 
scripts/import/dbSNP/GenericContig.pm:    $all_ped_sth->execute()||die "ERROR executing: $DBI::errstr\n";
scripts/import/dbSNP/GenericContig.pm:    my $ped = $all_ped_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericContig.pm:	if(defined $l->[3]){
scripts/import/dbSNP/GenericContig.pm:	    $l->[3] =~ s/M/Male/;	   
scripts/import/dbSNP/GenericContig.pm:	    $l->[3] =~ s/F/Female/;
scripts/import/dbSNP/GenericContig.pm:	$ped{$l->[0]}{father} = $l->[1];
scripts/import/dbSNP/GenericContig.pm:	$ped{$l->[0]}{mother} = $l->[2];
scripts/import/dbSNP/GenericContig.pm:	$ped{$l->[0]}{gender} = $l->[3];
scripts/import/dbSNP/GenericContig.pm:   my $all_ind_sth = $self->{'dbSNP'}->prepare(qq[ SELECT si.submitted_ind_id,
scripts/import/dbSNP/GenericContig.pm:   $all_ind_sth->execute()||die "ERROR executing: $DBI::errstr\n";
scripts/import/dbSNP/GenericContig.pm:   my $inds = $all_ind_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericContig.pm:       $individuals{$l->[3]}{des}  = $l->[2]
scripts/import/dbSNP/GenericContig.pm:         if defined $l->[2] && $l->[2] !~ /^unknown|byPopDesc/i ;
scripts/import/dbSNP/GenericContig.pm:       $samples{$l->[0]}{name} = $l->[1];
scripts/import/dbSNP/GenericContig.pm:       $samples{$l->[0]}{ind}  = $l->[3] if defined $l->[3];
scripts/import/dbSNP/GenericContig.pm:       $samples{$l->[0]}{pid}  = $l->[4] if defined $l->[4];
scripts/import/dbSNP/GenericContig.pm:    my $pop_ext_sth =   $self->{'dbVar'}->prepare(qq[ select population_id, pop_id from population where pop_id is not null ]);
scripts/import/dbSNP/GenericContig.pm:    $pop_ext_sth->execute();
scripts/import/dbSNP/GenericContig.pm:    my $pop_link = $pop_ext_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericContig.pm:	$pop_id{$l->[1]} = $l->[0];
scripts/import/dbSNP/GenericContig.pm:    my $size_ext_sth = $self->{'dbVar'}->prepare(qq[ select population.population_id, count(*) 
scripts/import/dbSNP/GenericContig.pm:    my $size_upd_sth = $self->{'dbVar'}->prepare(qq[ update population
scripts/import/dbSNP/GenericContig.pm:    $size_ext_sth->execute()||die "Failed to extact individual counts for populations\n";
scripts/import/dbSNP/GenericContig.pm:    my $sizes =  $size_ext_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericContig.pm:	$size_upd_sth->execute( $l->[1], $l->[0])||die "Failed to update individual counts for populations\n";
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm: update_allele_schema($self->{'dbVar'});  
scripts/import/dbSNP/GenericContig.pm:  my $file_prefix = $self->{'tmpdir'} . '/allele_table';
scripts/import/dbSNP/GenericContig.pm:##=head hashed out to re-run failed job
scripts/import/dbSNP/GenericContig.pm:    #First, get the population_id -> sample_id mapping and write it to the file. The subroutine can also get it but it's faster to get all at once since we expect many to be used. 
scripts/import/dbSNP/GenericContig.pm:    my $sth = $self->{'dbVar'}->prepare($stmt);
scripts/import/dbSNP/GenericContig.pm:    $sth->execute();
scripts/import/dbSNP/GenericContig.pm:    while (my @row = $sth->fetchrow_array()) {
scripts/import/dbSNP/GenericContig.pm:    #hash out task file creation if re-running 1 failed job
scripts/import/dbSNP/GenericContig.pm:    if($self->{source_engine} =~/postgreSQL/ ){
scripts/import/dbSNP/GenericContig.pm:        $jobindex =write_allele_task_file_pg($self->{'dbSNP'}->db_handle(),$task_manager_file, $loadfile,  $allelefile, $samplefile,$self->{limit});
scripts/import/dbSNP/GenericContig.pm:        $jobindex = write_allele_task_file($self->{'dbSNP'}->db_handle(),$task_manager_file, $loadfile,  $allelefile, $samplefile,$self->{limit});
scripts/import/dbSNP/GenericContig.pm:    debug(localtime() . "\tAt allele table - written export task file");
scripts/import/dbSNP/GenericContig.pm:    $result = $self->run_on_farm($jobname,$file_prefix,'allele_table',$task_manager_file,$start,$jobindex); 
scripts/import/dbSNP/GenericContig.pm:    $jobid = $result->{'jobid'};
scripts/import/dbSNP/GenericContig.pm:    debug(localtime() . "\tAt allele table - export jobs run on farm");
scripts/import/dbSNP/GenericContig.pm:    if ((my @error_subtasks = grep($result->{'subtask_details'}{$_}{'generated_error'},keys(%{$result->{'subtask_details'}})))) {
scripts/import/dbSNP/GenericContig.pm:      warn($result->{'message'});
scripts/import/dbSNP/GenericContig.pm:      print $logh Progress::location() . "\t " . $result->{'message'};
scripts/import/dbSNP/GenericContig.pm:    if (!$result->{'success'}) {
scripts/import/dbSNP/GenericContig.pm:      warn($result->{'message'});
scripts/import/dbSNP/GenericContig.pm:      print $logh Progress::location() . "\t " . $result->{'message'};
scripts/import/dbSNP/GenericContig.pm:      foreach my $index (grep($result->{'subtask_details'}{$_}{'fail_reason'} =~ m/UNKNOWN/,keys(%{$result->{'subtask_details'}}))) {
scripts/import/dbSNP/GenericContig.pm:      foreach my $index (grep($result->{'subtask_details'}{$_}{'fail_reason'} =~ m/OUT_OF_[MEMORY|TIME]/,keys(%{$result->{'subtask_details'}}))) {
scripts/import/dbSNP/GenericContig.pm:    die("Some subtasks are failing (see log output). This needs to be resolved before proceeding with the loading of alleles!") unless ($result->{'success'});
scripts/import/dbSNP/GenericContig.pm:  die "Exiting: Number of allele files to merge not known - is load_only set?\n" unless defined $jobindex;
scripts/import/dbSNP/GenericContig.pm:  my $new_load_file_name =  $self->{'tmpdir'} . "/allele_load_file_new.txt";
scripts/import/dbSNP/GenericContig.pm:      my $cat_file = $self->{'tmpdir'} ."/allele_table_loadfile.txt_$n";
scripts/import/dbSNP/GenericContig.pm:  ### start loading process - run as single job
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do( qq[ LOAD DATA LOCAL INFILE "$new_load_file_name" INTO TABLE allele( variation_id,subsnp_id,population_id,allele,frequency,count,frequency_submitter_handle )]) || die "Erro loading allele data: $self->{'dbVar'}::errstr \n";
scripts/import/dbSNP/GenericContig.pm:  debug(localtime() . "\tAt allele table - data load complete");
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do( qq[ alter table allele enable keys]);
scripts/import/dbSNP/GenericContig.pm:  debug(localtime() . "\tAt allele table - indexing complete");
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:  debug(localtime() . "\tAt allele_string table - starting");
scripts/import/dbSNP/GenericContig.pm:      $self->{'dbSNP_share_db'}.UniVariation uv ON (
scripts/import/dbSNP/GenericContig.pm:  dumpSQL($self->{'dbSNP'},$stmt, $self->{source_engine} );
scripts/import/dbSNP/GenericContig.pm:  create_and_load($self->{'dbVar'},"tmp_allele_string","snp_name * not_null","allele");
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/GenericContig.pm:  $dbVar_dbh->do( qq[ drop table allele ] ); 
scripts/import/dbSNP/GenericContig.pm:  $dbVar_dbh->do( qq [ CREATE TABLE allele (
scripts/import/dbSNP/GenericContig.pm:  $dbVar_dbh->do( qq[ alter table allele disable keys]);
scripts/import/dbSNP/GenericContig.pm:    my $ss_extract_sth = $dbh->prepare($stmt);
scripts/import/dbSNP/GenericContig.pm:    $ss_extract_sth->execute() ||die "Error extracting ss ids for allele_table binning\n";
scripts/import/dbSNP/GenericContig.pm:    $ss_extract_sth->bind_columns(\$ssid);
scripts/import/dbSNP/GenericContig.pm:    while( $ss_extract_sth->fetchrow_arrayref()){
scripts/import/dbSNP/GenericContig.pm:    debug(localtime() . "\tAt write_allele_task_file - starting");
scripts/import/dbSNP/GenericContig.pm:    $dbh->begin_work();
scripts/import/dbSNP/GenericContig.pm:    $dbh->do("DECLARE csr CURSOR  FOR $stmt");
scripts/import/dbSNP/GenericContig.pm:        my $sth = $dbh->prepare($stmt);
scripts/import/dbSNP/GenericContig.pm:            $sth->execute;
scripts/import/dbSNP/GenericContig.pm:        last if 0 == $sth->rows;
scripts/import/dbSNP/GenericContig.pm:        debug(localtime() . "\tAt write_allele_task_file - executed");
scripts/import/dbSNP/GenericContig.pm:        while( $ssid = $sth->fetchrow_arrayref()){
scripts/import/dbSNP/GenericContig.pm:                $first = $ssid->[0];
scripts/import/dbSNP/GenericContig.pm:                $first       = $ssid->[0];
scripts/import/dbSNP/GenericContig.pm:                $previous = $ssid->[0];
scripts/import/dbSNP/GenericContig.pm:    $dbh->do("CLOSE csr");
scripts/import/dbSNP/GenericContig.pm:    $dbh->rollback();
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq{CREATE TABLE tmp_seq (variation_id int NOT NULL,
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq{ create table if not exists flanking_sequence (
scripts/import/dbSNP/GenericContig.pm:  if($self->{'dbm'}->dbCore()->species =~ /human|homo/i) {
scripts/import/dbSNP/GenericContig.pm:		if ($self->{'limit'}) {
scripts/import/dbSNP/GenericContig.pm:		  $stmt .= "TOP $self->{'limit'} ";
scripts/import/dbSNP/GenericContig.pm:		if ($self->{'limit'}) {
scripts/import/dbSNP/GenericContig.pm:		dumpSQL($self->{'dbSNP'}, $stmt,  $self->{source_engine} );
scripts/import/dbSNP/GenericContig.pm:		$self->{'dbVar'}->do(qq{CREATE TABLE tmp_seq_$type\_$partition (
scripts/import/dbSNP/GenericContig.pm:               load($self->{'dbVar'}, "tmp_seq_$type\_$partition", "subsnp_id", "seq_type", "line_num", "line");
scripts/import/dbSNP/GenericContig.pm:               $self->{'dbVar'}->do("CREATE INDEX subsnp_id_idx on tmp_seq_$type\_$partition (subsnp_id)");  
scripts/import/dbSNP/GenericContig.pm:		$self->{'dbVar'}->do(qq{INSERT INTO tmp_seq (variation_id, subsnp_id, seq_type, line_num, type, line, revcom)
scripts/import/dbSNP/GenericContig.pm:		$self->{'dbVar'}->do(qq{DROP TABLE tmp_seq_$type\_$partition});
scripts/import/dbSNP/GenericContig.pm:      if ($self->{'limit'}) {
scripts/import/dbSNP/GenericContig.pm:	$stmt .= "TOP $self->{'limit'} ";
scripts/import/dbSNP/GenericContig.pm:       if ($self->{'limit'}) {
scripts/import/dbSNP/GenericContig.pm:      dumpSQL($self->{'dbSNP'},$stmt,  $self->{source_engine} );
scripts/import/dbSNP/GenericContig.pm:      $self->{'dbVar'}->do(qq{CREATE TABLE tmp_seq_$type (
scripts/import/dbSNP/GenericContig.pm:      load($self->{'dbVar'}, "tmp_seq_$type", "subsnp_id", "seq_type", "line_num", "line", "revcom");
scripts/import/dbSNP/GenericContig.pm:      $self->{'dbVar'}->do(qq{INSERT INTO tmp_seq (variation_id, subsnp_id, seq_type,
scripts/import/dbSNP/GenericContig.pm:      $self->{'dbVar'}->do(qq{DROP TABLE tmp_seq_$type});
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do("ALTER TABLE tmp_seq ADD INDEX idx (subsnp_id, type, seq_type, line_num)");
scripts/import/dbSNP/GenericContig.pm:  my $sth = $self->{'dbVar'}->prepare(qq{SELECT ts.variation_id, ts.subsnp_id, ts.type,
scripts/import/dbSNP/GenericContig.pm:  $sth->execute();
scripts/import/dbSNP/GenericContig.pm:  $sth->bind_columns(\$vid, \$ssid, \$type, \$line, \$revcom);
scripts/import/dbSNP/GenericContig.pm:  open(FH, ">" . $self->{'tmpdir'} . "/" . $self->{'tmpfile'});
scripts/import/dbSNP/GenericContig.pm:  while($sth->fetch()) {
scripts/import/dbSNP/GenericContig.pm:  $sth->finish();
scripts/import/dbSNP/GenericContig.pm:  #$self->{'dbVar'}->do("DROP TABLE tmp_seq");
scripts/import/dbSNP/GenericContig.pm:  load($self->{'dbVar'},"flanking_sequence","variation_id","up_seq","down_seq");
scripts/import/dbSNP/GenericContig.pm:  unlink($self->{'tmpdir'} . "/" . $self->{'tmpfile'});
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do("alter table variation_feature modify column map_weight int default null");
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:  dumpSQL($self->{'dbCore'}->db_handle, qq{SELECT sr.seq_region_id, sr.name, sr.coord_system_id
scripts/import/dbSNP/GenericContig.pm:  load($self->{'dbVar'}, "seq_region", "seq_region_id", "name");
scripts/import/dbSNP/GenericContig.pm:  my $version = substr($self->{'dbSNP_version'} ,1);
scripts/import/dbSNP/GenericContig.pm:  if(  $version < 137){ ## table rename for dbSNP - keeping this temporarily for backwards comparibility
scripts/import/dbSNP/GenericContig.pm:## 201206 - dbSNP no longer using assembly version in table names
scripts/import/dbSNP/GenericContig.pm:## - leaving this temporarily for backwards compatibility
scripts/import/dbSNP/GenericContig.pm: # my ($assembly_version) =  $self->{'assembly_version'} =~ /^[a-zA-Z]+(\d+)\.*.*$/;
scripts/import/dbSNP/GenericContig.pm: # $assembly_version = 1 if $self->{'dbm'}->dbCore()->species =~ /ornith/i;
scripts/import/dbSNP/GenericContig.pm:  #$assembly_version = 3 if $self->{'dbm'}->dbCore()->species =~ /rerio/i;
scripts/import/dbSNP/GenericContig.pm:                  $self->{'snp_dbname'}..sysobjects 
scripts/import/dbSNP/GenericContig.pm:                  name LIKE '$self->{'dbSNP_version'}\_SNPContigLoc\__'
scripts/import/dbSNP/GenericContig.pm:        my $sth = $self->{'dbSNP'}->prepare($stmt);
scripts/import/dbSNP/GenericContig.pm:        $sth->execute();
scripts/import/dbSNP/GenericContig.pm:        while($row = $sth->fetchrow_arrayref()) {
scripts/import/dbSNP/GenericContig.pm:            next if $row->[0] =~/Locus/;
scripts/import/dbSNP/GenericContig.pm:            $tablename1 = $row->[0];
scripts/import/dbSNP/GenericContig.pm:               $self->{'snp_dbname'}..sysobjects 
scripts/import/dbSNP/GenericContig.pm:               name LIKE '$self->{'dbSNP_version'}\_ContigInfo%'
scripts/import/dbSNP/GenericContig.pm:	my $sth1 = $self->{'dbSNP'}->prepare($stmt);
scripts/import/dbSNP/GenericContig.pm:	$sth1->execute();
scripts/import/dbSNP/GenericContig.pm:	while($row = $sth1->fetchrow_arrayref()) {
scripts/import/dbSNP/GenericContig.pm:	    $tablename2 = $row->[0];
scripts/import/dbSNP/GenericContig.pm:      $tablename1 = $self->{'dbSNP_version'} . "_SNPContigLoc" ;
scripts/import/dbSNP/GenericContig.pm:      $tablename2 = $self->{'dbSNP_version'} . "_ContigInfo";      
scripts/import/dbSNP/GenericContig.pm:	if ($self->{'limit'}) {
scripts/import/dbSNP/GenericContig.pm:    $stmt .= "TOP $self->{'limit'} ";
scripts/import/dbSNP/GenericContig.pm:                  -1
scripts/import/dbSNP/GenericContig.pm:     if ($self->{'limit'}) {
scripts/import/dbSNP/GenericContig.pm:      dumpSQL($self->{'dbSNP'},$stmt, $self->{source_engine});
scripts/import/dbSNP/GenericContig.pm:  create_and_load($self->{'dbVar'}, "tmp_contig_loc", "snp_id i* not_null", "contig * not_null", "start i", 
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq{CREATE TABLE tmp_genotyped_var SELECT DISTINCT variation_id FROM tmp_sample_genotype_single_bp});
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq{CREATE UNIQUE INDEX variation_idx ON tmp_genotyped_var (variation_id)});
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq{INSERT IGNORE INTO  tmp_genotyped_var SELECT DISTINCT variation_id FROM sample_genotype_multiple_bp});
scripts/import/dbSNP/GenericContig.pm:  dumpSQL($self->{'dbVar'},qq{SELECT v.variation_id, ts.seq_region_id, tcl.start, tcl.end, tcl.strand, v.name, v.source_id, tcl.aln_quality, v.somatic, v.class_attrib_id
scripts/import/dbSNP/GenericContig.pm:  create_and_load($self->{'dbVar'},'tmp_variation_feature',"variation_id i* not_null","seq_region_id i", "seq_region_start i", "seq_region_end i", "seq_region_strand i", "variation_name", "source_id i not_null", "aln_quality d", "somatic i", "class_attrib_id i");
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq{INSERT INTO variation_feature (variation_id, seq_region_id,seq_region_start, seq_region_end, seq_region_strand,variation_name, flags, source_id, alignment_quality, somatic, class_attrib_id)
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do("DROP TABLE tmp_contig_loc");
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do("DROP TABLE tmp_genotyped_var");
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do("DROP TABLE tmp_variation_feature");
scripts/import/dbSNP/GenericContig.pm:  my $ind_gty_stmt = get_create_statement($genotype_table,$self->{'schema_file'});
scripts/import/dbSNP/GenericContig.pm:  my $failure_recovery ;   ## set to allow re-running of individual export jobs after memory failure
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'}; 
scripts/import/dbSNP/GenericContig.pm:  if($self->{source_engine} =~/mssql|sqlserver/ ){
scripts/import/dbSNP/GenericContig.pm:                 FROM $self->{'snp_dbname'}..sysobjects 
scripts/import/dbSNP/GenericContig.pm:  elsif($self->{source_engine} =~/postgreSQL/ ){
scripts/import/dbSNP/GenericContig.pm:                 WHERE schemaname = '$self->{schema_name}' 
scripts/import/dbSNP/GenericContig.pm:  my @subind_tables = map {$_->[0]} @{$self->{'dbSNP'}->db_handle()->selectall_arrayref($sql)};
scripts/import/dbSNP/GenericContig.pm: my $table_sth = $self->{'dbVar'}->prepare($table2_ext_stmt);
scripts/import/dbSNP/GenericContig.pm: my $file_prefix = $self->{'tmpdir'} . '/sample_genotypes';
scripts/import/dbSNP/GenericContig.pm: #Multi-bp genotypes will be written to a separate loadfile
scripts/import/dbSNP/GenericContig.pm:    #The subtable to store the data for this subind table and the loadfile to use. The mapping file is used to temporarily store the subsnp_id -> variation_id mapping
scripts/import/dbSNP/GenericContig.pm:    $table_sth->execute($dst_table);
scripts/import/dbSNP/GenericContig.pm:    if (defined($table_sth->fetchrow_arrayref())) {
scripts/import/dbSNP/GenericContig.pm:     ($jobindex,$task_manager_file) = $self->create_parallelized_individual_genotypes_task_file(\%gty_tables, $target_rows);   
scripts/import/dbSNP/GenericContig.pm:    my $result = $self->run_on_farm($jobname,$file_prefix,'calculate_gtype',$task_manager_file,1,$jobindex);
scripts/import/dbSNP/GenericContig.pm:    my $jobid = $result->{'jobid'};
scripts/import/dbSNP/GenericContig.pm:    if ((my @error_subtasks = grep($result->{'subtask_details'}{$_}{'generated_error'},keys(%{$result->{'subtask_details'}})))) {
scripts/import/dbSNP/GenericContig.pm:      warn($result->{'message'});
scripts/import/dbSNP/GenericContig.pm:      print $logh Progress::location() . "\t " . $result->{'message'};
scripts/import/dbSNP/GenericContig.pm:    if (!$result->{'success'}) {
scripts/import/dbSNP/GenericContig.pm:      warn($result->{'message'});
scripts/import/dbSNP/GenericContig.pm:      print $logh Progress::location() . "\t " . $result->{'message'};
scripts/import/dbSNP/GenericContig.pm:      foreach my $index (grep($result->{'subtask_details'}{$_}{'fail_reason'} =~ m/UNKNOWN/,keys(%{$result->{'subtask_details'}}))) {
scripts/import/dbSNP/GenericContig.pm:      foreach my $index (grep($result->{'subtask_details'}{$_}{'fail_reason'} =~ m/OUT_OF_[MEMORY|TIME]/,keys(%{$result->{'subtask_details'}}))) {
scripts/import/dbSNP/GenericContig.pm:    die("Some subtasks are failing (see log output). This needs to be resolved before proceeding with the loading of genotypes!") unless ($result->{'success'});
scripts/import/dbSNP/GenericContig.pm:  my $file_data_ext_sth = $self->{'dbVar'}->prepare(qq[SELECT sub_file, destination_file from tmp_indgeno_file]);
scripts/import/dbSNP/GenericContig.pm:  $file_data_ext_sth->execute()||die "Problem extracting list of files to merge\n";
scripts/import/dbSNP/GenericContig.pm:  my $file_list =  $file_data_ext_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericContig.pm:      unless (-e $pair->[0] ){
scripts/import/dbSNP/GenericContig.pm:        warn "No file of name $pair->[0] created\n" unless $pair->[0] =~/multi/;  ## many bins have multi files missing - report only missing singles 
scripts/import/dbSNP/GenericContig.pm:      open my $load_file, ">>", $pair->[1] || die "Failed to open $pair->[1] to write: $!\n";
scripts/import/dbSNP/GenericContig.pm:#      print "Cat'ing $pair->[0] to $pair->[1]\n";
scripts/import/dbSNP/GenericContig.pm:      open my $subfile, "<", $pair->[0] ||die  "Failed to open $pair->[0] to read: $!\n";
scripts/import/dbSNP/GenericContig.pm:    my $dst_table = $gty_tables{$subind_table}->[0];
scripts/import/dbSNP/GenericContig.pm:    my $loadfile = $gty_tables{$subind_table}->[1];
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/GenericContig.pm:    next unless (-e $loadfile);
scripts/import/dbSNP/GenericContig.pm:  if (-e $multi_bp_gty_file) {
scripts/import/dbSNP/GenericContig.pm:  my $result = $self->run_on_farm($jobname,$file_prefix,'load_data_infile',$task_manager_file,1,$jobindex);
scripts/import/dbSNP/GenericContig.pm:  my $jobid = $result->{'jobid'};
scripts/import/dbSNP/GenericContig.pm:  if ((my @error_subtasks = grep($result->{'subtask_details'}{$_}{'generated_error'},keys(%{$result->{'subtask_details'}})))) {
scripts/import/dbSNP/GenericContig.pm:    warn($result->{'message'});
scripts/import/dbSNP/GenericContig.pm:    print $logh Progress::location() . "\t " . $result->{'message'};
scripts/import/dbSNP/GenericContig.pm:  if (!$result->{'success'}) {
scripts/import/dbSNP/GenericContig.pm:    warn($result->{'message'});
scripts/import/dbSNP/GenericContig.pm:    print $logh Progress::location() . "\t " . $result->{'message'};
scripts/import/dbSNP/GenericContig.pm:    foreach my $index (grep($result->{'subtask_details'}{$_}{'fail_reason'} =~ m/UNKNOWN/,keys(%{$result->{'subtask_details'}}))) {
scripts/import/dbSNP/GenericContig.pm:    foreach my $index (grep($result->{'subtask_details'}{$_}{'fail_reason'} =~ m/OUT_OF_[MEMORY|TIME]/,keys(%{$result->{'subtask_details'}}))) {
scripts/import/dbSNP/GenericContig.pm:  die("Some subtasks are failing (see log output). This needs to be resolved before proceeding with the loading of genotypes!") unless ($result->{'success'});
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do($drop_tmp_stmt);
scripts/import/dbSNP/GenericContig.pm:  my $merge_subtables = join(",",map {$gty_tables{$_}->[0]} keys(%gty_tables));
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/GenericContig.pm:  dumpSQL($self->{'dbVar'},$stmt);
scripts/import/dbSNP/GenericContig.pm:  create_and_load($self->{'dbVar'},"tmp_multiple_bp_gty_variations","variation_id i* not_null"); 
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:  #Multi-bp genotypes will be written to a separate loadfile
scripts/import/dbSNP/GenericContig.pm:  my $multi_bp_gty_file =  $self->{'tmpdir'} . '/sample_genotypes_multi_bp_gty';
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq[ DROP TABLE IF EXISTS tmp_indgeno_file ]);
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq[ CREATE TABLE tmp_indgeno_file (sub_file varchar(255), destination_file varchar(255) ) ] );
scripts/import/dbSNP/GenericContig.pm:  my $file_ins_sth = $self->{'dbVar'}->prepare(qq[insert into tmp_indgeno_file (sub_file ,destination_file) values (?,?)]);
scripts/import/dbSNP/GenericContig.pm:  my $count_lines_sth = $self->{'dbSNP'}->prepare($stmt);
scripts/import/dbSNP/GenericContig.pm:  $count_lines_sth->execute();
scripts/import/dbSNP/GenericContig.pm:  $count_lines_sth->bind_columns(\$submitted_ind_id,\$genotype_count);
scripts/import/dbSNP/GenericContig.pm:  my $start_id = -1;
scripts/import/dbSNP/GenericContig.pm:  while ($count_lines_sth->fetch()) {
scripts/import/dbSNP/GenericContig.pm: 	$start_id = -1;
scripts/import/dbSNP/GenericContig.pm:    $file_ins_sth->execute("$$gty_tables{$arr[0]}->[1]\_$jobindex", $$gty_tables{$arr[0]}->[1])|| die "Problem entering geno file info\n";
scripts/import/dbSNP/GenericContig.pm:    $file_ins_sth->execute("$multi_bp_gty_file\_$jobindex", $multi_bp_gty_file)|| die "Problem entering geno file info\n";
scripts/import/dbSNP/GenericContig.pm:    print MGMT qq{$jobindex $arr[0] $$gty_tables{$arr[0]}->[1]\_$jobindex $multi_bp_gty_file\_$jobindex $arr[1] $arr[2] $$gty_tables{$arr[0]}->[2]\n};
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do( qq[drop table population_genotype]);
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do( qq[CREATE TABLE  population_genotype (
scripts/import/dbSNP/GenericContig.pm:    my $allele_table_ref = $self->{'dbVar'}->db_handle->selectall_arrayref(qq{show tables like "tmp_rev_allele"});
scripts/import/dbSNP/GenericContig.pm:    my $allele_table = $allele_table_ref->[0][0];
scripts/import/dbSNP/GenericContig.pm:		   $self->{'dbSNP_share_db'}.Allele a1, 
scripts/import/dbSNP/GenericContig.pm:		   $self->{'dbSNP_share_db'}.Allele a2
scripts/import/dbSNP/GenericContig.pm:      dumpSQL($self->{'dbSNP'},$stmt, $self->{source_engine});
scripts/import/dbSNP/GenericContig.pm:      create_and_load($self->{'dbVar'}, "tmp_rev_allele", "allele_id i* not_null","allele * not_null", "rev_allele not_null");
scripts/import/dbSNP/GenericContig.pm:    if ($self->{'limit'}) {
scripts/import/dbSNP/GenericContig.pm:      $stmt .= "TOP $self->{'limit'} ";
scripts/import/dbSNP/GenericContig.pm:	       	  $self->{'dbSNP_share_db'}.UniGty ug, 
scripts/import/dbSNP/GenericContig.pm:	       	  $self->{'dbSNP_share_db'}.Allele a1, 
scripts/import/dbSNP/GenericContig.pm:	       	  $self->{'dbSNP_share_db'}.Allele a2
scripts/import/dbSNP/GenericContig.pm:     if ($self->{'limit'}) {
scripts/import/dbSNP/GenericContig.pm:    dumpSQL($self->{'dbSNP'},$stmt, $self->{source_engine});
scripts/import/dbSNP/GenericContig.pm:     create_and_load($self->{'dbVar'}, "tmp_pop_gty", 'subsnp_id i* not_null unsigned', 'pop_id i* not_null', 'freq','count','allele_1', 'allele_2');
scripts/import/dbSNP/GenericContig.pm:   $self->{'dbVar'}->do(qq{CREATE UNIQUE INDEX pop_genotype_idx ON population_genotype(variation_id,subsnp_id,frequency,population_id,allele_1(5),allele_2(5))});
scripts/import/dbSNP/GenericContig.pm:  ## human is too big to do in one go - breaking up crudely 
scripts/import/dbSNP/GenericContig.pm:  my $get_max_sth = $self->{'dbVar'}->prepare(qq[select max(variation_synonym_id) from variation_synonym]);
scripts/import/dbSNP/GenericContig.pm:  $get_max_sth->execute()||die;
scripts/import/dbSNP/GenericContig.pm:  my $max = $get_max_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do(qq{INSERT IGNORE INTO population_genotype (variation_id,subsnp_id,allele_1, allele_2, frequency, population_id, count)
scripts/import/dbSNP/GenericContig.pm:     $self->{'dbVar'}->do(qq{INSERT IGNORE INTO population_genotype (variation_id,subsnp_id,allele_1, allele_2, frequency, population_id, count)
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do(qq{DROP INDEX pop_genotype_idx ON population_genotype});
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do("DROP TABLE tmp_pop_gty");
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:  while( $start  < $max->[0]->[0] ){	
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do(qq{INSERT IGNORE INTO population_genotype (variation_id,subsnp_id,allele_1, allele_2, frequency, population_id, count)
scripts/import/dbSNP/GenericContig.pm:     $self->{'dbVar'}->do(qq{INSERT IGNORE INTO population_genotype (variation_id,subsnp_id,allele_1, allele_2, frequency, population_id, count)
scripts/import/dbSNP/GenericContig.pm:    return unless $self->table_exists_and_populated('RsMergeArch');
scripts/import/dbSNP/GenericContig.pm:    my $source_id = $self->source_table("Archive dbSNP");
scripts/import/dbSNP/GenericContig.pm:    my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:    if($self->{source_engine} =~/mssql/ ){
scripts/import/dbSNP/GenericContig.pm:    elsif($self->{source_engine} =~/postgreSQL/ ){
scripts/import/dbSNP/GenericContig.pm:    dumpSQL($self->{'dbSNP'}, $concat_sql , $self->{source_engine} ) ;
scripts/import/dbSNP/GenericContig.pm:   create_and_load( $self->{'dbVar'}, "rsHist", "rsHigh * not_null", "rsCurrent * not_null","orien2Current not_null", "rsLow") ;
scripts/import/dbSNP/GenericContig.pm:   my $get_max_sth = $self->{'dbVar'}->prepare(qq[select min(snp_id), max(snp_id) from variation ]);
scripts/import/dbSNP/GenericContig.pm:   $get_max_sth->execute()||die;
scripts/import/dbSNP/GenericContig.pm:   my $range = $get_max_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericContig.pm:   my $start      = $range->[0]->[0];
scripts/import/dbSNP/GenericContig.pm:   my $max        = $range->[0]->[1];
scripts/import/dbSNP/GenericContig.pm:   # append to synonym table with database 'Archive dbSNP' - slow query binned
scripts/import/dbSNP/GenericContig.pm:      $self->{'dbVar'}->do(qq{INSERT INTO variation_synonym (variation_id, source_id, name)
scripts/import/dbSNP/GenericContig.pm:      if($self->{source_engine} =~/mssql/ ){
scripts/import/dbSNP/GenericContig.pm:	  $self->{'dbVar'}->do(qq{INSERT INTO variation_synonym (variation_id, source_id, name)
scripts/import/dbSNP/GenericContig.pm:	  $self->{'dbVar'}->do(qq{INSERT INTO variation_synonym (variation_id, source_id, name)
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do(qq[drop table rsHist]);
scripts/import/dbSNP/GenericContig.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do('CREATE TABLE tmp_pop (population_id int PRIMARY KEY)'); #create a temporary table with unique populations
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do('INSERT IGNORE INTO tmp_pop SELECT distinct(population_id) FROM allele'); #add the populations from the alleles
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do('INSERT IGNORE INTO tmp_pop SELECT distinct(population_id) FROM population_genotype'); #add the populations from the population_genotype
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do('INSERT IGNORE INTO tmp_pop SELECT population_id FROM individual_population'); #add the populations from the individuals
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do(qq{INSERT IGNORE INTO tmp_pop SELECT super_population_id 
scripts/import/dbSNP/GenericContig.pm: 				      WHERE tp.population_id = ps.sub_population_id}); #add the populations from the super-populations
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do($sql); #delete from population
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do($sql_2); #delete from population_synonym
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do('DROP TABLE tmp_pop'); #and finally remove the temporary table
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do('ALTER TABLE variation_synonym DROP COLUMN substrand_reversed_flag');
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do('ALTER TABLE population DROP COLUMN pop_class_id, DROP COLUMN pop_id');
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do('DROP TABLE tmp_ind');
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do('DROP TABLE tmp_indgeno_file');
scripts/import/dbSNP/GenericContig.pm:    $self->{'dbVar'}->do('DROP TABLE tmp_var_allele');
scripts/import/dbSNP/GenericContig.pm:  dumpSQL($self->{'dbSNP'}, $hgvs_extr_stmt , $self->{source_engine} ) ;
scripts/import/dbSNP/GenericContig.pm:  create_and_load( $self->{'dbVar'}, "dbsnp_hgvs", "snp_id * not_null", "hgvs_name * not_null") ;
scripts/import/dbSNP/GenericContig.pm:  my $get_source_sth = $self->{'dbVar'}->prepare(qq[select source_id from source where name ='dbSNP HGVS' ]);
scripts/import/dbSNP/GenericContig.pm:  $get_source_sth->execute()||die;
scripts/import/dbSNP/GenericContig.pm:  my $synon_source = $get_source_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericContig.pm:  $self->{'dbVar'}->do(qq[INSERT IGNORE INTO variation_synonym (variation_id,name,source_id)  (select variation.variation_id, dbsnp_hgvs.hgvs_name, $synon_source->[0]->[0]
scripts/import/dbSNP/Mosquito.pm:Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dbSNP/Mosquito.pm:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dbSNP/Mosquito.pm:     http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dbSNP/Mosquito.pm:    $self->SUPER::dump_dbSNP();
scripts/import/dbSNP/Mosquito.pm:    $self->add_strains();    
scripts/import/dbSNP/Mosquito.pm:      $self->{'dbVariation'}->do(qq{INSERT INTO sample (name,description)
scripts/import/dbSNP/Mosquito.pm:      $STRAINS{$population_name} = $self->{'dbVariation'}->{'mysql_insertid'};
scripts/import/dbSNP/Mosquito.pm:    $self->{'dbVariation'}->do(qq{INSERT INTO population (sample_id) 
scripts/import/dbSNP/Mosquito.pm:    dumpSQL($self->{'dbSNP'},$stmt);
scripts/import/dbSNP/Mosquito.pm:    create_and_load($self->{'dbVariation'},'tmp_strain', "subsnp_id i*", "strain");
scripts/import/dbSNP/Mosquito.pm:    $self->{'dbVariation'}->do(qq{UPDATE allele , variation_synonym, tmp_strain
scripts/import/dbSNP/Mosquito.pm:    $self->{'dbVariation'}->do(qq{UPDATE allele , variation_synonym, tmp_strain
scripts/import/dbSNP/Mosquito.pm:    $self->{'dbVariation'}->do(qq{DROP TABLE tmp_strain});
scripts/import/dbSNP/Mosquito.pm:    my %scaff; #contains relation AAAB -> NW
scripts/import/dbSNP/Mosquito.pm:    open(IN,"gzip -dc dbSNP/scaff_NW_chr_CRA_AAAB.gz |") || die "Could not get file with scaff mapping data: $!\n";
scripts/import/dbSNP/Mosquito.pm:    my $sth = $self->{'dbCore'}->dbc()->prepare(qq{SELECT sr.seq_region_id, sr.name
scripts/import/dbSNP/Mosquito.pm:    $sth->execute();
scripts/import/dbSNP/Mosquito.pm:    open(FH,">" . $self->{'tmpdir'} . '/' . $self->{'tmpfile'}); #open the file with the data dump from the core database
scripts/import/dbSNP/Mosquito.pm:    while($row = $sth->fetchrow_arrayref()) {
scripts/import/dbSNP/Mosquito.pm:    $sth->finish();
scripts/import/dbSNP/Mosquito.pm:    create_and_load($self->{'dbVariation'}, "tmp_seq_region", "seq_region_id", "name *");
scripts/import/dbSNP/Mosquito.pm:    my ($assembly_version) =  $self->{'assembly_version'} =~ /^[a-zA-Z]+(\d+)\.*.*$/; $assembly_version=2;
scripts/import/dbSNP/Mosquito.pm:                    $self->{'snp_dbname'}..sysobjects 
scripts/import/dbSNP/Mosquito.pm:                    name LIKE '$self->{'dbSNP_version'}\_SNPContigLoc\_$assembly_version\__'
scripts/import/dbSNP/Mosquito.pm:    my $sth1 = $self->{'dbSNP'}->prepare($stmt);
scripts/import/dbSNP/Mosquito.pm:    $sth1->execute();
scripts/import/dbSNP/Mosquito.pm:    while($row = $sth1->fetchrow_arrayref()) {
scripts/import/dbSNP/Mosquito.pm:      $tablename1 = $row->[0];
scripts/import/dbSNP/Mosquito.pm:                 $self->{'snp_dbname'}..sysobjects 
scripts/import/dbSNP/Mosquito.pm:                 name LIKE '$self->{'dbSNP_version'}\_ContigInfo\_$assembly_version\__'
scripts/import/dbSNP/Mosquito.pm:    my $sth2 = $self->{'dbSNP'}->prepare($stmt);
scripts/import/dbSNP/Mosquito.pm:    $sth2->execute();
scripts/import/dbSNP/Mosquito.pm:    while($row = $sth2->fetchrow_arrayref()) {
scripts/import/dbSNP/Mosquito.pm:      $tablename2 = $row->[0];
scripts/import/dbSNP/Mosquito.pm:    if ($self->{'limit'}) {
scripts/import/dbSNP/Mosquito.pm:      $stmt .= "TOP $self->{'limit'} ";
scripts/import/dbSNP/Mosquito.pm:		    -1
scripts/import/dbSNP/Mosquito.pm:    dumpSQL($self->{'dbSNP'},$stmt);
scripts/import/dbSNP/Mosquito.pm:    create_and_load($self->{'dbVariation'}, "tmp_contig_loc", "snp_id i*", "contig *", "start i", 
scripts/import/dbSNP/Mosquito.pm:     $self->{'dbVariation'}->do(qq{CREATE TABLE tmp_genotyped_var SELECT DISTINCT variation_id FROM tmp_individual_genotype_single_bp});
scripts/import/dbSNP/Mosquito.pm:     $self->{'dbVariation'}->do(qq{CREATE UNIQUE INDEX variation_idx ON tmp_genotyped_var (variation_id)});
scripts/import/dbSNP/Mosquito.pm:     $self->{'dbVariation'}->do(qq{INSERT IGNORE INTO  tmp_genotyped_var SELECT DISTINCT variation_id FROM individual_genotype_multiple_bp});
scripts/import/dbSNP/Mosquito.pm:    $self->{'dbVariation'}->do(qq{INSERT INTO variation_feature 
scripts/import/dbSNP/Mosquito.pm:    $self->{'dbVariation'}->do("DROP TABLE tmp_contig_loc");
scripts/import/dbSNP/Mosquito.pm:    $self->{'dbVariation'}->do("DROP TABLE tmp_seq_region");
scripts/import/dbSNP/Mosquito.pm:    $self->{'dbVariation'}->do("DROP TABLE tmp_genotyped_var");
scripts/import/dbSNP/GenericChromosome.pm:Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dbSNP/GenericChromosome.pm:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dbSNP/GenericChromosome.pm:     http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dbSNP/GenericChromosome.pm:    $self->{'dbVar'}->do("alter table variation_feature modify column map_weight int default null");
scripts/import/dbSNP/GenericChromosome.pm:     dumpSQL($self->{'dbCore'}->db_handle, qq{SELECT sr.seq_region_id, sr.name
scripts/import/dbSNP/GenericChromosome.pm:     load($self->{'dbVar'}, "seq_region", "seq_region_id", "name");
scripts/import/dbSNP/GenericChromosome.pm:     my $version_number = $self->{'dbSNP_version'};
scripts/import/dbSNP/GenericChromosome.pm:    if(  $version_number  < 137){ ## table rename for dbSNP - keeping this temporarily for backwards comparibility
scripts/import/dbSNP/GenericChromosome.pm:     print "assembly_version is ",$self->{'assembly_version'},"\n";
scripts/import/dbSNP/GenericChromosome.pm:     my ($assembly_version) =  $self->{'assembly_version'} =~ /^[a-zA-Z]+\_?(\d+)\.*.*$/;
scripts/import/dbSNP/GenericChromosome.pm:     $assembly_version=$1 if $self->{'assembly_version'} =~ /RGSC\d\.(\d+)/;
scripts/import/dbSNP/GenericChromosome.pm:                    FROM    $self->{'snp_dbname'}..sysobjects 
scripts/import/dbSNP/GenericChromosome.pm:                    WHERE   name LIKE '$self->{'dbSNP_version'}\_SNPContigLoc\__%'
scripts/import/dbSNP/GenericChromosome.pm:     my $sth = $self->{'dbSNP'}->prepare($stmt);
scripts/import/dbSNP/GenericChromosome.pm:     $sth->execute();
scripts/import/dbSNP/GenericChromosome.pm:     while($row = $sth->fetchrow_arrayref()) {
scripts/import/dbSNP/GenericChromosome.pm:	($genome_build) = $row->[0] =~ m/SNPContigLoc\_(.+)$/;
scripts/import/dbSNP/GenericChromosome.pm:	    die("Could not find the " . $self->{'dbSNP_version'} . "_SNPContigLoc_NNN table!");
scripts/import/dbSNP/GenericChromosome.pm:    $tablename1 = $self->{'dbSNP_version'} . "_SNPContigLoc_" . $genome_build;
scripts/import/dbSNP/GenericChromosome.pm:                 FROM    $self->{'snp_dbname'}..sysobjects 
scripts/import/dbSNP/GenericChromosome.pm:                 WHERE name LIKE '$self->{'dbSNP_version'}\_ContigInfo\_$assembly_version\_%'};
scripts/import/dbSNP/GenericChromosome.pm:     my $sth1 = $self->{'dbSNP'}->prepare($stmt);
scripts/import/dbSNP/GenericChromosome.pm:     $sth1->execute();
scripts/import/dbSNP/GenericChromosome.pm:     while($row = $sth1->fetchrow_arrayref()) {
scripts/import/dbSNP/GenericChromosome.pm:       $tablename2 = $row->[0];
scripts/import/dbSNP/GenericChromosome.pm:    $tablename2 = $self->{'dbSNP_version'} . "_ContigInfo_" . $genome_build;
scripts/import/dbSNP/GenericChromosome.pm:         $tablename1 = $self->{'dbSNP_version'} . "_SNPContigLoc";
scripts/import/dbSNP/GenericChromosome.pm:         $tablename2 = $self->{'dbSNP_version'} . "_ContigInfo";
scripts/import/dbSNP/GenericChromosome.pm:    ## hack for human multi-build support
scripts/import/dbSNP/GenericChromosome.pm:    $tablename1 = $tablename1 . "_108" if $self->{'group_label'} =~ /GRCh38/;
scripts/import/dbSNP/GenericChromosome.pm:    $tablename2 = $tablename2 . "_108" if $self->{'group_label'} =~ /GRCh38/;
scripts/import/dbSNP/GenericChromosome.pm:    $tablename1 = $tablename1 . "_105" if $self->{'group_label'} =~ /GRCh37/;
scripts/import/dbSNP/GenericChromosome.pm:    $tablename2 = $tablename2 . "_105" if $self->{'group_label'} =~ /GRCh37/;
scripts/import/dbSNP/GenericChromosome.pm:    my $group_term = $self->{'group_term'};
scripts/import/dbSNP/GenericChromosome.pm:    my $group_label = $self->{'group_label'};
scripts/import/dbSNP/GenericChromosome.pm:        my $result = $self->{'dbSNP'}->db_handle->selectall_arrayref($stmt);
scripts/import/dbSNP/GenericChromosome.pm:        $group_term = $result->[0][0];
scripts/import/dbSNP/GenericChromosome.pm:        $group_label = $result->[0][1];
scripts/import/dbSNP/GenericChromosome.pm:                have to truncate the variation_feature table and re-run the variation_feature subroutine.
scripts/import/dbSNP/GenericChromosome.pm:    # In the query below, the pre-131 syntax was ref-assembly. In 131 it is GRCh37 for human. What is it for other species??
scripts/import/dbSNP/GenericChromosome.pm:    #my ($release) = $self->{'dbSNP_version'} =~ m/^b?(\d+)$/;
scripts/import/dbSNP/GenericChromosome.pm:    #$group_term = 'GRCh' if ($self->{'dbm'}->dbCore()->species =~ m/homo|human/i && $release > 130);
scripts/import/dbSNP/GenericChromosome.pm:    my $extract_mappings_for = qq['$group_term', 'non-nuclear'];
scripts/import/dbSNP/GenericChromosome.pm:		     (loc.phys_pos_from + 1 + loc.asn_to - loc.asn_from )
scripts/import/dbSNP/GenericChromosome.pm:		     -1
scripts/import/dbSNP/GenericChromosome.pm:                     -1
scripts/import/dbSNP/GenericChromosome.pm:     dumpSQL($self->{'dbSNP'},$stmt, $self->{source_engine} );
scripts/import/dbSNP/GenericChromosome.pm:     create_and_load($self->{'dbVar'}, "tmp_contig_loc_chrom", "snp_id i* not_null", "ctg * not_null", "ctg_gi i", "ctg_start i not_null", "ctg_end i", "chr *", "start i", "end i", "strand i", "aln_quality d", "ctg_strand i");
scripts/import/dbSNP/GenericChromosome.pm:    my $gtype_ref = $self->{'dbVar'}->db_handle->selectall_arrayref(qq{SELECT COUNT(*) FROM  tmp_sample_genotype_single_bp});
scripts/import/dbSNP/GenericChromosome.pm:    my $gtype_row = $gtype_ref->[0][0] if $gtype_ref;
scripts/import/dbSNP/GenericChromosome.pm:	$self->{'dbVar'}->do(qq{CREATE TABLE tmp_genotyped_var SELECT DISTINCT variation_id FROM tmp_sample_genotype_single_bp});
scripts/import/dbSNP/GenericChromosome.pm:	$self->{'dbVar'}->do(qq{CREATE UNIQUE INDEX variation_idx ON tmp_genotyped_var (variation_id)});
scripts/import/dbSNP/GenericChromosome.pm:	$self->{'dbVar'}->do(qq{INSERT IGNORE INTO tmp_genotyped_var SELECT DISTINCT variation_id FROM sample_genotype_multiple_bp});
scripts/import/dbSNP/GenericChromosome.pm:    dumpSQL($self->{'dbVar'},qq{SELECT v.variation_id, ts.seq_region_id, 
scripts/import/dbSNP/GenericChromosome.pm:    create_and_load($self->{'dbVar'},'tmp_variation_feature_chrom',"variation_id i* not_null","seq_region_id i", "seq_region_start i", "seq_region_end i", "seq_region_strand", "variation_name", "source_id", "aln_quality d");
scripts/import/dbSNP/GenericChromosome.pm:    dumpSQL($self->{'dbVar'},qq{SELECT v.variation_id, ts.seq_region_id, 
scripts/import/dbSNP/GenericChromosome.pm:    create_and_load($self->{'dbVar'},'tmp_variation_feature_ctg',"variation_id i* not_null","seq_region_id i ", "seq_region_start i", "seq_region_end i", "seq_region_strand", "variation_name", "source_id",  "aln_quality d");
scripts/import/dbSNP/GenericChromosome.pm:    my $get_max_sth = $self->{'dbVar'}->prepare(qq[select max(variation_id) from variation]);
scripts/import/dbSNP/GenericChromosome.pm:    $get_max_sth->execute()||die;
scripts/import/dbSNP/GenericChromosome.pm:    my $max = $get_max_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericChromosome.pm:     	my $vf_ins_sth = $self->{'dbVar'}->prepare(qq{INSERT INTO variation_feature (variation_id, seq_region_id,seq_region_start, seq_region_end, seq_region_strand,variation_name, flags, source_id, alignment_quality, somatic)
scripts/import/dbSNP/GenericChromosome.pm:       while( $start  < $max->[0]->[0] ){
scripts/import/dbSNP/GenericChromosome.pm:           $vf_ins_sth->execute($start, $end)||die;
scripts/import/dbSNP/GenericChromosome.pm:      $self->{'dbVar'}->do(qq{UPDATE variation_feature vf, tmp_genotyped_var tgv
scripts/import/dbSNP/GenericChromosome.pm:	 my $vf_ins_sth =$self->{'dbVar'}->prepare(qq{INSERT INTO variation_feature (variation_id, seq_region_id,seq_region_start, seq_region_end, seq_region_strand,variation_name, flags, source_id, alignment_quality, somatic)
scripts/import/dbSNP/GenericChromosome.pm:	while( $start  < $max->[0]->[0] ){	
scripts/import/dbSNP/GenericChromosome.pm:	    $vf_ins_sth->execute($start, $end)||die;
scripts/import/dbSNP/GenericChromosome.pm:    if ($self->{'dbm'}->dbCore()->species =~ /homo/i){
scripts/import/dbSNP/GenericChromosome.pm:	debug(localtime() . "\tDumping non-primary assembly data for human");
scripts/import/dbSNP/GenericChromosome.pm:	$self->extract_haplotype_mappings($tablename1, $tablename2, $group_label);
scripts/import/dbSNP/GenericChromosome.pm:    $self->{'dbVar'}->do("DROP TABLE IF EXISTS tmp_contig_loc_chrom");
scripts/import/dbSNP/GenericChromosome.pm:    $self->{'dbVar'}->do("DROP TABLE IF EXISTS tmp_genotyped_var");
scripts/import/dbSNP/GenericChromosome.pm:    $self->{'dbVar'}->do("DROP TABLE IF EXISTS tmp_variation_feature_chrom");
scripts/import/dbSNP/GenericChromosome.pm:    $self->{'dbVar'}->do("DROP TABLE IF EXISTS tmp_variation_feature_ctg");
scripts/import/dbSNP/GenericChromosome.pm:    dumpSQL($self->{'dbCore'},$syn_ext_stmt);       
scripts/import/dbSNP/GenericChromosome.pm:    create_and_load($self->{'dbVar'}, "tmp_hap_synonym", "seq_region_id i* not_null", "name * not_null", "synonym * not_null", "asm_start i", "asm_end i"   );
scripts/import/dbSNP/GenericChromosome.pm:    ### check for reverse strand patches - not expecting any, so merely warn
scripts/import/dbSNP/GenericChromosome.pm:    my $strand_ch_sth = $self->{'dbVar'}->prepare(qq[ select seq_region_id, name from tmp_hap_synonym where asm_start > asm_end]);
scripts/import/dbSNP/GenericChromosome.pm:    $strand_ch_sth->execute();
scripts/import/dbSNP/GenericChromosome.pm:    my $problem = $strand_ch_sth->fetchall_arrayref();
scripts/import/dbSNP/GenericChromosome.pm:    warn "DANGER: Patch id $problem->[0]->[0] name $problem->[0]->[1] on reverse strand\n" if defined $problem->[0]->[0];
scripts/import/dbSNP/GenericChromosome.pm:    if($self->{source_engine} =~/mssql/){
scripts/import/dbSNP/GenericChromosome.pm:    elsif($self->{source_engine} =~/postgreSQL/i){
scripts/import/dbSNP/GenericChromosome.pm:	warn "setting search path for postgreSQL: " .$self->{'schema_name'} . "\n";
scripts/import/dbSNP/GenericChromosome.pm:	my $sth = "SET search_path TO $self->{'schema_name'},dbsnp_main,public";
scripts/import/dbSNP/GenericChromosome.pm:                            THEN   -1
scripts/import/dbSNP/GenericChromosome.pm:                            WHERE  ctg.group_term !=   'Primary_Assembly' and ctg.group_term !=   'non-nuclear'
scripts/import/dbSNP/GenericChromosome.pm:    dumpSQL($self->{'dbSNP'},$dat_ext_stmt);
scripts/import/dbSNP/GenericChromosome.pm:    create_and_load($self->{'dbVar'}, "tmp_contig_loc_hap", "snp_id i* not_null", "seq_av * not_null",  "seq_start i not_null", "seq_end i", "strand i", "aln_quality d");
scripts/import/dbSNP/GenericChromosome.pm:    $self->{'dbVar'}->do(qq[ INSERT INTO variation_feature (variation_id, seq_region_id,seq_region_start, seq_region_end, seq_region_strand,
scripts/import/dbSNP/GenericChromosome.pm:                                                                   SELECT v.variation_id, ths.seq_region_id, tvf.seq_start+ths.asm_start-1, tvf.seq_end+ths.asm_start-1, tvf.strand, 
scripts/import/dbSNP/EnsemblIds.pm:Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dbSNP/EnsemblIds.pm:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dbSNP/EnsemblIds.pm:     http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dbSNP/EnsemblIds.pm:    $self->SUPER::dump_dbSNP();
scripts/import/dbSNP/EnsemblIds.pm:    $duration = Progress::time_format($end-$start);
scripts/import/dbSNP/EnsemblIds.pm:    print $duration->{'weeks'} . " weeks, " . $duration->{'days'} . " days, " . $duration->{'hours'} . " hours, " . $duration->{'minutes'} . " minutes and " . $duration->{'seconds'} . " seconds spent in SUPER::dump_dbSNP()\n";
scripts/import/dbSNP/EnsemblIds.pm:    $self->dump_LSDBIDs() if $self->{'dbm'}->dbCore()->species =~ /hum|homo/i;
scripts/import/dbSNP/EnsemblIds.pm:    $duration = Progress::time_format($end-$start);
scripts/import/dbSNP/EnsemblIds.pm:    print $duration->{'weeks'} . " weeks, " . $duration->{'days'} . " days, " . $duration->{'hours'} . " hours, " . $duration->{'minutes'} . " minutes and " . $duration->{'seconds'} . " seconds spent in dump_LSDBIDs()\n";
scripts/import/dbSNP/EnsemblIds.pm:    if ($self->{'dbCore'}->species =~ /$species/i) {
scripts/import/dbSNP/EnsemblIds.pm:	$self->{'dbVar'}->do(qq{INSERT INTO source (name,version,description) values ("ENSEMBL_$batch_name",1,"Variation called by ENSEMBL")});
scripts/import/dbSNP/EnsemblIds.pm:	my $source_id = $self->{'dbVar'}->db_handle->{'mysql_insertid'}; #get the last autoinc id in the database (the one from the ENS source)
scripts/import/dbSNP/EnsemblIds.pm:	dumpSQL($self->{'dbSNP'},$stmt);
scripts/import/dbSNP/EnsemblIds.pm:	create_and_load($self->{'dbVar'},"tmp_rs_ENS_$batch_name","rsID *","ss_id i","source_id i","ENSid");
scripts/import/dbSNP/EnsemblIds.pm:	$self->{'dbVar'}->do(qq{ INSERT IGNORE INTO variation_synonym (variation_id, subsnp_id, source_id, name)
scripts/import/dbSNP/EnsemblIds.pm:	#$self->{'dbVar'}->do(qq{DROP TABLE tmp_rs_ENS_$batch_name});
scripts/import/dbSNP/EnsemblIds.pm:# This method uses the pontus_affy_array_mapping database on ens-variation
scripts/import/dbSNP/EnsemblIds.pm:  dumpSQL($self->{'dbSNP'},$stmt);
scripts/import/dbSNP/EnsemblIds.pm:  create_and_load($self->{'dbVar'},"tmp_rs_AFFY","rsID *","AFFYid", "affy_name");
scripts/import/dbSNP/EnsemblIds.pm:      $source_description = "Variants from the Affymetrix Genome-Wide Human SNP Array 6.0";
scripts/import/dbSNP/EnsemblIds.pm:    $self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/EnsemblIds.pm:    $self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/EnsemblIds.pm:    $self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/EnsemblIds.pm:    $self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/EnsemblIds.pm:    $self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/EnsemblIds.pm:    # The code below has been replaced by the dump-and-load code above
scripts/import/dbSNP/EnsemblIds.pm:    #$self->{'dbVar'}->do(qq{CREATE TABLE $table\_name_pair like $table.name_pair});
scripts/import/dbSNP/EnsemblIds.pm:    #$self->{'dbVar'}->do(qq{insert into $table\_name_pair select * from $table.name_pair});
scripts/import/dbSNP/EnsemblIds.pm:    #$self->{'dbVar'}->do(qq{insert ignore into $table\_name_pair
scripts/import/dbSNP/EnsemblIds.pm:	$self->{'dbVar'}->do($stmt);
scripts/import/dbSNP/EnsemblIds.pm:    my $source_id_ref = $self->{'dbVar'}->db_handle->selectall_arrayref(qq{
scripts/import/dbSNP/EnsemblIds.pm:    my $source_id = $source_id_ref->[0][0];
scripts/import/dbSNP/EnsemblIds.pm:      $self->{'dbVar'}->do(qq{insert into source (name,description,url,type) values("$source_name","$source_description","$source_url","chip")});
scripts/import/dbSNP/EnsemblIds.pm:      $source_id = $self->{'dbVar'}->db_handle->{'mysql_insertid'};
scripts/import/dbSNP/EnsemblIds.pm:    $self->{'dbVar'}->do(qq{ INSERT IGNORE INTO variation_synonym (variation_id, source_id, name)
scripts/import/dbSNP/EnsemblIds.pm:    #$self->{'dbVar'}->do(qq{update tmp_rs_AFFY_test t, rsHist h set t.rsID=h.rsCurrent where t.rsID=h.rsHigh});
scripts/import/dbSNP/EnsemblIds.pm:    $self->{'dbVar'}->do(qq{ INSERT IGNORE INTO variation_synonym (variation_id, source_id, name)
scripts/import/dbSNP/EnsemblIds.pm:    $self->{'dbVar'}->do(qq{DROP TABLE $table});
scripts/import/dbSNP/EnsemblIds.pm:    my $dbh = $self->{'dbVar'}->db_handle();
scripts/import/dbSNP/EnsemblIds.pm:    my ($species,$tax_id,$version) = $self->{'snp_dbname'} =~ m/^(.+)?\_([0-9]+)\_([0-9]+)$/;
scripts/import/dbSNP/EnsemblIds.pm:    my $batch_data = $self->get_lsdb_batches();
scripts/import/dbSNP/EnsemblIds.pm:			JOIN $self->{'dbSNP_share_db'}.Method m ON b.method_id = m.method_id AND m.method_class = 109
scripts/import/dbSNP/EnsemblIds.pm:    dumpSQL($self->{'dbSNP'}, $stmt, $self->{source_engine});
scripts/import/dbSNP/EnsemblIds.pm:    create_and_load($self->{'dbVar'}, "tmp_lsdb_ids", 'name', 'ssid i*', 'rsid i*','batch_id');
scripts/import/dbSNP/EnsemblIds.pm:    my $syn_ins_sth = $dbh->prepare(qq[ INSERT INTO variation_synonym
scripts/import/dbSNP/EnsemblIds.pm:    my $dat_ext_sth = $dbh->prepare(qq[SELECT distinct v.variation_id,
scripts/import/dbSNP/EnsemblIds.pm:    $dat_ext_sth->execute()||die;
scripts/import/dbSNP/EnsemblIds.pm:    while( my $line = $dat_ext_sth->fetchrow_arrayref()){
scripts/import/dbSNP/EnsemblIds.pm:        if( defined $batch_data->{ $line->[2]}->{phencode} ){
scripts/import/dbSNP/EnsemblIds.pm:            $syn_ins_sth->execute($line->[0], $line->[1], $source_ids{phencode}, $line->[3])||die;
scripts/import/dbSNP/EnsemblIds.pm:        ## link to source db if not in phencode   - could link to both if name switch implemented
scripts/import/dbSNP/EnsemblIds.pm:        elsif( defined $batch_data->{$line->[2]}->{db} ){
scripts/import/dbSNP/EnsemblIds.pm:            $syn_ins_sth->execute($line->[0], $line->[1], $source_ids{ $batch_data->{$line->[2]}->{db} }, $line->[3])||die;
scripts/import/dbSNP/EnsemblIds.pm:            next if(defined $done{$line->[3]}{default} );
scripts/import/dbSNP/EnsemblIds.pm:	    $done{$line->[3]}{default} = 1;
scripts/import/dbSNP/EnsemblIds.pm:            $syn_ins_sth->execute($line->[0], $line->[1], $source_ids{default}, $line->[3])||die;
scripts/import/dbSNP/EnsemblIds.pm:    $self->{'dbVar'}->db_handle->do(qq{DROP TABLE tmp_lsdb_ids});
scripts/import/dbSNP/EnsemblIds.pm:    die "Cannot handle nameless source\n" unless defined $source_data->{name};
scripts/import/dbSNP/EnsemblIds.pm:    my $source_ext_sth = $dbh->prepare(qq[ select source_id from source where name = ?]);
scripts/import/dbSNP/EnsemblIds.pm:    my $source_ins_sth = $dbh->prepare(qq[ insert into source (name, version, description, url, somatic_status) values (?,?,?,?,?) ]);
scripts/import/dbSNP/EnsemblIds.pm:    $source_ext_sth->execute($source_data->{name})||die;
scripts/import/dbSNP/EnsemblIds.pm:    my $id = $source_ext_sth->fetchall_arrayref();
scripts/import/dbSNP/EnsemblIds.pm:    return $id->[0]->[0] if defined $id->[0]->[0];
scripts/import/dbSNP/EnsemblIds.pm:    $source_ins_sth->execute($source_data->{name}, $source_data->{version}, $source_data->{desc}, $source_data->{url}, $source_data->{somatic} )||die;
scripts/import/dbSNP/EnsemblIds.pm:    $source_ext_sth->execute($source_data->{name})||die;
scripts/import/dbSNP/EnsemblIds.pm:    my $idn = $source_ext_sth->fetchall_arrayref();
scripts/import/dbSNP/EnsemblIds.pm:    return $idn->[0]->[0] if defined $idn->[0]->[0];
scripts/import/dbSNP/EnsemblIds.pm:    die "Failed to get source for $source_data->{name} \n";
scripts/import/dbSNP/EnsemblIds.pm:## find pre-checked batches and source info
scripts/import/dbSNP/EnsemblIds.pm:    my $dbh = $self->{'dbInt'}->db_handle();
scripts/import/dbSNP/EnsemblIds.pm:    my $req_ext_sth = $dbh->prepare(qq[ select dbSNP_lsdb_batch.dbSNP_batch, 
scripts/import/dbSNP/EnsemblIds.pm:    $req_ext_sth->execute();
scripts/import/dbSNP/EnsemblIds.pm:    my $dat = $req_ext_sth->fetchall_arrayref();
scripts/import/dbSNP/EnsemblIds.pm:	if($l->[2] ==1){
scripts/import/dbSNP/EnsemblIds.pm:	    $data{$l->[0]}{db}   = $l->[1];
scripts/import/dbSNP/EnsemblIds.pm:	    $data{$l->[0]}{desc} = $l->[4];
scripts/import/dbSNP/EnsemblIds.pm:	    $data{$l->[0]}{url}  = $l->[5];
scripts/import/dbSNP/EnsemblIds.pm:	if($l->[3] ==1){
scripts/import/dbSNP/EnsemblIds.pm:	    $data{$l->[0]}{db} = 'phencode';
scripts/import/dbSNP/EnsemblIds.pm:	    $data{$l->[0]}{phencode} = 1;
scripts/import/dbSNP/run_task.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dbSNP/run_task.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dbSNP/run_task.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dbSNP/run_task.pl:my $dbm = dbSNP::DBManager->new(
scripts/import/dbSNP/run_task.pl:$dbm->dbSNP_shared($dbSNP_shared);
scripts/import/dbSNP/run_task.pl:if (defined($ENV{'LSB_JOBINDEX'}) && -e $task_management_file) {
scripts/import/dbSNP/run_task.pl:my $task_obj = dbSNP::ImportTask->new(
scripts/import/dbSNP/run_task.pl:$task_obj->$task(@args);
scripts/import/dbSNP/DBManager.pm:Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dbSNP/DBManager.pm:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dbSNP/DBManager.pm:     http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dbSNP/DBManager.pm:  $registry->load_all( $registryfile );
scripts/import/dbSNP/DBManager.pm:  $ref->{'registryfile'} = $registryfile;
scripts/import/dbSNP/DBManager.pm:  $ref->{'registry'} = $registry;
scripts/import/dbSNP/DBManager.pm:  $ref->{'species'} = $species;
scripts/import/dbSNP/DBManager.pm:  $ref->{'bulk_insert_buffer_size'} = (512 * 1024 * 1024);
scripts/import/dbSNP/DBManager.pm:  $ref->{'schema_name'}  = $schema if defined $schema;    
scripts/import/dbSNP/DBManager.pm:    $self->{'dbSNP_shared'} = $shared;
scripts/import/dbSNP/DBManager.pm:  return $self->{'dbSNP_shared'};
scripts/import/dbSNP/DBManager.pm:  my $adaptor =  $self->get_dbAdaptor('dbsnp');
scripts/import/dbSNP/DBManager.pm:  if(defined $self->{'schema_name'} && $self->{'schema_name'} =~/\w+/){
scripts/import/dbSNP/DBManager.pm:      print "setting search path for postgreSQL: " .$self->{'schema_name'} . ", " . $self->{'dbSNP_shared'} ."\n";
scripts/import/dbSNP/DBManager.pm:      my $sth = "SET search_path TO $self->{'schema_name'},$self->{'dbSNP_shared'},public";
scripts/import/dbSNP/DBManager.pm:      $adaptor->dbc()->do($sth);
scripts/import/dbSNP/DBManager.pm:  return $self->get_dbAdaptor('variation');
scripts/import/dbSNP/DBManager.pm:  return $self->get_dbAdaptor('core');
scripts/import/dbSNP/DBManager.pm:  return $self->get_dbAdaptor('intvar', 'multi');
scripts/import/dbSNP/DBManager.pm:  my $species = shift || $self->{'species'};
scripts/import/dbSNP/DBManager.pm:  if (!defined($self->{$type})) {
scripts/import/dbSNP/DBManager.pm:    my $dba = $self->{'registry'}->get_DBAdaptor($species,$type) or die ("Could not get DBadaptor to $type database");
scripts/import/dbSNP/DBManager.pm:    #$dba->dbc->disconnect_when_inactive(1);
scripts/import/dbSNP/DBManager.pm:    $dba->dbc->{mysql_auto_reconnect} = 1;
scripts/import/dbSNP/DBManager.pm:          bulk_insert_buffer_size=$self->{'bulk_insert_buffer_size'}
scripts/import/dbSNP/DBManager.pm:      $dba->dbc->do($stmt);
scripts/import/dbSNP/DBManager.pm:    $self->{$type} = $dba;
scripts/import/dbSNP/DBManager.pm:  return $self->{$type};
scripts/import/dbSNP/DBManager.pm:  return $self->{'registryfile'};
scripts/import/dbSNP/DBManager.pm:  return $self->{'registry'};
scripts/import/dbSNP/DBManager.pm:  return $self->{'species'};
scripts/import/dbSNP/DBManager.pm:  return $self->{'schema'};
scripts/import/dbSNP/ImportTask.pm:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dbSNP/ImportTask.pm:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dbSNP/ImportTask.pm:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dbSNP/ImportTask.pm:  $ref->{'db_manager'} = $dbm;
scripts/import/dbSNP/ImportTask.pm:  $ref->{'task'} = $task;
scripts/import/dbSNP/ImportTask.pm:  $ref->{'file_prefix'} = $file_prefix;
scripts/import/dbSNP/ImportTask.pm:  $ref->{'unique_suffix'} = $unique_suffix;
scripts/import/dbSNP/ImportTask.pm:  $ref->{'log'} = $log;
scripts/import/dbSNP/ImportTask.pm:### from  local dbSNP database - mysql/SQLserver version
scripts/import/dbSNP/ImportTask.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/ImportTask.pm:  my $dbm  = $self->{'db_manager'};
scripts/import/dbSNP/ImportTask.pm:  my $allele_sth =  $self->get_allele_sth();
scripts/import/dbSNP/ImportTask.pm:  my $handle_ext_sth  = $self->get_handle_ext_sth();
scripts/import/dbSNP/ImportTask.pm:  my $handle_ins_sth  = $self->get_handle_ins_sth();
scripts/import/dbSNP/ImportTask.pm:  my $population_sth = $self->get_pop_sth();
scripts/import/dbSNP/ImportTask.pm:  my $variation_ids = $self->get_var_ss_map($task_start, $task_end);
scripts/import/dbSNP/ImportTask.pm:  my $ss_no_freq_stmt = $self->get_no_freq_stmt($task_start, $task_end);
scripts/import/dbSNP/ImportTask.pm:  my  $ss_with_freq_stmt = $self->get_with_freq_stmt($task_start,$task_end );
scripts/import/dbSNP/ImportTask.pm: my $ss_with_freq_sth = $dbm->dbSNP()->dbc->prepare($ss_with_freq_stmt)  ||
scripts/import/dbSNP/ImportTask.pm:  $ss_with_freq_sth->execute()||
scripts/import/dbSNP/ImportTask.pm:  while( my $line = $ss_with_freq_sth->fetchrow_arrayref()){
scripts/import/dbSNP/ImportTask.pm:      unless ($variation_ids->{$line->[0]}{'variation_id'}){ warn "Variation id not found for $line->[0]\n";}
scripts/import/dbSNP/ImportTask.pm:      ## look-ups from ensembl db
scripts/import/dbSNP/ImportTask.pm:      unless( defined $line->[6] ){ $line->[6] = 0 ; }
scripts/import/dbSNP/ImportTask.pm:      if (!exists($population{$line->[1]})) {  $population{$line->[1]} = get_population($line->[1], $population_sth);}     
scripts/import/dbSNP/ImportTask.pm:      if (!exists($handle{$line->[6]}))  {  $handle{$line->[6]}  = get_handle($line->[6], $handle_ext_sth, $handle_ins_sth);}
scripts/import/dbSNP/ImportTask.pm:      if (!exists($alleles{$line->[2]})) {  $alleles{$line->[2]} = get_allele($line->[2], $allele_sth);}   # returns alleles as  [for, rev]    
scripts/import/dbSNP/ImportTask.pm:      unless (defined $alleles{$line->[2]}->[$line->[3]]){ die "No allele for ss $line->[0] strand $line->[3]\n";}
scripts/import/dbSNP/ImportTask.pm:      ## save as done by subsnp id pop and allele (don't loose 2nd allele for non-poly)
scripts/import/dbSNP/ImportTask.pm:      $done{$line->[0]}{$line->[1]}{$alleles{$line->[2]}->[$line->[3]]} = 1;
scripts/import/dbSNP/ImportTask.pm:        ##$done{$line->[0]}{0} = 1;  ## don't want to import records without population info if records with held
scripts/import/dbSNP/ImportTask.pm:      my $row = join("\t",($variation_ids->{$line->[0]}{'variation_id'},$line->[0],$population{$line->[1]},$alleles{$line->[2]}->[$line->[3]],$line->[4],$line->[5],$handle{$line->[6]} )) ;
scripts/import/dbSNP/ImportTask.pm:  my $ss_no_freq_sth = $dbm->dbSNP()->dbc->prepare($ss_no_freq_stmt) ||
scripts/import/dbSNP/ImportTask.pm:  $ss_no_freq_sth->execute()||
scripts/import/dbSNP/ImportTask.pm:  while( my $line = $ss_no_freq_sth->fetchrow_arrayref() ){
scripts/import/dbSNP/ImportTask.pm:      unless ($variation_ids->{$line->[0]}{'variation_id'}){ warn "Variation id not found for $line->[0]\n"; next}
scripts/import/dbSNP/ImportTask.pm:      unless( defined $line->[1] ){ $line->[1] = 0; }        
scripts/import/dbSNP/ImportTask.pm:      if (!exists($population{$line->[1]})) {  $population{$line->[1]} = get_population($line->[1], $population_sth);}
scripts/import/dbSNP/ImportTask.pm:      my $sep_alleles = get_alleles_from_pattern($line->[2]);    ## Reported allele pattern [ eg A/T ]
scripts/import/dbSNP/ImportTask.pm:          if ($line->[3] ==1 && $sep_allele !~ m /[^ACGTUSWNXKBYVHMDR\-]/i ){ ##don't flip descriptions
scripts/import/dbSNP/ImportTask.pm:              $line->[2] =~/^\(\w+\)/ ?  $sep_allele = revcomp_tandem($sep_allele):           
scripts/import/dbSNP/ImportTask.pm:          next if defined  $done{$line->[0]}{$line->[1]}{$sep_allele} ;
scripts/import/dbSNP/ImportTask.pm:          my $row = join("\t",($variation_ids->{$line->[0]}{'variation_id'},$line->[0],$population{$line->[1]},$sep_allele,'\N','\N','\N' )) ;
scripts/import/dbSNP/ImportTask.pm:  print    Progress::location() . "Written no-freq data\n";
scripts/import/dbSNP/ImportTask.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/ImportTask.pm:  my $dbm  = $self->{'db_manager'};
scripts/import/dbSNP/ImportTask.pm:  my $allele_sth =  $self->get_allele_sth();
scripts/import/dbSNP/ImportTask.pm:  my $handle_ext_sth  = $self->get_handle_ext_sth();
scripts/import/dbSNP/ImportTask.pm:  my $handle_ins_sth  = $self->get_handle_ins_sth();
scripts/import/dbSNP/ImportTask.pm:  my $population_sth = $self->get_pop_sth();
scripts/import/dbSNP/ImportTask.pm:  my $variation_ids = $self->get_var_ss_map( $task_start, $task_end  );
scripts/import/dbSNP/ImportTask.pm:  my $ss_no_freq_stmt = $self->get_no_freq_stmt($task_start, $task_end);
scripts/import/dbSNP/ImportTask.pm:  my  $ss_with_freq_stmt = $self->get_with_freq_stmt($task_start,$task_end );
scripts/import/dbSNP/ImportTask.pm:  $dbm->dbSNP()->dbc->db_handle->begin_work() ||die "Error beginning : $!\n"; ;
scripts/import/dbSNP/ImportTask.pm:  $dbm->dbSNP()->dbc->do("DECLARE $cursor_name CURSOR  FOR $ss_with_freq_stmt") ||die "Failed to declare cursor :$!\n";
scripts/import/dbSNP/ImportTask.pm:      my $sth = $dbm->dbSNP()->dbc->prepare("fetch 500 from $cursor_name ")||die "Failed to prep cursor select: $!\n";
scripts/import/dbSNP/ImportTask.pm:      $sth->execute() ||die "Error getting freq data :$!\n";
scripts/import/dbSNP/ImportTask.pm:      last if 0 == $sth->rows;
scripts/import/dbSNP/ImportTask.pm:      while( my $line = $sth->fetchrow_arrayref()){
scripts/import/dbSNP/ImportTask.pm:          unless ($variation_ids->{$line->[0]}{'variation_id'}){ warn "Variation id not found for $line->[0]\n";}
scripts/import/dbSNP/ImportTask.pm:          ## look-ups from ensembl db
scripts/import/dbSNP/ImportTask.pm:          unless( defined $line->[6] ){ $line->[6] = 0 ; }
scripts/import/dbSNP/ImportTask.pm:          if (!exists($population{$line->[1]})) {  $population{$line->[1]} = get_population($line->[1], $population_sth);}     
scripts/import/dbSNP/ImportTask.pm:          if (!exists($handle{$line->[6]}))  {  $handle{$line->[6]}  = get_handle($line->[6], $handle_ext_sth, $handle_ins_sth);}
scripts/import/dbSNP/ImportTask.pm:          if (!exists($alleles{$line->[2]})) {  $alleles{$line->[2]} = get_allele($line->[2], $allele_sth);}   # returns alleles as  [for, rev]    
scripts/import/dbSNP/ImportTask.pm:          unless (defined $alleles{$line->[2]}->[$line->[3]]){ die "No allele for ss $line->[0] strand $line->[3]\n";}
scripts/import/dbSNP/ImportTask.pm:          ## save as done by subsnp id pop and allele (don't loose 2nd allele for non-poly)
scripts/import/dbSNP/ImportTask.pm:          $done{$line->[0]}{$line->[1]}{$alleles{$line->[2]}->[$line->[3]]} = 1;
scripts/import/dbSNP/ImportTask.pm:          ##$done{$line->[0]}{0} = 1;  ## don't want to import records without population info if records with held
scripts/import/dbSNP/ImportTask.pm:          my $row = join("\t",($variation_ids->{$line->[0]}{'variation_id'},$line->[0],$population{$line->[1]},$alleles{$line->[2]}->[$line->[3]],$line->[4],$line->[5],$handle{$line->[6]} )) ;
scripts/import/dbSNP/ImportTask.pm:  $dbm->dbSNP()->dbc->do("CLOSE $cursor_name");
scripts/import/dbSNP/ImportTask.pm:  $dbm->dbSNP()->dbc->db_handle->rollback();
scripts/import/dbSNP/ImportTask.pm:  return 1 if $dbm->dbCore()->species =~ /homo/i;
scripts/import/dbSNP/ImportTask.pm:  $dbm->dbSNP()->dbc->db_handle->begin_work()||die "Failed to begin work: $!\n";
scripts/import/dbSNP/ImportTask.pm:  $dbm->dbSNP()->dbc->do("DECLARE $cursor_name CURSOR  FOR $ss_no_freq_stmt")||die "Failed to declare cursor: $!\n";
scripts/import/dbSNP/ImportTask.pm:      my $sth = $dbm->dbSNP()->dbc->prepare("fetch 500 from $cursor_name") ||die "Failed to prep cursor select: $!\n";
scripts/import/dbSNP/ImportTask.pm:      $sth->execute() ||die "Error getting no-freq data :$!\n";;
scripts/import/dbSNP/ImportTask.pm:      last if 0 == $sth->rows;
scripts/import/dbSNP/ImportTask.pm:    while( my $line = $sth->fetchrow_arrayref()){
scripts/import/dbSNP/ImportTask.pm:        unless ($variation_ids->{$line->[0]}{'variation_id'}){ warn "Variation id not found for $line->[0]\n"; next}
scripts/import/dbSNP/ImportTask.pm:        unless( defined $line->[1] ){ $line->[1] = 0; }        
scripts/import/dbSNP/ImportTask.pm:        if (!exists($population{$line->[1]})) {  $population{$line->[1]} = get_population($line->[1], $population_sth);}
scripts/import/dbSNP/ImportTask.pm:        my $sep_alleles = get_alleles_from_pattern($line->[2]);    ## Reported allele pattern [ eg A/T ]
scripts/import/dbSNP/ImportTask.pm:          if ($line->[3] ==1 && $sep_allele !~ m /[^ACGTUSWNXKBYVHMDR\-]/i ){ ##don't flip descriptions
scripts/import/dbSNP/ImportTask.pm:              $line->[2] =~/^\(\w+\)/ ?  $sep_allele = revcomp_tandem($sep_allele):           
scripts/import/dbSNP/ImportTask.pm:          next if defined  $done{$line->[0]}{$line->[1]}{$sep_allele} ;
scripts/import/dbSNP/ImportTask.pm:          my $row = join("\t",($variation_ids->{$line->[0]}{'variation_id'},$line->[0],$population{$line->[1]},$sep_allele,'\N','\N','\N' )) ;
scripts/import/dbSNP/ImportTask.pm:  $dbm->dbSNP()->dbc->do("CLOSE $cursor_name ");
scripts/import/dbSNP/ImportTask.pm:  $dbm->dbSNP()->dbc->db_handle->rollback();
scripts/import/dbSNP/ImportTask.pm:  print    Progress::location() . "Written no-freq data\n";
scripts/import/dbSNP/ImportTask.pm:## extract ensembl database id for pre-imported population
scripts/import/dbSNP/ImportTask.pm:    $population_sth->execute($pop_id)|| die "Failed to find population id for $pop_id: $DBI::errstr\n";
scripts/import/dbSNP/ImportTask.pm:    my $population_id = $population_sth->fetchall_arrayref();
scripts/import/dbSNP/ImportTask.pm:    if(defined $population_id->[0]->[0]){
scripts/import/dbSNP/ImportTask.pm:        return $population_id->[0]->[0];
scripts/import/dbSNP/ImportTask.pm:    $allele_sth->execute($allele_id)|| die "Failed to find allele id for $allele_id: $DBI::errstr\n";
scripts/import/dbSNP/ImportTask.pm:    my  $alleles = $allele_sth->fetchall_arrayref();
scripts/import/dbSNP/ImportTask.pm:    return $alleles->[0];
scripts/import/dbSNP/ImportTask.pm:    my $shared_db  =  $self->{'db_manager'}->dbSNP_shared();
scripts/import/dbSNP/ImportTask.pm:    my $dbh = $self->{'db_manager'}->dbVar()->dbc();
scripts/import/dbSNP/ImportTask.pm:  my $vs_sth = $dbh->prepare($vs_stmt) ||die "ERROR preparing vs_sth: $DBI::errstr\n";
scripts/import/dbSNP/ImportTask.pm:  $vs_sth->execute($task_start,$task_end)||die "ERROR getting the SubSNPs variation id mapping: $DBI::errstr\n";
scripts/import/dbSNP/ImportTask.pm:  my $variation_ids = $vs_sth->fetchall_hashref(['subsnp_id']);
scripts/import/dbSNP/ImportTask.pm:    my $dbh        = $self->{'db_manager'}->dbSNP()->dbc();
scripts/import/dbSNP/ImportTask.pm:    my $shared_db  = $self->{'db_manager'}->dbSNP_shared();
scripts/import/dbSNP/ImportTask.pm:  my $allele_sth = $dbh->prepare($stmt)||die "ERROR preparing allele_sth: $DBI::errstr\n";
scripts/import/dbSNP/ImportTask.pm:    my $dbh = $self->{'db_manager'}->dbVar()->dbc();
scripts/import/dbSNP/ImportTask.pm:    my $population_sth = $dbh->prepare($population_stmt)||
scripts/import/dbSNP/ImportTask.pm:    my $dbh = $self->{'db_manager'}->dbVar()->dbc();
scripts/import/dbSNP/ImportTask.pm:    my $handle_ext_sth  = $dbh->prepare(qq[select handle_id from submitter_handle where handle =?])||die "ERROR preparing handle_ins_sth: $DBI::errstr\n";
scripts/import/dbSNP/ImportTask.pm:    my $dbh = $self->{'db_manager'}->dbVar()->dbc();
scripts/import/dbSNP/ImportTask.pm:    my $handle_ins_sth  = $dbh->prepare(qq[insert into submitter_handle (handle) values (?)]);
scripts/import/dbSNP/ImportTask.pm:    $handle_ext_sth->execute($handle)|| die "Failed to find handle id for $handle: $DBI::errstr\n";
scripts/import/dbSNP/ImportTask.pm:    my  $id = $handle_ext_sth->fetchall_arrayref();
scripts/import/dbSNP/ImportTask.pm:    unless(defined $id->[0]->[0]){ ## handle unknown => enter
scripts/import/dbSNP/ImportTask.pm:       $handle_ins_sth->execute($handle)|| die "Failed to insert handle id for $handle: $DBI::errstr\n";
scripts/import/dbSNP/ImportTask.pm:        $handle_ext_sth->execute($handle)|| die "Failed to find handle id for $handle: $DBI::errstr\n";
scripts/import/dbSNP/ImportTask.pm:        $id = $handle_ext_sth->fetchall_arrayref();
scripts/import/dbSNP/ImportTask.pm:   return $id->[0]->[0];
scripts/import/dbSNP/ImportTask.pm:  my $logh = $self->{'log'};
scripts/import/dbSNP/ImportTask.pm:  print $logh Progress::location() . "\tDumping from $subind_table to $loadfile, processing genotype data for submitted_ind_ids $start - $end\n";  
scripts/import/dbSNP/ImportTask.pm:  my $dbm = $self->{'db_manager'};
scripts/import/dbSNP/ImportTask.pm:  my $shared_db = $dbm->dbSNP_shared();
scripts/import/dbSNP/ImportTask.pm:  my $dbVar = $dbm->dbVar();
scripts/import/dbSNP/ImportTask.pm:  my $dbSNP = $dbm->dbSNP();
scripts/import/dbSNP/ImportTask.pm:  my $stmt; ## re-used for multiple queries
scripts/import/dbSNP/ImportTask.pm:  #Order the results by subsnp_id so that we can do the subsnp_id -> variation_id lookup more efficiently
scripts/import/dbSNP/ImportTask.pm:  my $vs_sth = $dbVar->dbc()->prepare($stmt);
scripts/import/dbSNP/ImportTask.pm:  my $sample_sth = $dbVar->dbc()->prepare($stmt);
scripts/import/dbSNP/ImportTask.pm:  my $allele_sth = $self->get_allele_sth();
scripts/import/dbSNP/ImportTask.pm:  %variation_ids = %{read_subsnp_mapping($mapping_file)} if (defined($mapping_file) && -e $mapping_file);
scripts/import/dbSNP/ImportTask.pm:  # Open a file handle to the file that will be used for loading the multi-bp genotypes
scripts/import/dbSNP/ImportTask.pm:   $dbSNP->dbc()->db_handle->begin_work();
scripts/import/dbSNP/ImportTask.pm:   $dbSNP->dbc()->do("DECLARE $cursor_name  CURSOR  FOR $genotype_ext_stmt");
scripts/import/dbSNP/ImportTask.pm:  #Now, loop over the import data and print it to the tempfile so we can import the data. Replace the allele_id with the corresponding allele on-the-fly
scripts/import/dbSNP/ImportTask.pm:     my $csth = $dbSNP->dbc()->prepare("fetch 250 from $cursor_name ");
scripts/import/dbSNP/ImportTask.pm:     $csth->execute()|| die "Failed to execute fetch from  $cursor_name & $genotype_ext_stmt";
scripts/import/dbSNP/ImportTask.pm:     last if 0 == $csth->rows;
scripts/import/dbSNP/ImportTask.pm:     while ( my $data = $csth->fetchrow_arrayref() ) {
scripts/import/dbSNP/ImportTask.pm:    my $subsnp_id   = $data->[0];
scripts/import/dbSNP/ImportTask.pm:    my $ind_sub_id  = $data->[1];
scripts/import/dbSNP/ImportTask.pm:    my $allele_id_1 = $data->[2];
scripts/import/dbSNP/ImportTask.pm:    my $allele_id_2 = $data->[3];
scripts/import/dbSNP/ImportTask.pm:    my $sub_strand  = $data->[4];
scripts/import/dbSNP/ImportTask.pm:    my $rev_alleles = $data->[5];
scripts/import/dbSNP/ImportTask.pm:    my $pattern_length = $data->[6];
scripts/import/dbSNP/ImportTask.pm:      $vs_sth->bind_param(1,$subsnp_id,SQL_INTEGER);
scripts/import/dbSNP/ImportTask.pm:      $vs_sth->execute();
scripts/import/dbSNP/ImportTask.pm:      $vs_sth->bind_columns(\$vs_subsnp_id,\$variation_id,\$substrand_reversed_flag);
scripts/import/dbSNP/ImportTask.pm:      $vs_sth->fetch();
scripts/import/dbSNP/ImportTask.pm:    my $reverse = ((($rev_alleles + $sub_strand + $variation_ids{$subsnp_id}->[1])%2 != 0) ? 1 : 0);
scripts/import/dbSNP/ImportTask.pm:    my $allele_1 = $alleles{$allele_id_1}->[$reverse];
scripts/import/dbSNP/ImportTask.pm:    my $allele_2 = $alleles{$allele_id_2}->[$reverse];
scripts/import/dbSNP/ImportTask.pm:    my $row = join("\t",($variation_ids{$subsnp_id}->[0],$subsnp_id,$sample{$ind_sub_id},$allele_1,$allele_2));
scripts/import/dbSNP/ImportTask.pm:    if ((length($allele_2) == 1 && length($allele_2) == 1) && $allele_1 ne '-' && $allele_2 ne '-') {
scripts/import/dbSNP/ImportTask.pm:  $dbSNP->dbc()->do("CLOSE $cursor_name");
scripts/import/dbSNP/ImportTask.pm:   #Now, loop over the import data and print it to the tempfile so we can import the data. Replace the allele_id with the corresponding allele on-the-fly
scripts/import/dbSNP/ImportTask.pm:    my $subind_sth = $dbSNP->dbc()->prepare($genotype_ext_stmt) ||die;
scripts/import/dbSNP/ImportTask.pm:     $subind_sth->execute()||die;
scripts/import/dbSNP/ImportTask.pm:    while ( my $data = $subind_sth->fetchrow_arrayref() ) {
scripts/import/dbSNP/ImportTask.pm:    my $subsnp_id   = $data->[0];
scripts/import/dbSNP/ImportTask.pm:    my $ind_sub_id  = $data->[1];
scripts/import/dbSNP/ImportTask.pm:    my $allele_id_1 = $data->[2];
scripts/import/dbSNP/ImportTask.pm:    my $allele_id_2 = $data->[3];
scripts/import/dbSNP/ImportTask.pm:    my $sub_strand  = $data->[4];
scripts/import/dbSNP/ImportTask.pm:    my $rev_alleles = $data->[5];
scripts/import/dbSNP/ImportTask.pm:    my $pattern_length = $data->[6];
scripts/import/dbSNP/ImportTask.pm:      $vs_sth->bind_param(1,$subsnp_id,SQL_INTEGER);
scripts/import/dbSNP/ImportTask.pm:      $vs_sth->execute();
scripts/import/dbSNP/ImportTask.pm:      $vs_sth->bind_columns(\$vs_subsnp_id,\$variation_id,\$substrand_reversed_flag);
scripts/import/dbSNP/ImportTask.pm:      $vs_sth->fetch();
scripts/import/dbSNP/ImportTask.pm:    my $reverse = ((($rev_alleles + $sub_strand + $variation_ids{$subsnp_id}->[1])%2 != 0) ? 1 : 0);
scripts/import/dbSNP/ImportTask.pm:    my $allele_1 = $alleles{$allele_id_1}->[$reverse];
scripts/import/dbSNP/ImportTask.pm:    my $allele_2 = $alleles{$allele_id_2}->[$reverse];
scripts/import/dbSNP/ImportTask.pm:    my $row = join("\t",($variation_ids{$subsnp_id}->[0],$subsnp_id,$sample{$ind_sub_id},$allele_1,$allele_2));
scripts/import/dbSNP/ImportTask.pm:    if ((length($allele_2) == 1 && length($allele_2) == 1) && $allele_1 ne '-' && $allele_2 ne '-') {
scripts/import/dbSNP/ImportTask.pm:  $sample_sth->execute($ind_sub_id);
scripts/import/dbSNP/ImportTask.pm:  $sample_sth->bind_columns(\$sample_id);
scripts/import/dbSNP/ImportTask.pm:  $sample_sth->fetch();
scripts/import/dbSNP/ImportTask.pm:  my $logh = $self->{'log'};  
scripts/import/dbSNP/ImportTask.pm:  my $dbm = $self->{'db_manager'};
scripts/import/dbSNP/ImportTask.pm:  my $dbVar = $dbm->dbVar();
scripts/import/dbSNP/ImportTask.pm:  $dbVar->dbc()->do($stmt);
scripts/import/dbSNP/ImportTask.pm:  loadfile($loadfile,$dbVar->dbc(),$dst_table,@args);
scripts/import/dbSNP/ImportTask.pm:  $dbVar->dbc()->do($stmt);
scripts/import/dbSNP/Human.pm:Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dbSNP/Human.pm:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dbSNP/Human.pm:     http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dbSNP/Human.pm:    $self->SUPER::dump_dbSNP();
scripts/import/dbSNP/Human.pm:    #$self->dump_HGVbaseIDs();
scripts/import/dbSNP/Human.pm:    #$self->dump_TSCIDs();
scripts/import/dbSNP/Human.pm:    $self->dump_AFFYIDs();
scripts/import/dbSNP/Human.pm:    #get mitochondrial SNPs provided by Yuan in .tb file formats---DON'T RUN THIS ANYMORE
scripts/import/dbSNP/Human.pm:    #$self->dump_mitocondrialSNPs();
scripts/import/dbSNP/Human.pm:    #copy the file with the rs-> HGVbaseID information to the temp folder
scripts/import/dbSNP/Human.pm:    system "gunzip -c dbSNP/rs_hgvbase.txt.gz > " . $self->{'tmpdir'} . "/" . $self->{'tmpfile'};
scripts/import/dbSNP/Human.pm:    create_and_load($self->{'dbVar'},"tmp_rs_hgvbase","rsID *","HGVbaseID");
scripts/import/dbSNP/Human.pm:    $self->{'dbVar'}->do(qq{INSERT INTO source (name,version) values ('HGVbase',15)
scripts/import/dbSNP/Human.pm:    my $source_id = $self->{'dbVar'}->db_handle->{'mysql_insertid'}; #get the last autoinc id from the database (the one from the HGVbase source)
scripts/import/dbSNP/Human.pm:    $self->{'dbVar'}->do(qq{INSERT INTO variation_synonym (variation_id,source_id,name)
scripts/import/dbSNP/Human.pm:    $self->{'dbVar'}->do(qq{DROP TABLE tmp_rs_hgvbase
scripts/import/dbSNP/Human.pm:     $self->{'dbVar'}->do(qq{INSERT INTO source (name,version) values ('TSC',1)
scripts/import/dbSNP/Human.pm:     my $source_id = $self->{'dbVar'}->db_handle->{'mysql_insertid'}; #get the last autoinc id in the database (the one from the TSC source)
scripts/import/dbSNP/Human.pm:     dumpSQL($self->{'dbSNP'},$stmt);
scripts/import/dbSNP/Human.pm:     create_and_load($self->{'dbVar'},"tmp_rs_TSC","rsID *","source_id","TSCid");
scripts/import/dbSNP/Human.pm:     $self->{'dbVar'}->do(qq{ INSERT IGNORE INTO variation_synonym (variation_id, source_id, name)
scripts/import/dbSNP/Human.pm:     $self->{'dbVar'}->do(qq{DROP TABLE tmp_rs_TSC
scripts/import/dbSNP/Human.pm:   dumpSQL($self->{'dbSNP'},$stmt);
scripts/import/dbSNP/Human.pm:   create_and_load($self->{'dbVar'},"tmp_rs_AFFY","rsID *","AFFYid", "affy_name");
scripts/import/dbSNP/Human.pm: #    $self->{'dbVar'}->do(qq{CREATE TABLE $table\_name_pair like $table.name_pair});
scripts/import/dbSNP/Human.pm: #    $self->{'dbVar'}->do(qq{insert into $table\_name_pair select * from $table.name_pair});
scripts/import/dbSNP/Human.pm: #    $self->{'dbVar'}->do(qq{insert ignore into $table\_name_pair
scripts/import/dbSNP/Human.pm:     my $source_id_ref = $self->{'dbVar'}->db_handle->selectall_arrayref(qq{
scripts/import/dbSNP/Human.pm:     my $source_id = $source_id_ref->[0][0];
scripts/import/dbSNP/Human.pm:       $self->{'dbVar'}->do(qq{insert into source (name) values("$source_name")});
scripts/import/dbSNP/Human.pm:       $source_id = $self->{'dbVar'}->db_handle->{'mysql_insertid'};
scripts/import/dbSNP/Human.pm:     $self->{'dbVar'}->do(qq{ INSERT IGNORE INTO variation_synonym_test (variation_id, source_id, name)
scripts/import/dbSNP/Human.pm:     #$self->{'dbVar'}->do(qq{update tmp_rs_AFFY_test t, rsHist h set t.rsID=h.rsCurrent where t.rsID=h.rsHigh});
scripts/import/dbSNP/Human.pm:     $self->{'dbVar'}->do(qq{ INSERT IGNORE INTO variation_synonym_test (variation_id, source_id, name)
scripts/import/dbSNP/Human.pm:    #$self->{'dbVar'}->do(qq{DROP TABLE $table\_name_pair});
scripts/import/dbSNP/Human.pm:    my $slice_adaptor = $self->{'dbCore'}->get_SliceAdaptor();
scripts/import/dbSNP/Human.pm:     $self->{'dbVar'}->do(qq{INSERT INTO source (name) values ('mitomap.com')
scripts/import/dbSNP/Human.pm:     my $source_id = $self->{'dbVar'}->dbh()->{'mysql_insertid'}; #get the last autoinc id in the database (the one from the mitomap.com source)
scripts/import/dbSNP/Human.pm:    $self->read_RefSNP(\%mitoSNPs,'/ecs2/scratch4/yuan/hum/MT_35/RefSNP.tb');
scripts/import/dbSNP/Human.pm:    $self->read_ContigHit(\%mitoSNPs,'/ecs2/scratch4/yuan/hum/MT_35/ContigHit.tb');
scripts/import/dbSNP/Human.pm:	if ($mitoSNPs{$snp}{'status'} eq 'by-other-pop'){
scripts/import/dbSNP/Human.pm:         $self->{'dbVar'}->do(qq{INSERT INTO variation (source_id,name,validation_status) VALUES ($source_id, "$mitoSNPs{$snp}{'name'}", $status);
scripts/import/dbSNP/Human.pm:         $variation_id = $self->{'dbVar'}->dbh()->{'mysql_insertid'}; #get the last autoinc id in the database (the in the variation table)
scripts/import/dbSNP/Human.pm:	if (!exists $region->{$mitoSNPs{$snp}{'region'}}){
scripts/import/dbSNP/Human.pm:	    $slice = $slice_adaptor->fetch_by_region('toplevel',$mitoSNPs{$snp}{'region'}); #will get the slice for the region where the SNP is present
scripts/import/dbSNP/Human.pm:	    $region->{$mitoSNPs{$snp}{'region'}} = $slice_adaptor->get_seq_region_id($slice); #get the seq_region_id and store it in a hash
scripts/import/dbSNP/Human.pm:	$seq_region_id = $region->{$mitoSNPs{$snp}{'region'}};
scripts/import/dbSNP/Human.pm:         $self->{'dbVar'}->do(qq{INSERT INTO flanking_sequence (variation_id,seq_region_id,seq_region_strand,up_seq,down_seq)
scripts/import/dbSNP/Human.pm:             $self->{'dbVar'}->do(qq{INSERT INTO allele (variation_id, allele) VALUES ($variation_id,"$allele")
scripts/import/dbSNP/Human.pm:         $self->{'dbVar'}->do(qq{INSERT INTO variation_feature (variation_id, seq_region_id,	
scripts/import/dbSNP/Human.pm:	$snps->{$snp_id}->{'name'} = $snp_name;
scripts/import/dbSNP/Human.pm:	$snps->{$snp_id}->{'alleles'} = $alleles;
scripts/import/dbSNP/Human.pm:	$snps->{$snp_id}->{'up_seq'} = $up_seq;
scripts/import/dbSNP/Human.pm:	$snps->{$snp_id}->{'down_seq'} = $down_seq;
scripts/import/dbSNP/Human.pm:	$snps->{$snp_id}->{'status'} = $status;
scripts/import/dbSNP/Human.pm:	$snps->{$snp_id}->{'region'} = $1;
scripts/import/dbSNP/Human.pm:	$snps->{$snp_id}->{'strand'} = $strand;
scripts/import/dbSNP/Human.pm:	$snps->{$snp_id}->{'start'} = $start;
scripts/import/dbSNP/Human.pm:	$snps->{$snp_id}->{'end'} = $end;
scripts/import/dbSNP/MappingChromosome.pm:Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dbSNP/MappingChromosome.pm:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dbSNP/MappingChromosome.pm:     http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dbSNP/MappingChromosome.pm:  $self->{'dbVar'}->do(qq{RENAME TABLE variation_feature TO variation_feature_before_mapping});
scripts/import/dbSNP/MappingChromosome.pm:  $self->{'dbVar'}->do(qq{CREATE TABLE variation_feature LIKE variation_feature_before_mapping});
scripts/import/dbSNP/MappingChromosome.pm:  $self->{'dbVar'}->do(qq{CREATE TABLE IF NOT EXISTS seq_region(
scripts/import/dbSNP/MappingChromosome.pm:  # Create hash of top-level seq_region_id keyed by seq_region_name
scripts/import/dbSNP/MappingChromosome.pm:  my $sth1 = $self->{'dbCore'}->dbc->prepare (qq{
scripts/import/dbSNP/MappingChromosome.pm:  $sth1->execute();
scripts/import/dbSNP/MappingChromosome.pm:  $sth1->bind_columns(\$seq_region_id,\$seq_region_name);
scripts/import/dbSNP/MappingChromosome.pm:  while ($sth1->fetch) {
scripts/import/dbSNP/MappingChromosome.pm:    $self->{'dbVar'}->do(qq{INSERT IGNORE INTO seq_region(seq_region_id,name)values($seq_region_id,"$seq_region_name")});
scripts/import/dbSNP/MappingChromosome.pm:  $sth1->finish();
scripts/import/dbSNP/MappingChromosome.pm:#  open (FH, ">" . $self->{'tmpdir'} . "/" . $self->{'tmpfile'} );
scripts/import/dbSNP/MappingChromosome.pm:  my $mapping_file_dir = $self->{'mapping_file_dir'};
scripts/import/dbSNP/MappingChromosome.pm:  if (-f "$mapping_file_dir") {
scripts/import/dbSNP/MappingChromosome.pm:    $ar[-1] = "THREE_MAPPINGS";
scripts/import/dbSNP/MappingChromosome.pm:  elsif (-d "$mapping_file_dir") {
scripts/import/dbSNP/MappingChromosome.pm:  $self->{'dbVar'}->do(qq{CREATE TABLE IF NOT EXISTS THREE_MAPPINGS (name varchar(15), unique key name(name))});
scripts/import/dbSNP/MappingChromosome.pm:  system("cp  $three_mappings " . $self->{'tmpdir'} . "/" . $self->{'tmpfile'});
scripts/import/dbSNP/MappingChromosome.pm:  load($self->{'dbVar'}, "THREE_MAPPINGS", "name");
scripts/import/dbSNP/MappingChromosome.pm:  $self->{'dbVar'}->do(qq{insert ignore into failed_variation (variation_id,failed_description_id) select v.variation_id,1 from variation v, THREE_MAPPINGS t where v.name=t.name});
scripts/import/dbSNP/MappingChromosome.pm:  open (FH, ">" . $self->{'tmpdir'} . "/" . $self->{'tmpfile'} );
scripts/import/dbSNP/MappingChromosome.pm:    if( $slice_name =~ /-/ ){
scripts/import/dbSNP/MappingChromosome.pm:      # Old style; <SRname>-<SRstart>-<SRend>
scripts/import/dbSNP/MappingChromosome.pm:          = split /\-/, $slice_name;
scripts/import/dbSNP/MappingChromosome.pm:      # New style: uses Bio::EnsEMBL::Slice->name
scripts/import/dbSNP/MappingChromosome.pm:      # Not in cache - query database 
scripts/import/dbSNP/MappingChromosome.pm:      my $sth = $self->{'dbCore'}->dbc->prepare (qq{SELECT seq_region_id from seq_region where name = ?});
scripts/import/dbSNP/MappingChromosome.pm:      $sth->execute("$seq_region_name");
scripts/import/dbSNP/MappingChromosome.pm:      $seq_region_id = $sth->fetchrow_array();
scripts/import/dbSNP/MappingChromosome.pm:      $new_seq_region_start = $seq_region_start + $start -1;
scripts/import/dbSNP/MappingChromosome.pm:      $new_seq_region_end   = $seq_region_start + $end   -1;
scripts/import/dbSNP/MappingChromosome.pm:    $strand = ($strand eq "+") ? 1 : -1;
scripts/import/dbSNP/MappingChromosome.pm:  create_and_load( $self->{'dbVar'}, 
scripts/import/dbSNP/MappingChromosome.pm:  # Copy from tmp variation_feature to final variation_feature, think about multi-mapping
scripts/import/dbSNP/MappingChromosome.pm:  $self->{'dbVar'}->do(qq{
scripts/import/dbSNP/MappingChromosome.pm:   $self->{'dbVar'}->do(qq{
scripts/import/dbSNP/MappingChromosome.pm:   $self->{'dbVar'}->do(qq{
scripts/import/dbSNP/MappingChromosome.pm:  $self->{'dbVar'}->do(qq{
scripts/import/dbSNP/MappingChromosome.pm:  $self->{'dbVar'}->do(qq{UPDATE variation_feature vf, variation_feature_before_mapping vfm 
scripts/import/dbSNP/MappingChromosome.pm:  $self->{'dbVar'}->do(qq{UPDATE variation_feature vf, tmp_genotyped_var tgv
scripts/import/dbSNP/MappingChromosome.pm:  #$self->{'dbVar'}->do(qq{DROP TABLE tmp_variation_feature});
scripts/import/dbSNP/MappingChromosome.pm:  #$self->{'dbVar'}->do(qq{DROP TABLE tmp_genotyped_var});
scripts/import/import_Phencode.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_Phencode.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_Phencode.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_Phencode.pl:   - extracts data from local phencode database
scripts/import/import_Phencode.pl:        - variants with multiple or inconsistent positions are skipped 
scripts/import/import_Phencode.pl:   - runs QC
scripts/import/import_Phencode.pl:        - bad alleles flagged
scripts/import/import_Phencode.pl:        - 4-allele substitutions flagged
scripts/import/import_Phencode.pl:        - reference miss-matches flagged
scripts/import/import_Phencode.pl:        - inconsistent coordinates flagged
scripts/import/import_Phencode.pl:   - imports data to ensembl schema
scripts/import/import_Phencode.pl:        - variants =< 50 bases are variations
scripts/import/import_Phencode.pl:        - variants > 50 bases are structural variations
scripts/import/import_Phencode.pl:        - variants already imported from dbSNP with Phencode ids are not re-entered
scripts/import/import_Phencode.pl:   - creates variation set
scripts/import/import_Phencode.pl:    - loaded attribs for fail statuses
scripts/import/import_Phencode.pl:    - seq_region table
scripts/import/import_Phencode.pl:    - dbSNP load with Phencode synonyms for redundancy checking
scripts/import/import_Phencode.pl:$reg->load_all($registry_file);
scripts/import/import_Phencode.pl:my $varfeat_adaptor   = $reg->get_adaptor('homo_sapiens', 'variation', 'variationfeature');
scripts/import/import_Phencode.pl:my $variation_adaptor = $reg->get_adaptor('homo_sapiens', 'variation', 'variation');
scripts/import/import_Phencode.pl:my $allele_adaptor    = $reg->get_adaptor('homo_sapiens', 'variation', 'allele');
scripts/import/import_Phencode.pl:my $db = Bio::DB::Fasta->new( $fasta_file );
scripts/import/import_Phencode.pl:                     "version" => "14-Nov-2012",
scripts/import/import_Phencode.pl:my $seq_ids   = get_seq_ids($varfeat_adaptor->dbc );
scripts/import/import_Phencode.pl:my $already_loaded = get_dbSNP_data($varfeat_adaptor->dbc );
scripts/import/import_Phencode.pl:    ## ~40 with same name, different locations (in repeat) - skip these
scripts/import/import_Phencode.pl:    next if  $var_counts->{$a[0]} > 1;
scripts/import/import_Phencode.pl:    next if $already_loaded->{$a[0]};
scripts/import/import_Phencode.pl:    my $ref_len = $a[4] - $a[3];
scripts/import/import_Phencode.pl:        my $dbID = insert_svar($varfeat_adaptor->dbc, \@a, $source_ob ,$seq_ids );
scripts/import/import_Phencode.pl:add_to_set( $varfeat_adaptor->dbc, \%new_var, \%new_svar);
scripts/import/import_Phencode.pl:    if ($line->[5] eq "-1" && $line->[1] !~/Phencode|del|ins/i){
scripts/import/import_Phencode.pl:        my @al = split(/\//,$line->[1]);
scripts/import/import_Phencode.pl:        $line->[1] = '';
scripts/import/import_Phencode.pl:            $line->[1] .= $al . "/";
scripts/import/import_Phencode.pl:        $line->[1] =~ s/\/$//;
scripts/import/import_Phencode.pl:        $line->[5] = 1;
scripts/import/import_Phencode.pl:    return $var->dbID();
scripts/import/import_Phencode.pl:    my $dbh = DBI->connect('dbi:mysql:phencode:ens-variation2:3306', $phenu, $phenp, undef);
scripts/import/import_Phencode.pl:    my $variant_ext_sth = $dbh->prepare(qq[ SELECT gv.id,
scripts/import/import_Phencode.pl:    $variant_ext_sth->execute() ||die;
scripts/import/import_Phencode.pl:    my $data = $variant_ext_sth->fetchall_arrayref();
scripts/import/import_Phencode.pl:        next unless $l->[2] =~ /\:g|\:c/;
scripts/import/import_Phencode.pl:        $l->[3] =~ s/chr//;
scripts/import/import_Phencode.pl:        $l->[4]++;
scripts/import/import_Phencode.pl:        ## hgvs but on non-reference seq => switch seq name & coords
scripts/import/import_Phencode.pl:        my ($reported_seq,$change) = split(/\:g|\:c\./,$l->[2], 2);
scripts/import/import_Phencode.pl:            ($ref_allele, $alt_allele) = get_hgvs_alleles( $l->[2] );
scripts/import/import_Phencode.pl:            warn "skipping $l->[2]  - $@\n";
scripts/import/import_Phencode.pl:            $ref_allele =  $db->seq($l->[3], $l->[4], $l->[5]) ;
scripts/import/import_Phencode.pl:            reverse_comp(\$ref_allele )if $l->[6] eq "-";
scripts/import/import_Phencode.pl:            my $dup_allele =  $db->seq($l->[3], $l->[4], $l->[5]) ;
scripts/import/import_Phencode.pl:            reverse_comp(\$ref_allele )if $l->[6] eq "-";
scripts/import/import_Phencode.pl:            warn "Skipping $l->[2] from $l->[7] as could not determine alleles\n";
scripts/import/import_Phencode.pl:        my $start = $l->[4];
scripts/import/import_Phencode.pl:        my $end   = $l->[5];
scripts/import/import_Phencode.pl:        if ($l->[6] eq "+"){
scripts/import/import_Phencode.pl:        elsif ($l->[6] eq "-"){
scripts/import/import_Phencode.pl:            $strand = -1;
scripts/import/import_Phencode.pl:            die "Unknown strand: $l->[6] \n";
scripts/import/import_Phencode.pl:                    "seqreg_name" =>  $l->[3], 
scripts/import/import_Phencode.pl:                    "label"       =>  $l->[2], 
scripts/import/import_Phencode.pl:                    "name"        =>  $l->[0],
scripts/import/import_Phencode.pl:                    "source"      =>  $l->[7],
scripts/import/import_Phencode.pl:        $count{$l->[0]}++;
scripts/import/import_Phencode.pl:    my $all_possible_check = check_four_bases($var->{allele});
scripts/import/import_Phencode.pl:    ## Type 14 resolve ambiguities before reference check - flag variants & alleles as fails
scripts/import/import_Phencode.pl:    my $is_ambiguous = check_for_ambiguous_alleles( $var->{allele} );
scripts/import/import_Phencode.pl:    # Extract reference sequence to run ref checks [ compliments for reverse strand multi-mappers]    
scripts/import/import_Phencode.pl:    my $exp_ref = (split/\//, $var->{allele} )[0] ; 
scripts/import/import_Phencode.pl:    my $ref = (split/\//, $var->{allele} )[0];
scripts/import/import_Phencode.pl:    my $match_coord_length = check_variant_size( $var->{start}, $var->{end}, $ref);
scripts/import/import_Phencode.pl:    my $source_adaptor = $reg->get_adaptor('homo_sapiens', 'variation', 'source');
scripts/import/import_Phencode.pl:    my $source = $source_adaptor->fetch_by_name($source_data->{name});
scripts/import/import_Phencode.pl:    $source = Bio::EnsEMBL::Variation::Source->new
scripts/import/import_Phencode.pl:       (-name        => $source_data->{name},
scripts/import/import_Phencode.pl:        -version     => $source_data->{version},
scripts/import/import_Phencode.pl:        -description => $source_data->{desc},
scripts/import/import_Phencode.pl:        -url         => $source_data->{url},
scripts/import/import_Phencode.pl:    $source_adaptor->store($source);
scripts/import/import_Phencode.pl:    die "Failed to find or enter source for $source_data->{name} \n";
scripts/import/import_Phencode.pl:    my $seq_ext_sth = $dbh->prepare(qq[ select seq_region_id, name from seq_region]);
scripts/import/import_Phencode.pl:    $seq_ext_sth->execute();
scripts/import/import_Phencode.pl:    my $dat = $seq_ext_sth->fetchall_arrayref();
scripts/import/import_Phencode.pl:        $seq_ids{$l->[1]} = $l->[0];
scripts/import/import_Phencode.pl:    my $var = Bio::EnsEMBL::Variation::Variation->new_fast({
scripts/import/import_Phencode.pl:        name             => $line->[0],
scripts/import/import_Phencode.pl:        _source_id       => $source_ob->dbID,
scripts/import/import_Phencode.pl:    $adaptor->store($var);
scripts/import/import_Phencode.pl:    if(defined $line->[8] && $line->[8] =~ /\d+/){
scripts/import/import_Phencode.pl:        if( $line->[8] =~/\,/){  @fails = split /\,/, $line->[8];}
scripts/import/import_Phencode.pl:        else{ push @fails , $line->[8] ;} 
scripts/import/import_Phencode.pl:        my $var_id = $var->dbID();
scripts/import/import_Phencode.pl:               $adaptor->dbc->do(qq[ insert into failed_variation (variation_id, failed_description_id) values ($var_id, $type ) ]);
scripts/import/import_Phencode.pl:    my $varfeat = Bio::EnsEMBL::Variation::VariationFeature->new_fast({
scripts/import/import_Phencode.pl:        variation_name   => $line->[0],
scripts/import/import_Phencode.pl:        _source_id       => $source_ob->dbID,
scripts/import/import_Phencode.pl:        allele_string    => $line->[1], 
scripts/import/import_Phencode.pl:        _variation_id    => $var->dbID(),                                          
scripts/import/import_Phencode.pl:        seq_region_id    => $seq_ids->{$line->[2]},
scripts/import/import_Phencode.pl:        start            => $line->[3],
scripts/import/import_Phencode.pl:        end              => $line->[4],
scripts/import/import_Phencode.pl:        strand           => $line->[5],
scripts/import/import_Phencode.pl:    $adaptor->store($varfeat);
scripts/import/import_Phencode.pl:    my @alleles = split/\//, $line->[1];
scripts/import/import_Phencode.pl:        my $al = Bio::EnsEMBL::Variation::Allele->new_fast({
scripts/import/import_Phencode.pl:        $adaptor->store($al);
scripts/import/import_Phencode.pl:    my $svar_ins_sth = $dbh->prepare(qq[ insert into structural_variation 
scripts/import/import_Phencode.pl:    my $svar_ext_sth = $dbh->prepare(qq[ select structural_variation_id from structural_variation 
scripts/import/import_Phencode.pl:   my $svarf_ins_sth = $dbh->prepare(qq[ insert into structural_variation_feature 
scripts/import/import_Phencode.pl:    $svar_ins_sth->execute($line->[0], $source, 12)||die;
scripts/import/import_Phencode.pl:    $svar_ext_sth->execute($line->[0], $source)||die;
scripts/import/import_Phencode.pl:    my $svar_id = $svar_ext_sth->fetchall_arrayref();
scripts/import/import_Phencode.pl:    die "Problem importing $line->[0] as sv\n" unless defined $svar_id->[0]->[0];
scripts/import/import_Phencode.pl:    $line->[1] = '\\N' if $line->[1] =~/deletion/;  ## no point entering descriptions like 9353_base_deletion as allele strings
scripts/import/import_Phencode.pl:    $svarf_ins_sth->execute($seq_ids->{$line->[2]}, $line->[3], $line->[4], $line->[5],$svar_id->[0]->[0], $line->[0], $source, 12, $line->[1])||die;
scripts/import/import_Phencode.pl:    return $svar_id->[0]->[0];
scripts/import/import_Phencode.pl:    my $vsv_ins_sth = $dbh->prepare(qq[ insert ignore into  variation_set_variation
scripts/import/import_Phencode.pl:        $vsv_ins_sth->execute( $var, $set_id );
scripts/import/import_Phencode.pl:    my $vssv_ins_sth = $dbh->prepare(qq[ insert ignore into  variation_set_structural_variation
scripts/import/import_Phencode.pl:        $vssv_ins_sth->execute( $svar, $set_id );
scripts/import/import_Phencode.pl:    my $set_ext_sth = $dbh->prepare(qq[ select variation_set_id from variation_set where name ='PhenCode']);
scripts/import/import_Phencode.pl:    my $set_ins_sth = $dbh->prepare(qq[insert into variation_set (  name, description, short_name_attrib_id) 
scripts/import/import_Phencode.pl:    $set_ext_sth->execute();
scripts/import/import_Phencode.pl:    my $id = $set_ext_sth->fetchall_arrayref();
scripts/import/import_Phencode.pl:    return $id->[0]->[0] if defined $id->[0]->[0] ;
scripts/import/import_Phencode.pl:    $set_ins_sth->execute(); 
scripts/import/import_Phencode.pl:    $set_ext_sth->execute();
scripts/import/import_Phencode.pl:    $id = $set_ext_sth->fetchall_arrayref();
scripts/import/import_Phencode.pl:    return $id->[0]->[0] if defined $id->[0]->[0] ;
scripts/import/import_Phencode.pl:##    - no need to re-import
scripts/import/import_Phencode.pl:    my $phencode_ext_sth = $dbh->prepare(qq[ select vs.name
scripts/import/import_Phencode.pl:    $phencode_ext_sth->execute()||die;
scripts/import/import_Phencode.pl:    my $dat = $phencode_ext_sth->fetchall_arrayref();
scripts/import/import_Phencode.pl:        $already_loaded{$l->[0]} = 1;
scripts/import/import_Phencode.pl:    die "Usage:\n\timport_Phencode.pl  -fasta [genomic sequence file for QC] -registry [registry file]\n\n";
scripts/import/dbSNP_v2/sort_table_by_columns.pl:$registry->load_all($reg_file);
scripts/import/dbSNP_v2/sort_table_by_columns.pl:my $db_adaptor = $registry->get_DBAdaptor("homo_sapiens", "variation");
scripts/import/dbSNP_v2/sort_table_by_columns.pl:my $dbh = $db_adaptor->dbc;
scripts/import/dbSNP_v2/sort_table_by_columns.pl:my $dbname = $dbh->dbname;
scripts/import/dbSNP_v2/sort_table_by_columns.pl:my $sth = $dbh->prepare( $sql );
scripts/import/dbSNP_v2/sort_table_by_columns.pl:$sth->execute();
scripts/import/dbSNP_v2/sort_table_by_columns.pl:my $vf = $sth->fetchall_arrayref();
scripts/import/dbSNP_v2/sort_table_by_columns.pl:my $min_id = $vf->[0]->[0];
scripts/import/dbSNP_v2/sort_table_by_columns.pl:my $max_id = $vf->[0]->[1];
scripts/import/dbSNP_v2/sort_table_by_columns.pl:  my $sth = $dbVar->prepare( $sql );
scripts/import/dbSNP_v2/sort_table_by_columns.pl:  $sth->execute();
scripts/import/dbSNP_v2/sort_table_by_columns.pl:  while ( my $aref = $sth->fetchrow_arrayref() ) {
scripts/import/dbSNP_v2/sort_table_by_columns.pl:  $sth->finish();
scripts/import/dbSNP_v2/sort_table_by_columns.pl:    $cols_string .= "-k${col},${col}n "
scripts/import/dbSNP_v2/sort_table_by_columns.pl:system("sort --parallel=8 --buffer-size=30G ${cols_string}-o $TMP_DIR/sorted_$TMP_FILE $TMP_DIR/$TMP_FILE");
scripts/import/dbSNP_v2/sort_table_by_columns.pl:$dbh->do( "DROP TABLE IF EXISTS ${table_name}_tmp" ) or die "Failed to drop pre-existing temp table";
scripts/import/dbSNP_v2/sort_table_by_columns.pl:$dbh->do( "CREATE TABLE ${table_name}_tmp LIKE $table_name") or die "Failed to create temp table";
scripts/import/dbSNP_v2/sort_table_by_columns.pl:$dbh->do( "ALTER TABLE ${table_name}_tmp DISABLE KEYS") or die "Failed to disable keys in tmp table";
scripts/import/dbSNP_v2/sort_table_by_columns.pl:$dbh->do( "LOAD DATA LOCAL INFILE \"${TMP_DIR}/sorted_${TMP_FILE}\" INTO TABLE ${table_name}_tmp") or die "Failed to load infile in tmp table";
scripts/import/dbSNP_v2/sort_table_by_columns.pl:$dbh->do( "ALTER TABLE ${table_name}_tmp ENABLE KEYS") or die "Failed to re-enable keys in tmp table";
scripts/import/dbSNP_v2/sort_table_by_columns.pl:  \t\t-registry [registry file]
scripts/import/dbSNP_v2/sort_table_by_columns.pl:  \t\t-columns [comma-separated list of numbers]
scripts/import/dbSNP_v2/sort_table_by_columns.pl:  \t\t-table_name [table name]
scripts/import/dbSNP_v2/sort_table_by_columns.pl:  \t\t-tmp [temp folder]\n\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dbSNP_v2/load_dbsnp.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dbSNP_v2/load_dbsnp.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dbSNP_v2/load_dbsnp.pl:print "species = $config->{'species'}\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:print "registry_file = $config->{'registry'}\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:my $debug = $config->{'debug'};
scripts/import/dbSNP_v2/load_dbsnp.pl:my $dbh_var = $config->{'dbh_var'};
scripts/import/dbSNP_v2/load_dbsnp.pl:my $dbh_core= $config->{'dbh_core'};
scripts/import/dbSNP_v2/load_dbsnp.pl:$config->{'source_id'} = get_sources($dbh_var);
scripts/import/dbSNP_v2/load_dbsnp.pl:if ($config->{'ref_check'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  $fai_index = Bio::DB::HTS::Faidx->new($config->{'fasta_file'});
scripts/import/dbSNP_v2/load_dbsnp.pl:if ($config->{'assign_ancestral_allele'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  $ancestral_fai_index = Bio::DB::HTS::Faidx->new($config->{'ancestral_fasta_file'});
scripts/import/dbSNP_v2/load_dbsnp.pl:  $ancestral_alleles_utils = Bio::EnsEMBL::Variation::Utils::AncestralAllelesUtils->new(-fasta_db => $ancestral_fai_index);
scripts/import/dbSNP_v2/load_dbsnp.pl:if (($config->{'assembly'} eq 'GRCh38') && ($config->{'add_maf'})) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $fh = $config->{join('-', 'ma', $ma_type, 'fh')};
scripts/import/dbSNP_v2/load_dbsnp.pl:    $fh->close();
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $rpt_dir = $config->{'rpt_dir'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my ($base_filename, $path, $suffix) = fileparse($config->{'input_file'}, @suffixes);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $config->{'error_file'} = join('/', $rpt_dir, $error_filename);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $config->{'rpt_file'} = join('/', $rpt_dir, $rpt_filename);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $config->{'data_file_short'} = join('', $base_filename, $suffix);
scripts/import/dbSNP_v2/load_dbsnp.pl:  print "rpt_file ($config->{'rpt_file'})\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (-e $config->{'rpt_file'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    die("$config->{'rpt_file'} already exists. Please rename or delete\n");
scripts/import/dbSNP_v2/load_dbsnp.pl:  print "error_file ($config->{'error_file'})\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (-e $config->{'error_file'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    die("$config->{'error_file'} already exists. Please rename or delete\n");
scripts/import/dbSNP_v2/load_dbsnp.pl:  # causing miss-matches with the minor allele.
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (($config->{'assembly'} eq 'GRCh38') && ($config->{'add_maf'})) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    print "Flip 1000Genomes minor alleles for strand differences between assembly $config->{'assembly'} and GRCh37\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:      my $filename = join('-', $base_filename, 'ma', $ma_type) . '.txt';
scripts/import/dbSNP_v2/load_dbsnp.pl:      if (-e "$rpt_dir/$filename") {
scripts/import/dbSNP_v2/load_dbsnp.pl:      my $fh = FileHandle->new("$rpt_dir/$filename", 'w');
scripts/import/dbSNP_v2/load_dbsnp.pl:        $config->{join('-', 'ma', $ma_type, 'fh')} = $fh;
scripts/import/dbSNP_v2/load_dbsnp.pl:    print "No flip of 1000Genomes minor alleles for assembly $config->{'assembly'}\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:  $reg->no_version_check(1); 
scripts/import/dbSNP_v2/load_dbsnp.pl:  $reg->load_all($config->{'registry'});
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $dbVar = $reg->get_DBAdaptor($config->{'species'}, 'variation') || die "Error getting db adaptor variation";
scripts/import/dbSNP_v2/load_dbsnp.pl:  $config->{'dbh_var'}  = $dbVar->dbc->db_handle;
scripts/import/dbSNP_v2/load_dbsnp.pl:  $config->{'attribute_adaptor'} = $reg->get_adaptor($config->{'species'}, 'variation', 'attribute') || die "Error getting attribute adaptor";
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $dbCore = $reg->get_DBAdaptor($config->{'species'}, 'core') || die "Error getting db adaptor core";
scripts/import/dbSNP_v2/load_dbsnp.pl:  $dbCore->dbc->disconnect_if_idle;
scripts/import/dbSNP_v2/load_dbsnp.pl:  $config->{'core_adaptor'} = $dbCore;
scripts/import/dbSNP_v2/load_dbsnp.pl:  $config->{'dbh_core'} = $dbCore->dbc->db_handle;
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $inputfile = $config->{'input_file'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (! -e $inputfile) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $batch_id = get_batch_id($config->{'dbh_var'}, $config->{'data_file_short'});
scripts/import/dbSNP_v2/load_dbsnp.pl:  die("no batch_id for $config->{'data_file_short'}") if (! $batch_id);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $config->{'batch_id'} = $batch_id;
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $rs_obj = JSON->new->decode($json_string) or throw("ERROR: Failed to read file $inputfile");
scripts/import/dbSNP_v2/load_dbsnp.pl:    print Dumper($refsnp_data) if (!$config->{'db_load'});
scripts/import/dbSNP_v2/load_dbsnp.pl:    print Dumper($refsnp_data) if (!$config->{'db_load'});
scripts/import/dbSNP_v2/load_dbsnp.pl:    import_refsnp($config->{'dbh_var'},$refsnp_data, $config) if ($config->{'db_load'});
scripts/import/dbSNP_v2/load_dbsnp.pl:  $data->{'refsnp_id'} = $rs_json->{'refsnp_id'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (exists $rs_json->{'primary_snapshot_data'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $data->{'variant_type'} = $rs_json->{'primary_snapshot_data'}->{'variant_type'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    $data->{'variant_type'} = undef;
scripts/import/dbSNP_v2/load_dbsnp.pl:  $data->{'v'}->{'name'} = 'rs' . $rs_json->{'refsnp_id'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  $data->{'v'}->{'source_id'} = $config->{'source_id'}->{'dbSNP'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  # Variation feature data - location
scripts/import/dbSNP_v2/load_dbsnp.pl:  $data->{'vfs'} = get_variant_features($rs_json);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $data->{'merges'} = get_merges($rs_json);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $data->{'dbsnp2_merges'} = get_dbsnp2_merges($rs_json);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $data->{'hgvs'} = get_hgvs($config, $rs_json);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $data->{'citations'} = get_citations($rs_json);
scripts/import/dbSNP_v2/load_dbsnp.pl:  ($data->{'snp_support'}, $data->{'freq_support'})  = get_support($rs_json);
scripts/import/dbSNP_v2/load_dbsnp.pl:  # $data->{'1000Genomes'} = get_study_frequency($rs_json, '1000Genomes');
scripts/import/dbSNP_v2/load_dbsnp.pl:  if ($config->{'add_maf'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $data->{'1000Genomes'} = get_study_frequency($rs_json, '1000Genomes');
scripts/import/dbSNP_v2/load_dbsnp.pl:  # - the assembly is GRCh38
scripts/import/dbSNP_v2/load_dbsnp.pl:  # - the 1000Genomes data has a minor_allele
scripts/import/dbSNP_v2/load_dbsnp.pl:  # TODO - add a flag if flipping should be done if for GRCh38
scripts/import/dbSNP_v2/load_dbsnp.pl:  if ( ($config->{'add_maf'}) &&
scripts/import/dbSNP_v2/load_dbsnp.pl:       ($config->{'assembly'} eq 'GRCh38') &&
scripts/import/dbSNP_v2/load_dbsnp.pl:       defined $data->{'1000Genomes'} &&
scripts/import/dbSNP_v2/load_dbsnp.pl:       $data->{'1000Genomes'}->{'minor_allele'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      my $old_minor_allele = $data->{'1000Genomes'}->{'minor_allele'};
scripts/import/dbSNP_v2/load_dbsnp.pl:                        $data->{'v'}->{'name'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                        $data->{'vfs'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                        $config->{'ma-log-fh'});
scripts/import/dbSNP_v2/load_dbsnp.pl:        $data->{'1000Genomes'}->{'org_minor_allele'} = $old_minor_allele;
scripts/import/dbSNP_v2/load_dbsnp.pl:        $data->{'1000Genomes'}->{'minor_allele'} = $new_minor_allele;
scripts/import/dbSNP_v2/load_dbsnp.pl:        my $fh = $config->{'ma-update-fh'};
scripts/import/dbSNP_v2/load_dbsnp.pl:        print $fh join("\t", $data->{'v'}->{'name'},
scripts/import/dbSNP_v2/load_dbsnp.pl:  if ($config->{assign_ancestral_allele}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    assign_ancestral_alleles($data->{'vfs'}, $ancestral_alleles_utils);
scripts/import/dbSNP_v2/load_dbsnp.pl:# vfs              - variation features for the variant
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $seq_name = $seq_regions_names->{$vf->{'seq_region_id'}};
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $ancestral_allele = $ancestral_alleles_utils->assign($seq_name, $vf->{'seq_region_start'}, $vf->{'seq_region_end'});
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'ancestral_allele'} = $ancestral_allele;
scripts/import/dbSNP_v2/load_dbsnp.pl:# old_minor_allele - allele from GRCh37
scripts/import/dbSNP_v2/load_dbsnp.pl:# var_name         - name of the variant
scripts/import/dbSNP_v2/load_dbsnp.pl:# align_diff       - alignment diff info between GRCh37 and GRCh38
scripts/import/dbSNP_v2/load_dbsnp.pl:# vfs              - variation features for the variant
scripts/import/dbSNP_v2/load_dbsnp.pl:# fh               - filehandle to log info and errors
scripts/import/dbSNP_v2/load_dbsnp.pl:  if ($align_diff->{'review_status'} ne 'ALIGN_DIFF') {
scripts/import/dbSNP_v2/load_dbsnp.pl:      'review_status: ' . $align_diff->{'review_status'}), "\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $grch37_loc = $align_diff->{'grch37_loc'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $grch38_loc = $align_diff->{'grch38_loc'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $allele_string = $vf->{'allele_string'};
scripts/import/dbSNP_v2/load_dbsnp.pl:                     $vf->{'seq_region_id'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                     $vf->{'seq_region_start'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                     $vf->{'seq_region_end'});
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $psd = $rs_json->{'primary_snapshot_data'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $variant_type = $psd->{'variant_type'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $variation_name = 'rs' . $rs_json->{'refsnp_id'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  foreach my $location (@{$psd->{'placements_with_allele'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    next if $location->{'seq_id'} !~ /^(NC|NW|NT)/;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'variant_type'} = $variant_type;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'variation_name'} = $variation_name;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $seq_id = $location->{'seq_id'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'seq_id'} = $seq_id;
scripts/import/dbSNP_v2/load_dbsnp.pl:      $seq_region_id = $nc_regions->{$seq_id};
scripts/import/dbSNP_v2/load_dbsnp.pl:      $vf->{'seq_region_id'} = $seq_region_id;
scripts/import/dbSNP_v2/load_dbsnp.pl:      $seq_region = $nw_regions->{$seq_id};
scripts/import/dbSNP_v2/load_dbsnp.pl:      $vf->{'seq_region_id'} = $seq_region->{'seq_region_id'};
scripts/import/dbSNP_v2/load_dbsnp.pl:      $vf->{'asm_start'} = $seq_region->{'asm_start'};
scripts/import/dbSNP_v2/load_dbsnp.pl:      $vf->{'asm_end'} = $seq_region->{'asm_end'};
scripts/import/dbSNP_v2/load_dbsnp.pl:      $vf->{'ori'} = $seq_region->{'ori'};
scripts/import/dbSNP_v2/load_dbsnp.pl:      $seq_region = $nt_regions->{$seq_id};
scripts/import/dbSNP_v2/load_dbsnp.pl:      $vf->{'seq_region_id'} = $seq_region->{'seq_region_id'};
scripts/import/dbSNP_v2/load_dbsnp.pl:      $vf->{'asm_start'} = $seq_region->{'asm_start'};
scripts/import/dbSNP_v2/load_dbsnp.pl:      $vf->{'asm_end'} = $seq_region->{'asm_end'};
scripts/import/dbSNP_v2/load_dbsnp.pl:      $vf->{'ori'} = $seq_region->{'ori'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $pa = $location->{'placement_annot'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    next if ($pa->{'seq_type'} !~ /refseq_chromosome|refseq_contig/);
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $aln_opposite = $pa->{'is_aln_opposite_orientation'} || 0; 
scripts/import/dbSNP_v2/load_dbsnp.pl:    next if (! @{$location->{'alleles'}});
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'alleles'} = $location->{'alleles'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    my ($allele_string, $position, $length_ref, $allele_errors) = get_allele_info($location->{'alleles'});
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'allele_string'} = $allele_string;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'seq_region_start'} = $position + 1;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'seq_region_end'} = $position + $length_ref;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'seq_region_strand'} = 1; 
scripts/import/dbSNP_v2/load_dbsnp.pl:    if (defined $vf->{'asm_start'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      if ($vf->{'ori'} != -1) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        $vf->{'seq_region_start'} = $position + $vf->{'asm_start'};
scripts/import/dbSNP_v2/load_dbsnp.pl:        $vf->{'seq_region_end'} = $position - 1 + $length_ref + $vf->{'asm_start'};
scripts/import/dbSNP_v2/load_dbsnp.pl:        $vf->{'seq_region_strand'} = -1;
scripts/import/dbSNP_v2/load_dbsnp.pl:        # Position is zero-based
scripts/import/dbSNP_v2/load_dbsnp.pl:        $vf->{'seq_region_end'} = $vf->{'asm_end'} - $position;
scripts/import/dbSNP_v2/load_dbsnp.pl:        $vf->{'seq_region_start'} = $vf->{'seq_region_end'} - $length_ref + 1;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'position'} = $position;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'aln_opposite'} = $aln_opposite;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'allele_errors'} = $allele_errors;
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $first_del_seq = $alleles_ref->[0]->{'allele'}->{'spdi'}->{'deleted_sequence'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $first_pos     = $alleles_ref->[0]->{'allele'}->{'spdi'}->{'position'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $paa = $alleles_ref->[$n];
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $spdi = $paa->{'allele'}->{'spdi'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($spdi->{'deleted_sequence'} eq $spdi->{'inserted_sequence'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      $ref_allele = $spdi->{'deleted_sequence'} || "-";
scripts/import/dbSNP_v2/load_dbsnp.pl:      push @allele_string, $spdi->{'inserted_sequence'} || "-";
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($spdi->{'deleted_sequence'} ne $first_del_seq) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($spdi->{'position'} ne $first_pos) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      $ref_allele = $first_del_seq || "-";
scripts/import/dbSNP_v2/load_dbsnp.pl:  if ($ref_allele && $ref_allele ne '-') {
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $dbsnp1_merges = $rs_json->{'dbsnp1_merges'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    push @merged_refsnps,  "rs" . $dbsnp1_merge_event->{'merged_rsid'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $present_obs_movements = $rs_json->{'present_obs_movements'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $allele_in_cur_release = $pom->{'allele_in_cur_release'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($allele_in_cur_release->{'deleted_sequence'} eq
scripts/import/dbSNP_v2/load_dbsnp.pl:      $allele_in_cur_release->{'inserted_sequence'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $prev_rel_rsids = $pom->{'previous_release'}->{'rsids'};
scripts/import/dbSNP_v2/load_dbsnp.pl:      if ($prev_rel_rsid != $rs_json->{'refsnp_id'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $psd = $rs_json->{'primary_snapshot_data'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  foreach my $loc (@{$psd->{'placements_with_allele'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $la = $loc->{'placement_annot'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($la->{'seq_type'} =~ /^(refseq_mrna|refseq_prot)$/) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      for my $allele (@{$loc->{'alleles'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        next if ($allele->{'hgvs'} !~ /^(NP|NM)/);
scripts/import/dbSNP_v2/load_dbsnp.pl:        next if ($allele->{'hgvs'} =~ /^(NP|NM).+=$/);
scripts/import/dbSNP_v2/load_dbsnp.pl:        if (length($allele->{'hgvs'}) >= 255) {
scripts/import/dbSNP_v2/load_dbsnp.pl:                 'length_HGVS=' . length($allele->{'hgvs'}),
scripts/import/dbSNP_v2/load_dbsnp.pl:                 'HGVS_start=' . substr($allele->{'hgvs'}, 0, 50));
scripts/import/dbSNP_v2/load_dbsnp.pl:          log_errors($config, 'rs' . $rs_json->{'refsnp_id'}, 'HGVS_length_ge_255', $info);
scripts/import/dbSNP_v2/load_dbsnp.pl:        $hgvs{$allele->{'hgvs'}}++;
scripts/import/dbSNP_v2/load_dbsnp.pl:  return $rs_json->{'citations'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  foreach my $support (@{$rs_json->{'primary_snapshot_data'}->{'support'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($support->{'id'}->{'type'} eq 'subsnp') {
scripts/import/dbSNP_v2/load_dbsnp.pl:      $subsnp_support{$support->{'submitter_handle'}}++;
scripts/import/dbSNP_v2/load_dbsnp.pl:    } elsif ($support->{'id'}->{'type'} eq 'frequency') {
scripts/import/dbSNP_v2/load_dbsnp.pl:      $freq_support{$support->{'submitter_handle'}}++;
scripts/import/dbSNP_v2/load_dbsnp.pl:  $rs_data->{'evidence_attribs'} = get_evidence($lu_info, $rs_data); 
scripts/import/dbSNP_v2/load_dbsnp.pl:  $rs_data->{'map_weight'} = get_map_weight($ref_regions, $rs_data) if ($add_map_weight);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $rs_data->{'num_par'} = get_vf_par($rs_data, $config->{'assembly'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                                     $lu_info->{'chrY_seq_region_id'});
scripts/import/dbSNP_v2/load_dbsnp.pl:  if ($rs_data->{'num_par'} && $rs_data->{'num_par'} == $rs_data->{'map_weight'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:                'map_weight=' . $rs_data->{'map_weight'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                'num_par=' . $rs_data->{'num_par'});
scripts/import/dbSNP_v2/load_dbsnp.pl:      log_errors($config, $rs_data->{'v'}->{'name'},
scripts/import/dbSNP_v2/load_dbsnp.pl:  $rs_data->{'variant_fails'} = get_variant_vf_fails($rs_data, $config->{'ref_check'}, $fai_index, $ref_regions);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $rs_data->{'display'} = set_display($rs_data);
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (%{$rs_data->{'freq_support'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    push @evidence, $lu_info->{'evidence_ids'}->{'Frequency'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (@{$rs_data->{'citations'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    push @evidence, $lu_info->{'evidence_ids'}->{'Cited'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $subsnp_support = $rs_data->{'snp_support'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    if (defined $subsnp_support->{'1000GENOMES'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      if (defined $lu_info->{'evidence_ids'}->{'1000Genomes'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        push @evidence, $lu_info->{'evidence_ids'}->{'1000Genomes'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    } elsif (defined $rs_data->{'freq_support'}->{'1000Genomes'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        push @evidence, $lu_info->{'evidence_ids'}->{'1000Genomes'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    # subsnp suppport (NHLBI-ESP)
scripts/import/dbSNP_v2/load_dbsnp.pl:    if (defined $subsnp_support->{'NHLBI-ESP'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      if (defined $lu_info->{'evidence_ids'}->{'ESP'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        push @evidence, $lu_info->{'evidence_ids'}->{'ESP'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    } elsif (defined $rs_data->{'freq_support'}->{'GoESP'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        push @evidence, $lu_info->{'evidence_ids'}->{'ESP'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    if (defined $subsnp_support->{'EVA_EXAC'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      if (defined $lu_info->{'evidence_ids'}->{'ExAC'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        push @evidence, $lu_info->{'evidence_ids'}->{'ExAC'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    if (defined $subsnp_support->{'TOPMED'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      if (defined $lu_info->{'evidence_ids'}->{'TOPMed'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        push @evidence, $lu_info->{'evidence_ids'}->{'TOPMed'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    if (defined $subsnp_support->{'GNOMAD'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      if (defined $lu_info->{'evidence_ids'}->{'gnomAD'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        push @evidence, $lu_info->{'evidence_ids'}->{'gnomAD'};
scripts/import/dbSNP_v2/load_dbsnp.pl:      push @evidence, $lu_info->{'evidence_ids'}->{'Frequency'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  # Loop through the vfs and count the regions that are top-level
scripts/import/dbSNP_v2/load_dbsnp.pl:  for my $vf (@{$rs_data->{'vfs'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    if (defined $regions->{$vf->{'seq_region_id'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:                     $vf->{'seq_region_id'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                     $vf->{'seq_region_start'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                     $vf->{'seq_region_end'});
scripts/import/dbSNP_v2/load_dbsnp.pl:  for my $vf (@{$rs_data->{'vfs'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'par'} = 0;
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($vf->{'seq_region_id'} == $Y_seq_region_id) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      if ($vf->{'seq_region_start'} >= $Y_PAR1_seq_region_start
scripts/import/dbSNP_v2/load_dbsnp.pl:          && $vf->{'seq_region_end'}   <= $Y_PAR1_seq_region_end
scripts/import/dbSNP_v2/load_dbsnp.pl:          && $vf->{'seq_region_start'} <= $Y_PAR1_seq_region_end
scripts/import/dbSNP_v2/load_dbsnp.pl:          && $vf->{'seq_region_end'} >= $Y_PAR1_seq_region_start) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        $vf->{'par'} = 1;
scripts/import/dbSNP_v2/load_dbsnp.pl:      } elsif ($vf->{'seq_region_start'} >= $Y_PAR2_seq_region_start
scripts/import/dbSNP_v2/load_dbsnp.pl:          && $vf->{'seq_region_end'} <=   $Y_PAR2_seq_region_end
scripts/import/dbSNP_v2/load_dbsnp.pl:          && $vf->{'seq_region_start'} <= $Y_PAR2_seq_region_end
scripts/import/dbSNP_v2/load_dbsnp.pl:          && $vf->{'seq_region_end'} >= $Y_PAR2_seq_region_start) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        $vf->{'par'} = 1;
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (!@{$rs_data->{'vfs'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  # Type 19 - fail variant if >1 mapping seen
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (defined $rs_data->{'map_weight'} && $rs_data->{'map_weight'} > 1) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      if (($rs_data->{'map_weight'} - $rs_data->{'num_par'}) > 1) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  # Type 13 - Alleles contain non-nucleotide characters
scripts/import/dbSNP_v2/load_dbsnp.pl:  # Type 14 - Alleles contain ambiguity codes
scripts/import/dbSNP_v2/load_dbsnp.pl:  # Type 20 - Variant at first base in sequence
scripts/import/dbSNP_v2/load_dbsnp.pl:  # Type 21 - Reference allele does not match the bases at this genome location
scripts/import/dbSNP_v2/load_dbsnp.pl:  for my $vf (@{$rs_data->{'vfs'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($vf->{'par'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($vf->{'allele_string'} =~ /^dbSNP_/) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      $vf->{'fails'} = {};
scripts/import/dbSNP_v2/load_dbsnp.pl:      if ($vf->{'allele_string'} eq 'dbSNP_novariation') {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'fails'} = get_vf_fails($vf, $ref_check, $fai_index);
scripts/import/dbSNP_v2/load_dbsnp.pl:      if (defined $vf->{'fails'}->{$code}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      if (defined $regions->{$vf->{'seq_region_id'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        if (defined $vf->{'fails'}->{21}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $num_vf = scalar(@{$rs_data->{'vfs'}});
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (defined $rs_data->{'map_weight'} &&
scripts/import/dbSNP_v2/load_dbsnp.pl:      ($rs_data->{'map_weight'} == 1) &&
scripts/import/dbSNP_v2/load_dbsnp.pl:  if ($vf->{'seq_region_start'} == 1 ) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $allele_string = $vf->{'allele_string'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  # Type 13  Alleles contain non-nucleotide characters
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (defined $illegal_alleles->[0]) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  # Type 14 -  Alleles contain ambiguity codes
scripts/import/dbSNP_v2/load_dbsnp.pl:  # Previously Reference match checks and re-ordering only run for variants with 1 genomic location
scripts/import/dbSNP_v2/load_dbsnp.pl:        $vf->{'ref_correct'} = 'no';
scripts/import/dbSNP_v2/load_dbsnp.pl:      my @alleles = split/\//, $vf->{allele_string};
scripts/import/dbSNP_v2/load_dbsnp.pl:      # The empty allele is represented by "-"
scripts/import/dbSNP_v2/load_dbsnp.pl:      # get_reference_base_hts return "-"
scripts/import/dbSNP_v2/load_dbsnp.pl:      # No specific checking for "-" needed
scripts/import/dbSNP_v2/load_dbsnp.pl:        $vf->{'ref_correct'} = 'no';
scripts/import/dbSNP_v2/load_dbsnp.pl:  if ( $vf->{'seq_region_end'} + 1 == $vf->{'seq_region_start'}) { 
scripts/import/dbSNP_v2/load_dbsnp.pl:    $ref_seq = "-";
scripts/import/dbSNP_v2/load_dbsnp.pl:  } elsif ($vf->{'seq_region_end'} < $vf->{'seq_region_start'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    warn "Incorrect coords $vf->{'seq_region_end'} - $vf->{'seq_region_start'} for $vf->{'name'} \n";
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $seq_name = $seq_regions_names->{$vf->{'seq_region_id'}};
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $location = $seq_name . ":" . $vf->{'seq_region_start'} . "-" . $vf->{'seq_region_end'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    $ref_seq = $fai_index->get_sequence_no_length($location);
scripts/import/dbSNP_v2/load_dbsnp.pl:    # If strand is "-" need to reverse complement it
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($vf->{'seq_region_strand'} == -1) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (@{$rs_data->{'citations'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (! (@{$rs_data->{'vfs'}})) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (%{$rs_data->{'variant_fails'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  import_batch($dbh, $config->{'batch_id'}, $variation_id, $rs_data->{'variant_type'});
scripts/import/dbSNP_v2/load_dbsnp.pl:  import_variation_feature($dbh, $variation_id, $rs_data, $config, $lu_info->{'failed_set_id'});
scripts/import/dbSNP_v2/load_dbsnp.pl:                $rs_data->{'merges'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                $config->{'source_id'}->{'Archive dbSNP'});
scripts/import/dbSNP_v2/load_dbsnp.pl:                $rs_data->{'dbsnp2_merges'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                $config->{'source_id'}->{'Former dbSNP'});
scripts/import/dbSNP_v2/load_dbsnp.pl:              $rs_data->{'hgvs'},
scripts/import/dbSNP_v2/load_dbsnp.pl:              $config->{'source_id'}->{'dbSNP HGVS'});
scripts/import/dbSNP_v2/load_dbsnp.pl:  import_citations($dbh, $variation_id, $rs_data->{'name'}, $rs_data->{'citations'});
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (! (@{$rs_data->{'vfs'}})) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (%{$rs_data->{'variant_fails'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    add_variant_fails($dbh, $variation_id, $rs_data->{'variant_fails'});
scripts/import/dbSNP_v2/load_dbsnp.pl:  $dbh->do(qq{INSERT INTO batch_variation
scripts/import/dbSNP_v2/load_dbsnp.pl:# - Add freq and evidence setting to function
scripts/import/dbSNP_v2/load_dbsnp.pl:# - Precision of 1000Genome frequencey
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $v = $data->{'v'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $freq = $data->{'1000Genomes'};
scripts/import/dbSNP_v2/load_dbsnp.pl:      $minor_allele = $freq->{'minor_allele'} || '-';
scripts/import/dbSNP_v2/load_dbsnp.pl:      $maf = format_frequency($freq->{'MAF'});
scripts/import/dbSNP_v2/load_dbsnp.pl:      $minor_allele_count = $freq->{'minor_allele_count'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (@{$data->{'evidence_attribs'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $evidence_attribs_str = join(",", @{$data->{'evidence_attribs'}});
scripts/import/dbSNP_v2/load_dbsnp.pl:  $dbh->do(qq{INSERT INTO variation (name, source_id,
scripts/import/dbSNP_v2/load_dbsnp.pl:                   $v->{'name'}, $v->{'source_id'}, 
scripts/import/dbSNP_v2/load_dbsnp.pl:                   $evidence_attribs_str, $data->{'display'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                   $v->{'class_attrib_id'});
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $db_variation_id = $dbh->last_insert_id(undef, undef, qw(variation variation_id)) or die("no insert id for variation");
scripts/import/dbSNP_v2/load_dbsnp.pl:    die("Unable to get variation_id for $v->{'name'}: $!");
scripts/import/dbSNP_v2/load_dbsnp.pl:  $v->{'variation_id'} = $db_variation_id;
scripts/import/dbSNP_v2/load_dbsnp.pl:# - Add freq and evidence setting to function
scripts/import/dbSNP_v2/load_dbsnp.pl:# - Source not be hardcoded
scripts/import/dbSNP_v2/load_dbsnp.pl:# - Precision of 1000Genomes frequency
scripts/import/dbSNP_v2/load_dbsnp.pl:# - Remove addition of non-schema columns
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $vfs = $data->{'vfs'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $freq = $data->{'1000Genomes'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $source_id = $data->{'v'}->{'source_id'};
scripts/import/dbSNP_v2/load_dbsnp.pl:      $minor_allele = $freq->{'minor_allele'} || '-';
scripts/import/dbSNP_v2/load_dbsnp.pl:      $maf = format_frequency($freq->{'MAF'});
scripts/import/dbSNP_v2/load_dbsnp.pl:      $minor_allele_count = $freq->{'minor_allele_count'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (@{$data->{'evidence_attribs'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $evidence_attribs_str = join(",", @{$data->{'evidence_attribs'}});
scripts/import/dbSNP_v2/load_dbsnp.pl:  if ($data->{'map_weight'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $map_weight = $data->{'map_weight'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (%{$data->{'variant_fails'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth=$dbh->prepare(qq[INSERT INTO variation_feature
scripts/import/dbSNP_v2/load_dbsnp.pl:    next if ($vf->{'par'});
scripts/import/dbSNP_v2/load_dbsnp.pl:                    $vf->{'seq_region_id'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                    $vf->{'seq_region_start'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                    $vf->{'seq_region_end'});
scripts/import/dbSNP_v2/load_dbsnp.pl:      import_placement_allele($dbh, $variation_id, $vf->{'alleles'}, $vf->{'variation_name'});
scripts/import/dbSNP_v2/load_dbsnp.pl:                'seq_region_id=' . $vf->{'seq_region_id'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                'seq_region_start=' . $vf->{'seq_region_start'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                'seq_region_end=' . $vf->{'seq_region_end'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                'seq_id=' . $vf->{'seq_id'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                'position=' . $vf->{'position'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                'strand=' . $vf->{'seq_region_strand'});
scripts/import/dbSNP_v2/load_dbsnp.pl:      log_errors($config, $vf->{'variation_name'},
scripts/import/dbSNP_v2/load_dbsnp.pl:    $sth->execute($vf->{'variation_name'}, $map_weight,
scripts/import/dbSNP_v2/load_dbsnp.pl:                  $vf->{'seq_region_id'}, $vf->{'seq_region_start'}, $vf->{'seq_region_end'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                  $vf->{'seq_region_strand'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                  $variation_id, $vf->{'allele_string'}, $vf->{'ancestral_allele'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                  $source_id, $sets, $vf->{'class_attrib_id'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                  $evidence_attribs_str, $data->{'display'});
scripts/import/dbSNP_v2/load_dbsnp.pl:    if (@{$vf->{'allele_errors'}} ||
scripts/import/dbSNP_v2/load_dbsnp.pl:           %{$vf->{'fails'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      my $db_vf_id = $dbh->last_insert_id(undef, undef, qw(variation_feature variation_feature_id)) or die("no insert id for variation_feature");
scripts/import/dbSNP_v2/load_dbsnp.pl:        die("Unable to get variation_feature_id for $vf->{'variation_name'}: $!");
scripts/import/dbSNP_v2/load_dbsnp.pl:      if (@{$vf->{'allele_errors'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        import_failed_alleles($dbh, $db_vf_id, $vf->{'allele_errors'}, $vf->{'allele_string'});
scripts/import/dbSNP_v2/load_dbsnp.pl:      if (%{$vf->{'fails'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        import_failed_variation_features($dbh, $db_vf_id, $vf->{'fails'});
scripts/import/dbSNP_v2/load_dbsnp.pl:    import_placement_allele($dbh, $variation_id, $vf->{'alleles'}, $vf->{'variation_name'});
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($vf->{'aln_opposite'} && ($vf->{'seq_region_strand'} == 1)) {
scripts/import/dbSNP_v2/load_dbsnp.pl:                'seq_id=' . $vf->{'seq_id'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                'position=' . $vf->{'position'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                'strand=' . $vf->{'seq_region_strand'});
scripts/import/dbSNP_v2/load_dbsnp.pl:      log_errors($config, $vf->{'variation_name'},
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth=$dbh->prepare(qq[INSERT INTO placement_allele
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $spdi = $allele->{'allele'}->{'spdi'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    #print "seq_id = $spdi->{'seq_id'}\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:    #print "position = $spdi->{'position'}\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:    #print "deleted_sequence = $spdi->{'deleted_sequence'}\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:    #print "insereted sequence = $spdi->{'inserted_sequence'}\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:    #print "hgvs = $allele->{'hgvs'}\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:    # TODO - alter the schema for placement allele
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $pa_hgvs = $allele->{'hgvs'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    $sth->execute($variation_id,
scripts/import/dbSNP_v2/load_dbsnp.pl:                  $spdi->{'seq_id'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                  $spdi->{'position'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                  $spdi->{'deleted_sequence'},
scripts/import/dbSNP_v2/load_dbsnp.pl:                  $spdi->{'inserted_sequence'},
scripts/import/dbSNP_v2/load_dbsnp.pl:    if (length($spdi->{$field}) > 255) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      $spdi->{$field} = substr($spdi->{$field}, 0,255);
scripts/import/dbSNP_v2/load_dbsnp.pl:                         $field . '=' . $spdi->{$field});
scripts/import/dbSNP_v2/load_dbsnp.pl:# Stores the SPDI allele errors - for local use only
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth=$dbh->prepare(qq[INSERT INTO failed_variation_feature_spdi
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth_vf=$dbh->prepare(qq[INSERT INTO failed_variation_feature
scripts/import/dbSNP_v2/load_dbsnp.pl:    $sth->execute($vf_id, $ae);
scripts/import/dbSNP_v2/load_dbsnp.pl:    $sth_vf->execute($vf_id, 22);
scripts/import/dbSNP_v2/load_dbsnp.pl:    $sth_vf->execute($vf_id, 4);
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth=$dbh->prepare(qq[INSERT INTO failed_variation_feature
scripts/import/dbSNP_v2/load_dbsnp.pl:    $sth->execute($vf_id, $error);
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth=$dbh->prepare(qq[INSERT INTO variation_synonym
scripts/import/dbSNP_v2/load_dbsnp.pl:    $sth->execute($variation_id, $source_id, $name);
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth = $dbh->prepare(qq[INSERT INTO variation_synonym
scripts/import/dbSNP_v2/load_dbsnp.pl:    $sth->execute($variation_id, $source_id, $name);
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth = $dbh->prepare(qq[INSERT INTO tmp_variation_citation
scripts/import/dbSNP_v2/load_dbsnp.pl:    $sth->execute($variation_id, $citation);
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth = $dbh->prepare(qq[INSERT INTO failed_variation
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth->execute($variation_id, 5);
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth = $dbh->prepare(qq[INSERT INTO failed_variation
scripts/import/dbSNP_v2/load_dbsnp.pl:    $sth->execute($variation_id, $fail_id) or die("Error inserting variation fails info");
scripts/import/dbSNP_v2/load_dbsnp.pl:  # Sub to be removed - so temp declaration of $run_info to pass compile
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $variant_id = $run_info->{'variant_seq'}->{'next_id'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  $run_info->{'variant_seq'}->{'next_id'}++;
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $start = $run_info->{'variant_seq'}->{'start'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $end   = $run_info->{'variant_seq'}->{'end'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    die("variant_id ($variant_id) is outside of sequence range ($start - $end)");
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $species = $config->{'species'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $input_file = $config->{'input_file'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $report_file = $config->{'rpt_file'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $batch_id = $config->{'batch_id'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  print $report "Report date:\t", strftime('%Y-%m-%d %H:%M:%S', localtime()), "\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (!$config->{'db_load'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $dbh = $config->{'dbh_var'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth = $dbh->prepare($sql);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth->execute($batch_id);
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $tbl_ary_ref = $sth->fetchall_arrayref();
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth = $dbh->prepare($sql);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth->execute($batch_id);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $tbl_ary_ref = $sth->fetchall_arrayref();
scripts/import/dbSNP_v2/load_dbsnp.pl:  print $report "\n\nSeq region - Variation failure reason:\n";
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth = $dbh->prepare($sql);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth->execute($batch_id);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $tbl_ary_ref = $sth->fetchall_arrayref();
scripts/import/dbSNP_v2/load_dbsnp.pl:  return $dbh->selectrow_array($sql, undef, $batch_id);
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth = $dbh->prepare(qq{SELECT seq_region_id, name FROM seq_region});
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth->execute() ||die "Error extracting seq_region_ids";
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $data = $sth->fetchall_arrayref();
scripts/import/dbSNP_v2/load_dbsnp.pl:    $seq_region{$l->[0]} = $l->[1];
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth = $dbh->prepare(qq{SELECT seq_region_id FROM seq_region WHERE name = ?});
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth->execute($chr) || die "Error getting seq_region_id for chr $chr";
scripts/import/dbSNP_v2/load_dbsnp.pl:  my ($seq_region_id) = $sth->fetchrow_array();
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth->finish();
scripts/import/dbSNP_v2/load_dbsnp.pl:  # get command-line options
scripts/import/dbSNP_v2/load_dbsnp.pl:  pod2usage(1) if ($config->{'help'} || !$args);
scripts/import/dbSNP_v2/load_dbsnp.pl:    if (! defined $config->{$param}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      pod2usage({ -message => "Mandatory argument ($param) is missing", 
scripts/import/dbSNP_v2/load_dbsnp.pl:                  -exitval => 2,
scripts/import/dbSNP_v2/load_dbsnp.pl:  $config->{'species'} ||= 'homo_sapiens';
scripts/import/dbSNP_v2/load_dbsnp.pl:  $config->{'debug'} ||= 0;
scripts/import/dbSNP_v2/load_dbsnp.pl:  $config->{'assembly'} ||= 'GRCh38';
scripts/import/dbSNP_v2/load_dbsnp.pl:  $config->{'db_load'} = 1;
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (exists $config->{'no_db_load'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $config->{'db_load'} = 0;
scripts/import/dbSNP_v2/load_dbsnp.pl:  $config->{'ref_check'} = 1;
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (exists $config->{'no_ref_check'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $config->{'ref_check'} = 0;
scripts/import/dbSNP_v2/load_dbsnp.pl:  $config->{'assign_ancestral_allele'} = 1;
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (exists $config->{'no_assign_ancestral_allele'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $config->{'assign_ancestral_allele'} = 0;
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (! -e $config->{'input_file'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    die("ERROR: Input file does not exist ($config->{'input_file'})\n");
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (! -e $config->{'registry'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    die("ERROR: Registry file does not exist ($config->{'registry'})\n");
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (! -d $config->{'rpt_dir'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    die("ERROR: Report directory does not exist ($config->{'rpt_dir'})\n");
scripts/import/dbSNP_v2/load_dbsnp.pl:  if ($config->{'assembly'} !~ /^(GRCh38|GRCh37)$/) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      die("ERROR: Assembly is invalid ($config->{'assembly'}). Please specify GRCh38 or GRCh37");
scripts/import/dbSNP_v2/load_dbsnp.pl:  if ($config->{'ref_check'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    if (! defined $config->{'fasta_file'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      pod2usage({ -message => "Mandatory argument (fasta_file) is missing", 
scripts/import/dbSNP_v2/load_dbsnp.pl:                  -exitval => 2,
scripts/import/dbSNP_v2/load_dbsnp.pl:    } elsif (! -e $config->{'fasta_file'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      die("ERROR: FASTA file does not exist ($config->{'fasta_file'})\n");
scripts/import/dbSNP_v2/load_dbsnp.pl:  if ($config->{'assign_ancestral_allele'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    if (! defined $config->{'ancestral_fasta_file'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      pod2usage({ -message => "Mandatory argument (ancestral_fasta_file) is missing", 
scripts/import/dbSNP_v2/load_dbsnp.pl:                  -exitval => 2,
scripts/import/dbSNP_v2/load_dbsnp.pl:    } elsif (! -e $config->{'ancestral_fasta_file'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      die("ERROR: Ancestral FASTA file does not exist ($config->{'ancestral_fasta_file'})\n");
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (exists $config->{'add_maf'}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $config->{'add_maf'} = 1;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $config->{'add_maf'} = 0;
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth = $dbh->prepare($sql);
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth->execute();
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth->dump_results();
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth = $dbh->prepare(qq{SELECT seq_region_id, name, srs_synonym FROM tmp_nc_synonym});
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth->execute() or die("Error extracting nc_regions");
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $data = $sth->fetchall_arrayref();
scripts/import/dbSNP_v2/load_dbsnp.pl:  unless(defined $data->[0]->[0]) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $nc_regions{$reg->[2]} = $reg->[0];
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth = $dbh->prepare(qq{SELECT seq_region_id, srs_synonym, asm_start, asm_end, ori FROM tmp_nw_synonym});
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth->execute() or die("Error extracting nw_regions");
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $data = $sth->fetchall_arrayref();
scripts/import/dbSNP_v2/load_dbsnp.pl:  unless(defined $data->[0]->[0]) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $rec->{'seq_region_id'} = $seq_region_id;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $rec->{'asm_start'} = $asm_start;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $rec->{'asm_end'} = $asm_end;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $rec->{'ori'} = $ori;
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth = $dbh->prepare(qq{SELECT seq_region_id, srs_synonym, asm_start, asm_end, ori FROM tmp_nt_synonym});
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth->execute() or die("Error extracting nt_regions");
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $data = $sth->fetchall_arrayref();
scripts/import/dbSNP_v2/load_dbsnp.pl:  unless(defined $data->[0]->[0]) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $rec->{'seq_region_id'} = $seq_region_id;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $rec->{'asm_start'} = $asm_start;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $rec->{'asm_end'} = $asm_end;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $rec->{'ori'} = $ori;
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth = $dbh->prepare(qq {SELECT sr.seq_region_id 
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth->execute() or die("Error extracting ref_regions");
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $is_ref = $sth->fetchall_arrayref();
scripts/import/dbSNP_v2/load_dbsnp.pl:    $ref_regions{$srid->[0]} = 1;
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth = $dbh->prepare(qq[ select variation_set_id
scripts/import/dbSNP_v2/load_dbsnp.pl:  $sth->execute('All failed variations')  || die "Failed to extract failed variant set id";
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $failed_set_id = $sth->fetchall_arrayref();
scripts/import/dbSNP_v2/load_dbsnp.pl:  die "Failed set not available" unless defined $failed_set_id->[0]->[0];
scripts/import/dbSNP_v2/load_dbsnp.pl:  return $failed_set_id->[0]->[0];
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $allele_annotations = $data->{'primary_snapshot_data'}->{'allele_annotations'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  return undef if (! exists $allele_annotations->[0]->{'frequency'});
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $freqs = $allele_annotations->[0]->{'frequency'};
scripts/import/dbSNP_v2/load_dbsnp.pl:      if ($freq->{'study_name'} eq $study) {
scripts/import/dbSNP_v2/load_dbsnp.pl:      my $freqs = $allele_annotations->[$i]->{'frequency'};
scripts/import/dbSNP_v2/load_dbsnp.pl:        if ($freq->{'study_name'} eq $study) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $cmp_obs = $alleles[0]->{'observation'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $cmp_seq_id = $cmp_obs->{'seq_id'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $cmp_position = $cmp_obs->{'position'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $cmp_deleted = $cmp_obs->{'deleted_sequence'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $obs = $alleles[$i]->{'observation'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($obs->{'seq_id'} ne $cmp_seq_id) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($obs->{'position'} ne $cmp_position) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($obs->{'deleted_sequence'} ne $cmp_deleted) {
scripts/import/dbSNP_v2/load_dbsnp.pl:  $study_freq->{'alleles'} = [@alleles];
scripts/import/dbSNP_v2/load_dbsnp.pl:  $study_freq->{'minor_allele'} = undef;
scripts/import/dbSNP_v2/load_dbsnp.pl:  $study_freq->{'MAF'} = undef;
scripts/import/dbSNP_v2/load_dbsnp.pl:  $study_freq->{'minor_allele_count'} = undef;
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (@{$study_freq->{'alleles'}} <= 1) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    my ($maf, $minor_allele, $minor_allele_count) = get_maf($study_freq->{'alleles'}, $data->{'refsnp_id'});
scripts/import/dbSNP_v2/load_dbsnp.pl:    $study_freq->{'MAF'} = $maf;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $study_freq->{'minor_allele'} = $minor_allele;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $study_freq->{'minor_allele_count'} = $minor_allele_count;
scripts/import/dbSNP_v2/load_dbsnp.pl:  $study_freq->{'allele_errors'} = {%allele_errors};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $refsnp = $rs_json->{'refsnp_id'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $psd = $rs_json->{'primary_snapshot_data'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $num_pwa = @{$psd->{'placements_with_allele'}};
scripts/import/dbSNP_v2/load_dbsnp.pl:  foreach my $loc (@{$psd->{'placements_with_allele'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $seq_id = $loc->{'seq_id'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $assembly = $loc->{'placement_annot'}->{'seq_id_traits_by_assembly'}->[0]->{'assembly_name'};
scripts/import/dbSNP_v2/load_dbsnp.pl:      $grch37_aln_opp++ if ($loc->{'placement_annot'}->{'is_aln_opposite_orientation'});
scripts/import/dbSNP_v2/load_dbsnp.pl:      $grch38_aln_opp++ if ($loc->{'placement_annot'}->{'is_aln_opposite_orientation'});
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $is_ptlp = $loc->{'is_ptlp'};
scripts/import/dbSNP_v2/load_dbsnp.pl:    $align_info->{'grch37_loc'} = $grch37_loc;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $align_info->{'grch38_loc'} = $grch38_loc;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $align_info->{'grch37_aln_opp'} = $grch37_aln_opp;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $align_info->{'grch38_aln_opp'} = $grch38_aln_opp;
scripts/import/dbSNP_v2/load_dbsnp.pl:    $align_info->{'review_status'} = $review_status;
scripts/import/dbSNP_v2/load_dbsnp.pl:                            $b->{'allele_count'} <=> $a->{'allele_count'}
scripts/import/dbSNP_v2/load_dbsnp.pl:                            $a->{'observation'}->{'inserted_sequence'} cmp $b->{'observation'}->{'inserted_sequence'}
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $maf = sprintf("%.6f", $sorted_alleles[1]->{'allele_count'}/$sorted_alleles[1]->{'total_count'});
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $minor_allele = $sorted_alleles[1]->{'observation'}->{'inserted_sequence'};
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $minor_allele_count = $sorted_alleles[1]->{'allele_count'};
scripts/import/dbSNP_v2/load_dbsnp.pl:       $config->{'attribute_adaptor'}->attrib_id_for_type_value('SO_term', $seq_alt);
scripts/import/dbSNP_v2/load_dbsnp.pl:  if (! (@{$data->{'vfs'}})) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    $data->{'v'}->{'class_attrib_id'} = $seq_alt_class_id;
scripts/import/dbSNP_v2/load_dbsnp.pl:  for my $vf (@{$data->{'vfs'}}) {
scripts/import/dbSNP_v2/load_dbsnp.pl:    # During mapping checking vf->{'ref_correct'} set to
scripts/import/dbSNP_v2/load_dbsnp.pl:    # TODO: Review if vf->{'ref_correct'} should be set to
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ($vf->{'allele_string'} =~ /^dbSNP_$/) {
scripts/import/dbSNP_v2/load_dbsnp.pl:        $vf->{'class_attrib_id'} = $seq_alt_class_id;
scripts/import/dbSNP_v2/load_dbsnp.pl:    if ((exists $vf->{'ref_correct'}) && $vf->{'ref_correct' eq 'no'})  {
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $so_term  = SO_variation_class($vf->{'allele_string'}, $ref_correct);
scripts/import/dbSNP_v2/load_dbsnp.pl:    my $class_id = $config->{'attribute_adaptor'}->attrib_id_for_type_value('SO_term', $so_term);
scripts/import/dbSNP_v2/load_dbsnp.pl:    $vf->{'class_attrib_id'} = $class_id;
scripts/import/dbSNP_v2/load_dbsnp.pl:  $data->{'v'}->{'class_attrib_id'} = $data->{'vfs'}->[0]->{'class_attrib_id'};
scripts/import/dbSNP_v2/load_dbsnp.pl:           'variant_class_attrib_id=' . $data->{'v'}->{'class_attrib_id'},
scripts/import/dbSNP_v2/load_dbsnp.pl:    log_errors($config, $data->{'v'}->{'name'},
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $error_file = $config->{error_file};
scripts/import/dbSNP_v2/load_dbsnp.pl:  open(my $fh, '>>', $config->{'error_file'}) or die "Failed to open error_file: $config->{'error_file'}: $!";
scripts/import/dbSNP_v2/load_dbsnp.pl:    strftime('%Y-%m-%d %H:%M:%S', localtime()),
scripts/import/dbSNP_v2/load_dbsnp.pl:  $fh->close;
scripts/import/dbSNP_v2/load_dbsnp.pl:  $dbh->do(qq{INSERT INTO batch
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $batch_id = $dbh->last_insert_id(undef, undef, qw(batch batch_id)) or die("no batch_id for batch");
scripts/import/dbSNP_v2/load_dbsnp.pl:  my $sth = $dbh->prepare(qq{select source_id from source where name = ?});
scripts/import/dbSNP_v2/load_dbsnp.pl:    $sth->execute($source);
scripts/import/dbSNP_v2/load_dbsnp.pl:    ($source_id) =  $sth->fetchrow_array();
scripts/import/dbSNP_v2/load_dbsnp.pl:    $sth->finish();
scripts/import/dbSNP_v2/load_dbsnp.pl:      $sources->{$source} = $source_id;
scripts/import/dbSNP_v2/load_dbsnp.pl: load_dbsnpl.pl --input_file test.json \
scripts/import/dbSNP_v2/load_dbsnp.pl:                --rpt_dir  /user1/load_reports \
scripts/import/dbSNP_v2/load_dbsnp.pl:                --fasta_file /user1/Homo_sapiens.GRCh38.dna.toplevel.fa.gz \
scripts/import/dbSNP_v2/load_dbsnp.pl:                --registry  /user1/ensembl.registry
scripts/import/dbSNP_v2/load_dbsnp.pl:=item B<--help>
scripts/import/dbSNP_v2/load_dbsnp.pl:=item B<--input_file FILE>
scripts/import/dbSNP_v2/load_dbsnp.pl:=item B<--rpt_dir DIR>
scripts/import/dbSNP_v2/load_dbsnp.pl:=item B<--assembly ASSEMBLY>
scripts/import/dbSNP_v2/load_dbsnp.pl:=item B<--ancestral_fasta_file FILE>
scripts/import/dbSNP_v2/load_dbsnp.pl:=item B<--fasta_file FILE>
scripts/import/dbSNP_v2/load_dbsnp.pl:=item B<--registry FILE>
scripts/import/dbSNP_v2/load_dbsnp.pl:=item B<--species NAME>
scripts/import/dbSNP_v2/load_dbsnp.pl:=item B<--no_db_load>
scripts/import/dbSNP_v2/load_dbsnp.pl:=item B<--no_ref_check>
scripts/import/dbSNP_v2/load_dbsnp.pl:=item B<--no_assign_ancestral_allele>
scripts/import/dbSNP_v2/load_dbsnp.pl:=item B<--no_maf>
scripts/import/dbSNP_v2/load_dbsnp.pl:=item B<--debug>
scripts/import/dbSNP_v2/init_load_dbsnp.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dbSNP_v2/init_load_dbsnp.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dbSNP_v2/init_load_dbsnp.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dbSNP_v2/init_load_dbsnp.pl:die("A registry file (--registry) is required") unless (defined($registry_file));
scripts/import/dbSNP_v2/init_load_dbsnp.pl:die("A temporary directory (--tmpdir) is required") unless (defined($tmpdir));
scripts/import/dbSNP_v2/init_load_dbsnp.pl:die("The dbSNP version (--dbsnp_version) is required") unless (defined($dbSNP_version));
scripts/import/dbSNP_v2/init_load_dbsnp.pl:if (! -e $tmpdir) {
scripts/import/dbSNP_v2/init_load_dbsnp.pl:if (! -e $registry_file) {
scripts/import/dbSNP_v2/init_load_dbsnp.pl:$reg->no_version_check(1); 
scripts/import/dbSNP_v2/init_load_dbsnp.pl:$reg->load_all($registry_file);
scripts/import/dbSNP_v2/init_load_dbsnp.pl:my $dbVar = $reg->get_DBAdaptor($species, 'variation') || die "Error getting db adaptor variation\n";
scripts/import/dbSNP_v2/init_load_dbsnp.pl:my $dbh_var = $dbVar->dbc->db_handle;
scripts/import/dbSNP_v2/init_load_dbsnp.pl:my $dbCore = $reg->get_DBAdaptor($species, 'core') || die "Error getting db adaptor core\n";
scripts/import/dbSNP_v2/init_load_dbsnp.pl:my $dbh_core = $dbCore->dbc->db_handle;
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  my $sth = $dbh_var->prepare($sql);
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  $sth->execute($source_id, $name, $description, $data_types);
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  # Insert the Archive dbSNP - dbsnp v1 merges
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  $sth->execute($source_id, $name, $description, $data_types);
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  $sth->execute($source_id, $name, $description, $data_types);
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  # Insert the Former dbSNP - dbsnp v2 merges 
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  $sth->execute($source_id, $name, $description, $data_types);
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  my $fail_attrib_ext_sth  = $dbh_var->prepare(qq[ select at.attrib_id
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  my $variation_set_ext_sth  = $dbh_var->prepare(qq[ select variation_set_id
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  my $variation_set_ins_sth  = $dbh_var->prepare(qq[ insert into variation_set
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  $variation_set_ext_sth->execute('All failed variations')  || die "Failed to extract failed variant set id\n";
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  my $failed_set_id = $variation_set_ext_sth->fetchall_arrayref();
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  unless(defined $failed_set_id->[0]->[0]){
scripts/import/dbSNP_v2/init_load_dbsnp.pl:    ## no set entered - look up attrib for short name and enter set
scripts/import/dbSNP_v2/init_load_dbsnp.pl:    $fail_attrib_ext_sth->execute() || die "Failed to extract failed set attrib reasons\n";
scripts/import/dbSNP_v2/init_load_dbsnp.pl:    my $attrib = $fail_attrib_ext_sth->fetchall_arrayref();
scripts/import/dbSNP_v2/init_load_dbsnp.pl:    die "Exiting: Error - attribs not found. Load attribs then re-run\n" unless defined $attrib->[0]->[0] ;
scripts/import/dbSNP_v2/init_load_dbsnp.pl:    $variation_set_ins_sth->execute( 'All failed variations',
scripts/import/dbSNP_v2/init_load_dbsnp.pl:                                     $attrib->[0]->[0] )|| die "Failed to insert failed set\n"; 
scripts/import/dbSNP_v2/init_load_dbsnp.pl:    $variation_set_ext_sth->execute('All failed variations')  || die "Failed to extract failed variant set id\n";
scripts/import/dbSNP_v2/init_load_dbsnp.pl:    $failed_set_id = $variation_set_ext_sth->fetchall_arrayref();      
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  return $failed_set_id->[0]->[0];
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  Creates seq region lookup tables for dbsnp-v2 import.
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  -h | --help          Displays this message and quit
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  --species            Species defaults to homo_sapiens
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  --registry           Registry file [required]
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  --tmpdir             Temporary directory to write dump files [required]
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  --dbsnp_version      dbSNP version being loaded (integer) [required]
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  --debug              Flag for debugging
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  my $sth = $dbh->prepare($sql);
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  $sth->execute();
scripts/import/dbSNP_v2/init_load_dbsnp.pl:  $sth->dump_results();
scripts/import/dbSNP_v2/dbsnp_v2_import_table.sql:-- Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dbSNP_v2/dbsnp_v2_import_table.sql:-- Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dbSNP_v2/dbsnp_v2_import_table.sql:-- 
scripts/import/dbSNP_v2/dbsnp_v2_import_table.sql:-- Licensed under the Apache License, Version 2.0 (the "License");
scripts/import/dbSNP_v2/dbsnp_v2_import_table.sql:-- you may not use this file except in compliance with the License.
scripts/import/dbSNP_v2/dbsnp_v2_import_table.sql:-- You may obtain a copy of the License at
scripts/import/dbSNP_v2/dbsnp_v2_import_table.sql:-- 
scripts/import/dbSNP_v2/dbsnp_v2_import_table.sql:--      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dbSNP_v2/dbsnp_v2_import_table.sql:-- 
scripts/import/dbSNP_v2/dbsnp_v2_import_table.sql:-- Unless required by applicable law or agreed to in writing, software
scripts/import/dbSNP_v2/dbsnp_v2_import_table.sql:-- distributed under the License is distributed on an "AS IS" BASIS,
scripts/import/dbSNP_v2/dbsnp_v2_import_table.sql:-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
scripts/import/dbSNP_v2/dbsnp_v2_import_table.sql:-- See the License for the specific language governing permissions and
scripts/import/dbSNP_v2/dbsnp_v2_import_table.sql:-- limitations under the License.
scripts/import/import_affy.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_affy.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_affy.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_affy.pl:usage('-shared_db argument is required')     if (!$shared_db);
scripts/import/import_affy.pl:usage('-registry_file argument is required') if (!$registry_file);
scripts/import/import_affy.pl:my $dbm = dbSNP::DBManager->new($registry_file,$species);
scripts/import/import_affy.pl:$dbm->dbSNP_shared($shared_db);
scripts/import/import_affy.pl:my $dbSNP  = $dbm->dbSNP()->dbc();
scripts/import/import_affy.pl:my $dbCore = $dbm->dbCore()->dbc();
scripts/import/import_affy.pl:my $dbVar  = $dbm->dbVar()->dbc();
scripts/import/import_affy.pl:my ($cs) = @{$dbm->dbCore()->get_CoordSystemAdaptor->fetch_all};
scripts/import/import_affy.pl:my $ASSEMBLY_VERSION = $cs->version();
scripts/import/import_affy.pl:my $duration = Progress::time_format($end-$start);
scripts/import/import_affy.pl:print $duration->{'weeks'} . " weeks, " . $duration->{'days'} . " days, " . $duration->{'hours'} . " hours, " . $duration->{'minutes'} . " minutes and " . $duration->{'seconds'} . " seconds spent in dump_AFFYIDs()\n";
scripts/import/import_affy.pl:# This method uses the pontus_affy_array_mapping database on ens-variation
scripts/import/import_affy.pl:      $source_description = "Variants from the Affymetrix Genome-Wide Human SNP Array 6.0";
scripts/import/import_affy.pl:    $dbVar->do($stmt);
scripts/import/import_affy.pl:    $dbVar->do($stmt);
scripts/import/import_affy.pl:    $dbVar->do($stmt);
scripts/import/import_affy.pl:    $dbVar->do($stmt);
scripts/import/import_affy.pl:    $dbVar->do($stmt);
scripts/import/import_affy.pl:    # The code below has been replaced by the dump-and-load code above
scripts/import/import_affy.pl:    #$dbVar->do(qq{CREATE TABLE $table\_name_pair like $table.name_pair});
scripts/import/import_affy.pl:    #$dbVar->do(qq{insert into $table\_name_pair select * from $table.name_pair});
scripts/import/import_affy.pl:    #$dbVar->do(qq{insert ignore into $table\_name_pair
scripts/import/import_affy.pl:      $dbVar->do($stmt);
scripts/import/import_affy.pl:    my $source_id_ref = $dbVar->db_handle->selectall_arrayref(qq{
scripts/import/import_affy.pl:    my $source_id = $source_id_ref->[0][0];
scripts/import/import_affy.pl:      $dbVar->do(qq{insert into source (name,description,url,type) 
scripts/import/import_affy.pl:      $source_id = $dbVar->db_handle->{'mysql_insertid'};
scripts/import/import_affy.pl:    $dbVar->do(qq{ INSERT IGNORE INTO variation_synonym (variation_id, source_id, name)
scripts/import/import_affy.pl:    #$dbVar->do(qq{update tmp_rs_AFFY_test t, rsHist h set t.rsID=h.rsCurrent where t.rsID=h.rsHigh});
scripts/import/import_affy.pl:    $dbVar->do(qq{ INSERT IGNORE INTO variation_synonym (variation_id, source_id, name)
scripts/import/import_affy.pl:    $dbVar->do(qq{DROP TABLE $table});
scripts/import/import_affy.pl:    -species <species>              name of the species (default = human)
scripts/import/import_affy.pl:    -shared_db <shared db>          name of the shared DB (e.g. shared_134)
scripts/import/import_affy.pl:    -registry_file <registry file>  registry file name (e.g. './ensembl.registry')
scripts/import/parallel_ld_populations.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/parallel_ld_populations.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/parallel_ld_populations.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/parallel_ld_populations.pl:my $default_population = 'CSHL-HAPMAP:HapMap-CEU'; #default population used to show by default on ldview
scripts/import/parallel_ld_populations.pl:  usage('-vdbname argument is required') if(!$vdbname);
scripts/import/parallel_ld_populations.pl:  usage('-cdbname argument is required') if(!$cdbname);
scripts/import/parallel_ld_populations.pl: # usage('-num_processes must at least be 1') if ($num_processes == 0);
scripts/import/parallel_ld_populations.pl:#  usage('-status_file argument is required') if (!$status_file);
scripts/import/parallel_ld_populations.pl:  my $dbCore = Bio::EnsEMBL::DBSQL::DBAdaptor->new
scripts/import/parallel_ld_populations.pl:    (-host   => $chost,
scripts/import/parallel_ld_populations.pl:     -user   => $cuser,
scripts/import/parallel_ld_populations.pl:     -pass   => $cpass,
scripts/import/parallel_ld_populations.pl:     -port   => $cport,
scripts/import/parallel_ld_populations.pl:     -dbname => $cdbname);
scripts/import/parallel_ld_populations.pl:  my $dbVar = DBH->connect
scripts/import/parallel_ld_populations.pl:    my $dbname = $dbVar->dbname(); #get the name of the database to create the file
scripts/import/parallel_ld_populations.pl:  my $csa = $dbCore->get_CoordSystemAdaptor();
scripts/import/parallel_ld_populations.pl:  my $cs = $csa->fetch_by_name($csname);
scripts/import/parallel_ld_populations.pl:  my $sth = $dbVar->prepare
scripts/import/parallel_ld_populations.pl:  $sth->execute($table_name, $cs->dbID());
scripts/import/parallel_ld_populations.pl:  $sth->finish();
scripts/import/parallel_ld_populations.pl:    my $sth_pop = $dbVar->prepare('SELECT s.sample_id FROM sample s, population p where p.sample_id = s.sample_id AND s.name = ?');
scripts/import/parallel_ld_populations.pl:    $sth_pop->execute($default_population);
scripts/import/parallel_ld_populations.pl:    $sth_pop->bind_columns(\$population_id);
scripts/import/parallel_ld_populations.pl:    $sth_pop->fetch();
scripts/import/parallel_ld_populations.pl:    $sth_pop->finish();
scripts/import/parallel_ld_populations.pl:    my $sth = $dbVar->prepare(qq{INSERT INTO meta (meta_key,meta_value) VALUES (?,?)
scripts/import/parallel_ld_populations.pl:    $sth->execute('pairwise_ld.default_population', $population_id);
scripts/import/parallel_ld_populations.pl:    $sth->finish();
scripts/import/parallel_ld_populations.pl:    -chost <hostname>    hostname of core Ensembl MySQL database (default = ecs2)
scripts/import/parallel_ld_populations.pl:    -cuser <user>        username of core Ensembl MySQL database (default = ensro)
scripts/import/parallel_ld_populations.pl:    -cpass <pass>        password of core Ensembl MySQL database
scripts/import/parallel_ld_populations.pl:    -cport <port>        TCP port of core Ensembl MySQL database (default = 3364)
scripts/import/parallel_ld_populations.pl:    -cdbname <dbname>    dbname of core Ensembl MySQL database
scripts/import/parallel_ld_populations.pl:    -vhost <hostname>    hostname of variation MySQL database to write to
scripts/import/parallel_ld_populations.pl:    -vuser <user>        username of variation MySQL database to write to (default = ensadmin)
scripts/import/parallel_ld_populations.pl:    -vpass <pass>        password of variation MySQL database to write to
scripts/import/parallel_ld_populations.pl:    -vport <port>        TCP port of variation MySQL database to write to (default = 3306)
scripts/import/parallel_ld_populations.pl:    -vdbname <dbname>    dbname of variation MySQL database to write to
scripts/import/parallel_ld_populations.pl:    -limit <number>      limit the number of rows for testing
scripts/import/parallel_ld_populations.pl:    -tmpdir <dir>        temp directory to use (with lots of space!)
scripts/import/parallel_ld_populations.pl:    -tmpfile <filename>   name of temp file to use
scripts/import/parallel_ld_populations.pl:    -num_processes <number> number of processes that are running (default = 1)
scripts/import/parallel_ld_populations.pl:    -status_file <filename> name of a temp file where all the processes write when they finish
scripts/import/update_changed_sets.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/update_changed_sets.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/update_changed_sets.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/update_changed_sets.pl:##  - find variants which are newly added to the set
scripts/import/update_changed_sets.pl:##  - find variants which have been removed from the set
scripts/import/update_changed_sets.pl:##  - re-calculate the summary set list in variation_feature for all changed variants.
scripts/import/update_changed_sets.pl:$registry->load_all($registry_file);
scripts/import/update_changed_sets.pl:my $db_adaptor = $registry->get_DBAdaptor($species, 'variation') 
scripts/import/update_changed_sets.pl:my $dbh = $db_adaptor->dbc;
scripts/import/update_changed_sets.pl:my $get_new_sth = $dbh->prepare(qq[ select vf.variation_id, vf.variation_set_id
scripts/import/update_changed_sets.pl:my $get_old_sth = $dbh->prepare(qq[ select vf.variation_id, vf.variation_set_id
scripts/import/update_changed_sets.pl:  $get_new_sth->execute($set_id) ||die;;
scripts/import/update_changed_sets.pl:  my $current = $get_new_sth->fetchall_arrayref();
scripts/import/update_changed_sets.pl:    $in_set{$l->[0]} = 1;
scripts/import/update_changed_sets.pl:    my @summ = split/\,/,$l->[1];
scripts/import/update_changed_sets.pl:    $recalculate_var{$l->[0]} = 1 unless grep $set_id,@summ;
scripts/import/update_changed_sets.pl:  $get_old_sth->execute($pattern) ||die;
scripts/import/update_changed_sets.pl:  my $previous = $get_old_sth->fetchall_arrayref();
scripts/import/update_changed_sets.pl:    $recalculate_var{$l->[0]} = 1 unless $in_set{$l->[0]} == 1;
scripts/import/update_changed_sets.pl:  my $get_struc_sth = $dbh->prepare(qq[ select variation_set_sub, variation_set_super from variation_set_structure]);
scripts/import/update_changed_sets.pl:  $get_struc_sth->execute() ||die;
scripts/import/update_changed_sets.pl:  my $dat = $get_struc_sth->fetchall_arrayref();
scripts/import/update_changed_sets.pl:    $parent{$l->[0]} = $l->[1] ;
scripts/import/update_changed_sets.pl:  my $get_set_sth = $dbh->prepare(qq[ select variation_set_id
scripts/import/update_changed_sets.pl:  $get_set_sth->execute($short_name) || die;
scripts/import/update_changed_sets.pl:  my $set_id = $get_set_sth->fetchall_arrayref();
scripts/import/update_changed_sets.pl:  die "No set found for $short_name\n" unless defined $set_id->[0]->[0];
scripts/import/update_changed_sets.pl:  return $set_id->[0]->[0];
scripts/import/update_changed_sets.pl:  my $get_vs_sth = $dbh->prepare(qq[ select variation_set_id
scripts/import/update_changed_sets.pl:  my $vf_upd_sth = $dbh->prepare(qq[ update variation_feature set variation_set_id = ? where variation_id = ?]);
scripts/import/update_changed_sets.pl:    $get_vs_sth->execute($var)||die;
scripts/import/update_changed_sets.pl:    my $dat = $get_vs_sth->fetchall_arrayref();
scripts/import/update_changed_sets.pl:      push @sets, $set->[0];
scripts/import/update_changed_sets.pl:      if (exists $parent->{$set->[0]}){
scripts/import/update_changed_sets.pl:        push @sets, $parent->{$set->[0]};
scripts/import/update_changed_sets.pl:        push @sets, $parent->{$parent->{$set->[0]}} if exists $parent->{$parent->{$set->[0]}};
scripts/import/update_changed_sets.pl:    $vf_upd_sth->execute( $set_summary,  $var )|| die;
scripts/import/update_changed_sets.pl:  die "\n\n\tUsage: update_changed_sets.pl -registry [registry file] -species [species name] -sets [short_name_attrib1,short_name_attrib2]\n\n";
scripts/import/get_target_dna.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/get_target_dna.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/get_target_dna.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/get_target_dna.pl:# eg -host -user -pass -port -snp_dbname -core_dbname etc
scripts/import/get_target_dna.pl:die('-species argument is required') if(!$species);
scripts/import/get_target_dna.pl:#usage('-target_dir argument is required') if(!$target_dir);
scripts/import/get_target_dna.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/get_target_dna.pl:my $cdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/get_target_dna.pl:my $dbCore = $cdb->dbc->db_handle;
scripts/import/get_target_dna.pl:  my $sa = $dba->get_SliceAdaptor();
scripts/import/get_target_dna.pl:    $slice = $sa->fetch_by_seq_region_id($seq_region_id,$start,$end);
scripts/import/get_target_dna.pl:    $slice = $sa->fetch_by_region( $coord_sys_name, $seq_region_name,$start,$end);
scripts/import/get_target_dna.pl:  my $output_name = "$target_dir/".$slice->seq_region_name().'-'.$slice->start.'.fa';
scripts/import/get_target_dna.pl:  #open OUT, ">$target_dir/".$slice->seq_region_name().'-'.$slice->start.'_rev.fa';
scripts/import/get_target_dna.pl:  print OUT ">".$slice->seq_region_name().'-'.$slice->start().'-'.$slice->end()."\n";
scripts/import/get_target_dna.pl:  my $seq = $slice->seq;
scripts/import/get_target_dna.pl:  my $sth = $dba->prepare(qq{
scripts/import/get_target_dna.pl:  $sth->execute;
scripts/import/get_target_dna.pl:  my $out = Bio::SeqIO->new(
scripts/import/get_target_dna.pl:			    -FORMAT => 'fasta',
scripts/import/get_target_dna.pl:  my $cla = $dba->get_RawContigAdaptor;
scripts/import/get_target_dna.pl:  while (my ($cid) = $sth->fetchrow) {
scripts/import/get_target_dna.pl:    my $contig = $cla->fetch_by_dbID($cid);
scripts/import/get_target_dna.pl:    $out->write_seq($contig);
scripts/import/get_target_dna.pl:  $sth->finish;
scripts/import/get_target_dna.pl:  ####change to use ensembl-4 api
scripts/import/get_target_dna.pl:  my $slice_adaptor = $dba->get_SliceAdaptor();
scripts/import/get_target_dna.pl:  #my $slice = $slice_adaptor->fetch_by_chr_name($chr_name);
scripts/import/get_target_dna.pl:  my $slice = $slice_adaptor->fetch_by_region ('chromosome',4,68800000,69500000);
scripts/import/get_target_dna.pl:  my $end   = $start + $SIZE -1;
scripts/import/get_target_dna.pl:  $end = $slice->length if($end > $slice->length);
scripts/import/get_target_dna.pl:  #open OUT, ">$target_dir/".$slice->seq_region_name().'_olap.fa' or die "can't open fasta files $! \n";
scripts/import/get_target_dna.pl:  while($start+$OVERLAP <= $slice->length) {
scripts/import/get_target_dna.pl:    print OUT ">". ($slice->start() + $start - 1) . '-' . ($slice->start() + $end - 1) . "\n";
scripts/import/get_target_dna.pl:    my $seq = $slice->subseq($start, $end);
scripts/import/get_target_dna.pl:    $start = $end - $OVERLAP + 1;
scripts/import/get_target_dna.pl:    $end = $start + $SIZE -1;
scripts/import/get_target_dna.pl:    $end = $slice->length if($end > $slice->length);
scripts/import/get_target_dna.pl:  my $slice_adaptor = $dba->get_SliceAdaptor();
scripts/import/get_target_dna.pl:  my @slices = @{$slice_adaptor->fetch_all($coord_sys_name,undef,1,1)};
scripts/import/get_target_dna.pl:	$slice = $slice->get_repeatmasked_seq();
scripts/import/get_target_dna.pl:      if ($slice->seq_region_name() =~ /NT|^A|^B|^C|^c|^Zv7/) {
scripts/import/get_target_dna.pl:      #print "seq_region_name is ",$slice->seq_region_name(),"\n";
scripts/import/get_target_dna.pl:      #if ($slice->seq_region_name() =~ /random|M|NT|^Contig/) {
scripts/import/get_target_dna.pl:	#print "name is ",$slice->seq_region_name(),"\n";
scripts/import/get_target_dna.pl:	open OUT, ">$target_dir/".$slice->seq_region_name().'.fa' or die "can't open fasta files $! \n";
scripts/import/get_target_dna.pl:      print OUT ">".$slice->seq_region_name().'-'.$slice->start().'-'.$slice->end()."\n";
scripts/import/get_target_dna.pl:      my $seq = $slice->seq;
scripts/import/import_lovd.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_lovd.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_lovd.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_lovd.pl:$registry->load_all($registry_file);
scripts/import/import_lovd.pl:my $sa = $registry->get_adaptor(
scripts/import/import_lovd.pl:my $dbh = $registry->get_adaptor(
scripts/import/import_lovd.pl:)->dbc->db_handle;
scripts/import/import_lovd.pl:my $src_sth = $dbh->prepare(qq{ SELECT source_id FROM source WHERE name LIKE "LOVD%"});
scripts/import/import_lovd.pl:$src_sth->execute;
scripts/import/import_lovd.pl:my $existing_src = $src_sth->fetchrow_arrayref;
scripts/import/import_lovd.pl:$src_sth->finish();
scripts/import/import_lovd.pl:  $source_id = $existing_src->[0];
scripts/import/import_lovd.pl:  my $sth = $dbh->prepare(qq{ UPDATE source SET version=? WHERE source_id=? });
scripts/import/import_lovd.pl:  $sth->execute($version,$source_id);
scripts/import/import_lovd.pl:  my $sth = $dbh->prepare(qq{
scripts/import/import_lovd.pl:  $sth->execute;
scripts/import/import_lovd.pl:  $source_id = $dbh->last_insert_id(undef, undef, undef, undef);
scripts/import/import_lovd.pl:  $sth->finish();
scripts/import/import_lovd.pl:my $study_sth = $dbh->prepare(qq{ SELECT study_id FROM study WHERE source_id=? });
scripts/import/import_lovd.pl:$study_sth->execute($source_id);
scripts/import/import_lovd.pl:my $existing_study = $study_sth->fetchrow_arrayref;
scripts/import/import_lovd.pl:$study_sth->finish();
scripts/import/import_lovd.pl:  $study_id = $existing_study->[0];
scripts/import/import_lovd.pl:  my $sth = $dbh->prepare(qq{
scripts/import/import_lovd.pl:      'Variants from Locus-specific databases (LSDBs) hosted by Leiden Open (source) Variation Database (LOVD). These are online gene-centered collections and displays of manually curated DNA variations.',
scripts/import/import_lovd.pl:  $sth->execute($source_id);
scripts/import/import_lovd.pl:  $study_id = $dbh->last_insert_id(undef, undef, undef, undef);
scripts/import/import_lovd.pl:  $sth->finish();
scripts/import/import_lovd.pl:my $attr_type_sth = $dbh->prepare(qq{ SELECT attrib_type_id FROM attrib_type WHERE code='SO_term'});
scripts/import/import_lovd.pl:$attr_type_sth->execute;
scripts/import/import_lovd.pl:my $attr_type_id = ($attr_type_sth->fetchrow_array)[0];
scripts/import/import_lovd.pl:$attr_type_sth->finish;
scripts/import/import_lovd.pl:my $find_existing_var_sth = $dbh->prepare(qq{
scripts/import/import_lovd.pl:my $add_var_sth = $dbh->prepare(qq{
scripts/import/import_lovd.pl:my $add_vf_sth = $dbh->prepare(qq{
scripts/import/import_lovd.pl:my $find_existing_svar_sth = $dbh->prepare(qq{
scripts/import/import_lovd.pl:my $add_svar_sth = $dbh->prepare(qq{
scripts/import/import_lovd.pl:my $add_svf_sth = $dbh->prepare(qq{
scripts/import/import_lovd.pl:      $al_alt = '-';
scripts/import/import_lovd.pl:      my $count = $1 - 1;
scripts/import/import_lovd.pl:      $al_ref = '-';
scripts/import/import_lovd.pl:      $al_ref = '-';
scripts/import/import_lovd.pl:    if ($type !~ /insertion/i && $stop-$start > 50) {
scripts/import/import_lovd.pl:    my $slice = $sa->fetch_by_region('chromosome', $chr, $start, $stop);
scripts/import/import_lovd.pl:      my $seq = $slice->seq;
scripts/import/import_lovd.pl:            $strand = -1;
scripts/import/import_lovd.pl:            $strand = -1;
scripts/import/import_lovd.pl:      print STDERR "Coordinates of the variant '$accession' can't be mapped to the genome ($chr:$start-$stop)\n";
scripts/import/import_lovd.pl:        print STDERR "Alleles of the variant '$accession' can't be mapped to the genome ($allele_string) => ($chr:$start-$stop)\n";
scripts/import/import_lovd.pl:        print STDERR "Coordinates of the variant '$accession' ($chr:$start-$stop) don't correspond to the type of variant '$type'\n";
scripts/import/import_lovd.pl:    if ($strand == -1 and $prefix eq '') {
scripts/import/import_lovd.pl:    my $class_attrib_id = $SO_terms->{$type};
scripts/import/import_lovd.pl:    my $seq_region_id = $sa->get_seq_region_id($slice);
scripts/import/import_lovd.pl:        $find_existing_var_sth->execute($accession);
scripts/import/import_lovd.pl:        my $existing_var = $find_existing_var_sth->fetchrow_arrayref;
scripts/import/import_lovd.pl:          $variation_id = $existing_var->[0];
scripts/import/import_lovd.pl:          $add_var_sth->execute($source_id, $accession, $flipped, $class_attrib_id);
scripts/import/import_lovd.pl:          $variation_id = $dbh->last_insert_id(undef, undef, undef, undef);
scripts/import/import_lovd.pl:      $add_vf_sth->execute(
scripts/import/import_lovd.pl:      $find_existing_svar_sth->execute($accession);
scripts/import/import_lovd.pl:      my $existing_svar = $find_existing_svar_sth->fetchrow_arrayref;
scripts/import/import_lovd.pl:        $structural_variation_id = $existing_svar->[0];
scripts/import/import_lovd.pl:        $add_svar_sth->execute($source_id, $study_id, $accession, $class_attrib_id);
scripts/import/import_lovd.pl:        $structural_variation_id = $dbh->last_insert_id(undef, undef, undef, undef);
scripts/import/import_lovd.pl:      $add_svf_sth->execute(
scripts/import/import_lovd.pl:  my $attr_list_sth = $dbh->prepare(qq{ SELECT attrib_id,value FROM attrib WHERE attrib_type_id=$type_id});
scripts/import/import_lovd.pl:  $attr_list_sth->execute;
scripts/import/import_lovd.pl:  while(my @row = $attr_list_sth->fetchrow_array) {
scripts/import/import_lovd.pl:  if ($dbh->do(qq{show columns from variation_feature like '$not_flipped_col';}) != 1){
scripts/import/import_lovd.pl:    $dbh->do(qq{ALTER TABLE variation_feature ADD COLUMN $not_flipped_col varchar(255) DEFAULT NULL;});
scripts/import/import_lovd.pl:  if ($dbh->do(qq{SHOW KEYS FROM variation_feature WHERE Key_name='name_key';}) < 1){
scripts/import/import_lovd.pl:    $dbh->do(qq{ALTER TABLE variation_feature ADD CONSTRAINT UNIQUE KEY `name_key` (`variation_name`,`seq_region_id`,`seq_region_start`)});
scripts/import/import_lovd.pl:  if ($dbh->do(qq{SHOW KEYS FROM structural_variation_feature WHERE Key_name='name_key';}) < 1){
scripts/import/import_lovd.pl:    $dbh->do(qq{ALTER TABLE structural_variation_feature ADD CONSTRAINT UNIQUE KEY `name_key` (`variation_name`,`seq_region_id`,`seq_region_start`)});
scripts/import/import_lovd.pl:  $dbh->do(qq{ALTER TABLE variation_feature DROP INDEX `name_key`});
scripts/import/import_lovd.pl:  $dbh->do(qq{ALTER TABLE structural_variation_feature DROP INDEX `name_key`});
scripts/import/import_lovd.pl:  $dbh->do(qq{DROP TABLE IF EXISTS tmp_vf_map_weight});
scripts/import/import_lovd.pl:  $dbh->do(qq{
scripts/import/import_lovd.pl:  $dbh->do(qq{
scripts/import/import_lovd.pl:  $dbh->do(qq{
scripts/import/import_lovd.pl:  $dbh->do(qq{ DROP table tmp_vf_map_weight});
scripts/import/import_lovd.pl:  $dbh->do(qq{
scripts/import/import_lovd.pl:    UPDATE variation_feature SET allele_string=$not_flipped_col,seq_region_strand=-1 WHERE $not_flipped_col is not null and map_weight>1;
scripts/import/import_lovd.pl:  #$dbh->do(qq{ALTER TABLE variation_feature DROP COLUMN $not_flipped_col});
scripts/import/import_set_from_file.pl:populate variation_set_variation from a list of variants & pre-loaded variation_set  
scripts/import/import_set_from_file.pl:import_set_from_file.pl -load_file [rs list] -variation_set [short name attrib] -species [species] -registry [ensembl registry]  -done_file [previously loaded rs id]
scripts/import/import_set_from_file.pl:sql to pre-load set & attrib if not present:
scripts/import/import_set_from_file.pl:die "\n Usage: import_set_from_file.pl -load_file [rs list] -variation_set [short name attrib] -species [species] -registry [ensembl registry]
scripts/import/import_set_from_file.pl:\tOptions: -done_file [previously loaded rs id]\n\n";
scripts/import/import_set_from_file.pl:$registry->load_all($registry_file);
scripts/import/import_set_from_file.pl:my $dba  = $registry->get_DBAdaptor($species, 'variation');
scripts/import/import_set_from_file.pl:my $dbh  = $dba->dbc->db_handle();
scripts/import/import_set_from_file.pl:my $var_ext_sth         =  $dbh->prepare(qq [select variation_id from variation where name =?]);
scripts/import/import_set_from_file.pl:my $old_var_ext_sth     =  $dbh->prepare(qq [select variation_id
scripts/import/import_set_from_file.pl:my $insert_varset_var   =  $dbh->prepare(qq [insert ignore into variation_set_variation
scripts/import/import_set_from_file.pl:## find pre-existing set
scripts/import/import_set_from_file.pl:my $vs_adaptor = $registry->get_adaptor($species,'variation','variationset');
scripts/import/import_set_from_file.pl:my $varset = $vs_adaptor->fetch_by_short_name($set_attrib);
scripts/import/import_set_from_file.pl:  open $load_var, "gunzip -c $load_file |" ||die "Failed to open $load_file :$!\n";
scripts/import/import_set_from_file.pl:  $var_ext_sth->execute(  $rs ) ||die "Error geting var id $rs\n";
scripts/import/import_set_from_file.pl:  my $id = $var_ext_sth->fetchall_arrayref();
scripts/import/import_set_from_file.pl:  unless(defined $id->[0]->[0]){ 
scripts/import/import_set_from_file.pl:    $old_var_ext_sth->execute($rs) ||die "Error geting synon var id $rs\n";
scripts/import/import_set_from_file.pl:    $id = $old_var_ext_sth->fetchall_arrayref();
scripts/import/import_set_from_file.pl:    unless(defined $id->[0]->[0]){ 
scripts/import/import_set_from_file.pl:  $insert_varset_var->execute( $varset->dbID() , $id->[0]->[0] ) ||die "Error inserting var_set var $rs\n"; 
scripts/import/import_variant_synonyms:Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_variant_synonyms:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_variant_synonyms:     http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_variant_synonyms:##  - initially from PharmGKB database
scripts/import/import_variant_synonyms:$reg->load_all($registry_file);
scripts/import/import_variant_synonyms:my $dba = $reg->get_DBAdaptor($species, 'variation');
scripts/import/import_variant_synonyms:$dba->include_failed_variations(1);
scripts/import/import_variant_synonyms:  my $prod_dbc = Bio::EnsEMBL::DBSQL::DBConnection->new
scripts/import/import_variant_synonyms:    ( '-host'    => $host,
scripts/import/import_variant_synonyms:      '-port'    => $port, 
scripts/import/import_variant_synonyms:      '-user'    => $user,
scripts/import/import_variant_synonyms:      '-pass'    => $pass,
scripts/import/import_variant_synonyms:      '-dbname'  => $db_name, 
scripts/import/import_variant_synonyms:      '-driver'  =>  'mysql' 
scripts/import/import_variant_synonyms:  # some synonyms names are duplicated - from different sources 
scripts/import/import_variant_synonyms:    $data{$result->[0].' '.$result->[1]}{rs_name} = $result->[0]; 
scripts/import/import_variant_synonyms:    $data{$result->[0].' '.$result->[1]}{source_id} = $result->[2]; 
scripts/import/import_variant_synonyms:  # Source UniProt - variation_set table 
scripts/import/import_variant_synonyms:  $source_description = $source_uniprot{$source_name}->{description}; 
scripts/import/import_variant_synonyms:  $source_url = $source_uniprot{$source_name}->{url}; 
scripts/import/import_variant_synonyms:  my $set = $source_uniprot{$source_name}->{set}; 
scripts/import/import_variant_synonyms:  my $object_type = $source_uniprot{$source_name}->{type}; 
scripts/import/import_variant_synonyms:  my $source_status = $source_uniprot{$source_name}->{status}; 
scripts/import/import_variant_synonyms:  my $source_id = $source->dbID();
scripts/import/import_variant_synonyms:  my $source_name = $source->name(); 
scripts/import/import_variant_synonyms:  if (exists($result->{'synonyms'})) {
scripts/import/import_variant_synonyms:    %synonym = %{$result->{'synonyms'}};
scripts/import/import_variant_synonyms:  $source_description ||= $source_eva{$source_name}->{description};
scripts/import/import_variant_synonyms:  $source_url ||= $source_eva{$source_name}->{url};
scripts/import/import_variant_synonyms:  my $source_status = $source_eva{$source_name}->{status};
scripts/import/import_variant_synonyms:  my $int_dba = $reg->get_DBAdaptor('multi', 'intvar') || warn "Error getting intvar db adaptor\n";;
scripts/import/import_variant_synonyms:  add_synonym_pig_chip($species, $dba, $int_dba, $source->dbID());
scripts/import/import_variant_synonyms:  my $http = HTTP::Tiny->new();
scripts/import/import_variant_synonyms:  my $response = $http->get($url); 
scripts/import/import_variant_synonyms:  die "Failed to pick up file: $data_file\n" unless $response->{success};
scripts/import/import_variant_synonyms:  print $out  $response->{content};
scripts/import/import_variant_synonyms:    if ($_ =~ m/^(\S+)\s+\S+\s+(VAR\_\d+)\s+\w\.\S+\s+(LP\/P|LB\/B|US)\s+(\-|rs\d*)\s*(.*)$/) {
scripts/import/import_variant_synonyms:      if ($rs_id ne '-') {
scripts/import/import_variant_synonyms:  my $sth = $db_adaptor->dbc->prepare($stmt);
scripts/import/import_variant_synonyms:  $sth->execute();
scripts/import/import_variant_synonyms:  $sth->bind_columns(\$variation_set_id);
scripts/import/import_variant_synonyms:  $sth->fetch();
scripts/import/import_variant_synonyms:    my $sth_attrib = $db_adaptor->dbc->prepare($stmt_attrib);
scripts/import/import_variant_synonyms:    $sth_attrib->execute();
scripts/import/import_variant_synonyms:    $sth_attrib->bind_columns(\$attrib_id);
scripts/import/import_variant_synonyms:    $sth_attrib->fetch();
scripts/import/import_variant_synonyms:    $db_adaptor->dbc->do($ins_stmt); 
scripts/import/import_variant_synonyms:    $variation_set_id = $db_adaptor->dbc->db_handle->{'mysql_insertid'};
scripts/import/import_variant_synonyms:  my $variation_adaptor = $db_adaptor->get_VariationAdaptor($species, 'variation', );
scripts/import/import_variant_synonyms:  my $check_variation_set_sth = $db_adaptor->dbc->prepare($stmt_check_var_set); 
scripts/import/import_variant_synonyms:  my $update_after_check_sth = $db_adaptor->dbc->prepare($stmt_update_after_check);
scripts/import/import_variant_synonyms:  my $update_variation_set_sth = $db_adaptor->dbc->prepare($stmt_update);
scripts/import/import_variant_synonyms:  my $insert_var_set = $db_adaptor->dbc->prepare($stmt_insert_var_set);
scripts/import/import_variant_synonyms:    my $variation = $variation_adaptor->fetch_by_name($rs_id);
scripts/import/import_variant_synonyms:    my $var_dbid = $variation->dbID();
scripts/import/import_variant_synonyms:    $variation->add_synonym($source_name, @{$synonyms->{$rs_id}}); 
scripts/import/import_variant_synonyms:    $variation_adaptor->store_synonyms($variation); 
scripts/import/import_variant_synonyms:    $check_variation_set_sth->bind_param(1, $var_dbid, SQL_VARCHAR);
scripts/import/import_variant_synonyms:    $check_variation_set_sth->execute();
scripts/import/import_variant_synonyms:    $check_variation_set_sth->bind_columns(\$var_set_id);
scripts/import/import_variant_synonyms:    $check_variation_set_sth->fetch();
scripts/import/import_variant_synonyms:      $update_after_check_sth->execute($var_dbid) or die ("Failed to update variation_set_id: variation_id $var_dbid\n");
scripts/import/import_variant_synonyms:      $update_variation_set_sth->execute($var_dbid) or die ("Failed to update variation_set_id: variation_id $var_dbid\n");
scripts/import/import_variant_synonyms:    $insert_var_set->execute($var_dbid, $variation_set_id) or die ("Failed to insert $rs_id into variation_set_variation\n");
scripts/import/import_variant_synonyms:    $row_data[7] =~ /CURR=(rs[0-9]+)/;
scripts/import/import_variant_synonyms:  my $variation_adaptor = $dba->get_VariationAdaptor($species, 'variation', );
scripts/import/import_variant_synonyms:    my $var = $variation_adaptor->fetch_by_name($var_name);
scripts/import/import_variant_synonyms:    $var->add_synonym($source->name(), $synonyms->{$var_name});
scripts/import/import_variant_synonyms:    $variation_adaptor->store_synonyms($var);
scripts/import/import_variant_synonyms:  my $variation_adaptor = $dest_db->get_VariationAdaptor($species, 'variation');  
scripts/import/import_variant_synonyms:    my $var_name = $data->{$synonym_name}->{rs_name}; 
scripts/import/import_variant_synonyms:    my $var = $variation_adaptor->fetch_by_name($var_name); 
scripts/import/import_variant_synonyms:    my $source_id = $data->{$synonym_name}->{source_id};
scripts/import/import_variant_synonyms:    my $source = $sources->{$source_id}; 
scripts/import/import_variant_synonyms:    # Clean synonym name before insert in db - remove rsid from name  
scripts/import/import_variant_synonyms:    $var->add_synonym($source->name(), $synonym_name);
scripts/import/import_variant_synonyms:    $variation_adaptor->store_synonyms($var); 
scripts/import/import_variant_synonyms:  my $variation_adaptor = $dba->get_VariationAdaptor($species, 'variation', );
scripts/import/import_variant_synonyms:  my $synonym_ext_sth = $int_dba->dbc->prepare(qq[ SELECT rs_name, synonym_name FROM pig_synonym ]);
scripts/import/import_variant_synonyms:  $synonym_ext_sth->execute();
scripts/import/import_variant_synonyms:  my $all_syn = $synonym_ext_sth->fetchall_arrayref();
scripts/import/import_variant_synonyms:  my $synonym_ins_sth   = $variation_adaptor->dbc->prepare(qq[ INSERT IGNORE INTO variation_synonym (variation_id, name, source_id)
scripts/import/import_variant_synonyms:    my $var = $variation_adaptor->fetch_by_name($synonym->[0]);
scripts/import/import_variant_synonyms:      $synonym_ins_sth->execute( $var->dbID, $synonym->[1], $source_id );
scripts/import/import_variant_synonyms:      warn "Variant $synonym->[0] not found\n";
scripts/import/import_variant_synonyms:  my $source_adaptor = $dba->get_SourceAdaptor($species, 'variation', );
scripts/import/import_variant_synonyms:  my $source = $source_adaptor->fetch_by_name($source_name);
scripts/import/import_variant_synonyms:      $source->version($version);
scripts/import/import_variant_synonyms:      $source_adaptor->update_version($source);   
scripts/import/import_variant_synonyms:      $version = localtime->strftime('%Y%m%d');
scripts/import/import_variant_synonyms:      $source->version($version);
scripts/import/import_variant_synonyms:      $source_adaptor->update_version($source);
scripts/import/import_variant_synonyms:    print "Source information not held for $source_name - adding supplied info\n" unless defined $source ;
scripts/import/import_variant_synonyms:    $source = Bio::EnsEMBL::Variation::Source->new
scripts/import/import_variant_synonyms:       (-name           => $source_name,
scripts/import/import_variant_synonyms:        -url            => $url           || undef,
scripts/import/import_variant_synonyms:        -version        => $version       || undef,
scripts/import/import_variant_synonyms:        -description    => $description   || undef,
scripts/import/import_variant_synonyms:        -somatic_status => $source_status || undef,
scripts/import/import_variant_synonyms:        -data_types     => ['variation_synonym']
scripts/import/import_variant_synonyms:      $source_adaptor->store($source);
scripts/import/import_variant_synonyms:  my $source_adaptor = $dest_db->get_SourceAdaptor('human', 'variation'); 
scripts/import/import_variant_synonyms:    # my $source_id = $result_from_source->[0]; 
scripts/import/import_variant_synonyms:    my $source_name = $result_from_source->[1]; 
scripts/import/import_variant_synonyms:    my $source = $source_adaptor->fetch_by_name($source_name);
scripts/import/import_variant_synonyms:      $source = Bio::EnsEMBL::Variation::Source->new
scripts/import/import_variant_synonyms:         (-name        => $source_name, 
scripts/import/import_variant_synonyms:          -url         => $result_from_source->[4],
scripts/import/import_variant_synonyms:          -version     => $result_from_source->[2],
scripts/import/import_variant_synonyms:          -description => $result_from_source->[3], 
scripts/import/import_variant_synonyms:          -data_types  => ['variation_synonym']
scripts/import/import_variant_synonyms:        $source_adaptor->store($source);
scripts/import/import_variant_synonyms:    $source_list{$result_from_source->[0]} = $source; 
scripts/import/import_variant_synonyms:  my $statement = $prod_dbc->prepare($sql_query);  
scripts/import/import_variant_synonyms:  $statement->execute(); 
scripts/import/import_variant_synonyms:  my $source_output = $statement->fetchall_arrayref();  
scripts/import/import_variant_synonyms:  $statement->finish(); 
scripts/import/import_variant_synonyms:  die "\nUsage : import_variant_synonyms -registry [registry file] -source_name [name]
scripts/import/import_variant_synonyms:\t         -data_file          [name of file to load]  - mandatory for EVA
scripts/import/import_variant_synonyms:\t         -source_name        [source]                - 'PharmGKB', 'dbSNP', 'UniProt', 'EVA' or 'pig_chip'
scripts/import/import_variant_synonyms:\t         -source_version     [version]
scripts/import/import_variant_synonyms:\t         -source_url         [url]
scripts/import/import_variant_synonyms:\t         -source_description [longer description]
scripts/import/import_variant_synonyms:\t         -species            [species]               - defaults to human
scripts/import/import_variant_synonyms:\t         -registry           [registry file]
scripts/import/import_variant_synonyms:\t         -db_name            [production db name]
scripts/import/import_variant_synonyms:\t         -host               [production db host]
scripts/import/import_variant_synonyms:\t         -port               [production db port]
scripts/import/import_variant_synonyms:\t         -user               [user]
scripts/import/import_variant_synonyms:\t         -pass               [pass]
scripts/import/import_variant_synonyms:\t         -clean                                      - remove old data\n\n";
scripts/import/nextstrain/nextstrain_geno2vcf.pl:my $db = Bio::DB::Fasta->new( $ARGV[1] )||die "Failed to index fasta for checking: $!\n";
scripts/import/nextstrain/nextstrain_geno2vcf.pl:  my $ref_seq = $db->seq($seq_name, $var, $var);
scripts/import/nextstrain/nextstrain_geno2vcf.pl:  ### deal with alleles - could be multi-allelic
scripts/import/nextstrain/nextstrain_geno2vcf.pl:    if (defined $samples->{$sam}{$var}{ref} ){
scripts/import/nextstrain/nextstrain_geno2vcf.pl:      if($al2code->{ $samples->{$sam}{$var}{ref} } ne "0"){
scripts/import/nextstrain/nextstrain_geno2vcf.pl:      #  print "Ref swap:\t$var\t$sam\t$samples->{$sam}{$var}{ref}\t$samples->{$sam}{$var}{alt}\n";
scripts/import/nextstrain/nextstrain_geno2vcf.pl:      unless( defined $al2code->{ $samples->{$sam}{$var}{alt}} ){
scripts/import/nextstrain/nextstrain_geno2vcf.pl:        die "no code for $sam $var ($samples->{$sam}{$var}{alt}})\n";
scripts/import/nextstrain/nextstrain_geno2vcf.pl:      $genos .= "$al2code->{ $samples->{$sam}{$var}{alt} }\t";
scripts/import/nextstrain/nextstrain_geno2vcf.pl:      ## allow for multi-allelic; skipping reference
scripts/import/nextstrain/nextstrain_geno2vcf.pl:      $counts{ $al2code->{ $samples->{$sam}{$var}{alt} } }++
scripts/import/nextstrain/nextstrain_geno2vcf.pl:        unless $al2code->{ $samples->{$sam}{$var}{alt} } eq "0";
scripts/import/nextstrain/nextstrain_json2geno.pl:  my $tr = $h->{tree}->{children};
scripts/import/nextstrain/nextstrain_json2geno.pl:    ## seed with a reference match to save ref-matching samples
scripts/import/nextstrain/nextstrain_json2geno.pl:  my $inherit_var = shift; ## may be undef - hash of variant locations from parent
scripts/import/nextstrain/nextstrain_json2geno.pl:  my $clade = $ch->{node_attrs}->{clade_membership}->{value};
scripts/import/nextstrain/nextstrain_json2geno.pl:  my $muts = $ch->{branch_attrs}->{mutations};
scripts/import/nextstrain/nextstrain_json2geno.pl:  if($muts->{nuc}){
scripts/import/nextstrain/nextstrain_json2geno.pl:    for( my $n =0; $n < scalar(@{$muts->{nuc}}) ; $n++ ){
scripts/import/nextstrain/nextstrain_json2geno.pl:      my $var  = $muts->{nuc}->[$n];
scripts/import/nextstrain/nextstrain_json2geno.pl:      my $prot = $muts->{$gene}->[$n] || "."; 
scripts/import/nextstrain/nextstrain_json2geno.pl:      unless ($ch->{name} =~/travel_history|NODE/){
scripts/import/nextstrain/nextstrain_json2geno.pl:        print $out "$changed_pos{$pos}\t$ch->{name}\t$clade\t$parent\n";
scripts/import/nextstrain/nextstrain_json2geno.pl:    $changed_pos{$pos} = $inherit_var->{$pos};
scripts/import/nextstrain/nextstrain_json2geno.pl:    unless( $ch->{name} =~/travel_history|NODE/){
scripts/import/nextstrain/nextstrain_json2geno.pl:      print $out $inherit_var->{$pos} . "\t$ch->{name}\t$clade\t$parent\n";
scripts/import/nextstrain/nextstrain_json2geno.pl:  foreach my $child (@{$ch->{children}}){
scripts/import/nextstrain/nextstrain_json2geno.pl:    parse_children($child, $ch->{name}, \%changed_pos);
scripts/import/dbSNP_submission.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dbSNP_submission.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dbSNP_submission.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dbSNP_submission.pl:# bsub -q bigmem -W4:00 -R"select[mem>3500] rusage[mem=3500]" -M3500000
scripts/import/dbSNP_submission.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/dbSNP_submission.pl:my $dbVariation = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/dbSNP_submission.pl:my $dbCore = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/dbSNP_submission.pl:my $var_adaptor = $dbVariation->get_VariationAdaptor();
scripts/import/dbSNP_submission.pl:my $pop_adaptor = $dbVariation->get_PopulationAdaptor();
scripts/import/dbSNP_submission.pl:my $population = $pop_adaptor->fetch_by_name($population_name);
scripts/import/dbSNP_submission.pl:my $variations = $var_adaptor->fetch_all_by_Population($population);
scripts/import/dbSNP_submission.pl:my $vf_adaptor = $dbVariation->get_VariationFeatureAdaptor();
scripts/import/dbSNP_submission.pl:    print SNP "METHOD:\tEnsembl-SSAHA\n";
scripts/import/dbSNP_submission.pl:	my $vf = shift @{$vf_adaptor->fetch_all_by_Variation($variation)};
scripts/import/dbSNP_submission.pl:	print SNP "SNP:\t",$variation->name,"\n";
scripts/import/dbSNP_submission.pl:	print SNP "ACCESSION:\t",$vf->slice->accession_number,"\n"; #is this the info they want ??
scripts/import/dbSNP_submission.pl:	print SNP "LENGTH:\t", length($variation->five_prime_flanking_seq) + length($variation->three_prime_flanking_seq) + 1,"\n";
scripts/import/dbSNP_submission.pl:	print SNP "5\'_FLANK:\t",$variation->five_prime_flanking_seq,"\n";
scripts/import/dbSNP_submission.pl:	print SNP "OBSERVED:\t", $vf->allele_string,"\n";
scripts/import/dbSNP_submission.pl:	print SNP "3\'_FLANK:\t",$variation->three_prime_flanking_seq,"\n";
scripts/import/dbSNP_submission.pl:    print $fh "ADDR:\tEMBL-EBI,Wellcome Trust Genome Campus,Hinxton,CB10 1SD Cambridge, UK\n";
scripts/import/dbSNP_submission.pl:    print $fh "ID:\tEnsembl-SSAHA\n"; #which method ??
scripts/import/import_cnv.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_cnv.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_cnv.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_cnv.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/import_cnv.pl:my $dbCore = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/import_cnv.pl:my $dbVar = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/import_cnv.pl:my $slice_adaptor = $dbCore->get_SliceAdaptor();
scripts/import/import_cnv.pl:    write_file("$TMP_DIR/flanking_sequence.txt",$variation_id,$start - 100,$start - 1,$end + 1, $end + 100, $seq_region_id,1);
scripts/import/import_cnv.pl:load($dbVar->dbc,"source","source_id","name");
scripts/import/import_cnv.pl:load($dbVar->dbc,"variation","variation_id","source_id","name");
scripts/import/import_cnv.pl:load($dbVar->dbc,"variation_synonym","variation_synonym_id","variation_id","source_id","name");
scripts/import/import_cnv.pl:load($dbVar->dbc,"variation_feature","variation_feature_id","seq_region_id","seq_region_start","seq_region_end","seq_region_strand","variation_id","allele_string","variation_name","map_weight","source_id");
scripts/import/import_cnv.pl:load($dbVar->dbc,"flanking_sequence","variation_id","up_seq_region_start","up_seq_region_end","down_seq_region_start","down_seq_region_end","seq_region_id","seq_region_strand");
scripts/import/import_cnv.pl:    my $slice = $slice_adaptor->fetch_by_region('chromosome',$chr);
scripts/import/import_cnv.pl:    return $slice->get_seq_region_id();
scripts/import/project_feature.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/project_feature.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/project_feature.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/project_feature.pl:) or die "Error: Failed to parse command-line args. Try --help for usage instructions\n";
scripts/import/project_feature.pl:if ($config->{help} || !$args) {
scripts/import/project_feature.pl:unless ($config->{vdbname_oldasm} && $config->{vhost_oldasm}) {
scripts/import/project_feature.pl:  unless ($config->{vdbname_newasm} && $config->{vhost_newasm}) {
scripts/import/project_feature.pl:    die 'The script requires information about the variation database that contains the table which needs to be projected. Try --help for usage instructions';
scripts/import/project_feature.pl:    $config->{use_new_vdb_only} = 1;
scripts/import/project_feature.pl:# Test argument settings are correct -------------------------
scripts/import/project_feature.pl:  unless ($config->{$arg}) {
scripts/import/project_feature.pl:    warn "--$arg must be defined\n";
scripts/import/project_feature.pl:  die 'Missing arguments. Try --help for usage instructions';
scripts/import/project_feature.pl:unless ($config->{feature_type} eq 'vf' || $config->{feature_type} eq 'svf') {
scripts/import/project_feature.pl:  die '--feature_type must be vf or svf. Try --help for usage instructions';
scripts/import/project_feature.pl:unless ($config->{use_new_vdb_only}) {
scripts/import/project_feature.pl:  die '--vdbname_oldasm must be defined. Try --help for usage instructions' unless ($config->{vdbname_oldasm});
scripts/import/project_feature.pl:  die '--vhost_oldasm must be defined. Try --help for usage instructions' unless ($config->{vhost_oldasm});
scripts/import/project_feature.pl:  $config->{$arg} ||= 3306;
scripts/import/project_feature.pl:  $config->{$arg} ||= 'ensro';
scripts/import/project_feature.pl:$config->{vuser_newasm} ||= 'ensadmin';
scripts/import/project_feature.pl:my $working_dir = $config->{working_dir};
scripts/import/project_feature.pl:die "$working_dir doesn't exist. Please create $working_dir before running the script" unless (-d $working_dir);
scripts/import/project_feature.pl:  die "$dir already exists. Please delete $dir before running the script" if (-d "$working_dir/$dir");
scripts/import/project_feature.pl:  $config->{$dir} = "$working_dir/$dir";
scripts/import/project_feature.pl:# Start projection ------------------------------------------------
scripts/import/project_feature.pl:if ($config->{load_failed_projections}) {
scripts/import/project_feature.pl:  unless ($config->{use_new_vdb_only}) {
scripts/import/project_feature.pl:        -host   => $config->{vhost_oldasm},
scripts/import/project_feature.pl:        -user   => $config->{vuser_oldasm},
scripts/import/project_feature.pl:        -port   => $config->{vport_oldasm},
scripts/import/project_feature.pl:        -dbname => $config->{vdbname_oldasm},
scripts/import/project_feature.pl:    $vdba_oldasm->dbc->reconnect_when_lost(1);
scripts/import/project_feature.pl:    $config->{vdba_oldasm} = $vdba_oldasm;
scripts/import/project_feature.pl:      -host   => $config->{vhost_newasm},
scripts/import/project_feature.pl:      -user   => $config->{vuser_newasm},
scripts/import/project_feature.pl:      -pass   => $config->{vpass_newasm},
scripts/import/project_feature.pl:      -port   => $config->{vport_newasm},
scripts/import/project_feature.pl:      -dbname => $config->{vdbname_newasm},
scripts/import/project_feature.pl:  $vdba_newasm->dbc->reconnect_when_lost(1);
scripts/import/project_feature.pl:  $config->{vdba_newasm} = $vdba_newasm;
scripts/import/project_feature.pl:      -host   => $config->{chost_oldasm},
scripts/import/project_feature.pl:      -user   => $config->{cuser_oldasm},
scripts/import/project_feature.pl:      -port   => $config->{cport_oldasm},
scripts/import/project_feature.pl:      -dbname => $config->{cdbname_oldasm},
scripts/import/project_feature.pl:  $cdba_oldasm->dbc->reconnect_when_lost(1);
scripts/import/project_feature.pl:  $config->{cdba_oldasm} = $cdba_oldasm;
scripts/import/project_feature.pl:      -host   => $config->{chost_newasm},
scripts/import/project_feature.pl:      -user   => $config->{cuser_newasm},
scripts/import/project_feature.pl:      -port   => $config->{cport_newasm},
scripts/import/project_feature.pl:      -dbname => $config->{cdbname_newasm},
scripts/import/project_feature.pl:  $cdba_newasm->dbc->reconnect_when_lost(1);
scripts/import/project_feature.pl:  $config->{cdba_newasm} = $cdba_newasm;
scripts/import/project_feature.pl:  if ($config->{include_asm_exceptions}) {
scripts/import/project_feature.pl:    my $cdba_newasm = $config->{cdba_newasm};
scripts/import/project_feature.pl:    my $sa_new = $cdba_newasm->get_SliceAdaptor; 
scripts/import/project_feature.pl:    my $aefa   = $cdba_newasm->get_AssemblyExceptionFeatureAdaptor;
scripts/import/project_feature.pl:    my $slices = $sa_new->fetch_all('chromosome', undef, 1, 1);
scripts/import/project_feature.pl:      my $seq_region_name = $slice->seq_region_name;
scripts/import/project_feature.pl:        my $assembly_exception_features = $aefa->fetch_all_by_Slice($slice);
scripts/import/project_feature.pl:          my $alt_slice = $feature->alternate_slice();
scripts/import/project_feature.pl:          foreach my $synonym (@{$alt_slice->get_all_synonyms()}) {
scripts/import/project_feature.pl:            $seq_names_synonyms->{$alt_slice->seq_region_name} = $synonym->name;
scripts/import/project_feature.pl:  $config->{synonyms} = $seq_names_synonyms;
scripts/import/project_feature.pl:  my $feature_table = $config->{feature_table_name_oldasm};
scripts/import/project_feature.pl:  if ($config->{use_new_vdb_only}) {
scripts/import/project_feature.pl:    $dbname = $config->{vdbname_newasm};
scripts/import/project_feature.pl:    $vdba   = $config->{vdba_newasm};
scripts/import/project_feature.pl:    $dbname = $config->{vdbname_oldasm};
scripts/import/project_feature.pl:    $vdba   = $config->{vdba_oldasm};
scripts/import/project_feature.pl:  my $dbh          = $vdba->dbc->db_handle;
scripts/import/project_feature.pl:  my $sth = $dbh->prepare(qq{
scripts/import/project_feature.pl:  $sth->execute();
scripts/import/project_feature.pl:  while (my @name = $sth->fetchrow_array) {
scripts/import/project_feature.pl:  $sth->finish();
scripts/import/project_feature.pl:  $config->{sorted_column_names} = $column_names_concat;
scripts/import/project_feature.pl:  $sth->finish();
scripts/import/project_feature.pl:  my $feature_table = $config->{feature_table_name_oldasm};
scripts/import/project_feature.pl:  my $column_names_concat = $config->{sorted_column_names};
scripts/import/project_feature.pl:  if ($config->{use_new_vdb_only}) {
scripts/import/project_feature.pl:    $dbname = $config->{vdbname_newasm};
scripts/import/project_feature.pl:    $vdba   = $config->{vdba_newasm};
scripts/import/project_feature.pl:    $dbname = $config->{vdbname_oldasm};
scripts/import/project_feature.pl:    $vdba   = $config->{vdba_oldasm};
scripts/import/project_feature.pl:  my $dbh          = $vdba->dbc->db_handle;
scripts/import/project_feature.pl:  my $dir_oldasm = $config->{dir_oldasm};
scripts/import/project_feature.pl:  my $cdba_oldasm = $config->{cdba_oldasm}; 
scripts/import/project_feature.pl:  my $sa_old = $cdba_oldasm->get_SliceAdaptor;
scripts/import/project_feature.pl:  if ($config->{include_asm_exceptions}) {
scripts/import/project_feature.pl:    $slices = $sa_old->fetch_all('chromosome', undef, 1); 
scripts/import/project_feature.pl:    $slices = $sa_old->fetch_all('chromosome', undef, 0); 
scripts/import/project_feature.pl:  my $sth = $dbh->prepare(qq{
scripts/import/project_feature.pl:    my $seq_region_name = $slice->seq_region_name;
scripts/import/project_feature.pl:    my $seq_region_id = $slice->get_seq_region_id; 
scripts/import/project_feature.pl:    my $fh = FileHandle->new("$dir_oldasm/$seq_region_name.txt", 'w');
scripts/import/project_feature.pl:    $sth->execute($seq_region_id);
scripts/import/project_feature.pl:    while (my $row = $sth->fetchrow_arrayref) {
scripts/import/project_feature.pl:    $sth->finish();
scripts/import/project_feature.pl:    $fh->close(); 
scripts/import/project_feature.pl:  my $dir_oldasm = $config->{dir_oldasm};    
scripts/import/project_feature.pl:  my $feature_type = $config->{feature_type}; 
scripts/import/project_feature.pl:  my $synonyms     = $config->{synonyms};
scripts/import/project_feature.pl:  my $cdba_newasm = $config->{cdba_newasm};
scripts/import/project_feature.pl:  my $sa_newasm   = $cdba_newasm->get_SliceAdaptor;
scripts/import/project_feature.pl:  my $oldasm_name = $config->{oldasm_name};
scripts/import/project_feature.pl:  my $dir_oldasm  = $config->{dir_oldasm};
scripts/import/project_feature.pl:  my $dir_newasm  = $config->{dir_newasm};
scripts/import/project_feature.pl:  my $slice_newdb_oldasm = $sa_newasm->fetch_by_region(
scripts/import/project_feature.pl:    my $fh = FileHandle->new("$dir_newasm/$report_type\_$seq_region_name.txt", 'w');
scripts/import/project_feature.pl:    $out->{$report_type} = $fh;
scripts/import/project_feature.pl:  if ($config->{flip}) {
scripts/import/project_feature.pl:    my $fh = FileHandle->new("$dir_newasm/flip_$seq_region_name.txt", 'w');
scripts/import/project_feature.pl:    $out->{flip} = $fh;
scripts/import/project_feature.pl:  my $fh = FileHandle->new("$dir_oldasm/$seq_region_name.txt", 'r');
scripts/import/project_feature.pl:      my $map_weight = $data->{map_weight};
scripts/import/project_feature.pl:      my $start  = $data->{seq_region_start};
scripts/import/project_feature.pl:      my $end    = $data->{seq_region_end};
scripts/import/project_feature.pl:      my $strand = $data->{seq_region_strand};    
scripts/import/project_feature.pl:        my $new_start           = $feature->seq_region_start;
scripts/import/project_feature.pl:        my $new_end             = $feature->seq_region_end;
scripts/import/project_feature.pl:        my $new_strand          = $feature->seq_region_strand;
scripts/import/project_feature.pl:        my $new_seq_region_id   = $feature->slice->get_seq_region_id;  
scripts/import/project_feature.pl:        my $new_seq_region_name = $feature->slice->seq_region_name;
scripts/import/project_feature.pl:        if ( $seq_region_name eq $new_seq_region_name || ($synonyms->{$new_seq_region_name} eq $seq_region_name) ) {
scripts/import/project_feature.pl:          if ($new_strand == -1 && $config->{flip}) {
scripts/import/project_feature.pl:            my $vf_id = $data->{variation_feature_id};
scripts/import/project_feature.pl:            my $var_name = $data->{variation_name};           
scripts/import/project_feature.pl:            my $report_flip_fh = $out->{flip};
scripts/import/project_feature.pl:            my $prev_allele_string = $data->{allele_string};
scripts/import/project_feature.pl:            reverse_comp(\($data->{allele_string}));        
scripts/import/project_feature.pl:            my $new_allele_string = $data->{allele_string};
scripts/import/project_feature.pl:          if ($config->{qc_ref_allele}) {
scripts/import/project_feature.pl:          $data->{seq_region_start}  = $new_start;
scripts/import/project_feature.pl:          $data->{seq_region_end}    = $new_end;
scripts/import/project_feature.pl:          $data->{seq_region_strand} = $new_strand;
scripts/import/project_feature.pl:          $data->{seq_region_id}     = $new_seq_region_id;
scripts/import/project_feature.pl:          write_output($out->{projection}, $data); 
scripts/import/project_feature.pl:          write_output($out->{not_useful_projection}, $data); 
scripts/import/project_feature.pl:        write_output($out->{no_projection}, $data); 
scripts/import/project_feature.pl:      my $strand = $data->{seq_region_strand};    
scripts/import/project_feature.pl:        next if ($data->{$location} eq '\N');
scripts/import/project_feature.pl:        my $feature = project_feature($config, $slice_newdb_oldasm, $data->{$location}, $data->{$location}, $strand);
scripts/import/project_feature.pl:          my $new_start  = $feature->seq_region_start;
scripts/import/project_feature.pl:          my $new_strand = $feature->seq_region_strand;
scripts/import/project_feature.pl:          $new_locations->{$location} = $new_start;
scripts/import/project_feature.pl:          $new_seq_region_id = $feature->slice->get_seq_region_id;
scripts/import/project_feature.pl:          write_output($out->{no_projection}, $data); 
scripts/import/project_feature.pl:          $data->{$location} = $new_locations->{$location}; 
scripts/import/project_feature.pl:        $data->{seq_region_id} = $new_seq_region_id;
scripts/import/project_feature.pl:        write_output($out->{projection}, $data); 
scripts/import/project_feature.pl:  $fh->close();
scripts/import/project_feature.pl:    my $fh = $out->{$report_type};
scripts/import/project_feature.pl:    $fh->close();
scripts/import/project_feature.pl:  my $newasm_name = $config->{newasm_name}; 
scripts/import/project_feature.pl:      -start  => $start,
scripts/import/project_feature.pl:      -end    => $end,
scripts/import/project_feature.pl:      -strand => $strand,
scripts/import/project_feature.pl:      -slice  => $slice,
scripts/import/project_feature.pl:  my $projected_feature = $feature->transform('chromosome', $newasm_name);
scripts/import/project_feature.pl:    $mapping->{$table_name} = $value;
scripts/import/project_feature.pl:    my $column_value = ($data->{$column_name}) ? $data->{$column_name} : '';
scripts/import/project_feature.pl:    my $vdba_newasm = $config->{vdba_newasm};
scripts/import/project_feature.pl:  my $dbc         = $vdba_newasm->dbc;
scripts/import/project_feature.pl:  my $result_table = $config->{feature_table_name_newasm};
scripts/import/project_feature.pl:  my $feature_table = $config->{feature_table_name_oldasm};
scripts/import/project_feature.pl:  $dbc->do(qq{ DROP TABLE IF EXISTS $result_table});
scripts/import/project_feature.pl:  $dbc->do(qq{ CREATE TABLE $result_table like $feature_table });
scripts/import/project_feature.pl:  my $column_names = $config->{sorted_column_names};
scripts/import/project_feature.pl:  my $dir_newasm = $config->{dir_newasm};
scripts/import/project_feature.pl:    - load data in variation_feature table, eg variation_feature_hgmd_37
scripts/import/project_feature.pl:    - create empty variation_feature table, eg variation_feature_hgmd_38
scripts/import/project_feature.pl:    - run script with all necessary parameters
scripts/import/project_feature.pl:    --help                                       # Display this message and quit
scripts/import/project_feature.pl:    --oldasm_name                                # Name of old assembly e.g. GRCh37
scripts/import/project_feature.pl:    --newasm_name                                # Name of new assembly e.g. GRCh38
scripts/import/project_feature.pl:    --working_dir                                # working dir to store tmp results (it creates a dir for dumping features on old assembly and dir to store projection results: dir_oldasm, dir_newasm)
scripts/import/project_feature.pl:    --ft | --feature_type                        # run projection for variation_feature (vf) or structural_variation_feature (svf): accepted values are vf and svf
scripts/import/project_feature.pl:    --ftn_oldasm | --feature_table_name_oldasm   # feature table name with feature to project
scripts/import/project_feature.pl:    --ftn_newasm | --feature_table_name_newasm   # feature table name to store projections
scripts/import/project_feature.pl:    --use_new_vdb_only                           # if this is set, feature table with features to project must be stored in vdb_newas
scripts/import/project_feature.pl:    --include_asm_exceptions                     # include features on patches and alt loci. Else only project features on ref sequence (e.g. human 1..22,X,Y,MT)
scripts/import/project_feature.pl:    --load_failed_projections                    # load failed projections into variation database 
scripts/import/project_feature.pl:    --flip                                       # flip on the fly. This is useful if you don't want to run Variant QC for the projected features.
scripts/import/project_feature.pl:    --qc_ref_allele
scripts/import/project_feature.pl:    --cdb_oldasm | --cdbname_oldasm              # required
scripts/import/project_feature.pl:    --cuser_oldasm                               # default ensro
scripts/import/project_feature.pl:    --chost_oldasm                               # required
scripts/import/project_feature.pl:    --cport_oldasm                               # default 3306
scripts/import/project_feature.pl:    --cdb_newasm | --cdbname_newasm              # required
scripts/import/project_feature.pl:    --cuser_newasm                               # default ensro
scripts/import/project_feature.pl:    --chost_newasm                               # required
scripts/import/project_feature.pl:    --cport_newasm                               # default 3306
scripts/import/project_feature.pl:    --vdb_oldasm | --vdbname_oldasm              # required unless feature table that needs to be projected is in vdbname_newasm
scripts/import/project_feature.pl:    --vuser_oldasm                               # default ensro
scripts/import/project_feature.pl:    --vhost_oldasm                               # required unless feature table that needs to be projected is in vdbname_newasm
scripts/import/project_feature.pl:    --vport_oldasm                               # default 3306
scripts/import/project_feature.pl:    --vdb_newasm | --vdbname_newasm              # required
scripts/import/project_feature.pl:    --vuser_newasm                               # default ensadmin
scripts/import/project_feature.pl:    --p | --vpass_newasm                         # required
scripts/import/project_feature.pl:    --vhost_newasm                               # required
scripts/import/project_feature.pl:    --vport_newasm                               # default 3306
scripts/import/load_car.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/load_car.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/load_car.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/load_car.pl:if (! -d $pipeline_dir) {
scripts/import/load_car.pl:if (! -d $car_load_dir) {
scripts/import/load_car.pl:$registry->load_all($registry_file);
scripts/import/load_car.pl:my $test_dba = $registry->get_DBAdaptor($species,'variation') or die ("Could not get a DBAdaptor for the variation");
scripts/import/load_car.pl:my $dbc = $test_dba->dbc();
scripts/import/load_car.pl:$dbc->reconnect_when_lost();
scripts/import/load_car.pl:# hgvs-17-52538080-57315268-load.tab
scripts/import/load_car.pl:   next if ($file !~ /hgvs-.*-\d{1,}-\d{1,}-load.tab/);
scripts/import/load_car.pl:  if (! -e $load_file) {
scripts/import/load_car.pl:  if (! -s $load_file) {
scripts/import/load_car.pl:  if (! -e $load_file) {
scripts/import/load_car.pl:  $line_count = `wc -l < $load_file`;
scripts/import/load_car.pl:  $rows_loaded = $dbc->do($sql);
scripts/import/parse_ssahaSNP.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/parse_ssahaSNP.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/parse_ssahaSNP.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/parse_ssahaSNP.pl:#perl parse_ssahaSNP_new.pl -species human -input_file [ssaha_ooutput_dir]/output_parse.txt -output_file [ssaha_ooutput_dir]/watson_output.txt -align_file [ssaha_ooutput_dir]/ALIGNMENT_file -tmpdir [tmpdir] -tmpfile temp_Watson.txt -individual 'Venter'
scripts/import/parse_ssahaSNP.pl:# eg -host -user -pass -port -snp_dbname -core_dbname etc
scripts/import/parse_ssahaSNP.pl:usage('-species argument is required') if(!$species);
scripts/import/parse_ssahaSNP.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/parse_ssahaSNP.pl:my $cdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/parse_ssahaSNP.pl:my $vdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/parse_ssahaSNP.pl:my $dbCore = $cdb->dbc;
scripts/import/parse_ssahaSNP.pl:my $dbVar = $vdb->dbc;
scripts/import/parse_ssahaSNP.pl:my $slice_adaptor = $cdb->get_SliceAdaptor;
scripts/import/parse_ssahaSNP.pl:    #SNP: 76 0 121186939 3 1-1-247249719 C/A gnl|ti|1759736436 -32 [  ] 0 3 0
scripts/import/parse_ssahaSNP.pl:    #     76 0 121186939 3 1-1-247249719 C/A gnl|ti|1759736680 220 [  ] 0 3 0
scripts/import/parse_ssahaSNP.pl:    #     76 0 121186939 3 1-1-247249719 C/A gnl|ti|1759732524 202 [  ] 0 3 0
scripts/import/parse_ssahaSNP.pl:    #SNP: 77 0 141615092 1 1-1-247249719 G/A gnl|ti|1759735512 56 [  ] 0 1 0
scripts/import/parse_ssahaSNP.pl:    #SNP: 78 0 141765872 1 1-1-247249719 A/T gnl|ti|1759732978 -148 [  ] 0 1 0
scripts/import/parse_ssahaSNP.pl:	    ($chr,$chr_start,$chr_end) = split /\-/, $subj_name;
scripts/import/parse_ssahaSNP.pl:	    $uniq_pos = "$chr\-$ref_pos";	    
scripts/import/parse_ssahaSNP.pl:		    #this is tri-allelic
scripts/import/parse_ssahaSNP.pl:		    ($chr,$chr_start) = split /\-/, $previous_snp_pos;
scripts/import/parse_ssahaSNP.pl:	#this is tri-allelic
scripts/import/parse_ssahaSNP.pl:        ($chr,$chr_start,$chr_end) = split /\-/, $subj_name;
scripts/import/parse_ssahaSNP.pl:    $dbVar->do(qq{INSERT INTO sample (name,description) values ("$ref_strain","reference population sample")});
scripts/import/parse_ssahaSNP.pl:    my $population_ref_sample_id = $dbVar->db_handle->{'mysql_insertid'};
scripts/import/parse_ssahaSNP.pl:    $dbVar->do(qq{INSERT INTO population (sample_id) values ($population_ref_sample_id)});
scripts/import/parse_ssahaSNP.pl:    $dbVar->do(qq{INSERT INTO sample (name,description) values ("$ind_pop_name","$ind_sample_pop_desc")});
scripts/import/parse_ssahaSNP.pl:    my $population_ind_sample_id = $dbVar->db_handle->{'mysql_insertid'};
scripts/import/parse_ssahaSNP.pl:    $dbVar->do(qq{INSERT INTO population (sample_id) values ($population_ind_sample_id)});
scripts/import/parse_ssahaSNP.pl:      $dbVar->do(qq{INSERT INTO sample (name,size,description) values ("$strain_name",NULL,"$ind_sample_desc")});
scripts/import/parse_ssahaSNP.pl:      my $individual_sample_id = $dbVar->db_handle->{'mysql_insertid'};
scripts/import/parse_ssahaSNP.pl:      $dbVar->do(qq{INSERT INTO individual (sample_id,individual_type_id) values ($individual_sample_id, $individual_type_id)});
scripts/import/parse_ssahaSNP.pl:      $dbVar->do(qq{INSERT INTO individual_population (individual_sample_id,population_sample_id) values ($individual_sample_id,$population_ind_sample_id)});
scripts/import/parse_ssahaSNP.pl:    $dbVar->do(qq{INSERT INTO source (name) values ("$source_name")});
scripts/import/parse_ssahaSNP.pl:    my $source_id = $dbVar->{'mysql_insertid'};
scripts/import/parse_ssahaSNP.pl:    $dbVar->do(qq{ALTER TABLE variation add column internal_name varchar(50)});
scripts/import/parse_ssahaSNP.pl:    $dbVar->do(qq{INSERT INTO variation (source_id,name,internal_name) select s.source_id as source_id,concat("$variation_name",snp.count) as name,concat("$var_pre_name\_",snp.uniq_pos) as internal_name from source s, ssaha_snp_out snp});
scripts/import/parse_ssahaSNP.pl:  $dbVar->do(qq{INSERT INTO variation_feature (seq_region_id,seq_region_start,seq_region_end,seq_region_strand,variation_id,allele_string,variation_name,map_weight,flags,source_id,validation_status,consequence_type)
scripts/import/parse_ssahaSNP.pl:  $dbVar->do(qq{INSERT INTO flanking_sequence (variation_id,up_seq,down_seq,up_seq_region_start,up_seq_region_end,down_seq_region_start,down_seq_region_end,seq_region_id,seq_region_strand)
scripts/import/parse_ssahaSNP.pl:              SELECT vf.variation_id,NULL,NULL,vf.seq_region_start-101,vf.seq_region_start-1,vf.seq_region_end+1,vf.seq_region_end+101,vf.seq_region_id,vf.seq_region_strand
scripts/import/parse_ssahaSNP.pl:    #ALIGNMENT 764 gnl|ti|900540082 10-1-110718848 5 794 39881618 39882407 F 790 99.75 795 SD
scripts/import/parse_ssahaSNP.pl:      my ($chr) = split /\-/, $target_name;
scripts/import/parse_ssahaSNP.pl:        if ($dbVar->dbname =~ /platypus/) {
scripts/import/parse_ssahaSNP.pl:	    print FH $buffer->{ $file };
scripts/import/parse_ssahaSNP.pl:	$buffer->{ $filename } .= $text;
scripts/import/parse_ssahaSNP.pl:	if( length( $buffer->{ $filename } ) > 10_000 ) {
scripts/import/parse_ssahaSNP.pl:	    print FH $buffer->{ $filename };
scripts/import/parse_ssahaSNP.pl:	    $buffer->{ $filename } = '';
scripts/import/new_calc_genotypes.c: * Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/new_calc_genotypes.c:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/new_calc_genotypes.c: *      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/new_calc_genotypes.c:  l->sz = INITIAL_LIST_SIZE;
scripts/import/new_calc_genotypes.c:  l->tail = -1;
scripts/import/new_calc_genotypes.c:  l->head = 0;
scripts/import/new_calc_genotypes.c:  l->locus = malloc(INITIAL_LIST_SIZE*sizeof(Locus_info));
scripts/import/new_calc_genotypes.c:  if (l->locus == NULL) {
scripts/import/new_calc_genotypes.c:  l->sz *= 2;
scripts/import/new_calc_genotypes.c:  if (( t = realloc(l->locus, l->sz * sizeof(Locus_info))) == NULL) {
scripts/import/new_calc_genotypes.c:  l->locus = t;
scripts/import/new_calc_genotypes.c:  ll->tail++;
scripts/import/new_calc_genotypes.c:  if (ll->tail == ll->sz)
scripts/import/new_calc_genotypes.c:  l = &ll->locus[ll->tail];
scripts/import/new_calc_genotypes.c:  l->locus = locus;
scripts/import/new_calc_genotypes.c:  l->position = pos;
scripts/import/new_calc_genotypes.c:  l->variation_feature_id = var_ft_id;
scripts/import/new_calc_genotypes.c:  l->seq_region_end = seq_reg_end;
scripts/import/new_calc_genotypes.c:  l->population_id = pop_id;
scripts/import/new_calc_genotypes.c:  l->genotypes[0].person_id = personid;
scripts/import/new_calc_genotypes.c:  l->genotypes[0].genotype = genotype;
scripts/import/new_calc_genotypes.c:  l->number_genotypes = 1;
scripts/import/new_calc_genotypes.c:  for (i=0;i<haplotypes->number_haplotypes;i++){
scripts/import/new_calc_genotypes.c:    h = haplotypes->haplotype[i];
scripts/import/new_calc_genotypes.c:    f_A_tmp += (2 - tmp);
scripts/import/new_calc_genotypes.c:    f_B_tmp += (2 - tmp);
scripts/import/new_calc_genotypes.c:  if (data1->person_id > data2->person_id) return 1;
scripts/import/new_calc_genotypes.c:  if (data1->person_id == data2->person_id) return 0;
scripts/import/new_calc_genotypes.c:  if (data1->person_id < data2->person_id) return -1;
scripts/import/new_calc_genotypes.c:  qsort(first->genotypes,first->number_genotypes,sizeof(Genotype),by_person_id);
scripts/import/new_calc_genotypes.c:  qsort(second->genotypes,second->number_genotypes,sizeof(Genotype),by_person_id);
scripts/import/new_calc_genotypes.c:  for (i=0;i< first->number_genotypes;i++){
scripts/import/new_calc_genotypes.c:    for (j=i;j<second->number_genotypes;j++){
scripts/import/new_calc_genotypes.c:      if (first->genotypes[i].person_id == second->genotypes[j].person_id){
scripts/import/new_calc_genotypes.c:	genotype = &second->genotypes[j];
scripts/import/new_calc_genotypes.c:	haplotype = first->genotypes[i].genotype << 2;
scripts/import/new_calc_genotypes.c:	haplotype |= genotype->genotype;
scripts/import/new_calc_genotypes.c:	if (first->genotypes[i].person_id < second->genotypes[j].person_id){
scripts/import/new_calc_genotypes.c:	/*      fprintf(stderr, "Could not find %hd in locus %d\n",first->genotypes[i].person_id,second->locus);*/
scripts/import/new_calc_genotypes.c:    s->N = N;
scripts/import/new_calc_genotypes.c:  while(fabs(theta-thetaprev) > 0.0001){
scripts/import/new_calc_genotypes.c:    tmp = ((nAB + (1-theta)*AaBb)*(nab + (1-theta)*AaBb) + (nAb + theta*AaBb)*(naB + theta*AaBb));
scripts/import/new_calc_genotypes.c:  D = (nAB+(1-theta)*AaBb) / N - (f_A*f_B);
scripts/import/new_calc_genotypes.c:  tmp = (f_A*f_B*(1-f_A)*(1-f_B));
scripts/import/new_calc_genotypes.c:    if (f_A*f_B < ((1-f_A)*(1-f_B))) Dmax = f_A*f_B;
scripts/import/new_calc_genotypes.c:    if (f_A*f_B >= ((1-f_A)*(1-f_B))) Dmax = (1-f_A)*(1-f_B);
scripts/import/new_calc_genotypes.c:    if (f_A*(1-f_B) < (1-f_A)*f_B) Dmax =  f_A*(1-f_B);
scripts/import/new_calc_genotypes.c:    if (f_A*(1-f_B) >= (1-f_A)*f_B) Dmax = (1-f_A)*f_B;
scripts/import/new_calc_genotypes.c:  s->D = D;
scripts/import/new_calc_genotypes.c:  s->r2 = r2;
scripts/import/new_calc_genotypes.c:  s->theta = theta;
scripts/import/new_calc_genotypes.c:  s->N = N;
scripts/import/new_calc_genotypes.c:  s->d_prime = (Dmax == 0) ? 0.0 : D/Dmax;
scripts/import/new_calc_genotypes.c:  s->people = haplotypes.number_haplotypes;
scripts/import/new_calc_genotypes.c:     second entries - I love C, sometimes */
scripts/import/new_calc_genotypes.c:  next = &ll->locus[ll->head];
scripts/import/new_calc_genotypes.c:  for (i = ll->head; i < ll->tail; i++, next++) {
scripts/import/new_calc_genotypes.c:	    head->variation_feature_id,
scripts/import/new_calc_genotypes.c:	    next->variation_feature_id,
scripts/import/new_calc_genotypes.c:	    head->population_id,
scripts/import/new_calc_genotypes.c:	    head->position,
scripts/import/new_calc_genotypes.c:	    next->position,
scripts/import/new_calc_genotypes.c:  int seq_region_id_previous = -1;
scripts/import/new_calc_genotypes.c:  int last_position = -1;
scripts/import/new_calc_genotypes.c:      last_position = -1;
scripts/import/new_calc_genotypes.c:      locus_list.tail = -1;
scripts/import/new_calc_genotypes.c:      l_tmp->genotypes[l_tmp->number_genotypes].person_id = personid;
scripts/import/new_calc_genotypes.c:      l_tmp->genotypes[l_tmp->number_genotypes].genotype = genotype2int(genotype);
scripts/import/new_calc_genotypes.c:      l_tmp->number_genotypes++;
scripts/import/new_calc_genotypes.c:      if (l_tmp->number_genotypes == SIZE) {
scripts/import/new_calc_genotypes.c:	    (abs(locus_list.locus[locus_list.head].position - position) > WINDOW_SIZE)){
scripts/import/new_calc_genotypes.c:      locus_list.tail = -1;
scripts/import/import_variant_submissions.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_variant_submissions.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_variant_submissions.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_variant_submissions.pl:Bio::EnsEMBL::Registry->load_all($registry_file);
scripts/import/import_variant_submissions.pl:my $vf_adaptor = Bio::EnsEMBL::Registry->get_adaptor($species,'Variation','VariationFeature');
scripts/import/import_variant_submissions.pl:my $dbh = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'Variation')->dbc->db_handle();
scripts/import/import_variant_submissions.pl:    my $vf = $vf_adaptor->fetch_by_hgvs_notation($hgvs);
scripts/import/import_variant_submissions.pl:    $vf->variation->source($source);
scripts/import/import_variant_submissions.pl:        $vf->variation->name("rs$rsid");
scripts/import/import_variant_submissions.pl:        $vf->variation->source("dbSNP");
scripts/import/import_variant_submissions.pl:        $vf->variation->add_synonym($source,$local_id);
scripts/import/import_variant_submissions.pl:        $vf->variation->name("ss$ssid");
scripts/import/import_variant_submissions.pl:        $vf->variation->add_synonym($source,$local_id);
scripts/import/import_variant_submissions.pl:        $vf->variation->name($local_id);
scripts/import/import_variant_submissions.pl:    $vf->source($vf->variation->source);
scripts/import/import_variant_submissions.pl:        map {$_->subsnp($ssid)} @{$vf->variation->get_all_Alleles()};
scripts/import/import_variant_submissions.pl:    $vf->add_validation_state('precious');
scripts/import/import_variant_submissions.pl:    $vf->variation->add_validation_state('precious');
scripts/import/import_variant_submissions.pl:    my $chr_vf = $vf->transform('chromosome');
scripts/import/import_variant_submissions.pl:    my $slice = $chr_vf->feature_Slice();
scripts/import/import_variant_submissions.pl:    my $existing_vfs = $vf_adaptor->fetch_all_by_Slice($slice);
scripts/import/import_variant_submissions.pl:    if (scalar(@{$existing_vfs}) && grep {$_->variation_name() eq $chr_vf->variation->name()} @{$existing_vfs}) {
scripts/import/import_variant_submissions.pl:        my ($ext_vf) = grep {$_->variation_name() eq $chr_vf->variation->name()} @{$existing_vfs};
scripts/import/import_variant_submissions.pl:        $chr_vf->dbID($ext_vf->dbID());
scripts/import/import_variant_submissions.pl:        $chr_vf->variation->dbID($ext_vf->variation->dbID());
scripts/import/import_variant_submissions.pl:        if ($chr_vf->strand() != $ext_vf->strand()) {
scripts/import/import_variant_submissions.pl:        import_alleles($chr_vf->variation,$dbh);
scripts/import/import_variant_submissions.pl:        import_variation_synonyms($chr_vf->variation,$dbh);
scripts/import/import_variant_submissions.pl:        unless (grep {$_ =~ m/precious/} @{$ext_vf->get_all_validation_states()}) {
scripts/import/import_variant_submissions.pl:            my $vid = $ext_vf->variation->dbID();
scripts/import/import_variant_submissions.pl:            $dbh->do($stmt);
scripts/import/import_variant_submissions.pl:        unless (grep {$_ =~ m/precious/} @{$ext_vf->variation->get_all_validation_states()}) {
scripts/import/import_variant_submissions.pl:            my $vid = $ext_vf->variation->dbID();
scripts/import/import_variant_submissions.pl:            $dbh->do($stmt);
scripts/import/import_variant_submissions.pl:        if ($chr_vf->strand() < 0) {
scripts/import/import_variant_submissions.pl:        import_variation($chr_vf->variation,$dbh);
scripts/import/import_variant_submissions.pl:        import_alleles($chr_vf->variation,$dbh);
scripts/import/import_variant_submissions.pl:        import_variation_synonyms($chr_vf->variation,$dbh);
scripts/import/import_variant_submissions.pl:        my $study = Bio::EnsEMBL::Variation::Study-new(
scripts/import/import_variant_submissions.pl:            -name => 
scripts/import/import_variant_submissions.pl:        my $v_annotation = Bio::EnsEMBL::Variation::VariationAnnotation->new(
scripts/import/import_variant_submissions.pl:            '-source_name' => $source,
scripts/import/import_variant_submissions.pl:            '-variation' => $chr_vf->variation(),
scripts/import/import_variant_submissions.pl:            '-phenotype_description' => $condition,
scripts/import/import_variant_submissions.pl:            '-study' => 'MIM:' . $omim,
scripts/import/import_variant_submissions.pl:            '-adaptor' => $vf_adaptor->db->get_VariationAnnotationAdaptor()
scripts/import/import_variant_submissions.pl:  my @alleles = split(/\//,${$vf}->allele_string());
scripts/import/import_variant_submissions.pl:  ${$vf}->allele_string(join("/",@alleles));
scripts/import/import_variant_submissions.pl:  foreach my $allele (@{${$vf}->variation()->get_all_Alleles()}) {
scripts/import/import_variant_submissions.pl:      my $seq = $allele->allele();
scripts/import/import_variant_submissions.pl:      $allele->allele($seq);
scripts/import/import_variant_submissions.pl:  ${$vf}->strand(-1 * ${$vf}->strand());
scripts/import/import_variant_submissions.pl:    my $check_sth = $dbh->prepare($stmt);
scripts/import/import_variant_submissions.pl:    my $sth = $dbh->prepare($stmt);
scripts/import/import_variant_submissions.pl:    $check_sth->execute(
scripts/import/import_variant_submissions.pl:        $va->variation->dbID(),
scripts/import/import_variant_submissions.pl:        $va->phenotype_description(),
scripts/import/import_variant_submissions.pl:        $va->source_name()
scripts/import/import_variant_submissions.pl:    my $row = $check_sth->fetchrow_arrayref();
scripts/import/import_variant_submissions.pl:    $dbid = $row->[0] if (defined($row));
scripts/import/import_variant_submissions.pl:    $va->dbID($dbid);
scripts/import/import_variant_submissions.pl:    unless (defined($va->dbID())) {
scripts/import/import_variant_submissions.pl:        my $phenotype_id = import_phenotype($va->phenotype_description(),$dbh);
scripts/import/import_variant_submissions.pl:        $sth->execute(
scripts/import/import_variant_submissions.pl:            $va->variation->dbID(),
scripts/import/import_variant_submissions.pl:            $va->source_name(),
scripts/import/import_variant_submissions.pl:            $va->study()
scripts/import/import_variant_submissions.pl:        $va->dbID($dbh->last_insert_id(undef,undef,undef,undef));
scripts/import/import_variant_submissions.pl:    return $va->dbID();
scripts/import/import_variant_submissions.pl:    my $sth = $dbh->prepare($stmt);
scripts/import/import_variant_submissions.pl:    my $subsnp_id = $variation->get_all_Alleles->[0]->subsnp() if (scalar(@{$variation->get_all_Alleles()}));
scripts/import/import_variant_submissions.pl:    foreach my $source (@{$variation->get_all_synonym_sources()}) {
scripts/import/import_variant_submissions.pl:        foreach my $synonym (@{$variation->get_all_synonyms($source)}) {
scripts/import/import_variant_submissions.pl:            $stmt = sprintf($check_stmt,$variation->dbID(),(defined($subsnp_id) ? "= $subsnp_id" : "IS NULL"),$source,$synonym);
scripts/import/import_variant_submissions.pl:            my $dbid = $dbh->selectall_arrayref($stmt)->[0][0];
scripts/import/import_variant_submissions.pl:                $sth->execute(
scripts/import/import_variant_submissions.pl:                    $variation->dbID(),
scripts/import/import_variant_submissions.pl:                $dbid = $dbh->last_insert_id(undef,undef,undef,undef);
scripts/import/import_variant_submissions.pl:    my $sth = $dbh->prepare($stmt);
scripts/import/import_variant_submissions.pl:    $sth->execute(
scripts/import/import_variant_submissions.pl:        $vf->variation->dbID(),
scripts/import/import_variant_submissions.pl:        $vf->seq_region_name(),
scripts/import/import_variant_submissions.pl:        $vf->seq_region_start(),
scripts/import/import_variant_submissions.pl:        $vf->seq_region_end(),
scripts/import/import_variant_submissions.pl:        $vf->seq_region_strand()
scripts/import/import_variant_submissions.pl:    my $row = $sth->fetchrow_arrayref;
scripts/import/import_variant_submissions.pl:    $dbid = $row->[0] if (defined($row));
scripts/import/import_variant_submissions.pl:    $vf->dbID($dbid);
scripts/import/import_variant_submissions.pl:    unless (defined($vf->dbID())) {
scripts/import/import_variant_submissions.pl:        $sth = $dbh->prepare($stmt);
scripts/import/import_variant_submissions.pl:        $sth->execute(
scripts/import/import_variant_submissions.pl:            $vf->seq_region_name(),
scripts/import/import_variant_submissions.pl:            $vf->seq_region_start(),
scripts/import/import_variant_submissions.pl:            $vf->seq_region_end(),
scripts/import/import_variant_submissions.pl:            $vf->seq_region_strand(),
scripts/import/import_variant_submissions.pl:            $vf->variation->dbID(),
scripts/import/import_variant_submissions.pl:            $vf->allele_string(),
scripts/import/import_variant_submissions.pl:            $vf->variation->name(),
scripts/import/import_variant_submissions.pl:            $vf->map_weight(),
scripts/import/import_variant_submissions.pl:            $vf->source(),
scripts/import/import_variant_submissions.pl:            (defined($vf->get_all_validation_states()) ? join(",",@{$vf->get_all_validation_states()}) : undef)
scripts/import/import_variant_submissions.pl:        $vf->dbID($dbh->last_insert_id(undef,undef,undef,undef));
scripts/import/import_variant_submissions.pl:    return $vf->dbID();
scripts/import/import_variant_submissions.pl:    my $sth = $dbh->prepare($stmt);
scripts/import/import_variant_submissions.pl:    foreach my $allele (@{$variation->get_all_Alleles()}) {
scripts/import/import_variant_submissions.pl:        $stmt = sprintf($check_stmt,$variation->dbID(),$allele->allele(),(defined($allele->subsnp()) ? "= " . $allele->subsnp() : "IS NULL "));
scripts/import/import_variant_submissions.pl:        my $dbid = $dbh->selectall_arrayref($stmt)->[0][0];
scripts/import/import_variant_submissions.pl:        $allele->dbID($dbid);
scripts/import/import_variant_submissions.pl:        unless (defined($allele->dbID())) {
scripts/import/import_variant_submissions.pl:            $sth->execute(
scripts/import/import_variant_submissions.pl:                $variation->dbID(),
scripts/import/import_variant_submissions.pl:                $allele->subsnp(),
scripts/import/import_variant_submissions.pl:                (defined($allele->population()) ? $allele->population->dbID() : undef),
scripts/import/import_variant_submissions.pl:                $allele->allele(),
scripts/import/import_variant_submissions.pl:                $allele->frequency(),
scripts/import/import_variant_submissions.pl:                $allele->count()
scripts/import/import_variant_submissions.pl:            $allele->dbID($dbh->last_insert_id(undef,undef,undef,undef));
scripts/import/import_variant_submissions.pl:        push(@dbIDs,$allele->dbID());
scripts/import/import_variant_submissions.pl:    my $sth = $dbh->prepare($stmt);
scripts/import/import_variant_submissions.pl:    $sth->execute($variation->name());
scripts/import/import_variant_submissions.pl:    my $row = $sth->fetchrow_arrayref;
scripts/import/import_variant_submissions.pl:    $dbid = $row->[0] if (defined($row));
scripts/import/import_variant_submissions.pl:    $variation->dbID($dbid);
scripts/import/import_variant_submissions.pl:    unless (defined($variation->dbID())) {
scripts/import/import_variant_submissions.pl:        $sth = $dbh->prepare($stmt);
scripts/import/import_variant_submissions.pl:        $sth->execute(
scripts/import/import_variant_submissions.pl:            $variation->source(),
scripts/import/import_variant_submissions.pl:            $variation->name(),
scripts/import/import_variant_submissions.pl:            (defined($variation->get_all_validation_states()) ? join(",",@{$variation->get_all_validation_states()}) : undef),
scripts/import/import_variant_submissions.pl:            $variation->ancestral_allele(),
scripts/import/import_variant_submissions.pl:        $variation->dbID($dbh->last_insert_id(undef,undef,undef,undef));
scripts/import/import_variant_submissions.pl:    return $variation->dbID();
scripts/import/import_variant_submissions.pl:    my $sth = $dbh->prepare($stmt);
scripts/import/import_variant_submissions.pl:    $sth->execute(
scripts/import/import_variant_submissions.pl:        $vf->variation->dbID(),
scripts/import/import_variant_submissions.pl:        ($vf->seq_region_start - $DEFAULT_FLANKING_SIZE),
scripts/import/import_variant_submissions.pl:        ($vf->seq_region_start - 1),
scripts/import/import_variant_submissions.pl:        ($vf->seq_region_end + 1),
scripts/import/import_variant_submissions.pl:        ($vf->seq_region_end + $DEFAULT_FLANKING_SIZE),
scripts/import/import_variant_submissions.pl:        $vf->seq_region_name,
scripts/import/import_variant_submissions.pl:        $vf->seq_region_strand
scripts/import/import_variant_submissions.pl:    return $vf->variation->dbID();
scripts/import/import_variant_submissions.pl:    my $check_sth = $dbh->prepare($stmt);
scripts/import/import_variant_submissions.pl:    my $sth = $dbh->prepare($stmt);
scripts/import/import_variant_submissions.pl:    $check_sth->execute(
scripts/import/import_variant_submissions.pl:    my $row = $check_sth->fetchrow_arrayref();
scripts/import/import_variant_submissions.pl:    $dbid = $row->[0] if (defined($row));
scripts/import/import_variant_submissions.pl:        $sth->execute(
scripts/import/import_variant_submissions.pl:        $dbid = $dbh->last_insert_id(undef,undef,undef,undef);
scripts/import/import_variant_submissions.pl:    my $sth = $dbh->prepare($stmt);
scripts/import/import_variant_submissions.pl:    my $fail_sth = $dbh->prepare($stmt);
scripts/import/import_variant_submissions.pl:    $subsnp_id = $vf->variation->get_all_Alleles->[0]->subsnp() if (defined($vf->variation->get_all_Alleles));
scripts/import/import_variant_submissions.pl:    unless (grep {$_->allele() eq $vf->feature_Slice->seq()} @{$vf->variation->get_all_Alleles()}) {
scripts/import/import_variant_submissions.pl:        warn ("None of the variant alleles for variation_feature_id " . $vf->dbID() . " (" . $vf->variation->name() . ", " . $vf->allele_string . ") match the reference sequence (" . $vf->seq_region_name . ":" . $vf->seq_region_start . "-" . $vf->seq_region_end . ":" . $vf->seq_region_strand . ")");
scripts/import/import_variant_submissions.pl:        $sth->execute($vf->variation->dbID(),$subsnp_id,2);
scripts/import/import_variant_submissions.pl:        # $fail_sth->execute($vf->variation->dbID());
scripts/import/import_variant_submissions.pl:    my $dbid = $dbh->selectall_arrayref($stmt)->[0][0];
scripts/import/import_variant_submissions.pl:        $dbh->do($stmt);
scripts/import/import_variant_submissions.pl:        $dbid = $dbh->last_insert_id(undef,undef,undef,undef);
scripts/import/get_reads.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/get_reads.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/get_reads.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/get_reads.pl:    GetOptions('-index_name=s' => \$index_name,
scripts/import/get_reads.pl:#	       '-individual_name=s' => \$individual_name,
scripts/import/get_reads.pl:#	       '-encode_region=s' => \$encode_region,
scripts/import/get_reads.pl:	       '-reads_names=s' => \$reads_names,
scripts/import/get_reads.pl:	       '-reads_file=s' => \$reads_file,
scripts/import/get_reads.pl:	       '-database_name=s' => \$database_name);
scripts/import/get_reads.pl:my $sql = qq{select s.query_name from ssahaSNP_feature s where substring_index(substring_index(target_name,'-',2),'-',1) = 'X' limit 10};
scripts/import/get_reads.pl:## my $sql = qq{select s.query_name from ssahaSNP_feature s, query_match_length_strain q where target_start > $start and substring_index(substring_index(target_name,'-',2),'-',1) = '$name' and target_end < $end and target_start < $end and s.query_name = q.query_name and q.strain_name = 'HuBB'};
scripts/import/get_reads.pl: #my $call = qq{mysql -h ens-genomics1 -u ensro $database_name -e "$sql" > [reads_dir]/$encode_region\.$individual_name};
scripts/import/get_reads.pl: my $call = qq{mysql -h ens-genomics1 -u ensro $database_name -e "$sql" > $reads_names};
scripts/import/get_reads.pl:    print OUT $seq->seq,"\n";
scripts/import/get_reads.pl:    my $fastq_index = Bio::Index::Fastq->new(-filename => $index_filename);
scripts/import/get_reads.pl:	$fastq_index = Bio::Index::Fastq->new(-filename => $index_filename);
scripts/import/get_reads.pl:    my $seq = $fastq_index->fetch($query_name);
scripts/import/Progress.pm:Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/Progress.pm:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/Progress.pm:     http://www.apache.org/licenses/LICENSE-2.0
scripts/import/Progress.pm:    $p->{'checkpoints'} = [];
scripts/import/Progress.pm:    $p->{'n'} = 0;
scripts/import/Progress.pm:    $self->{'n'}++;
scripts/import/Progress.pm:    $label ||= $self->{'n'};
scripts/import/Progress.pm:    push(@{$self->{'checkpoints'}},$cp);
scripts/import/Progress.pm:        foreach my $cp (@{$self->{'checkpoints'}}) {
scripts/import/Progress.pm:            next if ($cp->{'label'} ne $end_checkpoint);
scripts/import/Progress.pm:    $start_checkpoint = $self->{'checkpoints'}[$self->{'n'}-1]{'label'} unless (defined($start_checkpoint));
scripts/import/Progress.pm:    foreach my $cp (@{$self->{'checkpoints'}}) {
scripts/import/Progress.pm:        next if ($cp->{'label'} ne $start_checkpoint);
scripts/import/Progress.pm:    ($end_checkpoint,$start_checkpoint) = ($start_checkpoint,$end_checkpoint) if ($start_checkpoint->{'time'} > $end_checkpoint->{'time'});
scripts/import/Progress.pm:    my $duration = $end_checkpoint->{'time'} - $start_checkpoint->{'time'};
scripts/import/Progress.pm:        $str .= $format->{$unit} . " $unit, ";
scripts/import/Progress.pm:        $str .= "\t" . $cp->{'label'};
scripts/import/Progress.pm:        $str .= " [" . $cp->{'package'};
scripts/import/Progress.pm:        $str .= "::" . $cp->{'file'};
scripts/import/Progress.pm:        $str .= ", line " . $cp->{'line'} . "]\n";
scripts/import/Progress.pm:    $time -= $weeks*$week;
scripts/import/Progress.pm:    $time -= $days*$day;
scripts/import/Progress.pm:    $time -= $hours*$hour;
scripts/import/Progress.pm:    $time -= $minutes*$minute;
scripts/import/Progress.pm:    foreach my $cp (@{$self->{'checkpoints'}}) {
scripts/import/Progress.pm:        next if (defined($label) && $label ne $cp->{'label'});
scripts/import/Progress.pm:        $str .= localtime($cp->{'time'}) . "\t\tCheckpoint " . $cp->{'label'} . ": At " . $cp->{'package'} . "::" . $cp->{'file'} . ", line $cp->{'line'}\n";
Binary file scripts/import/Progress.pm matches
scripts/import/post_import_phenotypes.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/post_import_phenotypes.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/post_import_phenotypes.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/post_import_phenotypes.pl:usage() if ($config->{help});
scripts/import/post_import_phenotypes.pl:die ('A registry file is required (--registry)') unless (defined($config->{registry}));
scripts/import/post_import_phenotypes.pl:die ('A species must be defiened (--species)') unless (defined($config->{species}));
scripts/import/post_import_phenotypes.pl:  $registry->load_all($config->{registry});
scripts/import/post_import_phenotypes.pl:  my $species = $config->{species};
scripts/import/post_import_phenotypes.pl:  my $vdba = $registry->get_DBAdaptor($species, 'variation');
scripts/import/post_import_phenotypes.pl:  my $dbh = $vdba->dbc->db_handle;
scripts/import/post_import_phenotypes.pl:  if ($config->{clean_up}) {
scripts/import/post_import_phenotypes.pl:    $dbh->do(qq{ DROP TABLE IF EXISTS variation_ids_old_phenotype_evdn});
scripts/import/post_import_phenotypes.pl:    $dbh->do(qq{ CREATE TABLE `variation_ids_old_phenotype_evdn` (`variation_id` int(10) unsigned NOT NULL, PRIMARY KEY (`variation_id`))});
scripts/import/post_import_phenotypes.pl:    $dbh->do(qq{ INSERT INTO variation_ids_old_phenotype_evdn SELECT distinct variation_id FROM variation WHERE evidence_attribs LIKE '%$phenotype_attrib_id%'}) ;
scripts/import/post_import_phenotypes.pl:    $dbh->do(qq{
scripts/import/post_import_phenotypes.pl:    $dbh->do(qq{
scripts/import/post_import_phenotypes.pl:    $dbh->do(qq{
scripts/import/post_import_phenotypes.pl:    $dbh->do(qq{ UPDATE variation SET evidence_attribs = NULL WHERE evidence_attribs = '';});
scripts/import/post_import_phenotypes.pl:    $dbh->do(qq{
scripts/import/post_import_phenotypes.pl:    $dbh->do(qq{ UPDATE variation_feature SET evidence_attribs = NULL WHERE evidence_attribs = '';});
scripts/import/post_import_phenotypes.pl:  $dbh->do(qq{ DROP TABLE IF EXISTS variation_ids_new_phenotype_evdn});
scripts/import/post_import_phenotypes.pl:  $dbh->do(qq{ CREATE TABLE `variation_ids_new_phenotype_evdn` (`variation_id` int(10) unsigned NOT NULL, PRIMARY KEY (`variation_id`))});
scripts/import/post_import_phenotypes.pl:  $dbh->do(qq{ INSERT INTO variation_ids_new_phenotype_evdn SELECT distinct v.variation_id FROM variation v, phenotype_feature pf WHERE pf.type = 'Variation' AND pf.object_id = v.name; }) ;
scripts/import/post_import_phenotypes.pl:  $dbh->do(qq{
scripts/import/post_import_phenotypes.pl:  $dbh->do(qq{
scripts/import/post_import_phenotypes.pl:  $dbh->do(qq{ INSERT IGNORE INTO variation_ids_new_phenotype_evdn SELECT distinct variation_id FROM variation_citation; }) ;
scripts/import/post_import_phenotypes.pl:  $dbh->do(qq{
scripts/import/post_import_phenotypes.pl:  $dbh->do(qq{
scripts/import/post_import_phenotypes.pl:  if ($config->{update_tv}) {
scripts/import/post_import_phenotypes.pl:    $dbh->do(qq{
scripts/import/post_import_phenotypes.pl:    $dbh->do(qq{
scripts/import/post_import_phenotypes.pl:  Usage: perl post_import_phenotype_data.pl -registry [registry_file] -species [species] [OPTIONS]
scripts/import/post_import_phenotypes.pl:    -help        Print this message
scripts/import/post_import_phenotypes.pl:    -clean_up    Use to clean up all Phenotype_or_Disease evidence attributes from the previous release
scripts/import/import_phenotype_data.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_phenotype_data.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_phenotype_data.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_phenotype_data.pl:  "NHGRI-EBI GWAS catalog" => {
scripts/import/import_phenotype_data.pl:    description => "Variants associated with phenotype data from the NHGRI-EBI GWAS catalog",
scripts/import/import_phenotype_data.pl:    description => "Variants imported from the European Genome-phenome Archive with phenotype association",
scripts/import/import_phenotype_data.pl:    url => "http://www.animalgenome.org/cgi-bin/QTLdb/index",
scripts/import/import_phenotype_data.pl:    description => "MAGIC (the Meta-Analyses of Glucose and Insulin-related traits Consortium) represents a collaborative effort to combine data from multiple GWAS to identify additional loci that impact on glycemic and metabolic traits",
scripts/import/import_phenotype_data.pl:    description => "Developmental Disorders Genotype-to-Phenotype Database",
scripts/import/import_phenotype_data.pl:die ("Database credentials (--host, --dbname, --user, --pass, --port) are required") unless (defined($host) && defined($dbname) && defined($user) && defined($pass));
scripts/import/import_phenotype_data.pl:  die ("Database credentials (--ontology_host, --ontology_dbname, --ontology_user, --ontology_port) are required for importing AnimalQTL data") unless (defined($ontology_host) && defined($ontology_dbname) && defined($ontology_user));
scripts/import/import_phenotype_data.pl:  die ("An input file (--infile) is required") unless (defined($infile));
scripts/import/import_phenotype_data.pl:  die ("A source (--source) is required") unless (defined($source));
scripts/import/import_phenotype_data.pl:  die ("A source version (--version) is required") unless (defined($source_version));
scripts/import/import_phenotype_data.pl:    In addition, there are the keys 'rsid' which holds the rs-id that the phenotype
scripts/import/import_phenotype_data.pl:    reference to a hash where the keys are rs-ids and each respective value is a
scripts/import/import_phenotype_data.pl:    reference to an array of synonyms for the rs-id.
scripts/import/import_phenotype_data.pl:  -host => $host,
scripts/import/import_phenotype_data.pl:  -user => $user,
scripts/import/import_phenotype_data.pl:  -pass => $pass,
scripts/import/import_phenotype_data.pl:  -port => $port,
scripts/import/import_phenotype_data.pl:  -dbname => $dbname
scripts/import/import_phenotype_data.pl:    -host => $chost,
scripts/import/import_phenotype_data.pl:    -user => $cuser,
scripts/import/import_phenotype_data.pl:    -pass => $cpass,
scripts/import/import_phenotype_data.pl:    -port => $cport,
scripts/import/import_phenotype_data.pl:    -dbname => $cdbname
scripts/import/import_phenotype_data.pl:    -host => $ontology_host,
scripts/import/import_phenotype_data.pl:    -user => $ontology_user,
scripts/import/import_phenotype_data.pl:    -port => $ontology_port,
scripts/import/import_phenotype_data.pl:    -dbname => $ontology_dbname
scripts/import/import_phenotype_data.pl:my $phenotype_adaptor = $db_adaptor->get_PhenotypeAdaptor;
scripts/import/import_phenotype_data.pl:our %phenotype_cache = map {$_->description() => $_->dbID()} @{$phenotype_adaptor->fetch_all};
scripts/import/import_phenotype_data.pl:my $initial_phenotype_count = $phenotype_adaptor->generic_count;
scripts/import/import_phenotype_data.pl:  $source_name = 'NHGRI-EBI GWAS catalog';
scripts/import/import_phenotype_data.pl:  #die("ERROR: No core DB parameters supplied (--chost, --cdbname, --cuser) or could not connect to core database") unless defined($core_db_adaptor);
scripts/import/import_phenotype_data.pl:  #die("ERROR: mim2gene file required (--mim2gene [file])\n") unless defined($mim2gene) && -e $mim2gene;
scripts/import/import_phenotype_data.pl:  $source_description = $SOURCES{$source_name}->{description};
scripts/import/import_phenotype_data.pl:  $source_url         = $SOURCES{$source_name}->{url};
scripts/import/import_phenotype_data.pl:  die("ERROR: No core DB parameters supplied (--chost, --cdbname, --cuser) or could not connect to core database") unless defined($core_db_adaptor); 
scripts/import/import_phenotype_data.pl:  die("ERROR: Assembly version not specified - use --assembly [version]") unless defined($assembly);
scripts/import/import_phenotype_data.pl:  die("ERROR: No core DB parameters supplied (--chost, --cdbname, --cuser) or could not connect to core database") unless defined($core_db_adaptor);
scripts/import/import_phenotype_data.pl:  $SOURCES{$source_name}->{type} = 'Gene'; # By default it is set to 'QTL'
scripts/import/import_phenotype_data.pl:  die("ERROR: p-value threshold not specified - use --threshold [p-value]") unless defined($threshold);
scripts/import/import_phenotype_data.pl:  die("ERROR: phenotype description not specified - use --phenotype [description]") unless defined($global_phenotype_description);
scripts/import/import_phenotype_data.pl:  die("ERROR: p-value threshold not specified - use --threshold [p-value]") unless defined($threshold);
scripts/import/import_phenotype_data.pl:  die("ERROR: phenotype description not specified - use --phenotype [description]") unless defined($global_phenotype_description);
scripts/import/import_phenotype_data.pl:  die("ERROR: No core DB parameters supplied (--chost, --cdbname, --cuser) or could not connect to core database") unless defined($core_db_adaptor);
scripts/import/import_phenotype_data.pl:  die("ERROR: No core DB parameters supplied (--chost, --cdbname, --cuser) or could not connect to core database") unless defined($core_db_adaptor);
scripts/import/import_phenotype_data.pl:  die("ERROR: No core DB parameters supplied (--chost, --cdbname, --cuser) or could not connect to core database") unless defined($core_db_adaptor);
scripts/import/import_phenotype_data.pl:    $url = '/mi/impc/solr/genotype-phenotype';
scripts/import/import_phenotype_data.pl:    $url = '/mi/impc/solr/mgi-phenotype';
scripts/import/import_phenotype_data.pl:  die "Coord file is required: ftp://ftp.informatics.jax.org/pub/reports/MGI_MRK_Coord.rpt" if (!-f $coord_file);
scripts/import/import_phenotype_data.pl:$source_description = $SOURCES{$source_name}->{description};
scripts/import/import_phenotype_data.pl:$source_url         = $SOURCES{$source_name}->{url};
scripts/import/import_phenotype_data.pl:$set                = defined($SOURCES{$source_name}->{set}) ? $SOURCES{$source_name}->{set} : undef;
scripts/import/import_phenotype_data.pl:$object_type        = $SOURCES{$source_name}->{type};
scripts/import/import_phenotype_data.pl:$source_status      = $SOURCES{$source_name}->{status} if (defined($SOURCES{$source_name}->{status}));
scripts/import/import_phenotype_data.pl:if (exists($result->{'synonyms'})) {
scripts/import/import_phenotype_data.pl:  %synonym = %{$result->{'synonyms'}};
scripts/import/import_phenotype_data.pl:if (exists($result->{'phenotypes'})) {
scripts/import/import_phenotype_data.pl:  @phenotypes = @{$result->{'phenotypes'}};
scripts/import/import_phenotype_data.pl:  @ids = map {$_->{'id'}} @phenotypes;
scripts/import/import_phenotype_data.pl:if(defined($phenotypes[0]->{seq_region_id})) {
scripts/import/import_phenotype_data.pl:      $coord->{'seq_region_'.$key} = $p->{'seq_region_'.$key};
scripts/import/import_phenotype_data.pl:    push @{$coords->{$p->{id}}}, $coord;
scripts/import/import_phenotype_data.pl:    $_->{seq_region_id}."_".
scripts/import/import_phenotype_data.pl:    $_->{seq_region_start}."_".
scripts/import/import_phenotype_data.pl:    $_->{seq_region_end}."_".
scripts/import/import_phenotype_data.pl:    $_->{seq_region_strand}."_" => $_
scripts/import/import_phenotype_data.pl:  } @{$coords->{$id}};
scripts/import/import_phenotype_data.pl:  $coords->{$id} = [values %tmp];
scripts/import/import_phenotype_data.pl:  my $added_phenotypes = $phenotype_adaptor->generic_count - $initial_phenotype_count;
scripts/import/import_phenotype_data.pl:#    next if (defined($var_id->[0]));
scripts/import/import_phenotype_data.pl:    if ($_ =~ m/^(\S+)\s+\S+\s+(VAR\_\d+)\s+\w\.\S+\s+(Disease|Polymorphism|Unclassified)\s+(\-|rs\d*)\s*(.*)$/) {
scripts/import/import_phenotype_data.pl:      if ($rs_id ne '-') {
scripts/import/import_phenotype_data.pl:      #$phenotype ||= '-';
scripts/import/import_phenotype_data.pl:      #if ($phenotype ne '-') {
scripts/import/import_phenotype_data.pl:  print STDOUT "Parsed " . scalar(keys(%synonym)) . " rs-ids with Uniprot synonyms\n" if ($verbose);
scripts/import/import_phenotype_data.pl:  #print STDOUT scalar(@phenotypes) . " phenotype associations were found linked to rs-ids\n" if ($verbose);
scripts/import/import_phenotype_data.pl:      my $rs_risk_allele = ($content{'STRONGEST SNP-RISK ALLELE'} =~ /\?/) ? '' : $content{'STRONGEST SNP-RISK ALLELE'};
scripts/import/import_phenotype_data.pl:      my $pvalue         = ($content{'P-VALUE'} ne '') ? $content{'P-VALUE'} : '';
scripts/import/import_phenotype_data.pl:      if ($rs_risk_allele =~ /^\s*$rs_id-+\s*(\w+)\s*$/i) {
scripts/import/import_phenotype_data.pl:      $gene =~ s/–/-/g;
scripts/import/import_phenotype_data.pl:      $gene =~ s/[^\x00-\x7F]//g; # Remove non ASCII characters
scripts/import/import_phenotype_data.pl:      while ($rs_id =~ m/(rs[0-9]+)/g) {
scripts/import/import_phenotype_data.pl:  my $nhgri_check_sth = $db_adaptor->dbc->prepare($nhgri_check_stmt);
scripts/import/import_phenotype_data.pl:  my $study_check_sth = $db_adaptor->dbc->prepare($study_check_stmt);
scripts/import/import_phenotype_data.pl:  my $study_ins_sth   = $db_adaptor->dbc->prepare($study_ins_stmt);
scripts/import/import_phenotype_data.pl:  my $asso_study_check_sth = $db_adaptor->dbc->prepare($asso_study_check_stmt);
scripts/import/import_phenotype_data.pl:  my $asso_study_ins_sth   = $db_adaptor->dbc->prepare($asso_study_ins_stmt);
scripts/import/import_phenotype_data.pl:    $nhgri_check_sth->bind_param(1,$pubmed,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:    $nhgri_check_sth->execute();
scripts/import/import_phenotype_data.pl:    $nhgri_check_sth->bind_columns(\$nhgri_study_id,\$study_type);
scripts/import/import_phenotype_data.pl:    $nhgri_check_sth->fetch();
scripts/import/import_phenotype_data.pl:      print "No NHGRI-EBI study found for the EGA $name | $pubmed !\n";
scripts/import/import_phenotype_data.pl:    $study_check_sth->bind_param(1,$name,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:    $study_check_sth->execute();
scripts/import/import_phenotype_data.pl:    $study_check_sth->bind_columns(\$study_id);
scripts/import/import_phenotype_data.pl:    $study_check_sth->fetch();
scripts/import/import_phenotype_data.pl:      $study_ins_sth->bind_param(1,$name,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:      $study_ins_sth->bind_param(2,$pubmed,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:      $study_ins_sth->bind_param(3,$url,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:      $study_ins_sth->bind_param(4,$study_type,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:      $study_ins_sth->execute();
scripts/import/import_phenotype_data.pl:      $study_id = $db_adaptor->dbc->db_handle->{'mysql_insertid'};
scripts/import/import_phenotype_data.pl:    $asso_study_check_sth->bind_param(1,$nhgri_study_id,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:    $asso_study_check_sth->bind_param(2,$study_id,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:    $asso_study_check_sth->execute();
scripts/import/import_phenotype_data.pl:    $asso_study_check_sth->bind_columns(\$is_associated);
scripts/import/import_phenotype_data.pl:    $asso_study_check_sth->fetch();
scripts/import/import_phenotype_data.pl:      $asso_study_ins_sth->bind_param(1,$nhgri_study_id,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:      $asso_study_ins_sth->bind_param(2,$study_id,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:      $asso_study_ins_sth->execute();
scripts/import/import_phenotype_data.pl:  my $ga = $core_db_adaptor->get_GeneAdaptor;
scripts/import/import_phenotype_data.pl:      my $gene = $ga->fetch_by_stable_id($gene_id);
scripts/import/import_phenotype_data.pl:        'id' => $gene->stable_id,
scripts/import/import_phenotype_data.pl:        'seq_region_id' => $gene->slice->get_seq_region_id,
scripts/import/import_phenotype_data.pl:        'seq_region_start' => $gene->seq_region_start,
scripts/import/import_phenotype_data.pl:        'seq_region_end' => $gene->seq_region_end,
scripts/import/import_phenotype_data.pl:        'seq_region_strand' => $gene->seq_region_strand,
scripts/import/import_phenotype_data.pl:  my $ga = $core_db_adaptor->get_GeneAdaptor;
scripts/import/import_phenotype_data.pl:    my $genes = $ga->fetch_all_by_external_name($data[0]);
scripts/import/import_phenotype_data.pl:        'id' => $gene->stable_id,
scripts/import/import_phenotype_data.pl:        'seq_region_id' => $gene->slice->get_seq_region_id,
scripts/import/import_phenotype_data.pl:        'seq_region_start' => $gene->seq_region_start,
scripts/import/import_phenotype_data.pl:        'seq_region_end' => $gene->seq_region_end,
scripts/import/import_phenotype_data.pl:        'seq_region_strand' => $gene->seq_region_strand
scripts/import/import_phenotype_data.pl:  my $ontology_term_adaptor = $ontology_db_adaptor->get_OntologyTermAdaptor; 
scripts/import/import_phenotype_data.pl:    if(!defined($seq_region_ids->{$data[0]})) {
scripts/import/import_phenotype_data.pl:      $extra->{$key} = $value;
scripts/import/import_phenotype_data.pl:    if ($extra->{'Map_Type'} eq 'Linkage' || $data[3] == 0) {
scripts/import/import_phenotype_data.pl:      print STDERR "WARNING: Could not find a precise location for the QTL ".$extra->{QTL_ID}."\n";
scripts/import/import_phenotype_data.pl:      print STDERR "WARNING: Could not find a numeric seq_region_end for the QTL ".$extra->{QTL_ID}."\n";
scripts/import/import_phenotype_data.pl:      'id' => $extra->{QTL_ID},
scripts/import/import_phenotype_data.pl:      'description' => $extra->{Name},
scripts/import/import_phenotype_data.pl:      'seq_region_id' => $seq_region_ids->{$data[0]},
scripts/import/import_phenotype_data.pl:    my $CMO_name = $extra->{CMO_name};
scripts/import/import_phenotype_data.pl:      my $terms = $ontology_term_adaptor->fetch_all_by_name($CMO_name, 'CMO'); 
scripts/import/import_phenotype_data.pl:        push @accessions, $term->accession;
scripts/import/import_phenotype_data.pl:    my $VTO_name = $extra->{VTO_name};
scripts/import/import_phenotype_data.pl:      my $terms = $ontology_term_adaptor->fetch_all_by_name($VTO_name, 'VT'); 
scripts/import/import_phenotype_data.pl:        push @accessions, $term->accession;
scripts/import/import_phenotype_data.pl:      $phenotype->{accessions} = \@accessions;
scripts/import/import_phenotype_data.pl:      $phenotype->{ontology_mapping_type} = 'is';
scripts/import/import_phenotype_data.pl:    if ($phenotype->{'seq_region_start'} > $phenotype->{'seq_region_end'}) {
scripts/import/import_phenotype_data.pl:      my $tmp_end = $phenotype->{'seq_region_end'};
scripts/import/import_phenotype_data.pl:      $phenotype->{'seq_region_start'} = $phenotype->{'seq_region_end'};
scripts/import/import_phenotype_data.pl:      $phenotype->{'seq_region_end'}   = $tmp_end;
scripts/import/import_phenotype_data.pl:    $phenotype->{'study'} = $pubmed_prefix.$extra->{'PUBMED_ID'} if defined($extra->{'PUBMED_ID'} && $extra->{'PUBMED_ID'} =~ /^\d+$/);
scripts/import/import_phenotype_data.pl:    $phenotype->{'p_value'} = $extra->{'P-value'} if defined($extra->{'P-value'});
scripts/import/import_phenotype_data.pl:    $phenotype->{'f_stat'} = $extra->{'F-stat'} if defined($extra->{'F-stat'});
scripts/import/import_phenotype_data.pl:    $phenotype->{'lod_score'} = $extra->{'LOD-score'} if defined($extra->{'LOD-score'});
scripts/import/import_phenotype_data.pl:    $phenotype->{'variance'} = $extra->{'Variance'} if defined($extra->{'Variance'});
scripts/import/import_phenotype_data.pl:    $phenotype->{'associated_gene'} = $extra->{'Candidate_Gene_Symble'} if defined($extra->{'Candidate_Gene_Symble'});
scripts/import/import_phenotype_data.pl:      if(!defined($seq_region_ids->{$chr})) {
scripts/import/import_phenotype_data.pl:        seq_region_id => $seq_region_ids->{$chr},
scripts/import/import_phenotype_data.pl:  my $gene_adaptor = $core_db_adaptor->get_GeneAdaptor;
scripts/import/import_phenotype_data.pl:        my $gene = $gene_adaptor->fetch_by_display_label($symbol);
scripts/import/import_phenotype_data.pl:          my $genes = $gene_adaptor->fetch_all_by_external_name($symbol,'RGD');
scripts/import/import_phenotype_data.pl:          $gene = $genes->[0] if (scalar(@$genes) > 0);
scripts/import/import_phenotype_data.pl:        $rgd_coords{$symbol} = { 'gene'   => $gene->stable_id,
scripts/import/import_phenotype_data.pl:                                 'chr'    => $gene->slice->seq_region_name,
scripts/import/import_phenotype_data.pl:                                 'start'  => $gene->start,
scripts/import/import_phenotype_data.pl:                                 'end'    => $gene->end,
scripts/import/import_phenotype_data.pl:                                 'strand' => $gene->strand
scripts/import/import_phenotype_data.pl:        seq_region_id => $seq_region_ids->{$rgd_coords{$symbol}{'chr'}},
scripts/import/import_phenotype_data.pl:        $phenotype->{external_id} = $1;
scripts/import/import_phenotype_data.pl:        $phenotype->{pubmed_id} = $2;
scripts/import/import_phenotype_data.pl:        $phenotype->{accessions} = [ $data{'TERM_ACC_ID'} ];
scripts/import/import_phenotype_data.pl:      # fix p-value
scripts/import/import_phenotype_data.pl:  my $ga = $core_db_adaptor->get_GeneAdaptor;
scripts/import/import_phenotype_data.pl:  my $xml_parser   = XML::LibXML->new();
scripts/import/import_phenotype_data.pl:  my $orphanet_doc = $xml_parser->parse_file($infile);
scripts/import/import_phenotype_data.pl:  foreach my $disorder ($orphanet_doc->findnodes('JDBOR/DisorderList/Disorder')) {
scripts/import/import_phenotype_data.pl:    my ($orpha_number_node) = $disorder->findnodes('./OrphaNumber');
scripts/import/import_phenotype_data.pl:    my $orpha_number = $orpha_number_node->to_literal;
scripts/import/import_phenotype_data.pl:    my ($name_node) = $disorder->findnodes('./Name');
scripts/import/import_phenotype_data.pl:    my $name = $name_node->to_literal;
scripts/import/import_phenotype_data.pl:    my @gene_nodes = $disorder->findnodes('./DisorderGeneAssociationList/DisorderGeneAssociation/Gene');
scripts/import/import_phenotype_data.pl:      foreach my $external_reference_node ($gene_node->findnodes('./ExternalReferenceList/ExternalReference')) {
scripts/import/import_phenotype_data.pl:        my ($source_node) = $external_reference_node->findnodes('./Source');
scripts/import/import_phenotype_data.pl:        if ($source_node->to_literal =~ /HGNC/) {
scripts/import/import_phenotype_data.pl:          my ($ref_node) = $external_reference_node->findnodes('./Reference');
scripts/import/import_phenotype_data.pl:          $ref = $ref_node->to_literal;
scripts/import/import_phenotype_data.pl:        if ($source_node->to_literal =~ /ensembl/i) {
scripts/import/import_phenotype_data.pl:          my ($ens_node) = $external_reference_node->findnodes('./Reference');
scripts/import/import_phenotype_data.pl:          $ens_ids{$ens_node->to_literal} = 1;
scripts/import/import_phenotype_data.pl:            my $g = $ga->fetch_by_stable_id($ens_id);
scripts/import/import_phenotype_data.pl:          my $genes = $ref =~ /^\d+$/ ? $ga->fetch_all_by_description('%HGNC:'.$ref.']%') : $ga->fetch_all_by_external_name($ref, 'HGNC');
scripts/import/import_phenotype_data.pl:          @$genes = grep {$_->stable_id !~ /^LRG_/} @$genes;
scripts/import/import_phenotype_data.pl:          @$genes = grep {$ens_ids{$_->stable_id}} @$genes if scalar keys %ens_ids;
scripts/import/import_phenotype_data.pl:              'id' => $gene->stable_id,
scripts/import/import_phenotype_data.pl:              'seq_region_id' => $gene->slice->get_seq_region_id,
scripts/import/import_phenotype_data.pl:              'seq_region_start' => $gene->seq_region_start,
scripts/import/import_phenotype_data.pl:              'seq_region_end' => $gene->seq_region_end,
scripts/import/import_phenotype_data.pl:              'seq_region_strand' => $gene->seq_region_strand
scripts/import/import_phenotype_data.pl:  my $ga = $core_db_adaptor->get_GeneAdaptor;
scripts/import/import_phenotype_data.pl:  my $csv = Text::CSV->new ( { binary => 1 } )  # should set binary attribute.
scripts/import/import_phenotype_data.pl:            or die "Cannot use CSV: ".Text::CSV->error_diag ();
scripts/import/import_phenotype_data.pl:  $csv->column_names ($csv->getline ($fh));
scripts/import/import_phenotype_data.pl:  while (my $content = $csv->getline_hr ($fh)) {
scripts/import/import_phenotype_data.pl:    my $symbol  = $content->{'gene symbol'};
scripts/import/import_phenotype_data.pl:    my $allelic = $content->{'allelic requirement'};
scripts/import/import_phenotype_data.pl:    my $mode    = $content->{'mutation consequence'};
scripts/import/import_phenotype_data.pl:    my $phen    = $content->{'disease name'};
scripts/import/import_phenotype_data.pl:    my $id      = $content->{'disease mim'};
scripts/import/import_phenotype_data.pl:    my @accns   = split/\;/,$content->{'phenotypes'};
scripts/import/import_phenotype_data.pl:      my $genes = $ga->fetch_all_by_external_name($symbol, 'HGNC');
scripts/import/import_phenotype_data.pl:      @$genes = grep {$_->stable_id !~ /^LRG_/} @$genes;
scripts/import/import_phenotype_data.pl:        my @tmp = grep {$_->external_name eq $symbol} @$genes;
scripts/import/import_phenotype_data.pl:          'id' => $gene->stable_id,
scripts/import/import_phenotype_data.pl:          'seq_region_id' => $gene->slice->get_seq_region_id,
scripts/import/import_phenotype_data.pl:          'seq_region_start' => $gene->seq_region_start,
scripts/import/import_phenotype_data.pl:          'seq_region_end' => $gene->seq_region_end,
scripts/import/import_phenotype_data.pl:          'seq_region_strand' => $gene->seq_region_strand,
scripts/import/import_phenotype_data.pl:  my $ga = $core_db_adaptor->get_GeneAdaptor;
scripts/import/import_phenotype_data.pl:    my $gene = $ga->fetch_by_stable_id($gene_id);
scripts/import/import_phenotype_data.pl:      'seq_region_id' => $gene->slice->get_seq_region_id,
scripts/import/import_phenotype_data.pl:      'seq_region_start' => $gene->seq_region_start,
scripts/import/import_phenotype_data.pl:      'seq_region_end' => $gene->seq_region_end,
scripts/import/import_phenotype_data.pl:      'seq_region_strand' => $gene->seq_region_strand,
scripts/import/import_phenotype_data.pl:#  my $ga = $core_db_adaptor->get_GeneAdaptor;
scripts/import/import_phenotype_data.pl:#      next unless $mim2gene->{$number} && $mim2gene->{$number}->{symbols} ne '-';
scripts/import/import_phenotype_data.pl:#        $label =~ s/\;\s[A-Z0-9]+$//; # strip gene name at end
scripts/import/import_phenotype_data.pl:#        my $symbol = $mim2gene->{$number}->{symbols};
scripts/import/import_phenotype_data.pl:#        my $genes = $ga->fetch_all_by_external_name($symbol, 'HGNC');
scripts/import/import_phenotype_data.pl:#        @$genes = grep {$_->stable_id !~ /^LRG_/} @$genes;
scripts/import/import_phenotype_data.pl:#          my @tmp = grep {$_->external_name eq $symbol} @$genes;
scripts/import/import_phenotype_data.pl:#              'id' => $gene->stable_id,
scripts/import/import_phenotype_data.pl:#              'seq_region_id' => $gene->slice->get_seq_region_id,
scripts/import/import_phenotype_data.pl:#              'seq_region_start' => $gene->seq_region_start,
scripts/import/import_phenotype_data.pl:#              'seq_region_end' => $gene->seq_region_end,
scripts/import/import_phenotype_data.pl:#              'seq_region_strand' => $gene->seq_region_strand,
scripts/import/import_phenotype_data.pl:    if ($pvalue =~ /^(\d\.\d+)(e-\d+)$/) {
scripts/import/import_phenotype_data.pl:    while ($rs_id =~ m/(rs[0-9]+)/g) {
scripts/import/import_phenotype_data.pl:  my $ga = $core_db_adaptor->get_GeneAdaptor;
scripts/import/import_phenotype_data.pl:      my $genes = $ga->fetch_all_by_external_name($symbol);
scripts/import/import_phenotype_data.pl:        my @tmp = grep {$_->external_name eq $symbol} @$genes;
scripts/import/import_phenotype_data.pl:          'id' => $gene->stable_id,
scripts/import/import_phenotype_data.pl:          'seq_region_id' => $gene->slice->get_seq_region_id,
scripts/import/import_phenotype_data.pl:          'seq_region_start' => $gene->seq_region_start,
scripts/import/import_phenotype_data.pl:          'seq_region_end' => $gene->seq_region_end,
scripts/import/import_phenotype_data.pl:          'seq_region_strand' => $gene->seq_region_strand,
scripts/import/import_phenotype_data.pl:  my $dbh = $db_adaptor->dbc->db_handle;
scripts/import/import_phenotype_data.pl:  my $fh = FileHandle->new($phenotype_file, 'r');
scripts/import/import_phenotype_data.pl:        $source_names->{$value} = 1;
scripts/import/import_phenotype_data.pl:        $source_names->{$value} = 1;
scripts/import/import_phenotype_data.pl:  $fh->close();
scripts/import/import_phenotype_data.pl:    my $sth = $dbh->prepare($stmt);
scripts/import/import_phenotype_data.pl:    $sth->execute();
scripts/import/import_phenotype_data.pl:    $sth->bind_columns(\$source_id);
scripts/import/import_phenotype_data.pl:    $sth->fetch();
scripts/import/import_phenotype_data.pl:      $source_name2id->{$source_name} = $source_id;
scripts/import/import_phenotype_data.pl:    $sth->finish();
scripts/import/import_phenotype_data.pl:  my $dbh = $db_adaptor->dbc->db_handle;
scripts/import/import_phenotype_data.pl:  $dbh->do(qq{ DELETE pfa FROM phenotype_feature_attrib pfa JOIN phenotype_feature pf ON pfa.phenotype_feature_id = pf.phenotype_feature_id AND pf.source_id IN ($source_ids);} );
scripts/import/import_phenotype_data.pl:  $dbh->do(qq{ DELETE FROM phenotype_feature WHERE source_id IN ($source_ids);} );
scripts/import/import_phenotype_data.pl:  my $individual_adaptor = $db_adaptor->get_IndividualAdaptor;
scripts/import/import_phenotype_data.pl:  my $fh = FileHandle->new($infile, 'r');
scripts/import/import_phenotype_data.pl:      $hash->{$key} = $value;
scripts/import/import_phenotype_data.pl:      $data{$value} = $hash->{$value};
scripts/import/import_phenotype_data.pl:    my $marker_accession_id = $hash->{marker_accession_id};
scripts/import/import_phenotype_data.pl:    my $description = $hash->{mp_term_name};
scripts/import/import_phenotype_data.pl:    $data{accession} = $hash->{mp_term_id};
scripts/import/import_phenotype_data.pl:      $source = $hash->{resource_name};
scripts/import/import_phenotype_data.pl:      $source = $hash->{project_name};
scripts/import/import_phenotype_data.pl:    $data{source_id} = $source_name2ids->{$source};
scripts/import/import_phenotype_data.pl:    my $pf_data           = $marker_coords->{$marker_accession_id};
scripts/import/import_phenotype_data.pl:    my $type              = $pf_data->{type};
scripts/import/import_phenotype_data.pl:    my $seq_region_id     = $pf_data->{seq_region_id};
scripts/import/import_phenotype_data.pl:    my $seq_region_start  = $pf_data->{seq_region_start};
scripts/import/import_phenotype_data.pl:    my $seq_region_end    = $pf_data->{seq_region_end};
scripts/import/import_phenotype_data.pl:    my $seq_region_strand = $pf_data->{seq_region_strand};
scripts/import/import_phenotype_data.pl:    my $strain_name       = $hash->{strain_name};
scripts/import/import_phenotype_data.pl:    my $gender            = $hash->{sex};
scripts/import/import_phenotype_data.pl:      my $strains = $individual_adaptor->fetch_all_by_name($strain_name);
scripts/import/import_phenotype_data.pl:          if (lc $strain->gender eq $gender) {
scripts/import/import_phenotype_data.pl:          $strain_id = $unique[0]->dbID();
scripts/import/import_phenotype_data.pl:            -name => $strain_name,
scripts/import/import_phenotype_data.pl:            -gender => $gender,
scripts/import/import_phenotype_data.pl:            -individual_type_id => 1,
scripts/import/import_phenotype_data.pl:        $individual_adaptor->store($individual);
scripts/import/import_phenotype_data.pl:        $strain_id = $individual_adaptor->last_insert_id();
scripts/import/import_phenotype_data.pl:    $data{associated_gene} = $hash->{marker_symbol};
scripts/import/import_phenotype_data.pl:    if ($hash->{p_value}) {
scripts/import/import_phenotype_data.pl:      $data{p_value} = convert_p_value($hash->{p_value});
scripts/import/import_phenotype_data.pl:    $data{external_id} = $hash->{mp_term_id};
scripts/import/import_phenotype_data.pl:    if ($pf_data->{object_id}) {
scripts/import/import_phenotype_data.pl:      @object_ids = split(';', $pf_data->{object_id});
scripts/import/import_phenotype_data.pl:        my $key = join('-', ($accession, $source, $object_id, $strain_id));
scripts/import/import_phenotype_data.pl:        unless ($already_inserted->{$key}) {
scripts/import/import_phenotype_data.pl:        $already_inserted->{$key} = 1;
scripts/import/import_phenotype_data.pl:  my $sth = $db_adaptor->dbc->prepare(qq{
scripts/import/import_phenotype_data.pl:  $sth->execute();
scripts/import/import_phenotype_data.pl:  $sth->bind_columns(\$attrib_type);
scripts/import/import_phenotype_data.pl:  while ($sth->fetch()) {
scripts/import/import_phenotype_data.pl:  $sth->finish;
scripts/import/import_phenotype_data.pl:  my $sth = $db_adaptor->dbc->prepare(qq{
scripts/import/import_phenotype_data.pl:  $sth->execute;
scripts/import/import_phenotype_data.pl:  $sth->bind_columns(\$id, \$name);
scripts/import/import_phenotype_data.pl:  $seq_region_ids{$name} = $id while $sth->fetch();
scripts/import/import_phenotype_data.pl:  $sth->finish;
scripts/import/import_phenotype_data.pl:  my $id_sth = $db_adaptor->dbc->prepare($id_stmt);
scripts/import/import_phenotype_data.pl:  my $syn_sth = $db_adaptor->dbc->prepare($syn_stmt);
scripts/import/import_phenotype_data.pl:    $id_sth->bind_param(1,$rs_id,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:    $id_sth->execute();
scripts/import/import_phenotype_data.pl:    $id_sth->bind_columns(\$var_id,\$var_name);
scripts/import/import_phenotype_data.pl:    $id_sth->fetch();
scripts/import/import_phenotype_data.pl:      $syn_sth->bind_param(1,$rs_id,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:      $syn_sth->execute();
scripts/import/import_phenotype_data.pl:      $syn_sth->bind_columns(\$var_id,\$var_name);
scripts/import/import_phenotype_data.pl:      $syn_sth->fetch();
scripts/import/import_phenotype_data.pl:    warn "$rs_id - no mapping found in variation db\n" unless $var_id ;  
scripts/import/import_phenotype_data.pl:  my @object_ids = ($type eq 'Variation') ? map { $variation_ids->{$_}[1] } keys(%$variation_ids): @$ids;
scripts/import/import_phenotype_data.pl:  my $sth = $db_adaptor->dbc->prepare(qq{
scripts/import/import_phenotype_data.pl:    $sth->bind_param(1,$id,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:    $sth->execute();
scripts/import/import_phenotype_data.pl:    $sth->bind_columns(\$sr_id, \$start, \$end, \$strand);
scripts/import/import_phenotype_data.pl:    push @{$coords->{$id}}, {
scripts/import/import_phenotype_data.pl:    } while $sth->fetch();
scripts/import/import_phenotype_data.pl:  $sth->finish();
scripts/import/import_phenotype_data.pl:  my $sth = $db_adaptor->dbc->prepare($stmt);
scripts/import/import_phenotype_data.pl:  $sth->execute();
scripts/import/import_phenotype_data.pl:  $sth->bind_columns(\$source_id);
scripts/import/import_phenotype_data.pl:  $sth->fetch();
scripts/import/import_phenotype_data.pl:    $db_adaptor->dbc->do($stmt);
scripts/import/import_phenotype_data.pl:    $source_id = $db_adaptor->dbc->db_handle->{'mysql_insertid'};
scripts/import/import_phenotype_data.pl:    my $update_source_sth =$db_adaptor->dbc->prepare($stmt);
scripts/import/import_phenotype_data.pl:    $update_source_sth->execute($source_name,$source_description,$source_url,$source_version,$source_id);
scripts/import/import_phenotype_data.pl:  my $st_ins_sth   = $db_adaptor->dbc->prepare($st_ins_stmt);
scripts/import/import_phenotype_data.pl:  my $pf_check_sth = $db_adaptor->dbc->prepare($pf_check_stmt);
scripts/import/import_phenotype_data.pl:  my $pf_ins_sth   = $db_adaptor->dbc->prepare($pf_ins_stmt);
scripts/import/import_phenotype_data.pl:  my $attrib_ins_sth = $db_adaptor->dbc->prepare($attrib_ins_stmt);
scripts/import/import_phenotype_data.pl:  my $attrib_ins_cast_sth = $db_adaptor->dbc->prepare($attrib_ins_cast_stmt);
scripts/import/import_phenotype_data.pl:  my $ontology_accession_ins_sth = $db_adaptor->dbc->prepare($ontology_accession_ins_stmt);
scripts/import/import_phenotype_data.pl:  my $attrib_id_ext_sth = $db_adaptor->dbc->prepare($attrib_id_ext_stmt);
scripts/import/import_phenotype_data.pl:  $attrib_id_ext_sth->execute();
scripts/import/import_phenotype_data.pl:  my $ont_attrib_type = $attrib_id_ext_sth->fetchall_hashref("value");
scripts/import/import_phenotype_data.pl:  if (exists $ont_attrib_type->{$source_name}){
scripts/import/import_phenotype_data.pl:  my @sorted = sort {($a->{description} || $a->{name}) cmp ($b->{description} || $b->{name})} @{$phenotypes};
scripts/import/import_phenotype_data.pl:    $object_type = $phenotype->{type} if defined($phenotype->{type});
scripts/import/import_phenotype_data.pl:    my $object_id = $phenotype->{"id"};
scripts/import/import_phenotype_data.pl:    next if $object_type =~ /Variation/ && (!defined($variation_ids->{$object_id}));
scripts/import/import_phenotype_data.pl:    $object_id = $variation_ids->{$object_id}[1] if ($object_type eq 'Variation');
scripts/import/import_phenotype_data.pl:    if(defined($phenotype->{study}) || defined($phenotype->{study_description}) || defined($phenotype->{study_type})) {
scripts/import/import_phenotype_data.pl:      if (!defined $phenotype->{"study"}) {$sql_study = 'IS NULL'; }
scripts/import/import_phenotype_data.pl:      if (!defined $phenotype->{"study_type"}) {$sql_type = 'IS NULL'; }  
scripts/import/import_phenotype_data.pl:      my $st_check_sth = $db_adaptor->dbc->prepare($st_check_stmt);
scripts/import/import_phenotype_data.pl:      if (defined $phenotype->{"study"}) {
scripts/import/import_phenotype_data.pl:        $st_check_sth->bind_param($param_num,$phenotype->{"study"},SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:      if (defined $phenotype->{"study_type"}) {
scripts/import/import_phenotype_data.pl:        $st_check_sth->bind_param($param_num,$phenotype->{"study_type"},SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:      $st_check_sth->bind_param($param_num,$phenotype->{"study_description"},SQL_VARCHAR) if ($source =~ m/dbgap/i);
scripts/import/import_phenotype_data.pl:      $st_check_sth->execute();
scripts/import/import_phenotype_data.pl:      $st_check_sth->bind_columns(\$study_id);
scripts/import/import_phenotype_data.pl:      $st_check_sth->fetch();
scripts/import/import_phenotype_data.pl:        $st_ins_sth->bind_param(1,$phenotype->{"study"},SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:        $st_ins_sth->bind_param(2,$phenotype->{"study_type"},SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:        $st_ins_sth->bind_param(3,$phenotype->{"study_description"},SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:        $st_ins_sth->execute();
scripts/import/import_phenotype_data.pl:        $study_id = $db_adaptor->dbc->db_handle->{'mysql_insertid'};
scripts/import/import_phenotype_data.pl:      $phenotype->{description} =~ s/$char/$new_char/g;
scripts/import/import_phenotype_data.pl:    foreach my $acc (@{$phenotype->{accessions}}){
scripts/import/import_phenotype_data.pl:      $ontology_accession_ins_sth->execute( $phenotype_id, $acc,  $ont_attrib_type->{$mapped_by}->{'attrib_id'}, $phenotype->{ontology_mapping_type} ) ||die "Failed to import phenotype accession\n";
scripts/import/import_phenotype_data.pl:    if ($phenotype->{"associated_gene"}) {
scripts/import/import_phenotype_data.pl:      $phenotype->{"associated_gene"} =~ s/\s//g;
scripts/import/import_phenotype_data.pl:      $phenotype->{"associated_gene"} =~ s/;/,/g;
scripts/import/import_phenotype_data.pl:    $phenotype->{"p_value"} = convert_p_value($phenotype->{"p_value"}) if (defined($phenotype->{"p_value"}));
scripts/import/import_phenotype_data.pl:    $pf_check_sth->bind_param(1,$object_id,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:    $pf_check_sth->bind_param(2,$object_type,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:    $pf_check_sth->bind_param(3,$phenotype_id,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:    $pf_check_sth->bind_param(4,$source_id,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:    $pf_check_sth->bind_param(5,$study_id,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:      $pf_check_sth->bind_param(6,$phenotype->{"variation_names"},SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:    # For nhgri-ebi gwas data
scripts/import/import_phenotype_data.pl:      $pf_check_sth->bind_param(6,$phenotype->{"p_value"},SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:      $pf_check_sth->bind_param(6,$phenotype->{"risk_allele"},SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:      $pf_check_sth->bind_param(7,$phenotype->{"associated_gene"},SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:    $pf_check_sth->execute();
scripts/import/import_phenotype_data.pl:    $pf_check_sth->bind_columns(\$pf_id);
scripts/import/import_phenotype_data.pl:    $pf_check_sth->fetch();
scripts/import/import_phenotype_data.pl:    my $is_significant = defined($threshold) ? ($phenotype->{"p_value"} && $phenotype->{"p_value"} < $threshold ? 1 : 0) : 1;
scripts/import/import_phenotype_data.pl:    foreach my $coord(@{$coords->{$object_id}}) {
scripts/import/import_phenotype_data.pl:      $pf_ins_sth->bind_param(1,$phenotype_id,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:      $pf_ins_sth->bind_param(2,$source_id,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:      $pf_ins_sth->bind_param(3,$study_id,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:      $pf_ins_sth->bind_param(4,$object_type,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:      $pf_ins_sth->bind_param(5,$object_id,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:      $pf_ins_sth->bind_param(6,$is_significant,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:      $pf_ins_sth->bind_param(7,$coord->{seq_region_id},SQL_INTEGER);
scripts/import/import_phenotype_data.pl:      $pf_ins_sth->bind_param(8,$coord->{seq_region_start},SQL_INTEGER);
scripts/import/import_phenotype_data.pl:      $pf_ins_sth->bind_param(9,$coord->{seq_region_end},SQL_INTEGER);
scripts/import/import_phenotype_data.pl:      $pf_ins_sth->bind_param(10,$coord->{seq_region_strand},SQL_INTEGER);
scripts/import/import_phenotype_data.pl:      $pf_ins_sth->execute();
scripts/import/import_phenotype_data.pl:      $pf_id = $db_adaptor->dbc->db_handle->{'mysql_insertid'};
scripts/import/import_phenotype_data.pl:      foreach my $attrib_type(grep {defined($phenotype->{$_}) && $phenotype->{$_} ne ''} @attrib_types) {
scripts/import/import_phenotype_data.pl:        my $value = $phenotype->{$attrib_type};
scripts/import/import_phenotype_data.pl:        $sth->bind_param(1,$pf_id,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:        $sth->bind_param(2,$value,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:        $sth->bind_param(3,$attrib_type,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:        $sth->execute();
scripts/import/import_phenotype_data.pl:  $name = $phenotype->{name};
scripts/import/import_phenotype_data.pl:  $description = $phenotype->{description};
scripts/import/import_phenotype_data.pl:      # skip if mismatch is anything word-like
scripts/import/import_phenotype_data.pl:        my $diff_pos  = $_->[1];
scripts/import/import_phenotype_data.pl:        my $diff_char = $_->[2];
scripts/import/import_phenotype_data.pl:  my $sth = $db_adaptor->dbc->prepare(qq{
scripts/import/import_phenotype_data.pl:  $sth->bind_param(1,$name,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:  $sth->bind_param(2,$description,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:  $sth->execute();
scripts/import/import_phenotype_data.pl:  my $phenotype_id = $db_adaptor->dbc->db_handle->{'mysql_insertid'};
scripts/import/import_phenotype_data.pl:  my $ins_sth = $db_adaptor->dbc->prepare($ins_stmt);
scripts/import/import_phenotype_data.pl:    my $var_id = $variation_ids->{$rs_id}[0];
scripts/import/import_phenotype_data.pl:      $ins_sth->bind_param(1,$var_id,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:      while (my $alt_id = shift(@{$synonyms->{$rs_id}})) {
scripts/import/import_phenotype_data.pl:        $ins_sth->bind_param(2,$alt_id,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:        $ins_sth->execute();
scripts/import/import_phenotype_data.pl:  print STDOUT "Added $alt_count synonyms for $variation_count rs-ids\n" if ($verbose);
scripts/import/import_phenotype_data.pl:  my $sth1 = $db_adaptor->dbc->prepare($select_set_stmt);
scripts/import/import_phenotype_data.pl:  $sth1->bind_param(1,$set,SQL_VARCHAR);
scripts/import/import_phenotype_data.pl:  $sth1->execute();
scripts/import/import_phenotype_data.pl:  $sth1->bind_columns(\$variation_set_id);
scripts/import/import_phenotype_data.pl:  $sth1->fetch();
scripts/import/import_phenotype_data.pl:  my $sth2 = $db_adaptor->dbc->prepare($insert_set_stmt);
scripts/import/import_phenotype_data.pl:  $sth2->bind_param(1,$variation_set_id,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:  $sth2->bind_param(2,$source_id,SQL_INTEGER);
scripts/import/import_phenotype_data.pl:  $sth2->execute();
scripts/import/import_phenotype_data.pl:    # If a range format is found (e.g. 10^-2 > p > 10^-3)
scripts/import/import_phenotype_data.pl:    if ($pval =~ /^\d+\^(-\d+)/) {
scripts/import/import_phenotype_data.pl:      $sci_pval = "1.00e$1"; # e.g 10^-2 > p > 10^-3 => 1.00e-2
scripts/import/import_phenotype_data.pl:    #$sci_pval = sprintf("%.2e",$pval); # e.g. 0.002 => 2,30e-3
scripts/import/import_phenotype_data.pl:    if ($pval =~ /^(\d+)(e-?\d+)/) {
scripts/import/import_phenotype_data.pl:    if ($pval =~ /^(\d+\.\d{1})(e-?\d+)/) {
scripts/import/import_phenotype_data.pl:  my $numblobs = int((($i/$total) * $width) - 2);
scripts/import/import_phenotype_data.pl:  return if defined($prev_prog) && $numblobs.'-'.$percent eq $prev_prog;
scripts/import/import_phenotype_data.pl:  $prev_prog = $numblobs.'-'.$percent;
scripts/import/import_phenotype_data.pl:  printf("\r% -${width}s% 1s% 10s", '['.('=' x $numblobs).($numblobs == $width - 2 ? '=' : '>'), ']', "[ " . $percent . "% ]");
scripts/import/import_phenotype_data.pl:  my $fh = FileHandle->new($phenotype_file, 'w');
scripts/import/import_phenotype_data.pl:  my $http = HTTP::Tiny->new();
scripts/import/import_phenotype_data.pl:    my $response = $http->get($server.$ext, {
scripts/import/import_phenotype_data.pl:      headers => { 'Content-type' => 'application/json' }
scripts/import/import_phenotype_data.pl:    my $hash = decode_json($response->{content});
scripts/import/import_phenotype_data.pl:    $rows = scalar @{$hash->{response}->{docs}};
scripts/import/import_phenotype_data.pl:    my $response = $http->get($server.$ext, {
scripts/import/import_phenotype_data.pl:      headers => { 'Content-type' => 'application/json' }
scripts/import/import_phenotype_data.pl:    die "Failed!\n" unless $response->{success};
scripts/import/import_phenotype_data.pl:    if (length $response->{content}) {
scripts/import/import_phenotype_data.pl:      my $hash = decode_json($response->{content});
scripts/import/import_phenotype_data.pl:      foreach my $result (@{$hash->{response}->{docs}}) {
scripts/import/import_phenotype_data.pl:          my $value = $result->{$key};
scripts/import/import_phenotype_data.pl:  $fh->close();
scripts/import/import_phenotype_data.pl:  my $http = HTTP::Tiny->new();
scripts/import/import_phenotype_data.pl:  my $response = $http->get($url, {
scripts/import/import_phenotype_data.pl:    headers => { 'Content-type' => 'application/json' }
scripts/import/import_phenotype_data.pl:  my $hash = decode_json($response->{content});
scripts/import/import_phenotype_data.pl:  my $data_release_date = $hash->{data_release_date};
scripts/import/import_phenotype_data.pl:  my ($date, $month, $year) = split(' ', $hash->{data_release_date}) ;
scripts/import/import_phenotype_data.pl:  my $month_number = $months->{$month};
scripts/import/import_phenotype_data.pl:  my $dbh = $db_adaptor->dbc->db_handle;
scripts/import/import_phenotype_data.pl:    $dbh->do(qq{UPDATE source SET version=$version WHERE name='$source_name';}) or die $dbh->errstr;
scripts/import/import_phenotype_data.pl:  my $gene_adaptor = $core_db_adaptor->get_GeneAdaptor;
scripts/import/import_phenotype_data.pl:  my $fh = FileHandle->new($phenotype_file, 'r');
scripts/import/import_phenotype_data.pl:      $hash->{$key} = $value;
scripts/import/import_phenotype_data.pl:      $column_headers->{$key} = 1;
scripts/import/import_phenotype_data.pl:    $markers->{$hash->{marker_accession_id}} = 1;
scripts/import/import_phenotype_data.pl:  $fh->close();
scripts/import/import_phenotype_data.pl:  $fh = FileHandle->new($coord_file, 'r');
scripts/import/import_phenotype_data.pl:        $header->{$column_number} = $column_name;
scripts/import/import_phenotype_data.pl:      unless ($header->{'1.'} eq 'MGI Marker Accession ID') { die 'Header in MGI_MRK_Coord.rpt has changed.'};
scripts/import/import_phenotype_data.pl:      unless ($header->{'6.'} eq 'Chromosome') { die 'Header in MGI_MRK_Coord.rpt has changed.'};
scripts/import/import_phenotype_data.pl:      unless ($header->{'7.'} eq 'Start Coordinate') { die 'Header in MGI_MRK_Coord.rpt has changed.'};
scripts/import/import_phenotype_data.pl:      unless ($header->{'8.'} eq 'End Coordinate') { die 'Header in MGI_MRK_Coord.rpt has changed.'};
scripts/import/import_phenotype_data.pl:      unless ($header->{'9.'} eq 'Strand') { die 'Header in MGI_MRK_Coord.rpt has changed.'};
scripts/import/import_phenotype_data.pl:    if ($markers->{$marker_acc}) {
scripts/import/import_phenotype_data.pl:      unless ($marker_coords->{$marker_acc}) {
scripts/import/import_phenotype_data.pl:        my $genes = $gene_adaptor->fetch_all_by_external_name($marker_acc);
scripts/import/import_phenotype_data.pl:            $unique_seq_region_id->{$gene->slice->get_seq_region_id} = 1;
scripts/import/import_phenotype_data.pl:        $marker_coords->{$marker_acc}->{type} = $marker_type;
scripts/import/import_phenotype_data.pl:        $marker_coords->{$marker_acc}->{object_id} = join(";", map {$_->stable_id} @$genes);
scripts/import/import_phenotype_data.pl:        $marker_coords->{$marker_acc}->{chromosome} = $chromosome;
scripts/import/import_phenotype_data.pl:        $marker_coords->{$marker_acc}->{seq_region_id} = $genes->[0]->slice->get_seq_region_id;
scripts/import/import_phenotype_data.pl:        $marker_coords->{$marker_acc}->{seq_region_start} = $start_coord;
scripts/import/import_phenotype_data.pl:        $marker_coords->{$marker_acc}->{seq_region_end} = $end_coord;
scripts/import/import_phenotype_data.pl:        $marker_coords->{$marker_acc}->{seq_region_strand} = ($strand eq '+') ? 1 : -1;
scripts/import/import_phenotype_data.pl:  $fh->close();
scripts/import/import_phenotype_data.pl:      -verbose           Progress information is printed
scripts/import/import_phenotype_data.pl:      -help              Print this message
scripts/import/import_phenotype_data.pl:      -skip_phenotypes   Skip the study, phenotype_feature, phenotype_feature_attrib and phenotype tables insertions.
scripts/import/import_phenotype_data.pl:      -skip_synonyms     Skip the variation_synonym table insertion.
scripts/import/import_phenotype_data.pl:      -skip_sets         Skip the variation_set_variation table insertion.
scripts/import/import_phenotype_data.pl:      -host      Variation database host name (Required)
scripts/import/import_phenotype_data.pl:      -dbname    Variation database name (Required)
scripts/import/import_phenotype_data.pl:      -user      Variation database user (Required)
scripts/import/import_phenotype_data.pl:      -pass      Variation database password (Required)
scripts/import/import_phenotype_data.pl:      -port      Variation database port (Default: 3306)
scripts/import/import_phenotype_data.pl:      -chost     Core database host name (Required for gene-type sources)
scripts/import/import_phenotype_data.pl:      -cdbname   Core database name (Required for gene-type sources)
scripts/import/import_phenotype_data.pl:      -cuser     Core database user (Required for gene-type sources)
scripts/import/import_phenotype_data.pl:      -cpass     Core database password (Required for gene-type sources)
scripts/import/import_phenotype_data.pl:      -cport     Core database port (Default: 3306)
scripts/import/import_phenotype_data.pl:    An input file must be specified. This file contains the data that will be imported, typically tab-delimited
scripts/import/import_phenotype_data.pl:    and obtained from the UniProt or NHGRI-EBI GWAS catalog. If a new source is required, a method for parsing the
scripts/import/import_phenotype_data.pl:      -infile          Typically a tab-delimited file (Required)
scripts/import/import_phenotype_data.pl:      -source             String indicating the source of the data (Required)
scripts/import/import_phenotype_data.pl:      -version           Numerical version of the source (Required)
scripts/import/ImportUtils.pm:Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/ImportUtils.pm:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/ImportUtils.pm:     http://www.apache.org/licenses/LICENSE-2.0
scripts/import/ImportUtils.pm:# This will strip non-xml-compliant characters from an infile, saving a backup in {infile name}.bak
scripts/import/ImportUtils.pm:      s/[^\x01-\x{D7FF}\x{E000}-\x{FFFD}\x{10000}-\x{10FFFF}]/$replacement/go;
scripts/import/ImportUtils.pm:      s/[\x01-\x08\x0B-\x0C\x0E-\x1F\x7F-\x84\x86-\x9F]/$replacement/go;
scripts/import/ImportUtils.pm:      s/[^\x09\x0A\x0D\x20-\x{D7FF}\x{E000}-\x{FFFD}\x{10000}-\x{10FFFF}]/$replacement/go;
scripts/import/ImportUtils.pm:   my $sth = $db->prepare( $sql );
scripts/import/ImportUtils.pm:   $sth->finish();
scripts/import/ImportUtils.pm:  $sth->{mysql_use_result} = 1;
scripts/import/ImportUtils.pm:  $sth->execute();
scripts/import/ImportUtils.pm:  while ( my $aref = $sth->fetchrow_arrayref() ) {
scripts/import/ImportUtils.pm:   $dbh->db_handle->begin_work();
scripts/import/ImportUtils.pm:   $dbh->do("DECLARE csr CURSOR  FOR $sql");
scripts/import/ImportUtils.pm:     my $sth = $dbh->prepare("fetch 100000 from csr");
scripts/import/ImportUtils.pm:     $sth->execute;
scripts/import/ImportUtils.pm:     last if 0 == $sth->rows;
scripts/import/ImportUtils.pm:     while ( my $aref = $sth->fetchrow_arrayref() ) {
scripts/import/ImportUtils.pm:   $dbh->do("CLOSE csr");
scripts/import/ImportUtils.pm:   $dbh->db_handle->rollback();
scripts/import/ImportUtils.pm:  if (! -e $loadfile) {
scripts/import/ImportUtils.pm:  if (-e $table_file) {
scripts/import/ImportUtils.pm:#  my $host = $db->host();
scripts/import/ImportUtils.pm:#  my $user = $db->user();
scripts/import/ImportUtils.pm:#  my $pass = $db->pass();
scripts/import/ImportUtils.pm:#  my $port = $db->port();
scripts/import/ImportUtils.pm:#  my $dbname = $db->dbname();
scripts/import/ImportUtils.pm:#  my $call = "mysqlimport -c $cols -h $host -u $user " .
scripts/import/ImportUtils.pm:#    "-p$pass -P$port $dbname $table_file";
scripts/import/ImportUtils.pm:#  elsif( ! -e $table_file ){ # File is not on local filesystem
scripts/import/ImportUtils.pm:   $db->do( $sql );
scripts/import/ImportUtils.pm:  $db->do( $sql );
scripts/import/ImportUtils.pm:  my $result = $dbc->db_handle->selectall_arrayref($stmt)->[0][1];
scripts/import/ImportUtils.pm:  $sth = $db->prepare($stmt);
scripts/import/ImportUtils.pm:  $sth->execute;
scripts/import/ImportUtils.pm:  my @source_cols = map {$_->[0]} @{$sth->fetchall_arrayref};
scripts/import/ImportUtils.pm:  $sth->finish;
scripts/import/ImportUtils.pm:  $sth = $db->prepare($stmt);
scripts/import/ImportUtils.pm:  $sth->execute;
scripts/import/ImportUtils.pm:  my @target_cols = map {$_->[0]} @{$sth->fetchall_arrayref};
scripts/import/ImportUtils.pm:  $sth->finish;
scripts/import/ImportUtils.pm:  $db->do($stmt);
scripts/import/ImportUtils.pm:  $db->do($stmt);
scripts/import/ImportUtils.pm:  $sth = $db->prepare("SELECT COUNT(*) FROM $target_table");
scripts/import/ImportUtils.pm:  $sth->execute();
scripts/import/ImportUtils.pm:  my $old_count = $sth->fetchall_arrayref()->[0]->[0];
scripts/import/ImportUtils.pm:  $sth->finish();
scripts/import/ImportUtils.pm:  $sth = $db->prepare("SELECT COUNT(*) FROM $tmp_table");
scripts/import/ImportUtils.pm:  $sth->execute();
scripts/import/ImportUtils.pm:  my $new_count = $sth->fetchall_arrayref()->[0]->[0];
scripts/import/ImportUtils.pm:  $sth->finish();
scripts/import/ImportUtils.pm:  $db->do(qq{DROP TABLE $target_table});
scripts/import/ImportUtils.pm:  $db->do(qq{RENAME TABLE $tmp_table TO $target_table});
scripts/import/import_ontology_xref.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_ontology_xref.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_ontology_xref.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_ontology_xref.pl:$reg->no_version_check(); 
scripts/import/import_ontology_xref.pl:$reg->load_all($registry_file);
scripts/import/import_ontology_xref.pl:my $pheno_adaptor  = $reg->get_adaptor('homo_sapiens', 'variation', 'phenotype');
scripts/import/import_ontology_xref.pl:my $phenof_adaptor = $reg->get_adaptor('homo_sapiens', 'variation', 'phenotypefeature');
scripts/import/import_ontology_xref.pl:my $study_adaptor  = $reg->get_adaptor('homo_sapiens', 'variation', 'study'); 
scripts/import/import_ontology_xref.pl:my $http = HTTP::Tiny->new();
scripts/import/import_ontology_xref.pl:  my $response = $http->get($request, {
scripts/import/import_ontology_xref.pl:        headers => { 'Content-type' => 'application/xml' }
scripts/import/import_ontology_xref.pl:  unless ($response->{success}){
scripts/import/import_ontology_xref.pl:   my $data =  JSON->new->decode($response->{content} );
scripts/import/import_ontology_xref.pl:  foreach my $term (@{$data->{_embedded}->{terms} }){
scripts/import/import_ontology_xref.pl:    foreach my $xref(@{ $term->{annotation}->{hasDbXref}}){
scripts/import/import_ontology_xref.pl:      push @links, [ $term->{obo_id}, $xref ] if $xref =~/OMIM/;;
scripts/import/import_ontology_xref.pl:  my $next = $data->{_links}->{next}->{href} if defined $data->{_links}->{next};
scripts/import/import_ontology_xref.pl:  my $pheno_adaptor  = $reg->get_adaptor('homo_sapiens', 'variation', 'phenotype');
scripts/import/import_ontology_xref.pl:  my $phenof_adaptor = $reg->get_adaptor('homo_sapiens', 'variation', 'phenotypefeature');
scripts/import/import_ontology_xref.pl:  my $study_adaptor  = $reg->get_adaptor('homo_sapiens', 'variation', 'study'); 
scripts/import/import_ontology_xref.pl:    my $study = $study_adaptor->fetch_all_by_external_reference($omim);
scripts/import/import_ontology_xref.pl:    next unless defined $study->[0];
scripts/import/import_ontology_xref.pl:    if (defined $study->[1]){
scripts/import/import_ontology_xref.pl:    my $feats = $phenof_adaptor->fetch_all_by_Study($study->[0]);
scripts/import/import_ontology_xref.pl:    next unless $feats->[0];
scripts/import/import_ontology_xref.pl:      $phen{$feat->phenotype()->description()} =1;
scripts/import/import_ontology_xref.pl:      warn "Skipping - 2 pheno for $omim\n";
scripts/import/import_ontology_xref.pl:    my $omim_pheno = $feats->[0]->phenotype();
scripts/import/import_ontology_xref.pl:    $omim_pheno->add_ontology_accession( {accession      => $orphanet, 
scripts/import/import_ontology_xref.pl:    $pheno_adaptor->store_ontology_accessions($omim_pheno);
scripts/import/import_ontology_xref.pl:       $pheno = $pheno_adaptor->fetch_by_description($desc);
scripts/import/import_ontology_xref.pl:    next unless $pheno->[0];  ## we don't expect to hold them all
scripts/import/import_ontology_xref.pl:    print "$desc\t" . join(",",@{$phenos->{$desc}}) ."\t" . $pheno->[0]->description() . "\n";
scripts/import/import_ontology_xref.pl:    foreach my $acc(@{$phenos->{$desc}}){
scripts/import/import_ontology_xref.pl:      $pheno->[0]->add_ontology_accession( {accession      => $acc, 
scripts/import/import_ontology_xref.pl:    $pheno_adaptor->store_ontology_accessions($pheno->[0]);
scripts/import/import_ontology_xref.pl:  die "\n\n\timport_ontology_xref.pl -registry [registry file] -type [ Orphanet or HP]
scripts/import/import_ontology_xref.pl:                   -data_file [annotations file] required for HP\n\n";
scripts/import/load_mapping2vf.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/load_mapping2vf.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/load_mapping2vf.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/load_mapping2vf.pl:  usage('-mapping_file argument is required.') if(!$mapping_file);
scripts/import/load_mapping2vf.pl:  Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/load_mapping2vf.pl:  my $cdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/load_mapping2vf.pl:  my $vdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/load_mapping2vf.pl:  $dbCore = $cdb->dbc;
scripts/import/load_mapping2vf.pl:  $dbVar = $vdb->dbc;
scripts/import/load_mapping2vf.pl:  my $sth = $dbVar->prepare (qq{SELECT v.variation_id, v.name, v.source_id, f.allele_string, v.validation_status 
scripts/import/load_mapping2vf.pl:  $sth->execute();
scripts/import/load_mapping2vf.pl:  while(my ($variation_id, $name, $source_id, $allele_string, $validation_status) = $sth->fetchrow_array()) {
scripts/import/load_mapping2vf.pl:    $h->{name} = $name;
scripts/import/load_mapping2vf.pl:    $h->{variation_id} = $variation_id;
scripts/import/load_mapping2vf.pl:    $h->{source_id} = $source_id;
scripts/import/load_mapping2vf.pl:    $h->{allele_string} = defined $allele_string ?  $allele_string : '\N';
scripts/import/load_mapping2vf.pl:    $h->{validation} = defined $validation_status ? $validation_status : '\N';
scripts/import/load_mapping2vf.pl:  $sth->finish();
scripts/import/load_mapping2vf.pl:      $strand = ($strand eq "+") ? 1 : -1;
scripts/import/load_mapping2vf.pl:      ($seq_region_name,$seq_region_start,$seq_region_end) = split /\-/, $slice_name
scripts/import/load_mapping2vf.pl:	if $slice_name =~ /\-/;
scripts/import/load_mapping2vf.pl:	$sth = $dbCore->prepare (qq{SELECT seq_region_id from seq_region where name = ?});
scripts/import/load_mapping2vf.pl:	$sth->execute("$seq_region_name");
scripts/import/load_mapping2vf.pl:	my $seq_region_id = $sth->fetchrow_array();
scripts/import/load_mapping2vf.pl:      my $new_seq_region_start = $seq_region_start + $start -1 if ($seq_region_start);
scripts/import/load_mapping2vf.pl:      my $new_seq_region_end = $seq_region_start + $end -1 if ($seq_region_start);
scripts/import/load_mapping2vf.pl:				print FH join ("\t", $seq_region_id,$new_seq_region_start,$new_seq_region_end,$strand,$rec{$ref_id}->{variation_id},$ref_id,$rec{$ref_id}->{allele_string},$rec{$ref_id}->{source_id},$rec{$ref_id}->{validation})."\n";
scripts/import/load_mapping2vf.pl:  $sth->finish();
scripts/import/load_mapping2vf.pl:  $dbVar->do(qq{CREATE TABLE IF NOT EXISTS variation_feature_mapping_MT LIKE variation_feature});
scripts/import/load_mapping2vf.pl:###./load_mapping2vf.pl -cdbname danio_rerio_core_24_4 -vdbname yuan_zfish_snp -alldiff /ecs2/scratch4/yuan/zfish/ds_chNotOndir/ALL_DIFF -vpass xxxx
scripts/import/vcf2ld.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/vcf2ld.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/vcf2ld.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/vcf2ld.pl:if(defined($config->{input})) {
scripts/import/vcf2ld.pl:	die("ERROR: Could not find input file ", $config->{input}, "\n") unless -e $config->{input};
scripts/import/vcf2ld.pl:	if($config->{input} =~ /\.gz$/){
scripts/import/vcf2ld.pl:		$in_file_handle->open("zcat ". $config->{input} . " | " ) or die("ERROR: Could not read from input file ", $config->{input_file}, "\n");
scripts/import/vcf2ld.pl:		$in_file_handle->open( $config->{input} ) or die("ERROR: Could not read from input file ", $config->{input}, "\n");
scripts/import/vcf2ld.pl:# no file specified - try to read data off command line
scripts/import/vcf2ld.pl:if(defined($config->{samples})) {
scripts/import/vcf2ld.pl:	open IN, $config->{samples} or die("ERROR: Could not open samples file ".$config->{samples}."\n");
scripts/import/vcf2ld.pl:	$data->{line} = $_;
scripts/import/vcf2ld.pl:		$data->{$_} = $split[$headers{$_}] for keys %headers;
scripts/import/vcf2ld.pl:		next if $data->{ALT} =~ /\,/;
scripts/import/vcf2ld.pl:		next unless $data->{ID} =~ /rs/;
scripts/import/vcf2ld.pl:			$data->{'#CHROM'},
scripts/import/vcf2ld.pl:			$data->{POS},
scripts/import/vcf2ld.pl:			$data->{POS},
scripts/import/vcf2ld.pl:		for(my $i = $config->{first_sample_col}; $i <= $#split; $i++) {
scripts/import/vcf2ld.pl:			my $sample_id = $config->{individuals}->[$i - $config->{first_sample_col}];
scripts/import/vcf2ld.pl:		$config->{first_sample_col} = $headers{FORMAT} + 1;
scripts/import/vcf2ld.pl:		splice(@split, 0, $config->{first_sample_col});
scripts/import/vcf2ld.pl:		$config->{individuals} = \@split;
scripts/import/create_dbSNP.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/create_dbSNP.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/create_dbSNP.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/create_dbSNP.pl:    my $ftp = Net::FTP->new("ftp.ncbi.nih.gov", Debug => 0 )|| die "Cannot connect to ftp.ncbi.nih.gov: $@";    
scripts/import/create_dbSNP.pl:    $ftp->login("anonymous",'-anonymous@') || die "Cannot login ", $ftp->message; 
scripts/import/create_dbSNP.pl:    $ftp->cwd("snp/organisms/$db/database/organism\_data")  || die "Cannot change working directory ", $ftp->message;
scripts/import/create_dbSNP.pl:    $ftp->binary(); 
scripts/import/create_dbSNP.pl:	    $ftp->get( "$file\.bcp.gz" ) || die " Failed to download file :$file\.bcp.gz\n" ;
scripts/import/create_dbSNP.pl:	    #print $ftp->message() . "\n";
scripts/import/create_dbSNP.pl:	    $ftp->get( "$file\.bcp.gz.md5" );
scripts/import/create_dbSNP.pl:	    #print $ftp->message() . "\n";
scripts/import/create_dbSNP.pl:    $ftp->cwd("../organism_schema")  || die "Cannot change working directory ", $ftp->message;
scripts/import/create_dbSNP.pl:    my $sql_file_list = $ftp->ls();
scripts/import/create_dbSNP.pl:    die "No ddl\n" unless defined $sql_file_list->[0];
scripts/import/create_dbSNP.pl:        $ftp->get( $file ); 
scripts/import/create_dbSNP.pl:    my $ftp = Net::FTP->new("ftp.ncbi.nih.gov", Debug => 0 )|| die "Cannot connect to ftp.ncbi.nih.gov: $@";    
scripts/import/create_dbSNP.pl:    $ftp->login("anonymous",'-anonymous@') || die "Cannot login ", $ftp->message; 
scripts/import/create_dbSNP.pl:    $ftp->cwd("snp/database/shared_data")  || die "Cannot change working directory ", $ftp->message;
scripts/import/create_dbSNP.pl:    $ftp->binary(); 
scripts/import/create_dbSNP.pl:        $ftp->get( "$file\.bcp.gz" ) || die " Failed to download file :$file\.bcp.gz\n" ;
scripts/import/create_dbSNP.pl:        #print $ftp->message() . "\n";
scripts/import/create_dbSNP.pl:        $ftp->get( "$file\.bcp.gz.md5" );
scripts/import/create_dbSNP.pl:        #print $ftp->message() . "\n";
scripts/import/create_dbSNP.pl:    $ftp->cwd("../shared_schema")  || die "Cannot change working directory ", $ftp->message;
scripts/import/create_dbSNP.pl:    my $sql_file_list = $ftp->ls();
scripts/import/create_dbSNP.pl:    die "No ddl\n" unless defined $sql_file_list->[0];
scripts/import/create_dbSNP.pl:        $ftp->get( $file ); 
scripts/import/create_dbSNP.pl:        ## extract supplied md5 - weird format
scripts/import/create_dbSNP.pl:            warn "Error - $file\tsupplied : $md5_dbSNP, found: $md5_output\n";
scripts/import/create_dbSNP.pl:        open my $in, "gunzip -c $table\.bcp.gz | "||die "Failed to open $table\.bcp.gz for reformatting : $!\n";
scripts/import/create_dbSNP.pl:                if($a =~/\w+|\-|\+|\?|\./ && $a =~/\n/){ print $out $a;}
scripts/import/create_dbSNP.pl:                elsif( $a =~/\w+|\-|\+|\?|\./)         { print $out "$a\t";}
scripts/import/create_dbSNP.pl:        open my $in, "gunzip -c $file |" || die "Failed to open $file to read: $!\n";
scripts/import/create_dbSNP.pl:            `mysql -h$host -uensadmin -p$pass -D $db_name < $ddl_file`
scripts/import/create_dbSNP.pl:        `mysql -h$host -uensadmin -p$pass -D $db_name -e "load data local infile '$dir/$table\_new.bcp' into table $table"` ;
scripts/import/create_dbSNP.pl:            `mysql -h$host -uensadmin -p$pass -D $db_name < $ddl_file`;
scripts/import/create_dbSNP.pl:    my $dbh = DBI->connect("dbi:mysql:$db_name:$host\:3306", 'ensadmin', $pass, undef);
scripts/import/create_dbSNP.pl:	my $pk_available = "-";
scripts/import/create_dbSNP.pl:   my $row_count_ext_sth  = $dbh->prepare(qq[ select count(*) from $table_name]);
scripts/import/create_dbSNP.pl:   $row_count_ext_sth->execute();
scripts/import/create_dbSNP.pl:   my $total_rows = $row_count_ext_sth->fetchall_arrayref();
scripts/import/create_dbSNP.pl:   return $total_rows->[0]->[0]; 
scripts/import/create_dbSNP.pl:   my $key_ext_sth  = $dbh->prepare(qq[ show indexes from $table_name where Key_name ='PRIMARY']);
scripts/import/create_dbSNP.pl:   $key_ext_sth->execute();
scripts/import/create_dbSNP.pl:   my $key = $key_ext_sth->fetchall_arrayref();
scripts/import/create_dbSNP.pl:   $found = 1 if defined $key->[0]->[0];
scripts/import/create_dbSNP.pl:    die  "\n\tUsage: create_dbSNP.pl -db [zebrafish_7955] -build [138]
scripts/import/create_dbSNP.pl:\tFor local database creation -pass [admin password]  -host [db server]  -db_name [name for empty mirror database]
scripts/import/create_dbSNP.pl:\tTo skip data file download/reformatting and only create the local database use -db_load_only\n\n";
scripts/import/convert_personal_genomes_to_vcf.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/convert_personal_genomes_to_vcf.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/convert_personal_genomes_to_vcf.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/convert_personal_genomes_to_vcf.pl:if(defined($config->{help})) {
scripts/import/convert_personal_genomes_to_vcf.pl:$config->{sample} ||= 'DEFAULT_SAMPLE_NAME';
scripts/import/convert_personal_genomes_to_vcf.pl:if(defined($config->{input})) {
scripts/import/convert_personal_genomes_to_vcf.pl:	die("ERROR: Could not find input file ", $config->{input}, "\n") unless -e $config->{input};
scripts/import/convert_personal_genomes_to_vcf.pl:	if($config->{input} =~ /\.gz$/){
scripts/import/convert_personal_genomes_to_vcf.pl:		$in_file_handle->open("zcat ". $config->{input} . " | " ) or die("ERROR: Could not read from input file ", $config->{input}, "\n");
scripts/import/convert_personal_genomes_to_vcf.pl:		$in_file_handle->open( $config->{input} ) or die("ERROR: Could not read from input file ", $config->{input}, "\n");
scripts/import/convert_personal_genomes_to_vcf.pl:	$config->{sample}."\n"
scripts/import/parse_hapmap_genotye.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/parse_hapmap_genotye.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/parse_hapmap_genotye.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/parse_hapmap_genotye.pl:  usage('-cdbname argument is required.') if(!$cdbname);
scripts/import/parse_hapmap_genotye.pl:  usage('-vdbname argument is required.') if(!$vdbname);
scripts/import/parse_hapmap_genotye.pl:  usage('-genotypefile argument is required.') if(!$genotype_file);
scripts/import/parse_hapmap_genotye.pl:  usage('-vpass argument is required.') if(!$vpass);
scripts/import/parse_hapmap_genotye.pl:  $dbVar = DBH->connect
scripts/import/parse_hapmap_genotye.pl:  $dbCore = Bio::EnsEMBL::DBSQL::DBConnection->new
scripts/import/parse_hapmap_genotye.pl:    (-host   => $chost,
scripts/import/parse_hapmap_genotye.pl:     -user   => $cuser,
scripts/import/parse_hapmap_genotye.pl:     -pass   => $cpass,
scripts/import/parse_hapmap_genotye.pl:     -port   => $cport,
scripts/import/parse_hapmap_genotye.pl:     -dbname => $cdbname);
scripts/import/parse_hapmap_genotye.pl:    $population_name = "Yoruba-30-trios";
scripts/import/parse_hapmap_genotye.pl:    $population_name = "CEPH-30-trios";
scripts/import/parse_hapmap_genotye.pl:    open GENO, "gunzip -c $genotype_file |" or debug"can't open file $genotype_file: $!\n";
scripts/import/parse_hapmap_genotye.pl:  my $sth = $dbVar->prepare (qq{SELECT variation_id, name
scripts/import/parse_hapmap_genotye.pl:  $sth->execute();
scripts/import/parse_hapmap_genotye.pl:  while(my ($variation_id, $name) = $sth->fetchrow_array()) {
scripts/import/parse_hapmap_genotye.pl:  my $desc = $pop_desc{$name}->{'desc'};
scripts/import/parse_hapmap_genotye.pl:  my $super_pop_id = $pop_desc{$name}->{'super_pop_id'};
scripts/import/parse_hapmap_genotye.pl:  my $sth = $dbVar->prepare (qq{SELECT population_id from population where name = ?;});
scripts/import/parse_hapmap_genotye.pl:  $sth->execute("$name");
scripts/import/parse_hapmap_genotye.pl:  my ($sub_pop_id) = $sth->fetchrow_array;
scripts/import/parse_hapmap_genotye.pl:    $dbVar->do(qq{INSERT INTO population (name,description) values ("$name","$desc")
scripts/import/parse_hapmap_genotye.pl:    $sub_pop_id = $dbVar->dbh()->{'mysql_insertid'};
scripts/import/parse_hapmap_genotye.pl:    $dbVar->do(qq{INSERT INTO population_structure (super_population_id, sub_population_id)
scripts/import/parse_hapmap_genotye.pl:  my $sth = $dbVar->prepare (qq{SELECT individual_id, name
scripts/import/parse_hapmap_genotye.pl:  $sth->execute();
scripts/import/parse_hapmap_genotye.pl:  while(my ($ind_id, $name) = $sth->fetchrow_array()) {
scripts/import/parse_hapmap_genotye.pl:  my $sth = $dbVar->prepare (qq{SELECT individual_id, name
scripts/import/parse_hapmap_genotye.pl:  $sth->execute();
scripts/import/parse_hapmap_genotye.pl:  while(my ($ind_id, $name) = $sth->fetchrow_array()) {
scripts/import/parse_hapmap_genotye.pl:    -chost <hostname>    hostname of core Ensembl MySQL database (default = ecs2)
scripts/import/parse_hapmap_genotye.pl:    -cuser <user>        username of core Ensembl MySQL database (default = ensro)
scripts/import/parse_hapmap_genotye.pl:    -cpass <pass>        password of core Ensembl MySQL database
scripts/import/parse_hapmap_genotye.pl:    -cport <port>        TCP port of core Ensembl MySQL database (default = 3364)
scripts/import/parse_hapmap_genotye.pl:    -cdbname <dbname>    dbname of core Ensembl MySQL database
scripts/import/parse_hapmap_genotye.pl:    -vhost <hostname>    hostname of variation MySQL database to write to
scripts/import/parse_hapmap_genotye.pl:    -vuser <user>        username of variation MySQL database to write to (default = ensadmin)
scripts/import/parse_hapmap_genotye.pl:    -vpass <pass>        password of variation MySQL database to write to
scripts/import/parse_hapmap_genotye.pl:    -vport <port>        TCP port of variation MySQL database to write to (default = 3306)
scripts/import/parse_hapmap_genotye.pl:    -vdbname <dbname>    dbname of variation MySQL database to write to
scripts/import/parse_hapmap_genotye.pl:    -limit <number>      limit the number of rows for testing
scripts/import/parse_hapmap_genotye.pl:    -tmpdir <dir>        temp directory to use (with lots of space!)
scripts/import/parse_hapmap_genotye.pl:    -tmpfile <filename>   name of temp file to use
scripts/import/parse_hapmap_genotye.pl:    -num_processes <number> number of processes that are running (default = 1)
scripts/import/parse_hapmap_genotye.pl:    -status_file <filename> name of a temp file where all the processes write when they finish
scripts/import/import_vcf_compress.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_vcf_compress.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_vcf_compress.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_vcf_compress.pl:import_vcf_compress.pl - imports genotypes directly into
scripts/import/import_vcf_compress.pl:use constant MAX_SHORT => 2**16 -1;
scripts/import/import_vcf_compress.pl:# get command-line options
scripts/import/import_vcf_compress.pl:	$reg->load_all($registry_file);
scripts/import/import_vcf_compress.pl:		$reg->load_registry_from_db(-host => $host,-user => $user, -pass => $password);
scripts/import/import_vcf_compress.pl:		$reg->load_registry_from_db(-host => $host,-user => $user);
scripts/import/import_vcf_compress.pl:	die("ERROR: Could not find input file ", $in_file, "\n") unless -e $in_file;
scripts/import/import_vcf_compress.pl:	$in_file_handle->open($in_file) or die("ERROR: Could not read from input file ", $in_file, "\n");
scripts/import/import_vcf_compress.pl:# no file specified - try to read data off command line
scripts/import/import_vcf_compress.pl:my $vdba = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation')
scripts/import/import_vcf_compress.pl:my $dbVar = $vdba->dbc->db_handle;
scripts/import/import_vcf_compress.pl:my $sth = $dbVar->prepare(qq{SELECT seq_region_id, name FROM seq_region});
scripts/import/import_vcf_compress.pl:$sth->execute;
scripts/import/import_vcf_compress.pl:$sth->bind_columns(\$seq_region_id, \$chr_name);
scripts/import/import_vcf_compress.pl:$seq_region_ids{$chr_name} = $seq_region_id while $sth->fetch;
scripts/import/import_vcf_compress.pl:$sth = $dbVar->prepare(qq{select sample_id from sample where name = ?});
scripts/import/import_vcf_compress.pl:$sth->execute($population);
scripts/import/import_vcf_compress.pl:$sth->bind_columns(\$pop_id);
scripts/import/import_vcf_compress.pl:$sth->fetch;
scripts/import/import_vcf_compress.pl:	$sth = $dbVar->prepare(qq{insert into sample(name) values(?)});
scripts/import/import_vcf_compress.pl:	$sth->execute($population);
scripts/import/import_vcf_compress.pl:	$pop_id = $dbVar->last_insert_id(undef, undef, qw(sample sample_id));
scripts/import/import_vcf_compress.pl:	$sth = $dbVar->prepare(qq{insert ignore into population(sample_id) values(?)});
scripts/import/import_vcf_compress.pl:	$sth->execute($pop_id);
scripts/import/import_vcf_compress.pl:$sth = $dbVar->do(qq{
scripts/import/import_vcf_compress.pl:	# populate sample-type tables
scripts/import/import_vcf_compress.pl:	$sth = $dbVar->prepare(qq{INSERT INTO sample(name) VALUES(?)});
scripts/import/import_vcf_compress.pl:	my $sth2 = $dbVar->prepare(qq{INSERT INTO individual_population(population_sample_id, individual_sample_id) VALUES(?,?)});
scripts/import/import_vcf_compress.pl:	my $sth3 = $dbVar->prepare(qq{INSERT INTO individual(sample_id, individual_type_id) VALUES(?,?)});
scripts/import/import_vcf_compress.pl:	my $sth4 = $dbVar->prepare(qq{select sample_id from sample where name = ?});
scripts/import/import_vcf_compress.pl:		$sth4->execute($sample_name);
scripts/import/import_vcf_compress.pl:		$sth4->bind_columns(\$sample_id);
scripts/import/import_vcf_compress.pl:		$sth4->fetch;
scripts/import/import_vcf_compress.pl:			$sth->execute($sample_name);
scripts/import/import_vcf_compress.pl:			$sample_id = $dbVar->last_insert_id(undef, undef, qw(sample sample_id));
scripts/import/import_vcf_compress.pl:			$sth2->execute($pop_id, $sample_id);
scripts/import/import_vcf_compress.pl:			$sth3->execute($sample_id, 3);
scripts/import/import_vcf_compress.pl:	# skip non-variant lines
scripts/import/import_vcf_compress.pl:	# work out if this is an indel or multi-bp
scripts/import/import_vcf_compress.pl:			$end += $num_deleted - 1;
scripts/import/import_vcf_compress.pl:			$data{ALT} = "-";
scripts/import/import_vcf_compress.pl:			$data{REF} = '-';
scripts/import/import_vcf_compress.pl:		my $sample_id = $sample_ids[$i-$first_sample_col];
scripts/import/import_vcf_compress.pl:			if (!defined $genotypes->{$sample_id}->{region_start}){
scripts/import/import_vcf_compress.pl:				$genotypes->{$sample_id}->{region_start} = $start;
scripts/import/import_vcf_compress.pl:				$genotypes->{$sample_id}->{region_end} = $end;
scripts/import/import_vcf_compress.pl:				(abs($genotypes->{$sample_id}->{region_start} - $start) > DISTANCE()) ||
scripts/import/import_vcf_compress.pl:				(abs($start - $genotypes->{$sample_id}->{region_end}) > MAX_SHORT) ||
scripts/import/import_vcf_compress.pl:				delete $genotypes->{$sample_id}; #and remove the printed entry
scripts/import/import_vcf_compress.pl:				$genotypes->{$sample_id}->{region_start} = $start;
scripts/import/import_vcf_compress.pl:			if ($start != $genotypes->{$sample_id}->{region_start}){
scripts/import/import_vcf_compress.pl:				my $blob = pack ("n",$start - $genotypes->{$sample_id}->{region_end} - 1);
scripts/import/import_vcf_compress.pl:				$genotypes->{$sample_id}->{genotypes} .= &escape($blob).($bits[0] || '-').($bits[1] || '0');
scripts/import/import_vcf_compress.pl:				$genotypes->{$sample_id}->{genotypes} = ($bits[0] || '-').($bits[1] || '0');
scripts/import/import_vcf_compress.pl:			$genotypes->{$sample_id}->{region_end} = $start;
scripts/import/import_vcf_compress.pl:		$sth = $dbVar->prepare(qq{INSERT INTO individual_genotype_multiple_bp_named(name, allele_1, allele_2, sample_id) values$vals});
scripts/import/import_vcf_compress.pl:		$sth->execute;
scripts/import/import_vcf_compress.pl:$dbVar->do(qq{DELETE FROM individual_genotype_multiple_bp_named WHERE allele_1 = '.' AND allele_2 = '.';});
scripts/import/import_vcf_compress.pl:print "Took ", time() - $start_time, " to run\n";
scripts/import/import_vcf_compress.pl:-h | --help           Display this message and quit
scripts/import/import_vcf_compress.pl:-i | --input_file     Input file - if not specified, reads from STDIN
scripts/import/import_vcf_compress.pl:--species             Species to use [default: "human"]
scripts/import/import_vcf_compress.pl:--population          Name of population [required]
scripts/import/import_vcf_compress.pl:--skip_multi          Do not import multi bp or indel genotypes
scripts/import/import_vcf_compress.pl:--gp                  Use the GP info tag to extract location information
scripts/import/import_vcf_compress.pl:--prefix              String to add as a prefix to sample names
scripts/import/import_vcf_compress.pl:-d | --db_host        Manually define database host [default: "ensembldb.ensembl.org"]
scripts/import/import_vcf_compress.pl:-u | --user           Database username [default: "anonymous"]
scripts/import/import_vcf_compress.pl:--password            Database password [default: not used]
scripts/import/import_vcf_compress.pl:-r | --registry_file  Registry file to use defines DB connections [default: not used]
scripts/import/import_vcf_compress.pl:	$id ||= '-';
scripts/import/import_vcf_compress.pl:	$id ||= '-';
scripts/import/import_vcf_compress.pl:				$genotypes->{$sample_id}->{region_start},
scripts/import/import_vcf_compress.pl:				$genotypes->{$sample_id}->{region_end},
scripts/import/import_vcf_compress.pl:				$genotypes->{$sample_id}->{genotypes}) . "\n";
scripts/import/import_vcf_compress.pl:			$genotypes->{$sample_id}->{region_start},
scripts/import/import_vcf_compress.pl:			$genotypes->{$sample_id}->{region_end},
scripts/import/import_vcf_compress.pl:			$genotypes->{$sample_id}->{genotypes}) . "\n";
scripts/import/dbSNP.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dbSNP.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dbSNP.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dbSNP.pl:    push(@opts,('-' . $name,$val));
scripts/import/dbSNP.pl:die("Please provide a current schema definition file for the variation database, use -schema_file option!") unless (-e $SCHEMA_FILE);
scripts/import/dbSNP.pl:# die("You must specify the dbSNP mirror host, port, user, pass, db and build version (-dshost, -dsport, -dsuser, -dspass, and -dbSNP_version options)") unless (defined($dshost) && defined($dsport) && defined($dsuser) && defined($dspass) && defined($dbSNP_BUILD_VERSION));
scripts/import/dbSNP.pl:die("You must specify a temp dir and temp file (-tmpdir and -tmpfile options)") unless(defined($ImportUtils::TMP_DIR) && defined($ImportUtils::TMP_FILE));
scripts/import/dbSNP.pl:die("You must specify the species. Use -species option") 
scripts/import/dbSNP.pl:die("You must specify the dbSNP build. Use -dbSNP_version option") 
scripts/import/dbSNP.pl:die("You must specify the dbSNP shared database. Use -shared_db option") 
scripts/import/dbSNP.pl:die("You must specify the sql driver, either through an environment variable (SYBASE) or the -sql_driver option") unless ((defined($mssql_driver) || defined($ENV{'SYBASE'})) ||  $source_engine =~/mysql|postgreSQL/i);
scripts/import/dbSNP.pl:my $dbm = dbSNP::DBManager->new($registry_file,$species, $schema_name );
scripts/import/dbSNP.pl:$dbm->dbSNP_shared($shared_db);
scripts/import/dbSNP.pl:my $dbCore = $dbm->dbCore();
scripts/import/dbSNP.pl:my ($cs) = @{$dbCore->get_CoordSystemAdaptor->fetch_all};
scripts/import/dbSNP.pl:my $ASSEMBLY_VERSION = $cs->version();
scripts/import/dbSNP.pl:  -DBManager => $dbm,
scripts/import/dbSNP.pl:  -tmpdir => $TMP_DIR,
scripts/import/dbSNP.pl:  -tmpfile => $TMP_FILE,
scripts/import/dbSNP.pl:  -limit => $LIMIT_SQL,
scripts/import/dbSNP.pl:  -mapping_file_dir => $MAPPING_FILE_DIR,
scripts/import/dbSNP.pl:  -dbSNP_version => $dbSNP_version,
scripts/import/dbSNP.pl:  -assembly_version => $ASSEMBLY_VERSION,
scripts/import/dbSNP.pl:  -group_term  => $GROUP_TERM,
scripts/import/dbSNP.pl:  -group_label => $GROUP_LABEL,
scripts/import/dbSNP.pl:  -skip_routines => \@skip_routines,
scripts/import/dbSNP.pl:  -scriptdir => $scriptdir,
scripts/import/dbSNP.pl:  -log => $logh,
scripts/import/dbSNP.pl:  -source_engine => $source_engine,
scripts/import/dbSNP.pl:  -schema_name   => $schema_name
scripts/import/dbSNP.pl:  $import_object = dbSNP::MappingChromosome->new(@parameters);
scripts/import/dbSNP.pl:    $import_object = dbSNP::GenericChromosome->new(@parameters);
scripts/import/dbSNP.pl:  $import_object = dbSNP::GenericContig->new(@parameters);
scripts/import/dbSNP.pl:  $import_object = dbSNP::Mosquito->new(@parameters);
scripts/import/dbSNP.pl:  $import_object = dbSNP::EnsemblIds->new(@parameters);
scripts/import/dbSNP.pl:$import_object->{'schema_file'} = $SCHEMA_FILE;
scripts/import/dbSNP.pl:my $clock = Progress->new();
scripts/import/dbSNP.pl:$clock->checkpoint('start_dump');
scripts/import/dbSNP.pl:$import_object->dump_dbSNP();
scripts/import/dbSNP.pl:$clock->checkpoint('end_dump');
scripts/import/dbSNP.pl:print $logh $clock->duration('start_dump','end_dump');
scripts/import/dbSNP.pl:my $meta_ins_sth = $dbm->dbVar()->dbc->db_handle->prepare(qq[ INSERT ignore INTO meta (species_id, meta_key, meta_value) values (?,?,?)]);
scripts/import/dbSNP.pl:my $meta_upd_sth = $dbm->dbVar()->dbc->db_handle->prepare(qq[ UPDATE meta set meta_value = ? where  meta_key = ?]);
scripts/import/dbSNP.pl:$meta_ins_sth->execute('1', 'species.production_name', $dbm->dbVar()->species() ) ||die;
scripts/import/dbSNP.pl:$meta_ins_sth->execute('1', 'ploidy', $ploidy ) ||die;
scripts/import/dbSNP.pl:    $meta_upd_sth->execute($ens_version, 'schema_version' ) ||die;
scripts/import/dbSNP.pl:my $dbSNP_name = $dbm->dbSNP()->dbc->dbname();
scripts/import/dbSNP.pl:$data{species}          = $dbm->dbVar()->species();
scripts/import/dbSNP.pl:$data{ensdb_name}       = $dbm->dbVar()->dbc->dbname();
scripts/import/dbSNP.pl:$data{registry}         = $dbm->registry();
scripts/import/dbSNP.pl:      -dshost <hostname>          hostname of dbSNP MSSQL database (default = dbsnp)
scripts/import/dbSNP.pl:      -dsuser <user>              username of dbSNP MSSQL database (default = dbsnpro)
scripts/import/dbSNP.pl:      -dspass <pass>              password of dbSNP MSSQL database
scripts/import/dbSNP.pl:      -dsport <port>              TCP port of dbSNP MSSQL database (default = 1026)
scripts/import/dbSNP.pl:      -dsdbname <dbname>          dbname of dbSNP MySQL database   (default = dbSNP_121)
scripts/import/dbSNP.pl:      -chost <hostname>           hostname of core Ensembl MySQL database (default = ecs2)
scripts/import/dbSNP.pl:      -cuser <user>               username of core Ensembl MySQL database (default = ensro)
scripts/import/dbSNP.pl:      -cpass <pass>               password of core Ensembl MySQL database
scripts/import/dbSNP.pl:      -cport <port>               TCP port of core Ensembl MySQL database (default = 3364)
scripts/import/dbSNP.pl:      -cdbname <dbname>           dbname of core Ensembl MySQL database
scripts/import/dbSNP.pl:      -vhost <hostname>           hostname of variation MySQL database to write to
scripts/import/dbSNP.pl:      -vuser <user>               username of variation MySQL database to write to (default = ensadmin)
scripts/import/dbSNP.pl:      -vpass <pass>               password of variation MySQL database to write to
scripts/import/dbSNP.pl:      -vport <port>               TCP port of variation MySQL database to write to (default = 3306)
scripts/import/dbSNP.pl:      -vdbname <dbname>           dbname of variation MySQL database to write to
scripts/import/dbSNP.pl:      -limit <number>             limit the number of rows transfered for testing
scripts/import/dbSNP.pl:      -tmpdir <dir>               temporary directory to use (with lots of space!)
scripts/import/dbSNP.pl:      -tmpfile <filename>         temporary filename to use
scripts/import/dbSNP.pl:      -mapping_file <filename>    file containing the mapping data
scripts/import/dbSNP.pl:      -group_term <group_term>    select the group_term to import
scripts/import/dbSNP.pl:      -group_label <group_label>  select the group_label to import
scripts/import/fetch_base_qual_new.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/fetch_base_qual_new.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/fetch_base_qual_new.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/fetch_base_qual_new.pl:#example: ./fetch_base_qual.pl -i [index_file] -r [reads_file] 19866807248411 -1 11
scripts/import/fetch_base_qual_new.pl:    my $fastq_index = Bio::Index::Fastq->new(-filename => $index_file);
scripts/import/fetch_base_qual_new.pl:    my $seq = $fastq_index->fetch($query_name);
scripts/import/fetch_base_qual_new.pl:  $start = $snp_pos-5;
scripts/import/fetch_base_qual_new.pl:  $start = 1 if $snp_pos -5 <= 0;
scripts/import/fetch_base_qual_new.pl:  $snp_base = substr($seq,$snp_pos-1,1);
scripts/import/fetch_base_qual_new.pl:  my $flanking_bases = substr($seq,$start-1,11);
scripts/import/fetch_base_qual_new.pl:  $snp_qual = substr($qual,$snp_pos-1,1);
scripts/import/fetch_base_qual_new.pl:  $qual_5 = substr($qual,$start-1,5);
scripts/import/fetch_base_qual_new.pl:  if ($query_strand ==-1) {
scripts/import/fetch_base_qual_new.pl:  my $flanking_quals = substr($qual,$start-1,11);
scripts/import/fetch_base_qual_new.pl:  @flanking_quals = map{unpack("C",$_)-33} @flanking_quals;
scripts/import/fetch_base_qual_new.pl:  if ($query_strand==-1) {
scripts/import/fetch_base_qual_new.pl:  @qual_5 = map{unpack("C",$_)-33} @qual_5;
scripts/import/fetch_base_qual_new.pl:  @qual_3 = map{unpack("C",$_)-33} @qual_3;
scripts/import/fetch_base_qual_new.pl:  $snp_qual = unpack("C",$snp_qual)-33;
scripts/import/fetch_base_qual_new.pl:  my $len = $seqobj->length;
scripts/import/fetch_base_qual_new.pl:  print $seqobj->seq,"\n";
scripts/import/fetch_base_qual_new.pl:  print @{$seqobj->qual},"\n";
scripts/import/fetch_base_qual_new.pl:  print "old_base ",substr($seqobj->seq,$snp_pos-6,11),"\n";
scripts/import/fetch_base_qual_new.pl:  print "old_qual ",@{$seqobj->subqual($snp_pos-5,$snp_pos+5)},"\n";
scripts/import/fetch_base_qual_new.pl:  $start = $snp_pos-5;
scripts/import/fetch_base_qual_new.pl:  $start = 1 if $snp_pos -5 < 0;
scripts/import/fetch_base_qual_new.pl:  $seqstr = $seqobj->baseat($snp_pos);
scripts/import/fetch_base_qual_new.pl:  $snp_qual = $seqobj->qualat($snp_pos);
scripts/import/fetch_base_qual_new.pl:  $qual_5 = $seqobj->subqual($start,$snp_pos-1);
scripts/import/fetch_base_qual_new.pl:  $qual_3 = $seqobj->subqual($snp_pos+1,$end);
scripts/import/fetch_base_qual_new.pl:  if ($query_strand ==-1) {
scripts/import/compress_genotypes_by_seq_region.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/compress_genotypes_by_seq_region.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/compress_genotypes_by_seq_region.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/compress_genotypes_by_seq_region.pl:use constant MAX_SHORT => 2**16 -1;
scripts/import/compress_genotypes_by_seq_region.pl:usage('-TMP_DIR argument is required') if(!$TMP_DIR);
scripts/import/compress_genotypes_by_seq_region.pl:usage('-TMP_FILE argument is required') if(!$TMP_FILE);
scripts/import/compress_genotypes_by_seq_region.pl:usage('-species argument is required') if(!$species);
scripts/import/compress_genotypes_by_seq_region.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/compress_genotypes_by_seq_region.pl:my $vdba = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/compress_genotypes_by_seq_region.pl:my $dbCore = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/compress_genotypes_by_seq_region.pl:my $dbVar = $vdba->dbc->db_handle;
scripts/import/compress_genotypes_by_seq_region.pl:  my $sth = $dbCore->dbc->prepare(qq{SELECT seq_region_id 
scripts/import/compress_genotypes_by_seq_region.pl:  $sth->execute();
scripts/import/compress_genotypes_by_seq_region.pl:  while (my ($seq_region_id) = $sth->fetchrow_array()) {
scripts/import/compress_genotypes_by_seq_region.pl:  my $res_ref = $dbVar->selectall_arrayref(qq{SELECT * FROM $table limit 10});
scripts/import/compress_genotypes_by_seq_region.pl:  my $table_rec = $res_ref->[0][0] ;
scripts/import/compress_genotypes_by_seq_region.pl:    $dbVar->do(qq{TRUNCATE TABLE $table});
scripts/import/compress_genotypes_by_seq_region.pl:    if (! -e "$TMP_DIR/genotype_dump\_$seq_region_id") {
scripts/import/compress_genotypes_by_seq_region.pl:      #system("sort -k 2 -g -o $TMP_DIR/genotype_dump\_$seq_region_id $TMP_DIR/$TMP_FILE");
scripts/import/compress_genotypes_by_seq_region.pl:      next if (defined $genotypes->{$sample_id}->{region_end} && $seq_region_start == $genotypes->{$sample_id}->{region_end}); 
scripts/import/compress_genotypes_by_seq_region.pl:      if (!defined $genotypes->{$sample_id}->{region_start}) {
scripts/import/compress_genotypes_by_seq_region.pl:	$genotypes->{$sample_id}->{region_start} = $seq_region_start;
scripts/import/compress_genotypes_by_seq_region.pl:	$genotypes->{$sample_id}->{region_end} = $seq_region_end;
scripts/import/compress_genotypes_by_seq_region.pl:      if ((abs($genotypes->{$sample_id}->{region_start} - $seq_region_start) > DISTANCE()) || (abs($seq_region_start - $genotypes->{$sample_id}->{region_end}) > MAX_SHORT)) {
scripts/import/compress_genotypes_by_seq_region.pl:	delete $genotypes->{$sample_id}; #and remove the printed entry
scripts/import/compress_genotypes_by_seq_region.pl:	$genotypes->{$sample_id}->{region_start} = $seq_region_start;
scripts/import/compress_genotypes_by_seq_region.pl:      if ($seq_region_start != $genotypes->{$sample_id}->{region_start}) {
scripts/import/compress_genotypes_by_seq_region.pl:	$blob = pack ("n",$seq_region_start - $genotypes->{$sample_id}->{region_end} - 1);
scripts/import/compress_genotypes_by_seq_region.pl:	$genotypes->{$sample_id}->{genotypes} .= escape($blob) . $allele_1 . $allele_2;
scripts/import/compress_genotypes_by_seq_region.pl:	$genotypes->{$sample_id}->{genotypes} = $allele_1 . $allele_2;
scripts/import/compress_genotypes_by_seq_region.pl:      $genotypes->{$sample_id}->{region_end} = $seq_region_start; #to avoid nasty effects of indels coordinates
scripts/import/compress_genotypes_by_seq_region.pl:      my $dbVar_write = $vdba->dbc;
scripts/import/compress_genotypes_by_seq_region.pl:	    print FH join("\t",$sample_id,$seq_region_id, $genotypes->{$sample_id}->{region_start}, $genotypes->{$sample_id}->{region_end}, 1, $genotypes->{$sample_id}->{genotypes}) . "\n";
scripts/import/compress_genotypes_by_seq_region.pl:	print FH join("\t",$sample_id,$seq_region_id, $genotypes->{$sample_id}->{region_start}, $genotypes->{$sample_id}->{region_end}, 1, $genotypes->{$sample_id}->{genotypes}) . "\n";
scripts/import/compress_genotypes_by_seq_region.pl:    my $csa = $dbCore->get_CoordSystemAdaptor();
scripts/import/compress_genotypes_by_seq_region.pl:    my $cs = $csa->fetch_by_name($csname);
scripts/import/compress_genotypes_by_seq_region.pl:    my $sth = $dbVar->prepare
scripts/import/compress_genotypes_by_seq_region.pl:    $sth->execute($table_name, $cs->dbID(),DISTANCE+1);
scripts/import/compress_genotypes_by_seq_region.pl:    $sth->finish();
scripts/import/compress_genotypes_by_seq_region.pl:    if ($seq_region_strand == -1){
scripts/import/compress_genotypes_by_seq_region.pl:    -tmpdir <dir>        temp directory to use (with lots of space!)
scripts/import/compress_genotypes_by_seq_region.pl:    -tmpfile <filename>   name of temp file to use
scripts/import/compress_genotypes_by_seq_region.pl:    -species <species_name> name of the specie you want to compress the genotypes
scripts/import/read_coverage.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/read_coverage.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/read_coverage.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/read_coverage.pl:my $range_registry = []; #reference to an array containing an rr for each of the possible levels (from 1-6)
scripts/import/read_coverage.pl:usage('-vdbname argument is required') if(!$vdbname);
scripts/import/read_coverage.pl:usage('-cdbname argument is required') if(!$cdbname);
scripts/import/read_coverage.pl:usage('-readfile argument is required (name of file with read information)') if (!$read_file);
scripts/import/read_coverage.pl:usage('-maxlevel argument is required (max level coverage calculated)') if (!$max_level);
scripts/import/read_coverage.pl:my $dbCore = Bio::EnsEMBL::DBSQL::DBAdaptor->new
scripts/import/read_coverage.pl:    (-host   => $chost,
scripts/import/read_coverage.pl:     -user   => $cuser,
scripts/import/read_coverage.pl:     -pass   => $cpass,
scripts/import/read_coverage.pl:     -port   => $cport,
scripts/import/read_coverage.pl:     -dbname => $cdbname);
scripts/import/read_coverage.pl:my $dbVar = Bio::EnsEMBL::Variation::DBSQL::DBAdaptor->new
scripts/import/read_coverage.pl:    (-host   => $vhost,
scripts/import/read_coverage.pl:     -user   => $vuser,
scripts/import/read_coverage.pl:     -pass   => $vpass,
scripts/import/read_coverage.pl:     -port   => $vport,
scripts/import/read_coverage.pl:     -dbname => $vdbname
scripts/import/read_coverage.pl:    if ($pair->[0] eq ''){$pair->[0] = 'Unknown'}
scripts/import/read_coverage.pl:my $slice_adaptor = $dbCore->get_SliceAdaptor;
scripts/import/read_coverage.pl:my $slice = $slice_adaptor->fetch_by_region('toplevel',$region);
scripts/import/read_coverage.pl:my $seq_region_id = $slice->get_seq_region_id();
scripts/import/read_coverage.pl:	$range_registry->[$level] = Bio::EnsEMBL::Mapper::RangeRegistry->new();
scripts/import/read_coverage.pl:    my $rr = Bio::EnsEMBL::Mapper::RangeRegistry->new();
scripts/import/read_coverage.pl:	$rr->check_and_register(1,$pair->[0],$pair->[1]);
scripts/import/read_coverage.pl:    return $rr->check_and_register(1,$range->[0],$range->[1]); #register again the range
scripts/import/read_coverage.pl:    $individuals->{$individual_name}++;
scripts/import/read_coverage.pl:    my $rr = $range_registry->[$level];
scripts/import/read_coverage.pl:    my $pair = $rr->check_and_register($individual_name,$range->[0],$range->[1]);
scripts/import/read_coverage.pl:	if ($individual_name ne '' && defined $range_registry->[$coverage_level]->get_ranges($individual_name)){
scripts/import/read_coverage.pl:	    foreach my $range (@{$range_registry->[$coverage_level]->get_ranges($individual_name)}){
scripts/import/read_coverage.pl:		print FH join("\t",$seq_region_id,$range->[0],$range->[1],$coverage_level,$individual_id->{$individual_name}),"\n";
scripts/import/read_coverage.pl:	if ($individual_id->{$individual_name} eq ''){
scripts/import/read_coverage.pl:	    my $individualAdaptor = $dbVar->get_IndividualAdaptor();
scripts/import/read_coverage.pl:	    my $individual = ($individualAdaptor->fetch_all_by_name($individual_name))->[0];
scripts/import/read_coverage.pl:		$dbVar->dbc()->do(qq{INSERT INTO sample (name,description) VALUES ("$individual_name",'Individuals used to get read information')});
scripts/import/read_coverage.pl:		$sample_id = $dbVar->dbc()->db_handle->{'mysql_insertid'}; #get the id inserted
scripts/import/read_coverage.pl:		$dbVar->dbc()->do(qq{INSERT INTO individual (sample_id,gender) VALUES ("$sample_id",'Unknown')});
scripts/import/read_coverage.pl:		my $population_adaptor = $dbVar->get_PopulationAdaptor();
scripts/import/read_coverage.pl:		my $population = $population_adaptor->fetch_by_name('UNKNOWN');
scripts/import/read_coverage.pl:		my $population_id = $population->dbID();
scripts/import/read_coverage.pl:		#insert the relation individual-population
scripts/import/read_coverage.pl:		$dbVar->dbc()->do(qq{INSERT INTO individual_population (individual_sample_id,population_sample_id) VALUES ("$sample_id","$population_id")});
scripts/import/read_coverage.pl:		$sample_id = $individual->dbID();
scripts/import/read_coverage.pl:	    $individual_id->{$individual_name} = $sample_id;
scripts/import/read_coverage.pl:  my $rca = $dbVar->get_ReadCoverageAdaptor();
scripts/import/read_coverage.pl:  my $levels = $rca->get_coverage_levels();
scripts/import/read_coverage.pl:  my $sth = $dbVar->dbc->prepare
scripts/import/read_coverage.pl:	  $sth->execute('read_coverage.coverage_level',$_);
scripts/import/read_coverage.pl:  $sth->finish();
scripts/import/read_coverage.pl:    -chost <hostname>    hostname of core Ensembl MySQL database (default = ecs2)
scripts/import/read_coverage.pl:    -cuser <user>        username of core Ensembl MySQL database (default = ensro)
scripts/import/read_coverage.pl:    -cpass <pass>        password of core Ensembl MySQL database
scripts/import/read_coverage.pl:    -cport <port>        TCP port of core Ensembl MySQL database (default = 3364)
scripts/import/read_coverage.pl:    -cdbname <dbname>    dbname of core Ensembl MySQL database
scripts/import/read_coverage.pl:    -vhost <hostname>    hostname of variation MySQL database to write to
scripts/import/read_coverage.pl:    -vuser <user>        username of variation MySQL database to write to (default = ensadmin)
scripts/import/read_coverage.pl:    -vpass <pass>        password of variation MySQL database to write to
scripts/import/read_coverage.pl:    -vport <port>        TCP port of variation MySQL database to write to (default = 3306)
scripts/import/read_coverage.pl:    -vdbname <dbname>    dbname of variation MySQL database to write to
scripts/import/read_coverage.pl:    -tmpdir <dir>        temp directory to use (with lots of space!)
scripts/import/read_coverage.pl:    -tmpfile <filename>  name of temp file to use
scripts/import/read_coverage.pl:    -readfile <filename> name of file with read information
scripts/import/read_coverage.pl:    -maxlevel <number>   max level of coverage calculated
scripts/import/post_process_variation_feature_variation_set.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/post_process_variation_feature_variation_set.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/post_process_variation_feature_variation_set.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/post_process_variation_feature_variation_set.pl:    This script will post-process the variation_feature table to update the variation_set_id column to contain the
scripts/import/post_process_variation_feature_variation_set.pl:die ("Required argument '-species' was not specified") unless (defined($species));
scripts/import/post_process_variation_feature_variation_set.pl:die ("Required argument '-registry_file' was not specified") unless (defined($registry_file));
scripts/import/post_process_variation_feature_variation_set.pl:$registry->load_all($registry_file);
scripts/import/post_process_variation_feature_variation_set.pl:my $dbVar = $registry->get_DBAdaptor($species,$group) or die ("Could not get variation DBAdaptor for $species and $group");
scripts/import/post_process_variation_feature_variation_set.pl:    my $max_id = $dbVar->dbc->db_handle->selectall_arrayref($stmt)->[0][0];
scripts/import/post_process_variation_feature_variation_set.pl:    my $tmp_tbl_sth = $dbVar->dbc->prepare($stmt);
scripts/import/post_process_variation_feature_variation_set.pl:    # Insert the variation_id and a comma-separated list of sets it explicitly belongs to into the temp_table
scripts/import/post_process_variation_feature_variation_set.pl:    my $ins_expl_sth = $dbVar->dbc->prepare($stmt);
scripts/import/post_process_variation_feature_variation_set.pl:    my $upd_impl_sth = $dbVar->dbc->prepare($stmt);
scripts/import/post_process_variation_feature_variation_set.pl:    ## Post-process
scripts/import/post_process_variation_feature_variation_set.pl:    $dbVar->dbc->do($stmt);
scripts/import/post_process_variation_feature_variation_set.pl:    $tmp_tbl_sth->execute();
scripts/import/post_process_variation_feature_variation_set.pl:    $ins_expl_sth->execute();
scripts/import/post_process_variation_feature_variation_set.pl:        $upd_impl_sth->execute();
scripts/import/post_process_variation_feature_variation_set.pl:        $update_count = $upd_impl_sth->rows();
scripts/import/post_process_variation_feature_variation_set.pl:		update_table($dbVar->dbc, $tmp_table, ($VARIATION_FEATURE_TABLE, $VAR_COL, $VAR_COL, 'variation_set_id', 'variation_set_id'), $clean);
scripts/import/post_process_variation_feature_variation_set.pl:    $dbVar->dbc->do($stmt);
scripts/import/post_process_variation_feature_variation_set.pl:    $dbVar->dbc->do(qq{TRUNCATE $mtmp_table_name});
scripts/import/post_process_variation_feature_variation_set.pl:	my $retrieve_sth = $dbVar->dbc->prepare($stmt, {mysql_use_result => 1});
scripts/import/post_process_variation_feature_variation_set.pl:	$retrieve_sth->execute;
scripts/import/post_process_variation_feature_variation_set.pl:	$retrieve_sth->bind_columns(\$var_id, \$set_ids);
scripts/import/post_process_variation_feature_variation_set.pl:	while($retrieve_sth->fetch) {
scripts/import/post_process_variation_feature_variation_set.pl:	# Some other post-processing "cleaning" queries (variation and variation_feature)
scripts/import/post_process_variation_feature_variation_set.pl:            $dbVar->dbc->do(qq[update variation set $col = NULL where $col = '';]);
scripts/import/post_process_variation_feature_variation_set.pl:            $dbVar->dbc->do(qq[update $VARIATION_FEATURE_TABLE set $col = NULL where $col = '';]);
scripts/import/post_process_variation_feature_variation_set.pl:	load($dbVar->dbc, $mtmp_table_name);
scripts/import/post_process_variation_feature_variation_set.pl:    $dbVar->dbc->do($stmt);
scripts/import/post_process_variation_feature_variation_set.pl:    print STDOUT localtime() . "\tPost-processing complete!\n" unless ($quiet);
scripts/import/post_process_variation_feature_variation_set.pl:    -registry_file f 
scripts/import/post_process_variation_feature_variation_set.pl:    -species s 
scripts/import/post_process_variation_feature_variation_set.pl:    -group g 
scripts/import/post_process_variation_feature_variation_set.pl:    -quiet 
scripts/import/post_process_variation_feature_variation_set.pl:  Post-process the variation_feature table to update the variation_set_id column to be a
scripts/import/post_process_variation_feature_variation_set.pl:  -registry_file f  (Required)
scripts/import/post_process_variation_feature_variation_set.pl:  -species s        (Required)
scripts/import/post_process_variation_feature_variation_set.pl:                    The species of the database for which to do the post-processing.
scripts/import/post_process_variation_feature_variation_set.pl:  -group g          (Optional)
scripts/import/post_process_variation_feature_variation_set.pl:                    The group identifier for the database to post-process as it is specified
scripts/import/post_process_variation_feature_variation_set.pl:  -sv               (Optional)
scripts/import/post_process_variation_feature_variation_set.pl:  -clean            (Optional)
scripts/import/post_process_variation_feature_variation_set.pl:                    If specified, all pre-existing variation_set_id entries in variation_feature are truncated. 
scripts/import/post_process_variation_feature_variation_set.pl:  -quiet            (Optional)
scripts/import/post_process_variation_feature_variation_set.pl:  -help             Displays this message.
scripts/import/post_process_variation_feature_variation_set.pl:  -no_mtmp          (Optional)
Binary file scripts/import/post_process_variation_feature_variation_set.pl matches
scripts/import/compress_genotypes_by_region.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/compress_genotypes_by_region.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/compress_genotypes_by_region.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/compress_genotypes_by_region.pl:use constant MAX_SHORT => 2**16 -1;
scripts/import/compress_genotypes_by_region.pl:usage('-TMP_DIR argument is required') if(!$TMP_DIR);
scripts/import/compress_genotypes_by_region.pl:usage('-TMP_FILE argument is required') if(!$TMP_FILE);
scripts/import/compress_genotypes_by_region.pl:usage('-species argument is required') if(!$species);
scripts/import/compress_genotypes_by_region.pl:$reg->load_all( $registry_file );
scripts/import/compress_genotypes_by_region.pl:$reg->set_reconnect_when_lost();
scripts/import/compress_genotypes_by_region.pl:my $vdba = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/compress_genotypes_by_region.pl:my $dbCore = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/compress_genotypes_by_region.pl:my $dbVar = $vdba->dbc->db_handle;
scripts/import/compress_genotypes_by_region.pl:my $gca = $reg->get_adaptor($species, 'variation', 'genotypecode');
scripts/import/compress_genotypes_by_region.pl:my %codes = map {(join "|", @{$_->genotype}) => $_->dbID} @{$gca->fetch_all()};
scripts/import/compress_genotypes_by_region.pl:my $max_code = (sort {$a <=> $b} values %codes)[-1] || 0;
scripts/import/compress_genotypes_by_region.pl:	my $sth = $dbVar->prepare(qq{DESCRIBE $genotype_table});
scripts/import/compress_genotypes_by_region.pl:	$sth->execute();
scripts/import/compress_genotypes_by_region.pl:	while(my $ref = $sth->fetchrow_arrayref) {
scripts/import/compress_genotypes_by_region.pl:		$has_proxy = 1 if $ref->[0] eq 'subsnp_proxy_id';
scripts/import/compress_genotypes_by_region.pl:	$sth->finish();
scripts/import/compress_genotypes_by_region.pl:	my $sth = $dbVar->prepare(qq{
scripts/import/compress_genotypes_by_region.pl:	$sth->execute;
scripts/import/compress_genotypes_by_region.pl:	$sth->bind_columns(\$sample_id);
scripts/import/compress_genotypes_by_region.pl:	push @sample_ids, $sample_id while $sth->fetch();
scripts/import/compress_genotypes_by_region.pl:	$sth->finish;
scripts/import/compress_genotypes_by_region.pl:            my @nnn = split /\-/, $val;
scripts/import/compress_genotypes_by_region.pl:            foreach my $sr($nnn[0]..$nnn[-1]) {
scripts/import/compress_genotypes_by_region.pl:		$sth = $dbVar->prepare(qq{SELECT distinct(seq_region_id) FROM variation_feature});
scripts/import/compress_genotypes_by_region.pl:		$sth->execute;
scripts/import/compress_genotypes_by_region.pl:		$sth->bind_columns(\$sr);
scripts/import/compress_genotypes_by_region.pl:		push @seq_regions, $sr while $sth->fetch;
scripts/import/compress_genotypes_by_region.pl:		$sth->finish();
scripts/import/compress_genotypes_by_region.pl:	$dbVar->do(qq{CREATE TABLE IF NOT EXISTS $tmp_table LIKE variation_feature});
scripts/import/compress_genotypes_by_region.pl:	$dbVar->do(qq{TRUNCATE $tmp_table});
scripts/import/compress_genotypes_by_region.pl:		$sth = $dbVar->prepare(qq{
scripts/import/compress_genotypes_by_region.pl:		$sth->execute($seq_region);
scripts/import/compress_genotypes_by_region.pl:		$sth->bind_columns(\$min_pos, \$max_pos);
scripts/import/compress_genotypes_by_region.pl:		$sth->fetch;
scripts/import/compress_genotypes_by_region.pl:		$sth->finish;
scripts/import/compress_genotypes_by_region.pl:			&progress($min_pos - $origin, $max_pos - $origin);
scripts/import/compress_genotypes_by_region.pl:			$dbVar->do(qq{TRUNCATE $tmp_table});
scripts/import/compress_genotypes_by_region.pl:			$sth = $dbVar->prepare(qq{
scripts/import/compress_genotypes_by_region.pl:			$sth->execute($seq_region, $min_pos, $min_pos + $jump);
scripts/import/compress_genotypes_by_region.pl:			$sth->finish();
scripts/import/compress_genotypes_by_region.pl:			$dbVar->do(qq{ALTER TABLE $tmp_table ORDER BY seq_region_start ASC});
scripts/import/compress_genotypes_by_region.pl:				$sth = $dbVar->prepare(qq{
scripts/import/compress_genotypes_by_region.pl:				$sth = $dbVar->prepare(qq{
scripts/import/compress_genotypes_by_region.pl:			$sth->execute();
scripts/import/compress_genotypes_by_region.pl:			$sth->bind_columns(\$seq_region_id, \$seq_region_start, \$seq_region_end, \$seq_region_strand, \$allele_1, \$allele_2, \$sample_id, \$variation_id);
scripts/import/compress_genotypes_by_region.pl:			while ($sth->fetch) {
scripts/import/compress_genotypes_by_region.pl:				my $flipped = (defined($flipped_status->{$variation_id}) ? $flipped_status->{$variation_id} : undef);
scripts/import/compress_genotypes_by_region.pl:					my $dbVar_write = $vdba->dbc->db_handle;
scripts/import/compress_genotypes_by_region.pl:				next if (defined $genotypes->{$sample_id}->{region_end} && $seq_region_start == $genotypes->{$sample_id}->{region_end}); #same variation and sample but different genotype !!!
scripts/import/compress_genotypes_by_region.pl:				if (!defined $genotypes->{$sample_id}->{region_start}){
scripts/import/compress_genotypes_by_region.pl:					$genotypes->{$sample_id}->{region_start} = $seq_region_start;
scripts/import/compress_genotypes_by_region.pl:					$genotypes->{$sample_id}->{region_end} = $seq_region_end;
scripts/import/compress_genotypes_by_region.pl:				if ((abs($genotypes->{$sample_id}->{region_start} - $seq_region_start) > DISTANCE()) || (abs($seq_region_start - $genotypes->{$sample_id}->{region_end}) > MAX_SHORT)){
scripts/import/compress_genotypes_by_region.pl:					delete $genotypes->{$sample_id}; #and remove the printed entry
scripts/import/compress_genotypes_by_region.pl:					$genotypes->{$sample_id}->{region_start} = $seq_region_start;
scripts/import/compress_genotypes_by_region.pl:				if ($seq_region_start != $genotypes->{$sample_id}->{region_start}){					
scripts/import/compress_genotypes_by_region.pl:					$blob = pack ("w",$seq_region_start - $genotypes->{$sample_id}->{region_end} - 1);
scripts/import/compress_genotypes_by_region.pl:					$genotypes->{$sample_id}->{genotypes} .= escape($blob) .escape(pack("w", $variation_id)). escape(pack("w", $genotype_code));
scripts/import/compress_genotypes_by_region.pl:					$genotypes->{$sample_id}->{genotypes} = escape(pack("w", $variation_id)).escape(pack("w", $genotype_code));
scripts/import/compress_genotypes_by_region.pl:				$genotypes->{$sample_id}->{region_end} = $seq_region_start;    #to avoid nasty effects of indels coordinates
scripts/import/compress_genotypes_by_region.pl:			$sth->finish();
scripts/import/compress_genotypes_by_region.pl:	$dbVar->do(qq{DROP TABLE $tmp_table});
scripts/import/compress_genotypes_by_region.pl:	$dbVar->do(qq{DELETE FROM compressed_genotype_region WHERE seq_region_id = 0;});
scripts/import/compress_genotypes_by_region.pl:	    print FH join("\t",$sample_id,$seq_region_id, $genotypes->{$sample_id}->{region_start}, $genotypes->{$sample_id}->{region_end}, 1, $genotypes->{$sample_id}->{genotypes}) . "\n";
scripts/import/compress_genotypes_by_region.pl:	print FH join("\t",$sample_id,$seq_region_id, $genotypes->{$sample_id}->{region_start}, $genotypes->{$sample_id}->{region_end}, 1, $genotypes->{$sample_id}->{genotypes}) . "\n";
scripts/import/compress_genotypes_by_region.pl:	$dbVar->do(qq{LOAD DATA LOCAL INFILE "$TMP_DIR/$dump_file" INTO TABLE compressed_genotype_region});
scripts/import/compress_genotypes_by_region.pl:    my $csa = $dbCore->get_CoordSystemAdaptor();
scripts/import/compress_genotypes_by_region.pl:    my $cs = $csa->fetch_by_name($csname);
scripts/import/compress_genotypes_by_region.pl:    my $sth = $dbVar->prepare
scripts/import/compress_genotypes_by_region.pl:    $sth->execute($table_name, $cs->dbID(),DISTANCE+1);
scripts/import/compress_genotypes_by_region.pl:    $sth->finish();
scripts/import/compress_genotypes_by_region.pl:		elsif($flipped == 0 && $seq_region_strand == -1) {
scripts/import/compress_genotypes_by_region.pl:	# flipped column has not been set - use old behaviour
scripts/import/compress_genotypes_by_region.pl:		if($seq_region_strand == -1) {
scripts/import/compress_genotypes_by_region.pl:	my $sth = $dbVar->prepare("SELECT variation.variation_id, variation.flipped FROM variation, $table 
scripts/import/compress_genotypes_by_region.pl:	$sth->execute;
scripts/import/compress_genotypes_by_region.pl:	$sth->bind_columns(\$var_id, \$flipped);
scripts/import/compress_genotypes_by_region.pl:	while($sth->fetch()) {
scripts/import/compress_genotypes_by_region.pl:	$sth->finish();
scripts/import/compress_genotypes_by_region.pl:	my $sth = $dbVar->prepare("INSERT INTO genotype_code (genotype_code_id, allele_code_id, haplotype_id) VALUES(?, ?, ?)");
scripts/import/compress_genotypes_by_region.pl:		$sth->execute($gt_code, $allele_code, $hap_id++);
scripts/import/compress_genotypes_by_region.pl:	$sth->finish;
scripts/import/compress_genotypes_by_region.pl:	my $sth = $dbVar->prepare("SELECT allele_code_id FROM allele_code WHERE allele = ?");
scripts/import/compress_genotypes_by_region.pl:	$sth->execute($allele);
scripts/import/compress_genotypes_by_region.pl:	$sth->bind_columns(\$allele_code);
scripts/import/compress_genotypes_by_region.pl:	$sth->fetch();
scripts/import/compress_genotypes_by_region.pl:	$sth->finish();
scripts/import/compress_genotypes_by_region.pl:		$sth = $dbVar->prepare("INSERT INTO allele_code(allele) VALUES(?)");
scripts/import/compress_genotypes_by_region.pl:		$sth->execute($allele);
scripts/import/compress_genotypes_by_region.pl:		$sth->finish();
scripts/import/compress_genotypes_by_region.pl:		$allele_code = $dbVar->last_insert_id(undef, undef, qw(allele_code allele_code_id));
scripts/import/compress_genotypes_by_region.pl:  -tmpdir <dir>            temp directory to use (with lots of space!)
scripts/import/compress_genotypes_by_region.pl:  -tmpfile <filename>      name of temp file to use
scripts/import/compress_genotypes_by_region.pl:  -registry <file>         registry file
scripts/import/compress_genotypes_by_region.pl:  -species <species_name>  name of the species
scripts/import/compress_genotypes_by_region.pl:  -table <table>           table name to read genotypes from
scripts/import/compress_genotypes_by_region.pl:  -no_flip                 don't flip genotypes
scripts/import/compress_genotypes_by_region.pl:  -monoploid               indicate this species is monoploid
scripts/import/compress_genotypes_by_region.pl:    my $numblobs = $total > 0 ? (($i/$total) * $width) - 2 : 0;
scripts/import/compress_genotypes_by_region.pl:    printf("\r% -${width}s% 1s% 10s", '['.('=' x $numblobs).($numblobs == $width - 2 ? '=' : '>'), ']', "[ " . $percent . "% ]");
scripts/import/compress_genotypes_by_region.pl:        ($time[5] + 1900)."-".
scripts/import/compress_genotypes_by_region.pl:        $time[4]."-".
scripts/import/compress_genotypes_by_region.pl:    print $time." - ".$text.($text =~ /\n$/ ? "" : "\n");
scripts/import/get_all_goa-imp_data.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/get_all_goa-imp_data.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/get_all_goa-imp_data.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/get_all_goa-imp_data.pl:usage('-output_dir argument is required') if (!$output_dir);
scripts/import/get_all_goa-imp_data.pl:die ("Output dir '$output_dir' doesn't exist") unless (-d $output_dir);
scripts/import/get_all_goa-imp_data.pl:  print "> Error! Please give an Ensembl version, using the option '-v' \n";
scripts/import/get_all_goa-imp_data.pl:  print "> Error! Please give the list of host names where the new databases are stored using the option '-hlist'\n";
scripts/import/get_all_goa-imp_data.pl:  print "> Error! Please give user name using the option '-user'\n";
scripts/import/get_all_goa-imp_data.pl:  while (my ($dbname) = $sth->fetchrow_array) {
scripts/import/get_all_goa-imp_data.pl:    $sth1->bind_columns(\$translation_id, \$translation, \$transcript_id, \$uniprot_id, \$go_term, \$go_desc);
scripts/import/get_all_goa-imp_data.pl:    while(my @res = $sth1->fetchrow_array()) {
scripts/import/get_all_goa-imp_data.pl:        $sth2->bind_columns(\$gene, \$transcript);
scripts/import/get_all_goa-imp_data.pl:        $sth2->fetch();
scripts/import/get_all_goa-imp_data.pl:        $sth2->finish();
scripts/import/get_all_goa-imp_data.pl:    $sth1->finish();
scripts/import/get_all_goa-imp_data.pl:    # 1 - Run web services
scripts/import/get_all_goa-imp_data.pl:    # 2 - Parse results (search results with PMIDs)
scripts/import/get_all_goa-imp_data.pl:    # 3 - Export data in a tabulated datafile
scripts/import/get_all_goa-imp_data.pl:    # 4 - Import the file using the script "import_phenotype_data.pl"
scripts/import/get_all_goa-imp_data.pl:    my $http = HTTP::Tiny->new();
scripts/import/get_all_goa-imp_data.pl:        my $response = $http->get($rest_url_with_params);
scripts/import/get_all_goa-imp_data.pl:        if ($response->{success}) {
scripts/import/get_all_goa-imp_data.pl:          my $pmids = parse_result($response->{content});
scripts/import/get_all_goa-imp_data.pl:    next if ($content{$pmid_col} eq '-');
scripts/import/get_all_goa-imp_data.pl:  my $dbh = DBI->connect($dsn, $user, $pswd) or die "Connection failed";
scripts/import/get_all_goa-imp_data.pl:  my $sth = $dbh->prepare($sql);
scripts/import/get_all_goa-imp_data.pl:  $sth->execute;
scripts/import/get_all_goa-imp_data.pl:  Usage: perl get_all_goa-imp_data.pl [OPTION]
scripts/import/get_all_goa-imp_data.pl:  Fetch and store the GO-IMP data into a tabulated text file. This file will be used to import the data in the Variation
scripts/import/get_all_goa-imp_data.pl:  database, using the script "import_phenotype_data.pl" with the option "-source go-imp"
scripts/import/get_all_goa-imp_data.pl:      -help        Print this message
scripts/import/get_all_goa-imp_data.pl:      -v           Ensembl version, e.g. 82 (Required)
scripts/import/get_all_goa-imp_data.pl:      -output_dir  Path to the output files. (Required)
scripts/import/get_all_goa-imp_data.pl:      -hlist       The list of host names (with port) where the new databases are stored, separated by a coma,
scripts/import/get_all_goa-imp_data.pl:      -user        MySQL user name (Required)
scripts/import/get_all_goa-imp_data.pl:      -species     The list of species from which the GOA data will be retrieved, separated by a coma,
scripts/import/select_tag_snps_vcf.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/select_tag_snps_vcf.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/select_tag_snps_vcf.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/select_tag_snps_vcf.pl:die("ERROR: Frequencies file $freq_file not found\n") unless -e $freq_file;
scripts/import/select_tag_snps_vcf.pl:	$maf->{$pos} = (sort {$a <=> $b} ($a1, $a2))[0];
scripts/import/select_tag_snps_vcf.pl:	$ld_file_handle->open("<$ld_file") or die("ERROR: Could not open LD file $ld_file\n");
scripts/import/select_tag_snps_vcf.pl:	push @{$ld->{$p1}}, $p2;
scripts/import/select_tag_snps_vcf.pl:$ld_file_handle->close;
scripts/import/select_tag_snps_vcf.pl:foreach my $pos (sort {$maf->{$b} <=> $maf->{$a} || $a <=> $b} keys %{$maf}){
scripts/import/select_tag_snps_vcf.pl:    if (!defined $remove_snps->{$pos}){
scripts/import/select_tag_snps_vcf.pl:		#map {$remove_snps->{$_}++;delete $MAF_snps->{$_}} @{$LD_values->{$seq_region_start}};
scripts/import/select_tag_snps_vcf.pl:		if(defined($ld->{$pos})) {
scripts/import/select_tag_snps_vcf.pl:			foreach(@{$ld->{$pos}}) {
scripts/import/select_tag_snps_vcf.pl:				$remove_snps->{$_}++;
scripts/import/select_tag_snps_vcf.pl:				delete $maf->{$_};
scripts/import/select_tag_snps_vcf.pl:				push @{$tagged_by->{$pos}}, $_;
scripts/import/select_tag_snps_vcf.pl:			$remove_snps->{$pos}++;
scripts/import/select_tag_snps_vcf.pl:			delete $maf->{$pos};
scripts/import/select_tag_snps_vcf.pl:	$out_file_handle->open(">$out_file") or die ("ERROR: Could not open output file $out_file\n");
scripts/import/select_tag_snps_vcf.pl:	foreach my $p2 (@{$tagged_by->{$p1}}) {
scripts/import/select_tag_snps_vcf.pl:$out_file_handle->close or die ("Could not close output file with tagged SNPs");
scripts/import/dump_strain_seq.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dump_strain_seq.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dump_strain_seq.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dump_strain_seq.pl:Bio::EnsEMBL::Registry->load_registry_from_db( -host => 'ens-staging',
scripts/import/dump_strain_seq.pl:                                               -db_version => $new_db_version,
scripts/import/dump_strain_seq.pl:                                               -user => 'ensro',
scripts/import/dump_strain_seq.pl:my $dbVar = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/dump_strain_seq.pl:my $dbCore = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/dump_strain_seq.pl:my $slice_adaptor = $dbCore->get_SliceAdaptor();
scripts/import/dump_strain_seq.pl:my $rc_adaptor = $dbVar->get_ReadCoverageAdaptor();
scripts/import/dump_strain_seq.pl:my $ind_adaptor = $dbVar->get_IndividualAdaptor();
scripts/import/dump_strain_seq.pl:m 1 v 1 n 1 h 1 r 1 d 1 w 1 s 1 b 1 y 1 k 1 c 1 a 1 t 1 g 1 - 1);
scripts/import/dump_strain_seq.pl:my $levels = $rc_adaptor->get_coverage_levels();
scripts/import/dump_strain_seq.pl:$MAX_LEVEL =$levels->[0] if ($levels->[0] > $levels->[1]);
scripts/import/dump_strain_seq.pl:$MAX_LEVEL =$levels->[1] if ($levels->[0] < $levels->[1]);
scripts/import/dump_strain_seq.pl:my $strains = $ind_adaptor->fetch_all_strains_with_coverage();   #get strains with coverage information, all the columns in the file
scripts/import/dump_strain_seq.pl:    @{$strains} = grep {$_->name eq 'SD'} @{$strains};
scripts/import/dump_strain_seq.pl:    @{$strains} = grep {$_->name =~ /Hu\w\w|Venter|Watson/i} @{$strains};
scripts/import/dump_strain_seq.pl:    #print $$strains[0]->name,"\n";
scripts/import/dump_strain_seq.pl:#my $slice = $slice_adaptor->fetch_by_region('chromosome','8',109_700_000,110_000_000); #dump this region to find problem 108213779-108237682
scripts/import/dump_strain_seq.pl:#my $slice = $slice_adaptor->fetch_by_region('chromosome','1',1_900_900,2_300_300);
scripts/import/dump_strain_seq.pl:my $slice = $slice_adaptor->fetch_by_region('chromosome',$region);
scripts/import/dump_strain_seq.pl:&create_file_header() if (defined $range_registry->get_ranges(1)); #create the file header, some regions might not have coverage at all
scripts/import/dump_strain_seq.pl:foreach my $region (@{$range_registry->get_ranges(1)}){
scripts/import/dump_strain_seq.pl:    $region->[0] = 1 if ($region->[0] < 0); #if the region lies outside the boundaries of the slice
scripts/import/dump_strain_seq.pl:    $region->[1] = ($slice->end - $slice->start + 1) if ($region->[1] + $slice->start > $slice->end); 
scripts/import/dump_strain_seq.pl:    $subSlice = $slice->sub_Slice($region->[0],$region->[1],1);
scripts/import/dump_strain_seq.pl:	    my $rcs = $rc_adaptor->fetch_all_by_Slice_Sample_depth($slice,$strain,$level);	    
scripts/import/dump_strain_seq.pl:	&apply_AF_to_seq($slice,$strain->name,\$seq);
scripts/import/dump_strain_seq.pl:	$strain_seq{$strain->name} = $seq;
scripts/import/dump_strain_seq.pl:    my $strainSlice = $slice->get_by_strain($strain);
scripts/import/dump_strain_seq.pl:    my $afs = $strainSlice->get_all_AlleleFeatures_Slice(1);
scripts/import/dump_strain_seq.pl:	my $format = "@" . ($af->start-1) . "A" . ($af->end - $af->start +1);
scripts/import/dump_strain_seq.pl:	$allele = ambiguity_code($af->allele_string);
scripts/import/dump_strain_seq.pl:	if ($base =~ /[A-Z]/){
scripts/import/dump_strain_seq.pl:	    substr($$ref_seq,$af->start-1,$af->end - $af->start + 1,uc($allele) . '*' x ($af->end - $af->start)) if ($allele ne '-');
scripts/import/dump_strain_seq.pl:	    substr($$ref_seq,$af->start-1,$af->end - $af->start + 1,'*' x ($af->end - $af->start +1 )) if ($allele eq '-');
scripts/import/dump_strain_seq.pl:	if ($base =~ /[a-z-]/){
scripts/import/dump_strain_seq.pl:	    #if it is a deletion, use the '-' to mean it is covered by 1 read
scripts/import/dump_strain_seq.pl:	    substr($$ref_seq,$af->start-1,$af->end - $af->start + 1,lc($allele) . '-' x ($af->end - $af->start)) if ($allele ne '-');
scripts/import/dump_strain_seq.pl:	    substr($$ref_seq,$af->start-1,$af->end - $af->start + 1,'-' x ($af->end - $af->start + 1)) if ($allele eq '-');
scripts/import/dump_strain_seq.pl:    my @ref_seq = split//,$slice->seq;
scripts/import/dump_strain_seq.pl:	push @{$strain_array[$index_strain]},split //,$strain_seq->{$strain->name};
scripts/import/dump_strain_seq.pl:	print DUMP join(" ",$ref_seq[$i],map {$strain_reads .= $read_code{$_->[$i]}. ' ';($_->[$i] eq '*') ? '-' : uc($_->[$i]) } @strain_array), " ";
scripts/import/dump_strain_seq.pl:	$rc->start(1) if ($rc->start <= 0); #if the region lies outside the boundaries of the slice
scripts/import/dump_strain_seq.pl:	$rc->end($slice->end - $slice->start + 1) if ($rc->end + $slice->start > $slice->end); 
scripts/import/dump_strain_seq.pl:	$$ref_seq .= '~' x ($rc->start - 1 - $end_level1) if ($rc->level == 1);
scripts/import/dump_strain_seq.pl:	$format = '@' . ($rc->start - 1) . 'A' . ($rc->end - $rc->start + 1);
scripts/import/dump_strain_seq.pl:	$$ref_seq .= lc(unpack($format,$slice->seq)) if ($rc->level == 1);
scripts/import/dump_strain_seq.pl:	substr($$ref_seq,$rc->start-1,$rc->end-$rc->start+1,uc(unpack($format,$$ref_seq))) if ($rc->level == $MAX_LEVEL);
scripts/import/dump_strain_seq.pl:	$end = $rc->end;
scripts/import/dump_strain_seq.pl:	$end_level1 = $rc->end if ($rc->level == 1);	
scripts/import/dump_strain_seq.pl:    $$ref_seq .= '~' x ($slice->length - $end);
scripts/import/dump_strain_seq.pl:    print DUMP "SEQ $species reference ", $slice->seq_region_name," ",$slice->start," ",$slice->end," ",$slice->strand,"\n";
scripts/import/dump_strain_seq.pl:	print DUMP "SEQ $species ",$strain->name, " WGS\n";
scripts/import/dump_strain_seq.pl:	print DUMP "SCORE aligned ",$strain->name, " reads\n";
scripts/import/dump_strain_seq.pl:    my $range_registry = Bio::EnsEMBL::Mapper::RangeRegistry->new();
scripts/import/dump_strain_seq.pl:      my $rcs = $rc_adaptor->fetch_all_by_Slice_Sample_depth($slice,$strain,1);
scripts/import/dump_strain_seq.pl:	$range_registry->check_and_register(1,$rc->start,$rc->end);
scripts/import/dump_strain_seq.pl:    #print DUMP "##RELEASE ",Bio::EnsEMBL::Registry->software_version(),"\n\n";
scripts/import/dump_strain_seq.pl:    -dump_file <filename>    file where you want to dump the resequencing data
scripts/import/dump_strain_seq.pl:    -species   <species>     species you want to dump data (default = mouse)
scripts/import/dump_strain_seq.pl:    -region    <region_name> region to dump the data
scripts/import/create_testdb.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/create_testdb.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/create_testdb.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/create_testdb.pl:$reg->load_all($registry_file);
scripts/import/create_testdb.pl:my $source = $reg->get_DBAdaptor($species,'source_db') or die ("Could not get a DBAdaptor for the source db");
scripts/import/create_testdb.pl:my $dest   = $reg->get_DBAdaptor($species,'dest_db') or die ("Could not get a DBAdaptor for the destination db");
scripts/import/create_testdb.pl:$dest->dbc->do(qq{ CREATE TABLE IF NOT EXISTS subsnp_map (
scripts/import/create_testdb.pl:$dest->dbc->do($stmt);
scripts/import/create_testdb.pl:my $source_db = $source->dbc->dbname();    
scripts/import/create_testdb.pl:my $ins_sth = $dest->dbc->prepare($ins_stmt);
scripts/import/create_testdb.pl:$ins_sth->execute();
scripts/import/create_testdb.pl:$ins_sth->finish();
scripts/import/create_testdb.pl:my $srcdb = $source->dbc->dbname();
scripts/import/create_testdb.pl:    add_foreign_data($dest,$table,$row->[0],$row->[1],$row->[2],$srcdb,{}); 
scripts/import/create_testdb.pl:my $source_db = $source->dbc->dbname();    
scripts/import/create_testdb.pl:my $poa_ins_sth = $dest->dbc->prepare($poa_ins_stmt);
scripts/import/create_testdb.pl:$poa_ins_sth->execute();
scripts/import/create_testdb.pl:$poa_ins_sth->finish();
scripts/import/create_testdb.pl:        my ($min,$max) = @{$source->dbc->db_handle->selectall_arrayref($stmt)->[0]};
scripts/import/create_testdb.pl:        my $sth = $source->dbc->prepare($stmt);
scripts/import/create_testdb.pl:                my $id = $min + int(rand($max-$min+1));
scripts/import/create_testdb.pl:                $sth->execute($id);
scripts/import/create_testdb.pl:                $sth->bind_columns(\$id);
scripts/import/create_testdb.pl:                $sth->fetch();
scripts/import/create_testdb.pl:        my $srcdb = $source->dbc->dbname();
scripts/import/create_testdb.pl:        my $ins_sth = $dest->dbc->prepare($ins_stmt);
scripts/import/create_testdb.pl:        map {$ins_sth->execute($_)} @$table_ids;
scripts/import/create_testdb.pl:    my $a_table = $row->[0];
scripts/import/create_testdb.pl:    my $column = $row->[1];
scripts/import/create_testdb.pl:    my $ref_column2 = $row->[2];
scripts/import/create_testdb.pl:    my $ins_sth = $dba->dbc->prepare($ins_stmt);
scripts/import/create_testdb.pl:    my $rc = $ins_sth->execute();
scripts/import/create_testdb.pl:    if ($rc > 0 && exists($foreign_keys->{$foreign_table})) {
scripts/import/create_testdb.pl:        foreach my $row (@{$foreign_keys->{$foreign_table}}) {
scripts/import/create_testdb.pl:            add_foreign_data($dba,$foreign_table,$row->[0],$row->[1],$row->[2],$source_db,$foreign_keys);
scripts/import/create_testdb.pl:    my $cols = $dba->dbc->db_handle->selectcol_arrayref($stmt);
scripts/import/import_EPMC.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_EPMC.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_EPMC.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_EPMC.pl:my $http = HTTP::Tiny->new();
scripts/import/import_EPMC.pl:## only import papers to non-human databases if the species is mentioned
scripts/import/import_EPMC.pl:$reg->no_version_check(1); 
scripts/import/import_EPMC.pl:$reg->load_all($registry_file);
scripts/import/import_EPMC.pl:my $dba = $reg->get_DBAdaptor($species, 'variation') || die "Error getting db adaptor\n";
scripts/import/import_EPMC.pl:## extract all variants - cited variants failing QC are still displayed
scripts/import/import_EPMC.pl:$dba->include_failed_variations(1);
scripts/import/import_EPMC.pl:  my $var_ad = $reg->get_adaptor($species, 'variation', 'variation');
scripts/import/import_EPMC.pl:  my $pub_ad = $reg->get_adaptor($species, 'variation', 'publication');
scripts/import/import_EPMC.pl:  my $source_ad = $reg->get_adaptor($species, 'variation', 'source');
scripts/import/import_EPMC.pl:    die "Type $type is not recognised - must be EPMC, UCSC or phenotype\n";
scripts/import/import_EPMC.pl:    my $var_ad = $reg->get_adaptor($species, 'variation', 'variation');
scripts/import/import_EPMC.pl:    my $pub_ad = $reg->get_adaptor($species, 'variation', 'publication');
scripts/import/import_EPMC.pl:    my $dba = $reg->get_DBAdaptor($species, 'variation') || die "Error getting db adaptor\n";
scripts/import/import_EPMC.pl:        my @var_id = unique(@{$data->{$pub}->{rsid}});
scripts/import/import_EPMC.pl:            my $pub_pmid = $data->{$pub}->{pmid};
scripts/import/import_EPMC.pl:            $source_attrib_id = $data->{$pub}->{source} if($type eq 'phenotype');
scripts/import/import_EPMC.pl:            my $v = $var_ad->fetch_by_name($rsid);
scripts/import/import_EPMC.pl:                if(defined $pub_pmid && $done_list->{$rsid}{$pub_pmid}){
scripts/import/import_EPMC.pl:                  my $source_data = $done_list->{$rsid}{$pub_pmid};
scripts/import/import_EPMC.pl:                  my $var_id = $v->dbID();
scripts/import/import_EPMC.pl:                  $pub_ad->update_citation_data_source($source_attrib_id, $var_id, $pub_pmid) unless $source_data =~ $source_attrib_id;
scripts/import/import_EPMC.pl:                  print $not_found "\"$rsid\",$data->{$pub}->{pmcid},$pub_pmid,MED\n";
scripts/import/import_EPMC.pl:                  print $not_found $rsid ."\t". $pub_pmid."\t-\t". $data->{$pub}->{doi} ."\t". $data->{$pub}->{title}."\t". $data->{$pub}->{authors} ."\t". $data->{$pub}->{year} ."\t".  $data->{$pub}->{ucsc} . "\n";
scripts/import/import_EPMC.pl:        my $title = (defined $ref->{resultList}->{result}->{title} ? $ref->{resultList}->{result}->{title}  : $data->{$pub}->{title});
scripts/import/import_EPMC.pl:        # UCSC imports publications where title is not valid, example: 'P1-200'
scripts/import/import_EPMC.pl:        next if ($title =~/Erratum/i || $title =~/Errata/i || $title =~/Not Available/i || $title =~/^P[0-9]+\-[0-9]+$/i);
scripts/import/import_EPMC.pl:        if($title =~ /^\[ ?[A-Za-z]{2}/){
scripts/import/import_EPMC.pl:        my $pmid   = $ref->{resultList}->{result}->{pmid}   || $data->{$pub}->{pmid};
scripts/import/import_EPMC.pl:        my $pmcid  = $ref->{resultList}->{result}->{pmcid}  || undef;
scripts/import/import_EPMC.pl:        my $doi    = $ref->{resultList}->{result}->{DOI}    || $data->{$pub}->{doi};
scripts/import/import_EPMC.pl:        $publication = $pub_ad->fetch_by_doi( $doi )     if defined $doi;
scripts/import/import_EPMC.pl:        $publication = $pub_ad->fetch_by_pmid( $pmid )   if defined $pmid && ! defined $publication;
scripts/import/import_EPMC.pl:        $publication = $pub_ad->fetch_by_pmcid( $pmcid ) if defined $pmcid && ! defined $publication;
scripts/import/import_EPMC.pl:            ##  warn "Linkings vars to existing pub ". $publication->dbID() ."\n";
scripts/import/import_EPMC.pl:            $pub_ad->update_variant_citation( $publication,$source_attrib_id,\@var_obs );
scripts/import/import_EPMC.pl:            $pub_ad->update_ucsc_id( $publication,  $data->{$pub}->{ucsc} ) if defined $data->{$pub}->{ucsc};
scripts/import/import_EPMC.pl:            my $publication = Bio::EnsEMBL::Variation::Publication->new(
scripts/import/import_EPMC.pl:                -title    => $new_title,
scripts/import/import_EPMC.pl:                -authors  => $ref->{resultList}->{result}->{authorString}   || $data->{$pub}->{authors},
scripts/import/import_EPMC.pl:                -pmid     => $ref->{resultList}->{result}->{pmid}           || $data->{$pub}->{pmid},
scripts/import/import_EPMC.pl:                -pmcid    => $ref->{resultList}->{result}->{pmcid}          || $data->{$pub}->{pmcid},
scripts/import/import_EPMC.pl:                -year     => $ref->{resultList}->{result}->{pubYear}        || $data->{$pub}->{year},
scripts/import/import_EPMC.pl:                -doi      => $ref->{resultList}->{result}->{DOI}            || $data->{$pub}->{doi},
scripts/import/import_EPMC.pl:                -ucsc_id  => $data->{$pub}->{ucsc}                          || undef,
scripts/import/import_EPMC.pl:                -variants => \@var_obs,
scripts/import/import_EPMC.pl:                -adaptor  => $pub_ad
scripts/import/import_EPMC.pl:            $pub_ad->store( $publication,$source_attrib_id );
scripts/import/import_EPMC.pl:  my $attrib_adaptor = $reg->get_adaptor($species, 'variation', 'attribute');
scripts/import/import_EPMC.pl:  my $attrib_id = $attrib_adaptor->attrib_id_for_type_value('citation_source',$source);
scripts/import/import_EPMC.pl:    if ($species_string !~/human|homo/ && defined $data->{$pub}->{pmcid} ){         
scripts/import/import_EPMC.pl:        my $pmcid = $data->{$pub}->{pmcid};
scripts/import/import_EPMC.pl:        if ($looks_ok == 0 && $ref->{resultList}->{result}->{title} !~ /$species_string/){
scripts/import/import_EPMC.pl:            print $error_log "ALL\t$data->{$pub}->{pmid}\t$ref->{resultList}->{result}->{title} - species not mentioned\n";
scripts/import/import_EPMC.pl:    if( defined $data->{$pub}->{pmid} ){
scripts/import/import_EPMC.pl:      $ref = get_epmc_data( "webservices/rest/search?query=ext_id:$data->{$pub}->{pmid}%20src:med" );
scripts/import/import_EPMC.pl:    elsif( defined $data->{$pub}->{doi} ){
scripts/import/import_EPMC.pl:      $ref = get_epmc_data( "webservices/rest/search?query=$data->{$pub}->{doi}" );
scripts/import/import_EPMC.pl:      return undef unless defined  $data->{$pub}->{doi} &&
scripts/import/import_EPMC.pl:      $ref->{resultList}->{result}->{doi} eq $data->{$pub}->{doi}; 
scripts/import/import_EPMC.pl:    elsif(defined $data->{$pub}->{pmcid}){
scripts/import/import_EPMC.pl:      $ref = get_epmc_data( "webservices/rest/search?query=$data->{$pub}->{pmcid}" );
scripts/import/import_EPMC.pl:      return undef unless defined $data->{$pub}->{pmcid} &&
scripts/import/import_EPMC.pl:      $ref->{resultList}->{result}->{pmcid} eq $data->{$pub}->{pmcid};
scripts/import/import_EPMC.pl:      print $error_log "ALL\t$pub - nothing to search on\n";
scripts/import/import_EPMC.pl:    unless (defined $ref->{resultList}->{result}->{title}){
scripts/import/import_EPMC.pl:        $mess .= "pmid:$data->{$pub}->{pmid}\t" if defined $data->{$pub}->{pmid};
scripts/import/import_EPMC.pl:        $mess .= "pmcid:$data->{$pub}->{pcmid}\t" if defined $data->{$pub}->{pmcid};
scripts/import/import_EPMC.pl:    my $trimmed_author_list = trim_author_list($ref->{resultList}->{result}->{authorString});
scripts/import/import_EPMC.pl:    $ref->{resultList}->{result}->{authorString} = $trimmed_author_list if $trimmed_author_list;
scripts/import/import_EPMC.pl:    my $xs   = XML::Simple->new();
scripts/import/import_EPMC.pl:    my $response = $http->get($request, {
scripts/import/import_EPMC.pl:    unless ($response->{success}){
scripts/import/import_EPMC.pl:    return $xs->XMLin($response->{content} );
scripts/import/import_EPMC.pl:## essential for non-humans
scripts/import/import_EPMC.pl:    if(defined $mined->{item}->{annotations}->{annotation}  &&
scripts/import/import_EPMC.pl:      ref($mined->{item}->{annotations}->{annotation}) eq 'ARRAY'){
scripts/import/import_EPMC.pl:      foreach my $found (@{$mined->{item}->{annotations}->{annotation}}) {
scripts/import/import_EPMC.pl:        if ($found->{exact} =~ /$species_string/i){
scripts/import/import_EPMC.pl:    elsif(defined $mined->{item}->{annotations}->{annotation} &&
scripts/import/import_EPMC.pl:      ref($mined->{item}->{annotations}->{annotation}) eq 'HASH'){
scripts/import/import_EPMC.pl:      foreach my $key (keys %{$mined->{item}->{annotations}->{annotation}}){
scripts/import/import_EPMC.pl:        if(ref($mined->{item}->{annotations}->{annotation}->{$key}) eq 'HASH' &&
scripts/import/import_EPMC.pl:          $mined->{item}->{annotations}->{annotation}->{$key}->{exact}){
scripts/import/import_EPMC.pl:          if($mined->{item}->{annotations}->{annotation}->{$key}->{exact} =~ /$species_string/i){
scripts/import/import_EPMC.pl:        if($key eq 'exact' && $mined->{item}->{annotations}->{annotation}->{$key} =~ /$species_string/i){
scripts/import/import_EPMC.pl:      if ($is_pmcid && ($avoid_list->{$rs}->{$pmcid} || $avoid_list->{$rs}->{$pmid})){
scripts/import/import_EPMC.pl:    my $intdba = $reg->get_DBAdaptor('multi', 'intvar') || warn "Error getting db adaptor\n";
scripts/import/import_EPMC.pl:    my $dat_ext_sth = $intdba->dbc->prepare(qq[ select pmid, pmc_id, variation_name from failed_citations]);
scripts/import/import_EPMC.pl:    $dat_ext_sth->execute();
scripts/import/import_EPMC.pl:    my $dat = $dat_ext_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:        $avoid{$l->[2]}{$l->[0]} = 1;
scripts/import/import_EPMC.pl:        $avoid{$l->[2]}{$l->[1]} = 1;
scripts/import/import_EPMC.pl:    my $pub_ext_sth = $dba->dbc()->prepare(qq[ select publication.publication_id, publication.pmid
scripts/import/import_EPMC.pl:    my $pub_upd_sth = $dba->dbc()->prepare(qq[ update publication
scripts/import/import_EPMC.pl:    $pub_ext_sth->execute();
scripts/import/import_EPMC.pl:    my $dat = $pub_ext_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    return unless defined $dat->[0]->[0];
scripts/import/import_EPMC.pl:        my $mined = get_epmc_data( "annotations_api/annotationsByArticleIds?articleIds=MED:$l->[1]&type=Organisms&format=XML" );
scripts/import/import_EPMC.pl:        my $ref   = get_epmc_data("webservices/rest/search?query=ext_id:$l->[1]%20src:med");
scripts/import/import_EPMC.pl:            print $error_log "NO EPMC data for PMID:$l->[1] - skipping\n";
scripts/import/import_EPMC.pl:        if ($looks_ok == 0 && defined $ref->{resultList}->{result}->{title} &&
scripts/import/import_EPMC.pl:            $ref->{resultList}->{result}->{title} !~/$species_string/i){
scripts/import/import_EPMC.pl:            print $error_log "WARN dbSNP data:\t$l->[1]\t($ref->{resultList}->{result}->{title}) - species not mentioned\n"
scripts/import/import_EPMC.pl:        my $trimmed_author_list = trim_author_list($ref->{resultList}->{result}->{authorString});
scripts/import/import_EPMC.pl:        $ref->{resultList}->{result}->{authorString} = $trimmed_author_list if $trimmed_author_list;
scripts/import/import_EPMC.pl:        $pub_upd_sth->execute( $ref->{resultList}->{result}->{title},
scripts/import/import_EPMC.pl:                               $ref->{resultList}->{result}->{pmcid},
scripts/import/import_EPMC.pl:                               $ref->{resultList}->{result}->{authorString},
scripts/import/import_EPMC.pl:                               $ref->{resultList}->{result}->{pubYear},
scripts/import/import_EPMC.pl:                               $ref->{resultList}->{result}->{doi},
scripts/import/import_EPMC.pl:                               $l->[0]
scripts/import/import_EPMC.pl:            ) if defined $ref->{resultList}->{result}->{title};
scripts/import/import_EPMC.pl:    my $attrib_ext_sth = $dba->dbc()->prepare(qq[ select attrib_id from attrib where value ='Cited']);
scripts/import/import_EPMC.pl:    $attrib_ext_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $attrib =  $attrib_ext_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    die "Not updating evidence as no attrib found\n" unless defined $attrib->[0]->[0];
scripts/import/import_EPMC.pl:    my $ev_ext_sth = $dba->dbc()->prepare(qq[ select variation.variation_id, variation.evidence_attribs 
scripts/import/import_EPMC.pl:    my $var_upd_sth     = $dba->dbc()->prepare(qq[ update variation set evidence_attribs = ? where variation_id = ?]);
scripts/import/import_EPMC.pl:    my $varfeat_upd_sth = $dba->dbc()->prepare(qq[ update variation_feature set evidence_attribs = ? where variation_id = ?]);
scripts/import/import_EPMC.pl:    $ev_ext_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $dat =  $ev_ext_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:        next if defined $l->[1] && $l->[1] =~ /$attrib->[0]->[0]/;
scripts/import/import_EPMC.pl:        if(defined $l->[1] && $l->[1] =~ /\w+/){
scripts/import/import_EPMC.pl:            $evidence .= "$l->[1],$attrib->[0]->[0]";
scripts/import/import_EPMC.pl:            $evidence = "$attrib->[0]->[0]";
scripts/import/import_EPMC.pl:        $var_upd_sth->execute($evidence, $l->[0]);
scripts/import/import_EPMC.pl:        $varfeat_upd_sth->execute($evidence, $l->[0]);
scripts/import/import_EPMC.pl:    my $dup1_ext_sth = $dba->dbc->prepare(qq[ select p1.publication_id, p2.publication_id, p2.pmid
scripts/import/import_EPMC.pl:    my $dup2_ext_sth = $dba->dbc->prepare(qq[ select p1.publication_id, p2.publication_id, p2.pmcid
scripts/import/import_EPMC.pl:   my $dup3_ext_sth = $dba->dbc->prepare(qq[ select p1.publication_id, p2.publication_id, p2.doi
scripts/import/import_EPMC.pl:    my $dup4_ext_sth = $dba->dbc->prepare(qq[ select title, authors, count(*)
scripts/import/import_EPMC.pl:    my $fail_ext_sth = $dba->dbc->prepare(qq[ select count(*) from publication
scripts/import/import_EPMC.pl:    $dup1_ext_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $dup1 = $dup1_ext_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    my $duplicated_pub = $dup1->[0]->[0];
scripts/import/import_EPMC.pl:    $dup2_ext_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $dup2 = $dup2_ext_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    my $duplicated_pub2 = $dup2->[0]->[0];
scripts/import/import_EPMC.pl:    $dup3_ext_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $dup3 = $dup3_ext_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    my $duplicated_pub3 = $dup3->[0]->[0];
scripts/import/import_EPMC.pl:    $dup4_ext_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $dup4 = $dup4_ext_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    my $duplicated_pub4 = $dup4->[0]->[0];
scripts/import/import_EPMC.pl:    $fail_ext_sth->execute() ||die;
scripts/import/import_EPMC.pl:    my $fail = $fail_ext_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    $title_null = $fail->[0]->[0]; 
scripts/import/import_EPMC.pl:        print $report "$l->[0]\t$l->[1]\t$l->[2]\n";
scripts/import/import_EPMC.pl:        print $report "$k->[0]\t$k->[1]\t$k->[2]\n";
scripts/import/import_EPMC.pl:        print $report "$m->[0]\t$m->[1]\t$m->[2]\n";
scripts/import/import_EPMC.pl:        print $report "$i->[0]\t$i->[1]\t$i->[2]\n"; 
scripts/import/import_EPMC.pl:    print $report "\n$title_null publications without a title - to be deleted\n";
scripts/import/import_EPMC.pl:    my $meta_ins_sth = $dba->dbc->prepare(qq[ insert ignore into meta
scripts/import/import_EPMC.pl:    $meta_ins_sth->execute($type . "_citation_update", run_date() );
scripts/import/import_EPMC.pl:    my $title_sth = $dba->dbc->prepare(qq[ select publication_id, title from publication where title like '\[%' and (title like '%\]' or title like '%\.\]' or title like '%\]\.') ]);
scripts/import/import_EPMC.pl:    my $title_cr_sth = $dba->dbc->prepare(qq[ select publication_id, title from publication where title like '%\n%' ]);
scripts/import/import_EPMC.pl:    my $authors_cr_sth = $dba->dbc->prepare(qq[ select publication_id, authors from publication where authors like '%\n%' ]);
scripts/import/import_EPMC.pl:    my $title_hex_char_sth = $dba->dbc->prepare(qq[ select publication_id, title from publication where title like '%&#x%' ]);
scripts/import/import_EPMC.pl:    my $authors_hex_char_sth = $dba->dbc->prepare(qq[ select publication_id, authors from publication where authors like '%&#x%' ]);
scripts/import/import_EPMC.pl:    my $wrong_title_sth = $dba->dbc->prepare(qq[ select publication_id, title from publication where title like '%Errata%'
scripts/import/import_EPMC.pl:    my $empty_sth = $dba->dbc->prepare(qq[ select publication_id, title from publication where (authors = '' or authors is null) and pmid is null and pmcid is null ]);
scripts/import/import_EPMC.pl:    $title_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $title_brackets = $title_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    $title_cr_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $get_title_cr = $title_cr_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    my $title_cr = $get_title_cr->[0]->[0];
scripts/import/import_EPMC.pl:    $authors_cr_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $get_authors_cr = $authors_cr_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    my $authors_cr = $get_authors_cr->[0]->[0];
scripts/import/import_EPMC.pl:    $title_hex_char_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $get_title_hex_char = $title_hex_char_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    my $title_hex_char = $get_title_hex_char->[0]->[0];
scripts/import/import_EPMC.pl:    $authors_hex_char_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $get_authors_hex_char = $authors_hex_char_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    my $authors_hex_char = $get_authors_hex_char->[0]->[0];
scripts/import/import_EPMC.pl:    $wrong_title_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $wrong_title = $wrong_title_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    $empty_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $empty_fields = $empty_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    if (defined $title_brackets->[0]->[0]){
scripts/import/import_EPMC.pl:      print $report "Publications with brackets in the title - clean the brackets:\n";
scripts/import/import_EPMC.pl:        my $pub_id = $l->[0];
scripts/import/import_EPMC.pl:        my $title = $l->[1];
scripts/import/import_EPMC.pl:        my $pub_clean_sth = $dba->dbc()->prepare(qq[ update publication set title = ? where publication_id = $pub_id ]);
scripts/import/import_EPMC.pl:        $pub_clean_sth->execute($title);
scripts/import/import_EPMC.pl:      print $report "\nPublications with carriage return in the title - clean:\n";
scripts/import/import_EPMC.pl:        my $pub_id = $t_cr->[0];
scripts/import/import_EPMC.pl:        my $title = $t_cr->[1];
scripts/import/import_EPMC.pl:        my $clean_title_sth = $dba->dbc()->prepare(qq[ update publication set title = ? where publication_id = $pub_id ]);
scripts/import/import_EPMC.pl:        $clean_title_sth->execute($title);
scripts/import/import_EPMC.pl:      print $report "\nPublications with carriage return in the authors - clean:\n";
scripts/import/import_EPMC.pl:        my $pub_id = $a_cr->[0];
scripts/import/import_EPMC.pl:        my $authors = $a_cr->[1];
scripts/import/import_EPMC.pl:        my $clean_authors_sth = $dba->dbc()->prepare(qq[ update publication set authors = ? where publication_id = $pub_id ]);
scripts/import/import_EPMC.pl:        $clean_authors_sth->execute($authors);
scripts/import/import_EPMC.pl:      print $report "\nPublications with hexadecimal characters in the title - clean:\n";
scripts/import/import_EPMC.pl:        my $pub_id = $t_hex_char->[0];
scripts/import/import_EPMC.pl:        my $title = $t_hex_char->[1];
scripts/import/import_EPMC.pl:          my $clean_title_sth = $dba->dbc()->prepare(qq[ update publication set title = ? where publication_id = $pub_id ]);
scripts/import/import_EPMC.pl:          $clean_title_sth->execute($new_title);
scripts/import/import_EPMC.pl:      print $report "\nPublications with hexadecimal characters in the authors - clean:\n";
scripts/import/import_EPMC.pl:        my $pub_id = $a_hex_char->[0];
scripts/import/import_EPMC.pl:        my $authors = $a_hex_char->[1];
scripts/import/import_EPMC.pl:          my $clean_authors_sth = $dba->dbc()->prepare(qq[ update publication set authors = ? where publication_id = $pub_id ]);
scripts/import/import_EPMC.pl:          $clean_authors_sth->execute($new_authors);
scripts/import/import_EPMC.pl:    if(defined $wrong_title->[0]->[0]){
scripts/import/import_EPMC.pl:      my $title_null_sth = $dba->dbc->prepare(qq[ select publication_id, pmid from publication where title is null or title = '' ]);
scripts/import/import_EPMC.pl:      $title_null_sth->execute();
scripts/import/import_EPMC.pl:      my $titles_null = $title_null_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:      if(defined $titles_null->[0]->[0]){
scripts/import/import_EPMC.pl:    if(defined $empty_fields->[0]->[0]){
scripts/import/import_EPMC.pl:    my $pub_id = $p->[0];
scripts/import/import_EPMC.pl:    my $title = $p->[1];
scripts/import/import_EPMC.pl:    my $var_id_sth = $dba->dbc->prepare(qq[ select variation_id from variation_citation where publication_id = $pub_id ]);
scripts/import/import_EPMC.pl:    $var_id_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $get_variation_ids = $var_id_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    my $variation_ids = $get_variation_ids->[0];
scripts/import/import_EPMC.pl:        my $failed_var_sth = $dba->dbc->prepare(qq[ select failed_variation_id from failed_variation where variation_id = $var_id ]);
scripts/import/import_EPMC.pl:        $failed_var_sth->execute()||die;
scripts/import/import_EPMC.pl:        my $get_failed_variant = $failed_var_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:        my $failed_variant = $get_failed_variant->[0]->[0];
scripts/import/import_EPMC.pl:        my $citation_delete_sth = $dba->dbc()->prepare(qq[ delete from variation_citation where publication_id = $pub_id ]);
scripts/import/import_EPMC.pl:        my $pub_delete_sth = $dba->dbc()->prepare(qq[ delete from publication where publication_id = $pub_id ]);
scripts/import/import_EPMC.pl:        $citation_delete_sth->execute();
scripts/import/import_EPMC.pl:        $pub_delete_sth->execute();
scripts/import/import_EPMC.pl:          my $other_publications_sth = $dba->dbc->prepare(qq[ select variation_id,publication_id from variation_citation where variation_id = $var_id ]);
scripts/import/import_EPMC.pl:          $other_publications_sth->execute()||die;
scripts/import/import_EPMC.pl:          my $other_publications = $other_publications_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:          next unless (!defined $other_publications->[0]->[0]); 
scripts/import/import_EPMC.pl:          my $check_phenotype_sth = $dba->dbc->prepare(qq[ select phenotype_feature_id from phenotype_feature where object_id = $var_id ]);
scripts/import/import_EPMC.pl:          $check_phenotype_sth->execute()||die;
scripts/import/import_EPMC.pl:          my $phenotype_var = $check_phenotype_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:          next unless (!defined $phenotype_var->[0]->[0]); 
scripts/import/import_EPMC.pl:          my $update_display_var_sth = $dba->dbc->prepare(qq[ update variation set display = 0 where variation_id = $var_id ]); 
scripts/import/import_EPMC.pl:          my $update_display_vf_sth = $dba->dbc->prepare(qq[ update variation_feature set display = 0 where variation_id = $var_id ]);      
scripts/import/import_EPMC.pl:          $update_display_var_sth->execute()||die;
scripts/import/import_EPMC.pl:          $update_display_vf_sth->execute()||die;
scripts/import/import_EPMC.pl:        my $other_pubs_sth = $dba->dbc->prepare(qq[ select publication_id from variation_citation where variation_id = $var_id ]);
scripts/import/import_EPMC.pl:        $other_pubs_sth->execute()||die;
scripts/import/import_EPMC.pl:        my $other_pubs = $other_pubs_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:        next unless (!defined $other_pubs->[0]->[0]);
scripts/import/import_EPMC.pl:        my $get_attrib_sth = $dba->dbc->prepare(qq[ select attrib_id from attrib where value = 'Cited' ]);
scripts/import/import_EPMC.pl:        $get_attrib_sth->execute()||die;
scripts/import/import_EPMC.pl:        my $get_attrib = $get_attrib_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:        my $attrib = $get_attrib->[0]->[0];
scripts/import/import_EPMC.pl:        my $update_evidence_sth = $dba->dbc->prepare(qq[ update variation set evidence_attribs = NULLIF(TRIM(BOTH ',' FROM REPLACE(CONCAT(',', evidence_attribs, ','), ',$attrib,', ',')), '') WHERE variation_id = $var_id ]);
scripts/import/import_EPMC.pl:        my $update_evidence_vf_sth = $dba->dbc->prepare(qq[ update variation_feature set evidence_attribs = NULLIF(TRIM(BOTH ',' FROM REPLACE(CONCAT(',', evidence_attribs, ','), ',$attrib,', ',')), '') WHERE variation_id = $var_id ]);
scripts/import/import_EPMC.pl:        $update_evidence_sth->execute()||die;
scripts/import/import_EPMC.pl:        $update_evidence_vf_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $dbh = DBI->connect('dbi:mysql:hgFixed:genome-mysql.cse.ucsc.edu:3306:max_allowed_packet=1MB', 'genome', '', undef);
scripts/import/import_EPMC.pl:    my $cit_ext_sth = $dbh->prepare(qq[ SELECT pma.markerId, pa.pmid, pma.section, pa.doi, pa.title, pa.authors, pa.year, pa.extId
scripts/import/import_EPMC.pl:    $cit_ext_sth->execute()||die;
scripts/import/import_EPMC.pl:    while( my $line = $cit_ext_sth->fetchrow_arrayref()){
scripts/import/import_EPMC.pl:        next if $line->[6] < 1999;             ## pre-dbSNP - must be random match
scripts/import/import_EPMC.pl:        next if $line->[7] eq "PMC$line->[1]"; ## incorrect/ missing PMID 
scripts/import/import_EPMC.pl:        next if $line->[4] eq "NotFound" || $line->[4] eq "TOC" || $line->[4] eq "Highlights"
scripts/import/import_EPMC.pl:            || $line->[4]  eq "Contents" || $line->[4] eq "Table of Contents" || $line->[4]  eq "Volume Contents"
scripts/import/import_EPMC.pl:            || $line->[4]  eq "Cannabis" || $line->[4] eq "Index"  || $line->[4] eq "Author Index"
scripts/import/import_EPMC.pl:            || $line->[4]  =~/This Issue/i      || $line->[4]  =~/This Month in/
scripts/import/import_EPMC.pl:            || $line->[4] eq "Ensembl 2011";
scripts/import/import_EPMC.pl:         if ( $avoid_list->{$rs}->{$pmid}){
scripts/import/import_EPMC.pl:    my $cit_ext_sth = $dba->dbc()->prepare(qq[ select variation.name, publication.pmid, variation_citation.data_source_attrib
scripts/import/import_EPMC.pl:    $cit_ext_sth->execute()||die;
scripts/import/import_EPMC.pl:    my $data =  $cit_ext_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:        $citations{$l->[0]}{$l->[1]} = $l->[2] if defined $l->[1];
scripts/import/import_EPMC.pl:  my $pheno_citations_sth = $dba->dbc()->prepare(qq[ select s.study_id, s.source_id, s.external_reference, s.study_type, p.object_id
scripts/import/import_EPMC.pl:  $pheno_citations_sth->execute()||die;
scripts/import/import_EPMC.pl:  my $data = $pheno_citations_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    my $source_id = $pheno_data->[1];
scripts/import/import_EPMC.pl:    my $study_type = $pheno_data->[3];
scripts/import/import_EPMC.pl:      my $source_obj = $source_ad->fetch_by_dbID($source_id);
scripts/import/import_EPMC.pl:      my $source_name = $source_obj->name();
scripts/import/import_EPMC.pl:      my $source_attrib_id = $citation_attribs->{$source_name};
scripts/import/import_EPMC.pl:    my $study_id = $l->[0];
scripts/import/import_EPMC.pl:    my $source_id = $l->[1];
scripts/import/import_EPMC.pl:    my $external_reference = $l->[2];
scripts/import/import_EPMC.pl:    my $study_type = $l->[3];
scripts/import/import_EPMC.pl:    my $rsid = $l->[4];
scripts/import/import_EPMC.pl:    # Get attrib id for source - some are null 
scripts/import/import_EPMC.pl:      $source_attrib_id = $citation_attribs->{$study_type};
scripts/import/import_EPMC.pl:  my $pheno_feature_sth = $dba->dbc()->prepare(qq[ select pfa.phenotype_feature_id, pfa.value, pf.source_id, pf.object_id
scripts/import/import_EPMC.pl:  $pheno_feature_sth->execute()||die;
scripts/import/import_EPMC.pl:  my $pheno_feature_data = $pheno_feature_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    my $source_id = $pheno_feat_data->[2];
scripts/import/import_EPMC.pl:      my $source_obj = $source_ad->fetch_by_dbID($source_id);
scripts/import/import_EPMC.pl:      my $source_name = $source_obj->name();
scripts/import/import_EPMC.pl:      my $source_attrib_id = $citation_attribs->{$source_name};
scripts/import/import_EPMC.pl:    # my $pheno_feat_id = $pheno_feat_data->[0];
scripts/import/import_EPMC.pl:    my $value_pubid = $pheno_feat_data->[1];
scripts/import/import_EPMC.pl:    my $source_id = $pheno_feat_data->[2];
scripts/import/import_EPMC.pl:    my $var_name = $pheno_feat_data->[3];
scripts/import/import_EPMC.pl:      # PMID=25806919 is already in the publication table - faster to skip this PMID and avoid duplicated data
scripts/import/import_EPMC.pl:  # get all citations from the sources 'ClinVar', 'dbGaP' and 'GWAS' - imported from the phenotype tables
scripts/import/import_EPMC.pl:  my $attrib_id_clinvar = $citation_attribs->{'ClinVar'};
scripts/import/import_EPMC.pl:  my $attrib_id_gwas = $citation_attribs->{'GWAS'};
scripts/import/import_EPMC.pl:  my $attrib_id_dbgap = $citation_attribs->{'dbGaP'};
scripts/import/import_EPMC.pl:  my $citations_sth = $dba->dbc()->prepare(qq[ select variation_id, publication_id, data_source_attrib
scripts/import/import_EPMC.pl:  $citations_sth->execute()||die;
scripts/import/import_EPMC.pl:  my $citations_data = $citations_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:    my $variation_id = $c->[0];
scripts/import/import_EPMC.pl:    my $publication_id = $c->[1];
scripts/import/import_EPMC.pl:    my $attrib_id = $c->[2];
scripts/import/import_EPMC.pl:    my $variation = $var_ad->fetch_by_dbID($variation_id);
scripts/import/import_EPMC.pl:    my $publication = $pub_ad->fetch_by_dbID($publication_id);
scripts/import/import_EPMC.pl:    my $variation_rsid = $variation->name();
scripts/import/import_EPMC.pl:    my $publication_pmid = $publication->pmid();
scripts/import/import_EPMC.pl:      print $wrt "$variation_rsid\t$publication_pmid\t$attrib\n" unless ($citations_pheno_feature->{$attrib.'_'.$publication_pmid} || $citations_pheno_feature_attrib->{$attrib.'_'.$publication_pmid});
scripts/import/import_EPMC.pl:  my $attrib_value_sth = $dba->dbc()->prepare(qq[ SELECT a.attrib_id, a.value FROM attrib a
scripts/import/import_EPMC.pl:  $attrib_value_sth->execute();
scripts/import/import_EPMC.pl:  my $citation_attribs = $attrib_value_sth->fetchall_arrayref();
scripts/import/import_EPMC.pl:  die "No attribute of type 'citation_source' was found in attrib table!\n" unless defined $citation_attribs->[0];
scripts/import/import_EPMC.pl:    my $id = $data->[0];
scripts/import/import_EPMC.pl:    my $name = $data->[1];
scripts/import/import_EPMC.pl:    die "\n\tUsage: import_EPMC.pl -type [ EPMC or UCSC or phenotype] -species [name] -registry [registry file]
scripts/import/import_EPMC.pl:          -data [file of citations]   - *required* for EPMC import
scripts/import/import_EPMC.pl:          -check_dbSNP [0/1]          - add detail to citations from dbSNP import (default:1)
scripts/import/import_EPMC.pl:          -clean [0/1]                - clean publications after import (default:0)
scripts/import/import_EPMC.pl:          -no_evidence                - don't update variation & variation_feature evidence statuses\n\n";
scripts/import/dump_strain_seq_1kg.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/dump_strain_seq_1kg.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/dump_strain_seq_1kg.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/dump_strain_seq_1kg.pl:# IMPORTANT - MAKE SURE YOUR REGISTRY IS POINTING TO THE CORRECT DATABASES!!!
scripts/import/dump_strain_seq_1kg.pl:#Bio::EnsEMBL::Registry->load_registry_from_db( -host => 'ens-staging',
scripts/import/dump_strain_seq_1kg.pl:#                                               -db_version => $new_db_version,
scripts/import/dump_strain_seq_1kg.pl:#                                               -user => 'ensro',
scripts/import/dump_strain_seq_1kg.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/dump_strain_seq_1kg.pl:my $dbVar = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/dump_strain_seq_1kg.pl:my $dbCore = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/dump_strain_seq_1kg.pl:my $slice_adaptor = $dbCore->get_SliceAdaptor();
scripts/import/dump_strain_seq_1kg.pl:my $rc_adaptor = $dbVar->get_ReadCoverageAdaptor();
scripts/import/dump_strain_seq_1kg.pl:my $ind_adaptor = $dbVar->get_IndividualAdaptor();
scripts/import/dump_strain_seq_1kg.pl:m 1 v 1 n 1 h 1 r 1 d 1 w 1 s 1 b 1 y 1 k 1 c 1 a 1 t 1 g 1 - 1);
scripts/import/dump_strain_seq_1kg.pl:my $levels = $rc_adaptor->get_coverage_levels();
scripts/import/dump_strain_seq_1kg.pl:my $strains = $ind_adaptor->fetch_all_strains_with_coverage();
scripts/import/dump_strain_seq_1kg.pl:    @{$strains} = grep {$_->name eq 'SD'} @{$strains};
scripts/import/dump_strain_seq_1kg.pl:    @{$strains} = grep {$_->name =~ /1KG\_NA\d+|Venter|Watson/i} @{$strains};
scripts/import/dump_strain_seq_1kg.pl:my $slice = $slice_adaptor->fetch_by_region('chromosome',$region);
scripts/import/dump_strain_seq_1kg.pl:my $end   = $start + $chunk_size -1;
scripts/import/dump_strain_seq_1kg.pl:$end = $slice->length if($end > $slice->length);
scripts/import/dump_strain_seq_1kg.pl:while($start <= $slice->length) {
scripts/import/dump_strain_seq_1kg.pl:    my $subSlice = $slice->sub_Slice($start, $end);
scripts/import/dump_strain_seq_1kg.pl:    $end = $start + $chunk_size -1;
scripts/import/dump_strain_seq_1kg.pl:    $end = $slice->length if($end > $slice->length);
scripts/import/dump_strain_seq_1kg.pl:	    # allow "normal" i.e. non-1KG individual
scripts/import/dump_strain_seq_1kg.pl:	    if ($strain->name !~ /^1KG/ and $level <3) {
scripts/import/dump_strain_seq_1kg.pl:		$rcs = $rc_adaptor->fetch_all_by_Slice_Sample_depth($slice,$strain,$level);
scripts/import/dump_strain_seq_1kg.pl:	    elsif ($strain->name =~ /^1KG/ and $level >2) {
scripts/import/dump_strain_seq_1kg.pl:		$rcs = $rc_adaptor->fetch_all_by_Slice_Sample_depth($slice,$strain,$level);
scripts/import/dump_strain_seq_1kg.pl:		    $strain_seq{$strain->name}{$pos} = $pos_level{$pos};
scripts/import/dump_strain_seq_1kg.pl:	&apply_AF_to_seq($slice,$strain->name,\$seq);
scripts/import/dump_strain_seq_1kg.pl:	$strain_seq{$strain->name}{'seq'} = $seq;
scripts/import/dump_strain_seq_1kg.pl:    my $strainSlice = $slice->get_by_strain($strain);
scripts/import/dump_strain_seq_1kg.pl:    my $afs = $strainSlice->get_all_AlleleFeatures_Slice();#get rid of 1 as level
scripts/import/dump_strain_seq_1kg.pl:	my $format = "@" . ($af->start-1) . "A" . ($af->end - $af->start +1);
scripts/import/dump_strain_seq_1kg.pl:	$allele = ambiguity_code($af->allele_string);
scripts/import/dump_strain_seq_1kg.pl:	if ($base =~ /[A-Z]/) {
scripts/import/dump_strain_seq_1kg.pl:	    substr($$ref_seq,$af->start-1,$af->end - $af->start + 1,uc($allele) . '*' x ($af->end - $af->start)) if ($allele ne '-');
scripts/import/dump_strain_seq_1kg.pl:	    substr($$ref_seq,$af->start-1,$af->end - $af->start + 1,'*' x ($af->end - $af->start +1 )) if ($allele eq '-');
scripts/import/dump_strain_seq_1kg.pl:	if ($base =~ /[a-z]/) {
scripts/import/dump_strain_seq_1kg.pl:	    #if it is a deletion, use the '-' to mean it is covered by 1 read
scripts/import/dump_strain_seq_1kg.pl:	    substr($$ref_seq,$af->start-1,$af->end - $af->start + 1,lc($allele) . '-' x ($af->end - $af->start)) if ($allele ne '-');
scripts/import/dump_strain_seq_1kg.pl:	    substr($$ref_seq,$af->start-1,$af->end - $af->start + 1,'-' x ($af->end - $af->start + 1)) if ($allele eq '-');
scripts/import/dump_strain_seq_1kg.pl:    my @ref_seq = split//,$slice->seq;
scripts/import/dump_strain_seq_1kg.pl:      push @{$strain_array[$index_strain]},split //,$strain_seq->{$strain->name}{'seq'};
scripts/import/dump_strain_seq_1kg.pl:      $rec{$strain_array[$index_strain]} = $strain->name;#keep same name-seq order by use array rather than hash
scripts/import/dump_strain_seq_1kg.pl:	#NB we have to adjust $i to $i+1 for the 1KG individuals as the RC-level data positions are recorded 1-indexed
scripts/import/dump_strain_seq_1kg.pl:	#instead of 0-indexed as the sequence etc is
scripts/import/dump_strain_seq_1kg.pl:			    $strain_reads .= ($_->[$i] eq '~') ? '0'.' ' : 
scripts/import/dump_strain_seq_1kg.pl:				($strain_seq->{$rec{$_}}{$i+1}) ? $strain_seq->{$rec{$_}}{$i+1}.' ' : $read_code{$_->[$i]}.' ';
scripts/import/dump_strain_seq_1kg.pl:			    ($_->[$i] eq '*') ? '-' : uc($_->[$i])
scripts/import/dump_strain_seq_1kg.pl:    $$ref_seq .= '~' x ($slice->end - $slice->start + 1) if length($$ref_seq) == 0;
scripts/import/dump_strain_seq_1kg.pl:	$rc->start(1) if ($rc->start <= 0);
scripts/import/dump_strain_seq_1kg.pl:	$rc->end($slice->end - $slice->start + 1) if ($rc->end + $slice->start > $slice->end);
scripts/import/dump_strain_seq_1kg.pl:	$format = '@' . ($rc->start - 1) . 'A' . ($rc->end - $rc->start + 1);
scripts/import/dump_strain_seq_1kg.pl:	if($rc->level == 1 or $rc->level >2) {
scripts/import/dump_strain_seq_1kg.pl:	    # lower-case formatted chunk from the slice sequence
scripts/import/dump_strain_seq_1kg.pl:	    substr($$ref_seq, $rc->start - 1, $rc->end - $rc->start + 1) = lc(unpack($format,$slice->seq));
scripts/import/dump_strain_seq_1kg.pl:	if($rc->level == 2 or $rc->level > 3) {
scripts/import/dump_strain_seq_1kg.pl:	    substr($$ref_seq, $rc->start - 1, $rc->end - $rc->start + 1) = uc(unpack($format,$slice->seq));
scripts/import/dump_strain_seq_1kg.pl:	# record each position covered at this level - NB these are 1-indexed, not 0-indexed
scripts/import/dump_strain_seq_1kg.pl:	for my $i($rc->start..$rc->end) {
scripts/import/dump_strain_seq_1kg.pl:	    $pos_level{$i} = $rc->level;
scripts/import/dump_strain_seq_1kg.pl:    print DUMP "SEQ $species reference ", $slice->seq_region_name," ",$slice->start," ",$slice->end," ",$slice->strand,"\n";
scripts/import/dump_strain_seq_1kg.pl:	print DUMP "SEQ $species ",$strain->name, " WGS\n";
scripts/import/dump_strain_seq_1kg.pl:	print DUMP "SCORE aligned ",$strain->name, " reads\n";
scripts/import/dump_strain_seq_1kg.pl:    my $range_registry = Bio::EnsEMBL::Mapper::RangeRegistry->new();
scripts/import/dump_strain_seq_1kg.pl:	my $rcs = $rc_adaptor->fetch_all_by_Slice_Sample_depth($slice,$strain);#delete 1 here to get data for all levels
scripts/import/dump_strain_seq_1kg.pl:	    $range_registry->check_and_register(1,$rc->start,$rc->end);
scripts/import/dump_strain_seq_1kg.pl:    print DUMP "##RELEASE ",Bio::EnsEMBL::Registry->software_version(),"\n\n";
scripts/import/dump_strain_seq_1kg.pl:    print DUMP "# 3: 0-5x               (1000 Genomes)\n";
scripts/import/dump_strain_seq_1kg.pl:    print DUMP "# 4: 6-25x              (1000 Genomes)\n";
scripts/import/dump_strain_seq_1kg.pl:    -dump_file <filename>    file where you want to dump the resequencing data
scripts/import/dump_strain_seq_1kg.pl:    -species   <species>     species you want to dump data (default = mouse)
scripts/import/dump_strain_seq_1kg.pl:    -region    <region_name> region to dump the data
scripts/import/dump_strain_seq_1kg.pl:    -chunk     <chunk_size>  size of chunks (default = 100kb)
scripts/import/compress_genotypes_by_var.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/compress_genotypes_by_var.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/compress_genotypes_by_var.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/compress_genotypes_by_var.pl:usage('-TMP_DIR argument is required') if(!$TMP_DIR);
scripts/import/compress_genotypes_by_var.pl:usage('-TMP_FILE argument is required') if(!$TMP_FILE);
scripts/import/compress_genotypes_by_var.pl:usage('-species argument is required') if(!$species);
scripts/import/compress_genotypes_by_var.pl:$reg->load_all( $registry_file );
scripts/import/compress_genotypes_by_var.pl:#$reg->set_reconnect_when_lost();
scripts/import/compress_genotypes_by_var.pl:my $vdba = $reg->get_DBAdaptor($species,'variation');
scripts/import/compress_genotypes_by_var.pl:my $dbCore = $reg->get_DBAdaptor($species,'core');
scripts/import/compress_genotypes_by_var.pl:my $dbVar = $vdba->dbc->db_handle;
scripts/import/compress_genotypes_by_var.pl:my $desc_sth = $dbVar->prepare("SHOW CREATE TABLE $genotype_table");
scripts/import/compress_genotypes_by_var.pl:$desc_sth->execute();
scripts/import/compress_genotypes_by_var.pl:$desc_sth->bind_columns(\$tmp_table, \$create_sql);
scripts/import/compress_genotypes_by_var.pl:$desc_sth->fetch();
scripts/import/compress_genotypes_by_var.pl:	debug("Specified genotype table looks like a MRG_MyISAM table - forcing --straight");
scripts/import/compress_genotypes_by_var.pl:		debug("Sorting tables - this may take a while!");
scripts/import/compress_genotypes_by_var.pl:				$dbVar->do("ALTER TABLE $sub_table ORDER BY variation_id, subsnp_id");
scripts/import/compress_genotypes_by_var.pl:my $gca = $reg->get_adaptor($species, 'variation', 'genotypecode');
scripts/import/compress_genotypes_by_var.pl:my %codes = map {(join "|", @{$_->genotype}) => $_->dbID} @{$gca->fetch_all()};
scripts/import/compress_genotypes_by_var.pl:my $max_code = (sort {$a <=> $b} values %codes)[-1] || 0;
scripts/import/compress_genotypes_by_var.pl:	my $sth1 = $dbVar->prepare(qq{SELECT max(variation_id) from $genotype_table});
scripts/import/compress_genotypes_by_var.pl:	$sth1->execute;
scripts/import/compress_genotypes_by_var.pl:	$sth1->bind_columns(\$max_var_id);
scripts/import/compress_genotypes_by_var.pl:	$sth1->fetch;
scripts/import/compress_genotypes_by_var.pl:	$sth1->finish;
scripts/import/compress_genotypes_by_var.pl:		$sth = $dbVar->prepare(qq{
scripts/import/compress_genotypes_by_var.pl:		my $sth3 = $dbVar->prepare(qq{SELECT count(*) from $genotype_table});
scripts/import/compress_genotypes_by_var.pl:		$sth3->execute;
scripts/import/compress_genotypes_by_var.pl:		$sth3->bind_columns(\$row_count);
scripts/import/compress_genotypes_by_var.pl:		$sth3->fetch;
scripts/import/compress_genotypes_by_var.pl:		$sth3->finish;
scripts/import/compress_genotypes_by_var.pl:		$dbVar->do(qq{
scripts/import/compress_genotypes_by_var.pl:		$sth = $dbVar->prepare(qq{
scripts/import/compress_genotypes_by_var.pl:			$dbVar->do(qq{TRUNCATE $tmp_var_table});
scripts/import/compress_genotypes_by_var.pl:			print TMP_VAR "$_\n" for ($low..($low+$jump)-1);
scripts/import/compress_genotypes_by_var.pl:		$sth->execute();#$low, $low+$jump);
scripts/import/compress_genotypes_by_var.pl:		$sth->bind_columns(\$var_id, \$ss_id, \$allele_1, \$allele_2, \$sample_id);
scripts/import/compress_genotypes_by_var.pl:		while ($sth->fetch){
scripts/import/compress_genotypes_by_var.pl:				my $flipped = $flipped_status->{$var_id};
scripts/import/compress_genotypes_by_var.pl:		$sth->finish();
scripts/import/compress_genotypes_by_var.pl:	$dbVar->do(qq{DROP TABLE $tmp_var_table}) unless defined($straight);
scripts/import/compress_genotypes_by_var.pl:	my $sth = $dbVar->prepare("INSERT INTO genotype_code (genotype_code_id, allele_code_id,  haplotype_id) VALUES(?, ?, ?)");
scripts/import/compress_genotypes_by_var.pl:		$sth->execute($gt_code, $allele_code, $hap_id++);
scripts/import/compress_genotypes_by_var.pl:	$sth->finish;
scripts/import/compress_genotypes_by_var.pl:	my $sth = $dbVar->prepare("SELECT allele_code_id FROM allele_code WHERE allele = ?");
scripts/import/compress_genotypes_by_var.pl:	$sth->execute($allele);
scripts/import/compress_genotypes_by_var.pl:	$sth->bind_columns(\$allele_code);
scripts/import/compress_genotypes_by_var.pl:	$sth->fetch();
scripts/import/compress_genotypes_by_var.pl:	$sth->finish();
scripts/import/compress_genotypes_by_var.pl:		$sth = $dbVar->prepare("INSERT INTO allele_code(allele) VALUES(?)");
scripts/import/compress_genotypes_by_var.pl:		$sth->execute($allele);
scripts/import/compress_genotypes_by_var.pl:		$sth->finish();
scripts/import/compress_genotypes_by_var.pl:		$allele_code = $dbVar->last_insert_id(undef, undef, qw(allele_code allele_code_id));
scripts/import/compress_genotypes_by_var.pl:	my $sth = $dbVar->prepare(qq{
scripts/import/compress_genotypes_by_var.pl:	$sth->execute;
scripts/import/compress_genotypes_by_var.pl:	$sth->bind_columns(\$var_id, \$flipped);
scripts/import/compress_genotypes_by_var.pl:	while($sth->fetch()) {
scripts/import/compress_genotypes_by_var.pl:	$sth->finish();
scripts/import/compress_genotypes_by_var.pl:	-tmpdir <dir>            temp directory to use (with lots of space!)
scripts/import/compress_genotypes_by_var.pl:	-tmpfile <filename>      name of temp file to use
scripts/import/compress_genotypes_by_var.pl:	-registry <file>         registry file
scripts/import/compress_genotypes_by_var.pl:	-species <species_name>  name of species
scripts/import/compress_genotypes_by_var.pl:	-table                   name of table to get genotypes from
scripts/import/compress_genotypes_by_var.pl:	-variation_id            variation_id to restart broken process from
scripts/import/compress_genotypes_by_var.pl:	-flip                    flip genotypes according to flipped column in variation table
scripts/import/compress_genotypes_by_var.pl:	-monoploid               indicate this species is monoploid
scripts/import/compress_genotypes_by_var.pl:    my $numblobs = (($i/$total) * $width) - 2;
scripts/import/compress_genotypes_by_var.pl:    printf("\r% -${width}s% 1s% 10s", '['.('=' x $numblobs).($numblobs == $width - 2 ? '=' : '>'), ']', "[ " . $percent . "% ]");
scripts/import/compress_genotypes_by_var.pl:        ($time[5] + 1900)."-".
scripts/import/compress_genotypes_by_var.pl:        $time[4]."-".
scripts/import/compress_genotypes_by_var.pl:    print $time." - ".$text.($text =~ /\n$/ ? "" : "\n");
scripts/import/var_db_check.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/var_db_check.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/var_db_check.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/var_db_check.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/var_db_check.pl:my $cdba = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/var_db_check.pl:my $vdba = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/var_db_check.pl:my $dbVar = $vdba->dbc;
scripts/import/var_db_check.pl:my $vdbname = $dbVar->dbname;
scripts/import/var_db_check.pl:my $sr_ref = $dbCore->dbc->db_handle->selectall_arrayref(qq{select sra.seq_region_id from seq_region_attrib sra, attrib_type at where sra.attrib_type_id=at.attrib_type_id and at.name="Non Reference"});
scripts/import/var_db_check.pl:my %hap_seq_id = map {$_->[0],1} @$sr_ref;
scripts/import/var_db_check.pl:  #$dbVar->do(qq{create table varid_one_allele select variation_id, count(*) as count from (select variation_id,allele from allele group by variation_id,allele) as tmp_table group by variation_id having count =1});
scripts/import/var_db_check.pl:  #my $varid_ref = $dbVar->db_handle->selectall_arrayref(qq{select count(*) from varid_one_allele});
scripts/import/var_db_check.pl:  #my $count = $varid_ref->[0][0];
scripts/import/var_db_check.pl:  my $sth = $dbVar->prepare(qq{select a.*,vf.allele_string from allele a, variation_feature vf where a.variation_id = vf.variation_id and vf.map_weight=1 $hap_line}, {mysql_use_result=>1});
scripts/import/var_db_check.pl:  $sth->execute();
scripts/import/var_db_check.pl:  $sth->bind_columns(\$allele_id,\$variation_id,\$subsnp_id,\$allele,\$frequency,\$sample_id,\$allele_string);
scripts/import/var_db_check.pl:  while($sth->fetch()) {
scripts/import/var_db_check.pl:    my $sth = $dbVar->prepare(qq{select gt.*, vf.allele_string, vf.seq_region_id from $table gt, variation_feature vf where gt.variation_id = vf.variation_id and vf.map_weight=1 $hap_line}, {mysql_use_result=>1});
scripts/import/var_db_check.pl:    $sth->execute();
scripts/import/var_db_check.pl:      $sth->bind_columns(\$population_genotype_id,\$variation_id,\$subsnp_id,\$allele_1,\$allele_2,\$frequency,\$sample_id,\$allele_string,\$seq_region_id);
scripts/import/var_db_check.pl:      $sth->bind_columns(\$variation_id,\$subsnp_id,\$allele_1,\$allele_2,\$sample_id,\$allele_string,\$seq_region_id);
scripts/import/var_db_check.pl:    LINE : while($sth->fetch()) {
scripts/import/var_db_check.pl:  my $sth = $dbVar->prepare(qq{select variation_id, allele_string from variation_feature where length(allele_string) - length(REPLACE(allele_string,'/','')) > 2}, {mysql_use_result=>1});  
scripts/import/var_db_check.pl:  $sth->execute();  
scripts/import/var_db_check.pl:  $sth->bind_columns(\$variation_id,\$allele_string);  
scripts/import/var_db_check.pl:  while($sth->fetch()) {
scripts/import/var_db_check.pl:  my $sth = $dbVar->prepare(qq{select allele_id,allele from $allele_table where allele like "%)%("}, {mysql_use_result=>1});
scripts/import/var_db_check.pl:  $sth->execute();
scripts/import/var_db_check.pl:  $sth->bind_columns(\$allele_id,\$allele);
scripts/import/var_db_check.pl:  while($sth->fetch()) {
scripts/import/var_db_check.pl:  my $sth = $dbVar->prepare(qq{select allele_id,allele,vf.allele_string from $allele_table a,variation_feature vf, varid_one_allele v where allele like "(%)%" and a.variation_id=v.variation_id and v.variation_id=vf.variation_id}, {mysql_use_result=>1});
scripts/import/var_db_check.pl:  $sth->execute();
scripts/import/var_db_check.pl:  $sth->bind_columns(\$allele_id,\$allele,\$allele_string);
scripts/import/var_db_check.pl:  while($sth->fetch()) {
scripts/import/var_db_check.pl:  #my $sth = $dbVar->prepare(qq{select allele_id,variation_id,allele,allele_string from $allele_table}, {mysql_use_result=>1});
scripts/import/var_db_check.pl:  my $sth = $dbVar->prepare(qq{select a.allele_id,v.variation_id,a.allele,vf.allele_string from $allele_table a,variation_feature vf, varid_one_allele v where allele like "(%)%" and a.variation_id=v.variation_id and v.variation_id=vf.variation_id}, {mysql_use_result=>1});
scripts/import/var_db_check.pl:  $sth->execute();
scripts/import/var_db_check.pl:  $sth->bind_columns(\$allele_id,\$variation_id,\$allele,\$allele_string);
scripts/import/var_db_check.pl:  while($sth->fetch()) {
scripts/import/var_db_check.pl:  #my $sth = $dbVar->prepare(qq{select allele_id,variation_id,allele,allele_string fro+m $allele_table}, {mysql_use_result=>1});  
scripts/import/var_db_check.pl:  my $sth = $dbVar->prepare(qq{select a.allele_id,v.variation_id,a.allele,vf.allele_string from $allele_table a,variation_feature vf, varid_one_allele v where allele like "(%)%" and a.variation_id=v.variation_id and v.variation_id=vf.variation_id}, {mysql_use_result=>1});
scripts/import/var_db_check.pl:  $sth->execute();
scripts/import/var_db_check.pl:  $sth->bind_columns(\$allele_id,\$variation_id,\$allele,\$allele_string);
scripts/import/var_db_check.pl:  while($sth->fetch()) {
scripts/import/var_db_check.pl:    my $sth1 = $dbCore->dbc->prepare(qq{SELECT sr.seq_region_id, sr.name
scripts/import/var_db_check.pl:    $sth1->execute();
scripts/import/var_db_check.pl:    while (my ($seq_reg_id,$name) = $sth1->fetchrow_array()) {
scripts/import/var_db_check.pl:    $dbVar->do(qq{DELETE FROM $table\_check WHERE $allele_column like "(%)"});
scripts/import/var_db_check.pl:    my $sth = $dbVar->prepare(qq{select v.* from $table\_check v}, {mysql_use_result=>1});
scripts/import/var_db_check.pl:    $sth->execute();
scripts/import/var_db_check.pl:      $sth->bind_columns(\$population_genotype_id,\$variation_id,\$ss_id,\$allele_1,\$allele_2,\$frequency,\$sample_id,\$allele_string,\$seq_region_id);
scripts/import/var_db_check.pl:      $sth->bind_columns(\$allele_id,\$variation_id,\$ss_id,\$allele,\$frequency,\$sample_id,\$allele_string);
scripts/import/var_db_check.pl:      $sth->bind_columns(\$variation_id,\$ss_id,\$allele_1,\$allele_2,\$sample_id,\$allele_string,\$seq_region_id);
scripts/import/var_db_check.pl:    LINE : while($sth->fetch()) {
scripts/import/var_db_check.pl:    my $sth1 = $dbCore->dbc->prepare(qq{SELECT sr.seq_region_id, sr.name
scripts/import/var_db_check.pl:    $sth1->execute();
scripts/import/var_db_check.pl:    while (my ($seq_reg_id,$name) = $sth1->fetchrow_array()) {
scripts/import/var_db_check.pl:    $dbVar->do(qq{DELETE FROM $vdbname\_$table\_$check WHERE $allele_column like "(%)"});
scripts/import/var_db_check.pl:    my $sth = $dbVar->prepare(qq{select v.* from $vdbname\_$table\_$check v where v.allele_2 != "R" and v.allele_2 != "Y"}, {mysql_use_result=>1});
scripts/import/var_db_check.pl:    $sth->execute();
scripts/import/var_db_check.pl:      $sth->bind_columns(\$population_genotype_id,\$variation_id,\$ss_id,\$allele_1,\$allele_2,\$frequency,\$sample_id,\$allele_string,\$seq_region_id);
scripts/import/var_db_check.pl:      $sth->bind_columns(\$allele_id,\$variation_id,\$ss_id,\$allele,\$frequency,\$sample_id,\$allele_string);
scripts/import/var_db_check.pl:      $sth->bind_columns(\$variation_id,\$ss_id,\$allele_1,\$allele_2,\$sample_id,\$allele_string,\$seq_region_id);
scripts/import/var_db_check.pl:    LINE : while($sth->fetch()) {
scripts/import/var_db_check.pl:        print FH $buffer->{ $file };
scripts/import/var_db_check.pl:      $buffer->{ $filename } .= $text;
scripts/import/var_db_check.pl:      if( length( $buffer->{ $filename } ) > 10_000 ) {
scripts/import/var_db_check.pl:        print FH $buffer->{ $filename };
scripts/import/var_db_check.pl:        $buffer->{ $filename } = '';
scripts/import/var_db_check.pl:  my $sth = $dbVar->prepare(qq{select variation_feature_id,allele_string from $variation_feature_table where allele_string like "%)%("}, {mysql_use_result=>1});
scripts/import/var_db_check.pl:  $sth->execute();
scripts/import/var_db_check.pl:  $sth->bind_columns(\$variation_feature_id,\$allele_string);
scripts/import/var_db_check.pl:  while($sth->fetch()) {
scripts/import/export_variation_reference_sequence.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/export_variation_reference_sequence.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/export_variation_reference_sequence.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/export_variation_reference_sequence.pl:$registry->load_all($registryfile);
scripts/import/export_variation_reference_sequence.pl:my $dba = $registry->get_DBAdaptor("human","variation");
scripts/import/export_variation_reference_sequence.pl:    my @seq_region_ids = map {$_->[0]} @{$dba->dbc->db_handle->selectall_arrayref($stmt)};
scripts/import/export_variation_reference_sequence.pl:    # A comma-separated list of seq_region_ids to use as job array elements
scripts/import/export_variation_reference_sequence.pl:    my $bsub_cmd = "bsub -J ref_seq_export[$jobarray]\%$joblimit -o $output_dir/ref_seq_export.\%J.\%I.out -e $output_dir/ref_seq_export.\%J.\%I.err perl $Bin/export_variation_reference_sequence.pl";
scripts/import/export_variation_reference_sequence.pl:        $bsub_cmd .= " -$key $value";
scripts/import/export_variation_reference_sequence.pl:$dba->dbc->do($stmt);
scripts/import/export_variation_reference_sequence.pl:$dba->dbc->do($stmt);
scripts/import/export_variation_reference_sequence.pl:my $slice_adaptor = $registry->get_adaptor($species,"core","slice");
scripts/import/export_variation_reference_sequence.pl:my $slice = $slice_adaptor->fetch_by_seq_region_id($seq_region_id) or die ("Could not fetch slice for seq_region_id $seq_region_id");
scripts/import/export_variation_reference_sequence.pl:# A hash to hold allele -> allele_id mapping
scripts/import/export_variation_reference_sequence.pl:my $fetch_sth = $dba->dbc->prepare($stmt);
scripts/import/export_variation_reference_sequence.pl:my $insert_sth = $dba->dbc->prepare($stmt);
scripts/import/export_variation_reference_sequence.pl:my $sth = $dba->dbc->prepare($stmt);
scripts/import/export_variation_reference_sequence.pl:$sth->execute($seq_region_id);
scripts/import/export_variation_reference_sequence.pl:$sth->bind_columns(\$vf_id,\$start,\$end,\$strand);
scripts/import/export_variation_reference_sequence.pl:while ($sth->fetch()) {
scripts/import/export_variation_reference_sequence.pl:    # If an insertion, the allele should be '-'
scripts/import/export_variation_reference_sequence.pl:        $seq = $slice->subseq($start,$end,$strand);
scripts/import/export_variation_reference_sequence.pl:        $seq = '-';
scripts/import/export_variation_reference_sequence.pl:$dba->dbc->do($stmt);
scripts/import/export_variation_reference_sequence.pl:$dba->dbc->do($stmt);
scripts/import/export_variation_reference_sequence.pl:    $fetch_sth->execute($seq);
scripts/import/export_variation_reference_sequence.pl:    $fetch_sth->bind_columns(\$id);
scripts/import/export_variation_reference_sequence.pl:    $fetch_sth->fetch();
scripts/import/export_variation_reference_sequence.pl:        $insert_sth->execute($seq);
scripts/import/export_variation_reference_sequence.pl:        $id = $dba->dbc->db_handle->selectall_arrayref(qq{SELECT LAST_INSERT_ID()})->[0][0]; 
scripts/import/map_hgmd_coord.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/map_hgmd_coord.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/map_hgmd_coord.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/map_hgmd_coord.pl:die("You need to specify an input file (option -input_file)") if (!defined($input_file));
scripts/import/map_hgmd_coord.pl:$source_name ||= 'HGMD-PUBLIC';
scripts/import/map_hgmd_coord.pl:usage('-species argument is required') if(!$species);
scripts/import/map_hgmd_coord.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/map_hgmd_coord.pl:my $cdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/map_hgmd_coord.pl:my $vdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/map_hgmd_coord.pl:my $dbVar = $vdb->dbc->db_handle;
scripts/import/map_hgmd_coord.pl:my $sa = $cdb->get_SliceAdaptor();
scripts/import/map_hgmd_coord.pl:my $source_description = 'Variants from HGMD-PUBLIC dataset';
scripts/import/map_hgmd_coord.pl:my $new_source_ref = $dbVar->selectall_arrayref(qq{SELECT source_id FROM source WHERE name = "$source_name"});
scripts/import/map_hgmd_coord.pl:$input_file =~ /(\d{4})\.(\d+)-hgmd-public/;
scripts/import/map_hgmd_coord.pl:my $month     = $month_hash->{$month_num} if ($month_num);
scripts/import/map_hgmd_coord.pl:if ($new_source_ref->[0][0]) {
scripts/import/map_hgmd_coord.pl:  $source_id = $new_source_ref->[0][0];
scripts/import/map_hgmd_coord.pl:  $dbVar->do(qq{UPDATE source SET description="$source_description", version=$year$month_num 
scripts/import/map_hgmd_coord.pl:    $dbVar->do(qq{INSERT INTO source(name,description,url,version)
scripts/import/map_hgmd_coord.pl:    $dbVar->do(qq{INSERT INTO source(name,description,url)
scripts/import/map_hgmd_coord.pl:  $source_id = $dbVar->{'mysql_insertid'};
scripts/import/map_hgmd_coord.pl:$dbVar->do(qq{CREATE TABLE IF NOT EXISTS `$header\_variation` (
scripts/import/map_hgmd_coord.pl:  my $slice = $sa->fetch_by_region('chromosome', $data{region_name}, $data{start},$data{end});
scripts/import/map_hgmd_coord.pl:  $data{region_id} = $slice->get_seq_region_id;
scripts/import/map_hgmd_coord.pl:  if (-e "$file") {
scripts/import/map_hgmd_coord.pl:    $file =~ s/\-/\_/g;
scripts/import/map_hgmd_coord.pl:    my $mapping_ref = $dbVar->selectall_arrayref(qq{show tables like "$file"});
scripts/import/map_hgmd_coord.pl:    if (!$mapping_ref->[0][0]) {
scripts/import/map_hgmd_coord.pl:  my $select_vf_sth = $dbVar->prepare(qq{
scripts/import/map_hgmd_coord.pl:  my $update_vf_sth = $dbVar->prepare(qq{
scripts/import/map_hgmd_coord.pl:  $select_vf_sth->execute();
scripts/import/map_hgmd_coord.pl:  while(my @res = $select_vf_sth->fetchrow_array){
scripts/import/map_hgmd_coord.pl:    my $end = $res[1]-1;
scripts/import/map_hgmd_coord.pl:    $update_vf_sth->execute($end, $res[0]) or die "Cannot execute: " . $update_vf_sth->errstr();
scripts/import/map_hgmd_coord.pl:  my $select_a_sth = $dbVar->prepare(qq{
scripts/import/map_hgmd_coord.pl:  my $select_v_sth = $dbVar->prepare(qq{
scripts/import/map_hgmd_coord.pl:  my $update_v_sth = $dbVar->prepare(qq{
scripts/import/map_hgmd_coord.pl:  my $update_vf_sth = $dbVar->prepare(qq{
scripts/import/map_hgmd_coord.pl:    $select_a_sth->execute($v);
scripts/import/map_hgmd_coord.pl:    $class{$k} = ($select_a_sth->fetchrow_array)[0];
scripts/import/map_hgmd_coord.pl:  $select_v_sth->execute();
scripts/import/map_hgmd_coord.pl:  while (my @res = $select_v_sth->fetchrow_array) {
scripts/import/map_hgmd_coord.pl:      $update_v_sth->execute($att,$res[0]) or die $!;
scripts/import/map_hgmd_coord.pl:  $update_vf_sth->execute() or die $!;
scripts/import/map_hgmd_coord.pl:      print FH $buffer->{ $file };
scripts/import/map_hgmd_coord.pl:    $buffer->{ $filename } .= $text;
scripts/import/map_hgmd_coord.pl:    if( length( $buffer->{ $filename } ) > 10_000 ) {
scripts/import/map_hgmd_coord.pl:       print FH $buffer->{ $filename };
scripts/import/map_hgmd_coord.pl:       $buffer->{ $filename } = '';
scripts/import/map_hgmd_coord.pl:  my $var_name = $data->{var_name};
scripts/import/map_hgmd_coord.pl:  my $var_type = $data->{var_type};
scripts/import/map_hgmd_coord.pl:  my $start    = $data->{start};
scripts/import/map_hgmd_coord.pl:  $dbVar->do(qq{INSERT INTO $header\_variation(source_id,name,type)values($source_id,"$var_name","$var_type")});
scripts/import/map_hgmd_coord.pl:  my $variation_id = $dbVar->{'mysql_insertid'};
scripts/import/map_hgmd_coord.pl:  print_buffered($buffer,"$TMP_DIR/$header\_variation_feature",join ("\t",$data->{region_id},$start,$data->{end},$data->{strand},"$variation_id\t".$data->{allele}."\t$var_name\t".$data->{map_weight}."\t".$data->{flags}."\t$source_id\t".$data->{status}."\t".$data->{consequence}."\n"));
scripts/import/map_hgmd_coord.pl:  print_buffered($buffer,"$TMP_DIR/$header\_allele", join ("\t",$variation_id,$data->{allele}) . "\n");
scripts/import/map_hgmd_coord.pl:  print_buffered($buffer,"$TMP_DIR/$header\_variation_annotation", join ("\t",$variation_id,$var_name,$data->{gene_symbol}) . "\n");
scripts/import/import_all_sv_data.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_all_sv_data.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_all_sv_data.pl:#      https://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_all_sv_data.pl:usage('-species argument is required')    if (!$species);
scripts/import/import_all_sv_data.pl:usage('-input_file or -input_dir argument is required') if (!$input_file and !$input_dir);
scripts/import/import_all_sv_data.pl:usage('-version argument is required')    if (!$version);
scripts/import/import_all_sv_data.pl:  $f_nb = (scalar(@files)-2);
scripts/import/import_all_sv_data.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/import_all_sv_data.pl:my $cdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/import_all_sv_data.pl:my $vdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/import_all_sv_data.pl:my $dbCore = $cdb->dbc->db_handle;
scripts/import/import_all_sv_data.pl:my $dbVar = $vdb->dbc->db_handle;
scripts/import/import_all_sv_data.pl:my $csa = Bio::EnsEMBL::Registry->get_adaptor($species, "core", "coordsystem");
scripts/import/import_all_sv_data.pl:our $default_cs = $csa->fetch_by_name("chromosome");
scripts/import/import_all_sv_data.pl:my $int_dba = Bio::EnsEMBL::Registry->get_DBAdaptor('multi', 'intvar');
scripts/import/import_all_sv_data.pl:$target_assembly ||= $default_cs->version;
scripts/import/import_all_sv_data.pl:# run the mapping sub-routine if the data needs mapping
scripts/import/import_all_sv_data.pl:  # Variation set - 1000 Genomes phase 3 and gnomAD
scripts/import/import_all_sv_data.pl:# Load data into temp tables - temp_sv, temp_sv_phenotype
scripts/import/import_all_sv_data.pl:  $dbVar->do("DROP TABLE IF EXISTS $temp_table;");
scripts/import/import_all_sv_data.pl:  $dbVar->do("DROP TABLE IF EXISTS $temp_phen_table;");
scripts/import/import_all_sv_data.pl:  # Fix nulls - after inserting in the temp tables some values need to be fixed
scripts/import/import_all_sv_data.pl:  if (($dbVar->selectrow_arrayref(qq{SELECT count(*) FROM $temp_table WHERE (outer_start=0 AND start=0 AND inner_start=0) OR (inner_end=0 AND end=0 AND outer_end=0);}))->[0] != 0) {
scripts/import/import_all_sv_data.pl:    $dbVar->do(qq{UPDATE $temp_table SET outer_start=outer_end, start=end, inner_start=inner_end WHERE outer_start=0 AND start=0 AND inner_start=0});
scripts/import/import_all_sv_data.pl:    $dbVar->do(qq{UPDATE $temp_table SET outer_end=outer_start, end=start, inner_end=inner_start WHERE outer_end=0 AND end=0 AND inner_end=0});
scripts/import/import_all_sv_data.pl:    $dbVar->do(qq{UPDATE $temp_table SET $coord = NULL WHERE $coord = 0;});
scripts/import/import_all_sv_data.pl:    $dbVar->do(qq{UPDATE $temp_table SET $col = NULL WHERE $col = '';});
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{UPDATE $temp_table SET start=outer_start, end=inner_start, 
scripts/import/import_all_sv_data.pl:    if ($dbVar->selectrow_arrayref(qq{SELECT source_id FROM source WHERE name='$source_name';})) {
scripts/import/import_all_sv_data.pl:      $dbVar->do(qq{UPDATE IGNORE source SET description='Database of Genomic Variants Archive',url='https://www.ebi.ac.uk/dgva/',version=$version where name='$source_name';});
scripts/import/import_all_sv_data.pl:      $dbVar->do(qq{INSERT INTO source (name,description,url,version,data_types,somatic_status) VALUES ('$source_name','Database of Genomic Variants Archive','https://www.ebi.ac.uk/dgva/',$version,'$data_types','$somatic_status');});
scripts/import/import_all_sv_data.pl:    if ($dbVar->selectrow_arrayref(qq{SELECT source_id FROM source WHERE name='$source_name';})) {
scripts/import/import_all_sv_data.pl:      $dbVar->do(qq{UPDATE IGNORE source SET description='NCBI database of human genomic structural variation',url='https://www.ncbi.nlm.nih.gov/dbvar/',version=$version where name='$source_name';});
scripts/import/import_all_sv_data.pl:      $dbVar->do(qq{INSERT INTO source (name,description,url,version,data_types,somatic_status) VALUES ('$source_name','NCBI database of human genomic structural variation','https://www.ncbi.nlm.nih.gov/dbvar/',$version,'$data_types','$somatic_status');});
scripts/import/import_all_sv_data.pl:  my @source_id = @{$dbVar->selectrow_arrayref(qq{SELECT source_id FROM source WHERE name='$source_name';})};
scripts/import/import_all_sv_data.pl:# This method removes data from db if -replace
scripts/import/import_all_sv_data.pl:  $data->{desc} = $data->{s_desc} if ($data->{s_desc} and !$data->{desc});
scripts/import/import_all_sv_data.pl:  my $study        = $data->{study};
scripts/import/import_all_sv_data.pl:  my $assembly     = $data->{assembly};
scripts/import/import_all_sv_data.pl:  my $study_desc   = $data->{desc};
scripts/import/import_all_sv_data.pl:  my $pmid         = $data->{pubmed};
scripts/import/import_all_sv_data.pl:  my $first_author = $data->{first_author};
scripts/import/import_all_sv_data.pl:  my $year         = $data->{year};
scripts/import/import_all_sv_data.pl:  my $author       = $data->{author};
scripts/import/import_all_sv_data.pl:  my $author_info  = $data->{author};
scripts/import/import_all_sv_data.pl:  my $study_type   = ($data->{study_type}) ? $data->{study_type} : undef;
scripts/import/import_all_sv_data.pl:  my $year_desc = $year->[0];
scripts/import/import_all_sv_data.pl:          $pmid_desc .= "$pmid->[$i]($year->[$i])";
scripts/import/import_all_sv_data.pl:  my $rows = $dbVar->selectall_arrayref($stmt);
scripts/import/import_all_sv_data.pl:    $study_id   = $rows->[0][0];
scripts/import/import_all_sv_data.pl:    $study_desc = $rows->[0][1];
scripts/import/import_all_sv_data.pl:    my $study_xref = $rows->[0][2];
scripts/import/import_all_sv_data.pl:    $stmt = $dbVar->prepare(qq[ UPDATE $study_table SET description = ?, external_reference = ?, study_type = ?, url = ? WHERE study_id = ? ]);
scripts/import/import_all_sv_data.pl:    $stmt->execute($study_desc,
scripts/import/import_all_sv_data.pl:    $stmt = $dbVar->prepare(qq[ INSERT INTO $study_table (name, description, url, source_id, external_reference, study_type) VALUES (?,?,?,?,?,?) ]);
scripts/import/import_all_sv_data.pl:    $stmt->execute($study,
scripts/import/import_all_sv_data.pl:    $study_id = $dbVar->{'mysql_insertid'};
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:  my $sv_ids = $dbVar->selectall_arrayref($stmt);
scripts/import/import_all_sv_data.pl:    my $id = $sv_id->[0];
scripts/import/import_all_sv_data.pl:    $dbVar->do(qq{UPDATE $svf_table SET breakpoint_order=1 WHERE structural_variation_id=$id AND somatic=1});
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:      $dbVar->do(qq{UPDATE $temp_table SET population='$sup_pop' WHERE population='$sub_pop'});
scripts/import/import_all_sv_data.pl:        vs.name=CONCAT('1000 Genomes 3 - ',t.population)
scripts/import/import_all_sv_data.pl:    $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:        vs.name='1000 Genomes 3 - All'
scripts/import/import_all_sv_data.pl:    $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:    my $sets_1kg = $dbVar->selectrow_arrayref(qq{
scripts/import/import_all_sv_data.pl:    $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:    $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:  my $sets = $dbVar->selectall_arrayref(qq{SELECT vs.name,a.value FROM variation_set vs, attrib a 
scripts/import/import_all_sv_data.pl:    my $meta_value = "sv_set#".$set->[0]."#".$set->[1]; 
scripts/import/import_all_sv_data.pl:    if (!$dbVar->selectrow_arrayref(qq{SELECT meta_id FROM meta WHERE meta_key='web_config' 
scripts/import/import_all_sv_data.pl:      $dbVar->do(qq{INSERT INTO meta (meta_key,meta_value) VALUES ('web_config','$meta_value')});
scripts/import/import_all_sv_data.pl:  my $study_name = ($dbVar->selectrow_arrayref(qq{SELECT name FROM study WHERE study_id=$study_id;}))->[0];
scripts/import/import_all_sv_data.pl:    my $rows_strains = $dbVar->selectall_arrayref($stmt);
scripts/import/import_all_sv_data.pl:      my $strain = $row->[0];
scripts/import/import_all_sv_data.pl:      if($row->[1] =~ /\w+/ && $row->[1] ne 'NULL') {
scripts/import/import_all_sv_data.pl:        $gender = get_gender($row->[1]);
scripts/import/import_all_sv_data.pl:      if (!$dbVar->selectrow_arrayref(qq{SELECT individual_id FROM individual WHERE name='$strain' LIMIT 1})) {
scripts/import/import_all_sv_data.pl:        $dbVar->do(qq{ INSERT IGNORE INTO individual (name,description,gender,individual_type_id) VALUES ('$strain','Strain from the DGVa study $study_name','$gender',1)});
scripts/import/import_all_sv_data.pl:        if ($dbVar->selectrow_arrayref(qq{SELECT individual_id FROM individual WHERE name='$strain' AND individual_type_id!=1})) {
scripts/import/import_all_sv_data.pl:          $dbVar->do(qq{UPDATE individual SET individual_type_id=1 WHERE name='$strain' AND individual_type_id!=1});
scripts/import/import_all_sv_data.pl:    my $rows_samples = $dbVar->selectall_arrayref($stmt);
scripts/import/import_all_sv_data.pl:      my $sample  = $row->[0];
scripts/import/import_all_sv_data.pl:      my $subject = $row->[1];
scripts/import/import_all_sv_data.pl:      $dbVar->do(qq{ INSERT IGNORE INTO sample (name,description,study_id,display,individual_id) SELECT '$sample','Sample from the DGVa study $study_name', $study_id,"MARTDISPLAYABLE",min(individual_id) FROM individual WHERE name='$subject' LIMIT 1});
scripts/import/import_all_sv_data.pl:    my $rows_subjects = $dbVar->selectall_arrayref($stmt);
scripts/import/import_all_sv_data.pl:      my $subject = $row->[0];
scripts/import/import_all_sv_data.pl:      if($row->[1] =~ /\w+/ && $row->[1] ne 'NULL') {
scripts/import/import_all_sv_data.pl:        $gender = get_gender($row->[1]);
scripts/import/import_all_sv_data.pl:      $dbVar->do(qq{ INSERT IGNORE INTO individual (name,description,gender,individual_type_id) VALUES ('$subject','Subject from the DGVa study $study_name','$gender',$itype_val)});
scripts/import/import_all_sv_data.pl:    my $rows_samples = $dbVar->selectall_arrayref($stmt);
scripts/import/import_all_sv_data.pl:      my $sample  = $row->[0];
scripts/import/import_all_sv_data.pl:      my $subject = $row->[1];
scripts/import/import_all_sv_data.pl:      #$dbVar->do(qq{ INSERT IGNORE INTO sample (name,description,study_id,individual_id) SELECT '$sample','Sample from the DGVa study $study_name', $study_id, min(individual_id) FROM individual WHERE name='$subject'});
scripts/import/import_all_sv_data.pl:      $dbVar->do(qq{ INSERT IGNORE INTO sample (name,description,individual_id) SELECT '$sample','Sample from the DGVa study $study_name', min(individual_id) FROM individual WHERE name='$subject'});
scripts/import/import_all_sv_data.pl:  $dbVar->do(q{OPTIMIZE TABLE sample});
scripts/import/import_all_sv_data.pl:  $dbVar->do(q{OPTIMIZE TABLE individual});
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:  my $stmt = $dbVar->prepare(qq { SELECT attrib_id FROM attrib WHERE value = 'trait' });
scripts/import/import_all_sv_data.pl:  $stmt->execute() || die;
scripts/import/import_all_sv_data.pl:  my $attrib_id = ($stmt->fetchrow_array)[0];
scripts/import/import_all_sv_data.pl:  if (($dbVar->selectall_arrayref($stmt))->[0][0] == 0) {
scripts/import/import_all_sv_data.pl:  my $rows = $dbVar->selectall_arrayref($stmt);
scripts/import/import_all_sv_data.pl:    my $phenotype = $row->[0];
scripts/import/import_all_sv_data.pl:    my $stmt_phenotype = $dbVar->prepare(qq[ INSERT INTO phenotype (description, class_attrib_id) VALUES (?,?) ]);
scripts/import/import_all_sv_data.pl:    $stmt_phenotype->execute($phenotype, $class_attrib_id);
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{DROP TABLE $temp_table;}) unless ($debug);
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{DROP TABLE $temp_phen_table;}) unless ($debug);
scripts/import/import_all_sv_data.pl:  my $sa = Bio::EnsEMBL::Registry->get_adaptor($species, 'core', 'slice');
scripts/import/import_all_sv_data.pl:        my $start_c = $info->{start};
scripts/import/import_all_sv_data.pl:        my $end_c   = $info->{end};
scripts/import/import_all_sv_data.pl:        if (!$info->{start}) {
scripts/import/import_all_sv_data.pl:          $start_c = ($info->{outer_start}) ? $info->{outer_start} : $info->{inner_start};
scripts/import/import_all_sv_data.pl:        if (!$info->{end}) {
scripts/import/import_all_sv_data.pl:          $end_c = ($info->{outer_end}) ? $info->{outer_end} : $info->{inner_end};
scripts/import/import_all_sv_data.pl:        if ($info->{chr}) {
scripts/import/import_all_sv_data.pl:          eval { $slice = $sa->fetch_by_region('chromosome', $info->{chr}, $start_c, $end_c, 1, $assembly); };
scripts/import/import_all_sv_data.pl:           warn("Structural variant '".$info->{ID}."' (study ".$header->{study}."): Unable to map from assembly $assembly or unable to retrieve slice ".$info->{chr}."\:$start_c\-$end_c");
scripts/import/import_all_sv_data.pl:          my ($min_start, $max_end) = (999999999, -999999999);
scripts/import/import_all_sv_data.pl:          foreach my $segment(@{$slice->project('chromosome', $target_assembly)}) {
scripts/import/import_all_sv_data.pl:            my $to_slice = $segment->to_Slice();
scripts/import/import_all_sv_data.pl:            if((defined $to_chr) && ($to_chr ne $to_slice->seq_region_name)) {
scripts/import/import_all_sv_data.pl:              warn("Segments of ".$info->{ID}." map to different chromosomes ($to_chr and ", $to_slice->seq_region_name, ")");
scripts/import/import_all_sv_data.pl:            $to_chr = $to_slice->seq_region_name;
scripts/import/import_all_sv_data.pl:            my $to_start = $to_slice->start;
scripts/import/import_all_sv_data.pl:            my $to_end = $to_slice->end;
scripts/import/import_all_sv_data.pl:            $to_start = ($to_start + $segment->from_start) - 1;
scripts/import/import_all_sv_data.pl:            $to_end = ($to_end + $segment->from_start) - 1;
scripts/import/import_all_sv_data.pl:            #print "$id\t$chr\t$start\t$end\tsize ",($end - $start + 1), "\t\-\>\t", $to_chr, "\t", $to_start, "\t", $to_end, " size ", ($to_end - $to_start + 1), "\n";
scripts/import/import_all_sv_data.pl:          #my $diff = abs(100 - (100 * (($end - $start + 1) / ($max_end - $min_start + 1))));
scripts/import/import_all_sv_data.pl:          #print "Before ",($end - $start + 1), " After ", ($max_end - $min_start + 1), " Diff $diff count $count\n";
scripts/import/import_all_sv_data.pl:          if((($count - 1) <= $num_gaps && $count && !$is_failed)) {# && $diff < $size_diff) {
scripts/import/import_all_sv_data.pl:            $num_mapped{$assembly}++ if (!$info->{is_ssv});
scripts/import/import_all_sv_data.pl:            $info->{chr}   = $to_chr;
scripts/import/import_all_sv_data.pl:            $info->{start} = $min_start;
scripts/import/import_all_sv_data.pl:            $info->{end}   = $max_end;
scripts/import/import_all_sv_data.pl:            $info->{outer_start} = $min_start - ($start_c - $info->{outer_start}) if $info->{outer_start} >= 1;
scripts/import/import_all_sv_data.pl:            $info->{inner_start} = $min_start + ($info->{inner_start} - $start_c) if $info->{inner_start} >= 1;
scripts/import/import_all_sv_data.pl:            $info->{inner_end}   = $max_end - ($end_c - $info->{inner_end}) if $info->{inner_end} >= 1;
scripts/import/import_all_sv_data.pl:            $info->{outer_end}   = $max_end + ($info->{outer_end} - $end_c) if $info->{outer_end} >= 1;
scripts/import/import_all_sv_data.pl:            if (!$info->{is_ssv}) {
scripts/import/import_all_sv_data.pl:              warn ("Structural variant '".$info->{ID}."' (study ".$header->{study}.") has location '$assembly:".$info->{chr}.":$start_c\-$end_c' , which could not be re-mapped to $target_assembly. This variant will be labelled as failed");
scripts/import/import_all_sv_data.pl:      $info->{is_failed} = $is_failed;
scripts/import/import_all_sv_data.pl:      if ($info->{phenotype}) {
scripts/import/import_all_sv_data.pl:        my @phenotypes = map { decode_text($_) } keys(%{$info->{phenotype}});
scripts/import/import_all_sv_data.pl:  # Example with more than one space: ##genome-build NCBI GRCh37
scripts/import/import_all_sv_data.pl:  # dbVar files contain header lines without ':', example: # assembly-name GRCh38  (hg38)
scripts/import/import_all_sv_data.pl:  $h->{author}       = $info if ($label =~ /Display.+name/i);
scripts/import/import_all_sv_data.pl:  $h->{first_author} = $info if ($label =~ /First.+author/i);
scripts/import/import_all_sv_data.pl:  $h->{assembly}     = $info if ($label =~ /Assembly.+name/i);
scripts/import/import_all_sv_data.pl:  $h->{study_type}   = $info if ($label =~ /Study.+type/i);
scripts/import/import_all_sv_data.pl:  $h->{study}        = (split(' ',$info))[0] if ($label =~ /Study.+accession/i);
scripts/import/import_all_sv_data.pl:  $somatic_study = 1 if (($h->{study_type} && $h->{study_type} =~ /(somatic)|(tumor)/i) || ($h->{author} && $h->{author} =~ /COSMIC/));
scripts/import/import_all_sv_data.pl:      push(@{$h->{pubmed}}, $p_info) if ($p_label =~ /PMID/i);
scripts/import/import_all_sv_data.pl:      push(@{$h->{year}}, $p_info) if ($p_label =~ /Publication.+year/i);
scripts/import/import_all_sv_data.pl:      $h->{desc} = $p_info if ($p_label =~ /Paper.+title/i && $p_info && $p_info ne 'None Given');
scripts/import/import_all_sv_data.pl:        $h->{first_author} = ($2) ? $2 : $s_info;
scripts/import/import_all_sv_data.pl:      $h->{s_desc} = $s_info if ($s_label =~ /Description/i);
scripts/import/import_all_sv_data.pl:    if($h->{author} =~ /1000.+Genomes/) {
scripts/import/import_all_sv_data.pl:      $h->{desc} = $h->{author};
scripts/import/import_all_sv_data.pl:      $h->{desc} =~ s/_/ /g;
scripts/import/import_all_sv_data.pl:    $h->{s_desc} = $info;
scripts/import/import_all_sv_data.pl:    if (defined($tissue) && ($h->{desc} =~ /cosmic/i || $h->{s_desc} =~ /cosmic/i)){
scripts/import/import_all_sv_data.pl:      $samples{$sample}{gender}     = $subjects{$subject}->{subject_sex};
scripts/import/import_all_sv_data.pl:      $samples{$sample}{phenotype}  = $subjects{$subject}->{phenotype_description};
scripts/import/import_all_sv_data.pl:      $samples{$sample}{population} = $subjects{$subject}->{subject_population};
scripts/import/import_all_sv_data.pl:      if (!defined($subjects{$subject}->{subject_population}) && $species =~ /mouse|mus.*mus/ && defined($pop)){
scripts/import/import_all_sv_data.pl:  $h->{author} =~ s/\s/_/g if($h->{author});
scripts/import/import_all_sv_data.pl:  my $assembly = $h->{assembly};
scripts/import/import_all_sv_data.pl:      warn("Could not guess assembly from file - assuming to be GRCh38");
scripts/import/import_all_sv_data.pl:  $h->{assembly} = $assembly;
scripts/import/import_all_sv_data.pl:  $info->{chr} = defined($1) ? $1 : $data[0];
scripts/import/import_all_sv_data.pl:  $info->{SO_term} = ($data[2] eq 'alu_insertion') ? ucfirst($data[2]) : $data[2];
scripts/import/import_all_sv_data.pl:  $info->{SO_term} = 'indel' if ($info->{SO_term} eq 'delins');
scripts/import/import_all_sv_data.pl:  $info->{start}   = $data[3];
scripts/import/import_all_sv_data.pl:  $info->{end}     = $data[4];
scripts/import/import_all_sv_data.pl:  $info->{strand}  = ($data[6] eq '.') ? 1 : ($data[6] eq '-') ? -1 : 1;
scripts/import/import_all_sv_data.pl:  $info->{chr} = ($seq_regions{$info->{chr}}) ? $seq_regions{$info->{chr}} : get_seq_region($info->{chr});
scripts/import/import_all_sv_data.pl:  my $sth = $dbVar->prepare(qq{ SELECT name FROM seq_region WHERE name=?});
scripts/import/import_all_sv_data.pl:  $sth->execute($seq_region);
scripts/import/import_all_sv_data.pl:  my $seq_region_name = ($sth->fetchrow_array)[0];
scripts/import/import_all_sv_data.pl:    $sth = $dbCore->prepare(qq{ SELECT seq.name FROM seq_region seq, seq_region_synonym syn WHERE syn.seq_region_id=seq.seq_region_id AND syn.synonym=?});
scripts/import/import_all_sv_data.pl:    $sth->execute($seq_region);
scripts/import/import_all_sv_data.pl:    $seq_region_name = ($sth->fetchrow_array)[0];
scripts/import/import_all_sv_data.pl:  $sth->finish;
scripts/import/import_all_sv_data.pl:    $info->{$key} = $value if ($key ne 'phenotype'); # Default
scripts/import/import_all_sv_data.pl:    $info->{ID} = $value if ($key eq 'Name');
scripts/import/import_all_sv_data.pl:        $info->{outer_start} = $s_range[0] if ($s_range[0] ne '.');
scripts/import/import_all_sv_data.pl:        $info->{inner_start} = $s_range[1] if ($s_range[1] ne '.');
scripts/import/import_all_sv_data.pl:        $info->{outer_end} = $e_range[1] if ($e_range[1] ne '.');
scripts/import/import_all_sv_data.pl:        $info->{inner_end} = $e_range[0] if ($e_range[0] ne '.');
scripts/import/import_all_sv_data.pl:      if ($key eq 'sample_name' || ($key eq 'subject_name' && !$info->{sample})) {
scripts/import/import_all_sv_data.pl:          $info->{sample} = ($samples{$value}{population}) ? $samples{$value}{population} : $value;
scripts/import/import_all_sv_data.pl:          $info->{sample} = ($samples{$value}{subject}) ? $samples{$value}{subject} : $value;
scripts/import/import_all_sv_data.pl:          $info->{subject} = $subject_name;
scripts/import/import_all_sv_data.pl:          $info->{subject} = ($samples{$value}{subject}) ? $samples{$value}{subject} : $info->{sample};
scripts/import/import_all_sv_data.pl:        $info->{population}  = ($samples{$value}{population}) ? $samples{$value}{population} : undef; # 1000 Genomes study
scripts/import/import_all_sv_data.pl:        $info->{gender}      = ($samples{$value}{gender}) ? $samples{$value}{gender} : undef;
scripts/import/import_all_sv_data.pl:        $info->{phenotype}{$s_phenotype} = 1;
scripts/import/import_all_sv_data.pl:      # Replace unsupported character, example: 'benign/likely benign' -> 'benign,likely benign'
scripts/import/import_all_sv_data.pl:      $info->{clinical} = $value;
scripts/import/import_all_sv_data.pl:    $info->{parent}      = $value if ($key eq 'Parent'); # Check how the 'parent' key is spelled
scripts/import/import_all_sv_data.pl:    $info->{is_somatic}  = 1 if ($key eq 'var_origin' && $value =~ /somatic/i);
scripts/import/import_all_sv_data.pl:    $info->{bp_order}    = ($info->{submitter_variant_id} && $info->{submitter_variant_id} =~ /\w_(\d+)$/) ? $1 : undef;
scripts/import/import_all_sv_data.pl:    $info->{bp_order}    = 1 if ($info->{SO_term} =~ /translocation/i);
scripts/import/import_all_sv_data.pl:    $info->{status}      = 'High quality' if ($key eq 'variant_region_description' && $value =~ /high.quality/i);
scripts/import/import_all_sv_data.pl:    $info->{alias}       = $value if ($key eq 'Alias' && $value !~ /^\d+$/);
scripts/import/import_all_sv_data.pl:    $info->{length}      = $value if ($key eq 'variant_call_length');
scripts/import/import_all_sv_data.pl:        $info->{zygosity} = 1;
scripts/import/import_all_sv_data.pl:        $info->{zygosity} = 2;
scripts/import/import_all_sv_data.pl:      my $copy = (split(/[-,\.\~]/,$value))[0];
scripts/import/import_all_sv_data.pl:      $info->{copy_number} = $copy if ($copy ne '');
scripts/import/import_all_sv_data.pl:    if ($species =~ /^(homo|human)/i && $info->{is_somatic}) {
scripts/import/import_all_sv_data.pl:      $info->{_bp_detail} = $value if ($key =~ /Breakpoint_detail/i);
scripts/import/import_all_sv_data.pl:      $info->{_bp_range}  = $value if ($key =~ /Breakpoint_range/i);
scripts/import/import_all_sv_data.pl:        $value =~ s/46,/46-/g;
scripts/import/import_all_sv_data.pl:      if($value =~ /2,4-/) {
scripts/import/import_all_sv_data.pl:        $value =~ s/2,4-/2-4-/g;
scripts/import/import_all_sv_data.pl:        if($phe =~ /46-/) {
scripts/import/import_all_sv_data.pl:          $phe =~ s/46-/46,/g;
scripts/import/import_all_sv_data.pl:	if($phe =~ /2-4-/) {
scripts/import/import_all_sv_data.pl:          $phe =~ s/2-4-/2,4-/g;
scripts/import/import_all_sv_data.pl:        # if a phenotype is invalid we do not store it and set $skip_phenotype to 1 to skip it in the next lines (#L1594-1595)
scripts/import/import_all_sv_data.pl:        $info->{phenotype}{$phe} = 1 unless $skip_phenotype;
scripts/import/import_all_sv_data.pl:    $info->{phenotype}{$value} = 1 if ($key eq 'phenotype_description' && !$skip_phenotype);
scripts/import/import_all_sv_data.pl:    $info->{phenotype_link} = $value if (($key eq 'phenotype_link' || $key eq 'phenotype_id') && !$skip_phenotype);
scripts/import/import_all_sv_data.pl:      $info->{allele_count} = $value;
scripts/import/import_all_sv_data.pl:      $info->{allele_frequency} = $value;
scripts/import/import_all_sv_data.pl:      $info->{allele_number} = $value;
scripts/import/import_all_sv_data.pl:  if ($info->{phenotype_link}) {
scripts/import/import_all_sv_data.pl:    my @phenotype_links = split(',',$info->{phenotype_link});
scripts/import/import_all_sv_data.pl:        $info->{phenotype}{$phenotype_value} = 1 if (defined($phenotype_value) && $phenotype_value ne '');
scripts/import/import_all_sv_data.pl:        $info->{phenotype}{$phenotype_value} = 1 if (defined($phenotype_value) && $phenotype_value ne '');
scripts/import/import_all_sv_data.pl:  $info->{is_ssv} = ($info->{ID} =~ /ssv/) ? 1 : 0;
scripts/import/import_all_sv_data.pl:  if (($info->{is_somatic} && $info->{is_somatic} == 1) && $info->{alias} =~ /^(.+)_\d+$/) {
scripts/import/import_all_sv_data.pl:    $info->{alias} = $1;
scripts/import/import_all_sv_data.pl:  if ($somatic_study && $info->{is_ssv} == 0) {
scripts/import/import_all_sv_data.pl:    my $cmd  = "grep 'parent=".$info->{ID}."' $fname";
scripts/import/import_all_sv_data.pl:    $info->{is_somatic} = 1 if ($text =~ /var_origin=Somatic/i || !$text);
scripts/import/import_all_sv_data.pl:  if ($somatic_study && $info->{alias} =~ /^COST\d+$/) {
scripts/import/import_all_sv_data.pl:    $info->{is_somatic} = 1;
scripts/import/import_all_sv_data.pl:  debug(localtime()."\t - Add temporary unique keys in $svf_table and $svs_table tables");
scripts/import/import_all_sv_data.pl:  if ($dbVar->do(qq{SHOW KEYS FROM $svf_table WHERE Key_name='name_coord_key';}) < 1){
scripts/import/import_all_sv_data.pl:    $dbVar->do(qq{ALTER TABLE $svf_table ADD CONSTRAINT  UNIQUE KEY
scripts/import/import_all_sv_data.pl:  if ($dbVar->do(qq{SHOW KEYS FROM $svf_table WHERE Key_name='name_key';}) < 1){
scripts/import/import_all_sv_data.pl:    $dbVar->do(qq{ALTER TABLE $svf_table ADD KEY `name_key` (`variation_name`)});
scripts/import/import_all_sv_data.pl:  if ($dbVar->do(qq{SHOW KEYS FROM $svs_table WHERE Key_name='sv_id_key';}) < 1){
scripts/import/import_all_sv_data.pl:    $dbVar->do(qq{ALTER TABLE $svs_table ADD CONSTRAINT UNIQUE KEY `sv_id_key` (`structural_variation_id`,`sample_id`)});
scripts/import/import_all_sv_data.pl:  debug(localtime()."\t - Add temporary unique keys in the individual table");
scripts/import/import_all_sv_data.pl:  if ($dbVar->do(qq{SHOW KEYS FROM individual WHERE Key_name='name_key';}) < 1){
scripts/import/import_all_sv_data.pl:    $dbVar->do(qq{ALTER TABLE individual ADD KEY `name_key` (`name`)});
scripts/import/import_all_sv_data.pl:  debug(localtime()."\t - Add temporary unique keys in the sample table");
scripts/import/import_all_sv_data.pl:  if ($dbVar->do(qq{SHOW KEYS FROM sample WHERE Key_name='name_key';}) < 1){
scripts/import/import_all_sv_data.pl:    $dbVar->do(qq{ALTER TABLE sample ADD KEY `name_key` (`name`)});
scripts/import/import_all_sv_data.pl:  debug(localtime()."\t - Add temporary columns in the $sv_table table");
scripts/import/import_all_sv_data.pl:  if ($dbVar->do(qq{show columns from $sv_table like '$tmp_sv_col';}) != 1){
scripts/import/import_all_sv_data.pl:    $dbVar->do(qq{ALTER TABLE $sv_table ADD COLUMN $tmp_sv_col varchar(255);});
scripts/import/import_all_sv_data.pl:  if ($dbVar->do(qq{show columns from $sv_table like '$tmp_sv_clin_col';}) != 1){
scripts/import/import_all_sv_data.pl:    $dbVar->do(qq{ALTER TABLE $sv_table ADD COLUMN $tmp_sv_clin_col varchar(255);});
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:    $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt_s);
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt_e);
scripts/import/import_all_sv_data.pl:  my $sth = $dbVar->prepare(qq{ SELECT s.sample_id, s.description, count(DISTINCT sv.study_id) c 
scripts/import/import_all_sv_data.pl:  $sth->execute();
scripts/import/import_all_sv_data.pl:  while (my @res = ($sth->fetchrow_array)) {
scripts/import/import_all_sv_data.pl:      $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:  $sth->finish;
scripts/import/import_all_sv_data.pl:  $sth = $dbVar->prepare(qq{ SELECT i.individual_id, i.description, count(DISTINCT sv.study_id) c 
scripts/import/import_all_sv_data.pl:  $sth->execute();
scripts/import/import_all_sv_data.pl:  while (my @res = ($sth->fetchrow_array)) {
scripts/import/import_all_sv_data.pl:      $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:  $sth->finish;
scripts/import/import_all_sv_data.pl:  $dbVar->do(q{OPTIMIZE TABLE phenotype});
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{DROP TABLE IF EXISTS $temp_clin_table});
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{CREATE TABLE $temp_clin_table (sv_id int(10), clin_sign varchar(255), primary key (sv_id))});
scripts/import/import_all_sv_data.pl:  my $sth_stmt = $dbVar->prepare($stmt);
scripts/import/import_all_sv_data.pl:  $sth_stmt->execute();
scripts/import/import_all_sv_data.pl:  my $all_clin_sign = $sth_stmt->fetchall_arrayref();
scripts/import/import_all_sv_data.pl:  my $sth_insert_temp = $dbVar->prepare(qq{ INSERT INTO $temp_clin_table (sv_id, clin_sign) values (?, ?) });
scripts/import/import_all_sv_data.pl:    my $sv_id = $data->[0];
scripts/import/import_all_sv_data.pl:    my $clin_sign_dup = $data->[1];
scripts/import/import_all_sv_data.pl:    $sth_insert_temp->execute($sv_id, $clin_sign_unique_final);
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt2);
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{DROP TABLE $temp_clin_table});
scripts/import/import_all_sv_data.pl:  $dbVar->do($stmt);
scripts/import/import_all_sv_data.pl:  my $max_length_ref = $dbVar->selectall_arrayref(qq{
scripts/import/import_all_sv_data.pl:    SELECT MAX(seq_region_end - seq_region_start + 1) FROM $svf_table
scripts/import/import_all_sv_data.pl:  my $max_length = $max_length_ref->[0][0];
scripts/import/import_all_sv_data.pl:  my $cs = $default_cs->dbID;
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{DELETE FROM meta_coord where table_name = '$svf_table';});
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{INSERT INTO meta_coord(table_name, coord_system_id, max_length) VALUES ('$svf_table', $cs, $max_length);});
scripts/import/import_all_sv_data.pl:  my $ensvardb_dba = $int_dba->get_EnsVardbAdaptor();
scripts/import/import_all_sv_data.pl:  my $result_dba   = $int_dba->get_ResultAdaptor();
scripts/import/import_all_sv_data.pl:  my $ensdb_name   = $vdb->dbc->dbname;
scripts/import/import_all_sv_data.pl:  my $ensdb = $ensvardb_dba->fetch_by_name($ensdb_name);
scripts/import/import_all_sv_data.pl:    $ensdb = Bio::EnsEMBL::IntVar::EnsVardb->new_fast({
scripts/import/import_all_sv_data.pl:    $ensdb->genome_reference($target_assembly);
scripts/import/import_all_sv_data.pl:    $ensvardb_dba->store($ensdb);
scripts/import/import_all_sv_data.pl:  $ensvardb_dba->update_status($ensdb, 'structural_variation_run');
scripts/import/import_all_sv_data.pl:      $result_dba->set_non_current_by_species_assembly_and_type($species, $target_assembly, $type, $st_name);
scripts/import/import_all_sv_data.pl:      $result_dba->set_non_current_by_species_and_type($species, $type);
scripts/import/import_all_sv_data.pl:    my $result = Bio::EnsEMBL::IntVar::Result->new_fast({ ensvardb     => $ensdb,
scripts/import/import_all_sv_data.pl:    $result_dba->store($result);
scripts/import/import_all_sv_data.pl:  my $sth = $dbVar->prepare(qq{ SELECT url FROM $study_table WHERE source_id=$source_id});
scripts/import/import_all_sv_data.pl:  $sth->execute();
scripts/import/import_all_sv_data.pl:  while (my $url = ($sth->fetchrow_array)[0]) {
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{ALTER TABLE $svf_table DROP KEY name_coord_key});
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{ALTER TABLE $svf_table DROP KEY name_key});
scripts/import/import_all_sv_data.pl:  debug(localtime()."\t - Table $svf_table: cleaned");
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{ALTER TABLE $svs_table DROP KEY sv_id_key});
scripts/import/import_all_sv_data.pl:  debug(localtime()."\t - Table $svs_table: cleaned");
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{ALTER TABLE individual DROP KEY name_key});
scripts/import/import_all_sv_data.pl:  debug(localtime()."\t - Table individual: cleaned");
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{ALTER TABLE sample DROP KEY name_key});
scripts/import/import_all_sv_data.pl:  debug(localtime()."\t - Table sample: cleaned");
scripts/import/import_all_sv_data.pl:  my $sth1 = $dbVar->prepare(qq{ SELECT count(*) FROM $sv_table WHERE source_id=$source_id AND class_attrib_id=0});
scripts/import/import_all_sv_data.pl:  $sth1->execute();
scripts/import/import_all_sv_data.pl:  my $sv_count = ($sth1->fetchrow_array)[0];
scripts/import/import_all_sv_data.pl:  $sth1->finish;
scripts/import/import_all_sv_data.pl:    $dbVar->do(qq{ALTER TABLE $sv_table DROP COLUMN $tmp_sv_col});
scripts/import/import_all_sv_data.pl:  my $sth2 = $dbVar->prepare(qq{ SELECT count(*) FROM $sv_table WHERE (clinical_significance is NULL OR clinical_significance = '') AND $tmp_sv_clin_col is not NULL});
scripts/import/import_all_sv_data.pl:  $sth2->execute();
scripts/import/import_all_sv_data.pl:  my $sv_clin_count = ($sth2->fetchrow_array)[0];
scripts/import/import_all_sv_data.pl:  $sth2->finish;
scripts/import/import_all_sv_data.pl:    my $sth_not_supported = $dbVar->prepare(qq{ SELECT distinct($tmp_sv_clin_col) FROM $sv_table WHERE (clinical_significance is NULL OR clinical_significance = '') AND $tmp_sv_clin_col is not NULL});
scripts/import/import_all_sv_data.pl:    $sth_not_supported->execute();
scripts/import/import_all_sv_data.pl:    my @clin_not_supported = $sth_not_supported->fetchrow_array;
scripts/import/import_all_sv_data.pl:    $dbVar->do(qq{ALTER TABLE $sv_table DROP COLUMN $tmp_sv_clin_col});
scripts/import/import_all_sv_data.pl:  debug(localtime()."\t - Table $sv_table: cleaned") if ($sv_flag == 0);
scripts/import/import_all_sv_data.pl:  my $sth_pheno = $dbVar->prepare(qq{ SELECT count(*) FROM phenotype WHERE phenotype_id NOT IN (SELECT phenotype_id FROM phenotype_feature)});
scripts/import/import_all_sv_data.pl:  $sth_pheno->execute() || die;
scripts/import/import_all_sv_data.pl:  my $n_phenotype = ($sth_pheno->fetchrow_array)[0];
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{ DELETE from $svs_table WHERE structural_variation_id IN 
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{ DELETE from $sva_table WHERE structural_variation_id IN 
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{ DELETE from $svf_table WHERE structural_variation_id IN 
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{ DELETE from $set_table WHERE structural_variation_id IN 
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{ DELETE from $pf_table WHERE study_id=$study_id });
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{ DELETE from $sv_failed WHERE structural_variation_id IN 
scripts/import/import_all_sv_data.pl:  $dbVar->do(qq{ DELETE from $sv_table WHERE study_id=$study_id });                  
scripts/import/import_all_sv_data.pl:  if(!defined($info->{bp_order})) {
scripts/import/import_all_sv_data.pl:    if (($info->{is_somatic} && $info->{is_somatic} == 1) || $somatic) {
scripts/import/import_all_sv_data.pl:      $info->{bp_order} = 1;
scripts/import/import_all_sv_data.pl:      $info->{bp_order} = undef;
scripts/import/import_all_sv_data.pl:  $info->{phenotype} = decode_text($info->{phenotype}) if($info->{phenotype}); 
scripts/import/import_all_sv_data.pl:  my @row = map { $info->{$_} ? $info->{$_} : '' } @attribs;
scripts/import/import_all_sv_data.pl:  my @row = ($info->{ID}, $phenotype);
scripts/import/import_all_sv_data.pl:  if (defined($info->{_bp_detail})) {
scripts/import/import_all_sv_data.pl:    my ($chr,$pos,$strand) = split(':',$info->{_bp_detail});
scripts/import/import_all_sv_data.pl:    my ($start,$end) = split(',',$info->{_bp_range});
scripts/import/import_all_sv_data.pl:      $bp_info{strand} = ($strand eq '-') ? -1 : 1;
scripts/import/import_all_sv_data.pl:  return undef unless (-e $medgen_file && defined($id));
scripts/import/import_all_sv_data.pl:  return undef unless (-e $hpo_file && defined($id));
scripts/import/import_all_sv_data.pl:  my $res = `grep -A1 -w "id: $id" $hpo_file`;
scripts/import/import_all_sv_data.pl:  -species         : species name
scripts/import/import_all_sv_data.pl:  -version         : date of data import in YYYYMM format -- e.g., 202210
scripts/import/import_all_sv_data.pl:  -input_file      : file containing data dump (required if no input_dir)
scripts/import/import_all_sv_data.pl:  -input_dir       : directory containing data dump (required if no input_file)
scripts/import/import_all_sv_data.pl:  -source_name     : name of data source (default: DGVa)
scripts/import/import_all_sv_data.pl:  -registry        : registry file (default: ensembl.registry)
scripts/import/import_all_sv_data.pl:  -replace         : flag to remove existing study data from the database before import (default: false)
scripts/import/import_all_sv_data.pl:  -target_assembly : assembly version to map to (optional)
scripts/import/import_all_sv_data.pl:  -mapping         : if set, map data to $target_assembly using the Ensembl API (default: false)
scripts/import/import_all_sv_data.pl:  -gaps            : number of gaps allowed in mapping (default: 1)
scripts/import/import_all_sv_data.pl:  -debug           : flag to keep the temp_cnv table (default: false)
scripts/import/import_all_sv_data.pl:  -medgen_file     : path to the unzipped MedGen file (see on https://ftp.ncbi.nlm.nih.gov/pub/medgen/csv/NAMES.csv.gz)
scripts/import/import_all_sv_data.pl:  -hpo_file        : path to the Human Phenotype Ontology (HPO) file (see on http://compbio.charite.de/hudson/job/hpo/lastSuccessfulBuild/artifact/hp/hp.obo)
scripts/import/process_car_lu.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/process_car_lu.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/process_car_lu.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/process_car_lu.pl:if (! -d $pipeline_dir) {
scripts/import/process_car_lu.pl:  if (! -d $dir) {
scripts/import/process_car_lu.pl:# hgvs-5-146688061-151578662-car-lu.json
scripts/import/process_car_lu.pl:   next if ($file !~ /hgvs-.*-\d{1,}-\d{1,}-car-lu.json/);
scripts/import/process_car_lu.pl:  # Take the JSON file remove the car-lu
scripts/import/process_car_lu.pl:  ($file_base = $file)  =~ s/-car-lu.json//;
scripts/import/process_car_lu.pl:  if (! -e $ar_json_file) {
scripts/import/process_car_lu.pl:  if (! -e $hgvs_file) {
scripts/import/process_car_lu.pl:  if (! -e $ar_json_file) {
scripts/import/process_car_lu.pl:  if (! -e $hgvs_file) {
scripts/import/process_car_lu.pl:  if (! -e $load_dir) {
scripts/import/process_car_lu.pl:  my $load_file = $filename . "-load.tab";
scripts/import/process_car_lu.pl:  my $error_file = $filename . "-error.tab";
scripts/import/process_car_lu.pl:  my $missing_file = $filename . "-miss.tab";
scripts/import/process_car_lu.pl:  my $data = JSON->new->decode($json_string) or throw("ERROR: Failed to parse json $json_string");
scripts/import/process_car_lu.pl:    if (exists $data->[$i]->{'@id'}) {
scripts/import/process_car_lu.pl:      my ($car_id) = ($data->[$i]->{'@id'} =~/(CA\d{1,})$/);
scripts/import/process_car_lu.pl:      my $ao = $data->[$i];
scripts/import/process_car_lu.pl:      next if (! $ao->{'errorType'});
scripts/import/process_car_lu.pl:        $ao->{'inputLine'},
scripts/import/process_car_lu.pl:        $ao->{'hgvs'} || '',
scripts/import/process_car_lu.pl:        $ao->{'errorType'},
scripts/import/process_car_lu.pl:        $ao->{'message'},
scripts/import/process_car_lu.pl:        $ao->{'description'}),
scripts/import/import_affy_array.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/import_affy_array.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/import_affy_array.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/import_affy_array.pl:#affy_probeset_name<->rsids are in :ia64g:yuan_hum_aff_40
scripts/import/import_affy_array.pl:  #SNP_A-1742900 1004 51 -4 TGCAGCTATGACCCAAAATTTGATG r PM A 
scripts/import/import_affy_array.pl:  #SNP_A-1742900 176  19 -4 CATCAAATGTTGGGTCATAGCTGCA f PM C
scripts/import/import_affy_array.pl:	#my $name = "$array_name\:$probe_set\:$x\:$y\-$num\-$base\-$dir\;";
scripts/import/import_affy_array.pl:	#print OUT1 "$array_name\t$probe_set\t$x\:$y\-$num\-$base\;\t$num\t$base\t$dir\n";
scripts/import/import_affy_array.pl:      $new_seq_region_start = $seq_region_start +12 - $num;
scripts/import/import_affy_array.pl:    #if ($probeset eq "SNP_A-2038704") {print "$_ AND $old_base $new_base\n";}
scripts/import/import_affy_array.pl:	my $up_seq_region_start = $new_start -100;
scripts/import/import_affy_array.pl:	my $up_seq_region_end = $new_start-1;
scripts/import/post_process.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/post_process.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/post_process.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/post_process.pl:  usage('-vdbname argument is required') if(!$vdbname);
scripts/import/post_process.pl:  usage('-cdbname argument is required') if(!$cdbname);
scripts/import/post_process.pl:  my $dbCore = Bio::EnsEMBL::DBSQL::DBAdaptor->new
scripts/import/post_process.pl:    (-host   => $chost,
scripts/import/post_process.pl:     -user   => $cuser,
scripts/import/post_process.pl:     -pass   => $cpass,
scripts/import/post_process.pl:     -port   => $cport,
scripts/import/post_process.pl:     -dbname => $cdbname);
scripts/import/post_process.pl:  my $dbVar = DBH->connect
scripts/import/post_process.pl:  my $slice_adaptor = $dbCore->get_SliceAdaptor();
scripts/import/post_process.pl:  my $asma = $dbCore->get_AssemblyMapperAdaptor();
scripts/import/post_process.pl:  my $csa  = $dbCore->get_CoordSystemAdaptor();
scripts/import/post_process.pl:  my $top_cs  = $csa->fetch_by_name('chromosome');
scripts/import/post_process.pl:  my $sctg_cs = $csa->fetch_by_name('supercontig');
scripts/import/post_process.pl:  my $seq_cs  = $csa->fetch_by_name('seqlevel');
scripts/import/post_process.pl:  my $mapper1 = $asma->fetch_by_CoordSystems($top_cs, $sctg_cs);
scripts/import/post_process.pl:  my $mapper2 = $asma->fetch_by_CoordSystems($top_cs, $seq_cs);
scripts/import/post_process.pl:  $mapper2->max_pair_count(10e6);
scripts/import/post_process.pl:  $mapper2->register_all();
scripts/import/post_process.pl:  $mapper1->max_pair_count(10e6);
scripts/import/post_process.pl:  $mapper1->register_all();
scripts/import/post_process.pl:  $dbVar->do(qq{CREATE TEMPORARY TABLE tmp_map_weight
scripts/import/post_process.pl:  $dbVar->do(qq{ALTER TABLE tmp_map_weight 
scripts/import/post_process.pl:  my $slice_adaptor = $dbCore->get_SliceAdaptor();
scripts/import/post_process.pl:  my $asma = $dbCore->get_AssemblyMapperAdaptor();
scripts/import/post_process.pl:  my $csa  = $dbCore->get_CoordSystemAdaptor();
scripts/import/post_process.pl:  my $top_cs  = $csa->fetch_by_name('toplevel');
scripts/import/post_process.pl:  my $sctg_cs = $csa->fetch_by_name('supercontig');
scripts/import/post_process.pl:  my $mapper = $asma->fetch_by_CoordSystems($top_cs, $sctg_cs);
scripts/import/post_process.pl:  my $sth = $dbVar->prepare
scripts/import/post_process.pl:  $sth->execute();
scripts/import/post_process.pl:  $sth->bind_columns(\$vf_id, \$sr_id, \$sr_start, \$sr_end, \$sr_strand,
scripts/import/post_process.pl:  while($sth->fetch()) {
scripts/import/post_process.pl:          print FH join("\t", $cur_vf_id, $top_sr_id, $top_coord->start(),
scripts/import/post_process.pl:                        $top_coord->end(), $top_coord->strand(),
scripts/import/post_process.pl:      my $slice = $slice_adaptor->fetch_by_seq_region_id($sr_id);
scripts/import/post_process.pl:      my @coords = $mapper->map($slice->seq_region_name(), $sr_start, $sr_end,
scripts/import/post_process.pl:      if(@coords != 1 || $coords[0]->isa('Bio::EnsEMBL::Mapper::Gap')) {
scripts/import/post_process.pl:        $slice = $slice_adaptor->fetch_by_region
scripts/import/post_process.pl:          ($top_coord->coord_system()->name(),$top_coord->id(),
scripts/import/post_process.pl:           $top_coord->start(),$top_coord->end(), $top_coord->strand(),
scripts/import/post_process.pl:           $top_coord->coord_system()->version());
scripts/import/post_process.pl:        $ref_allele = $slice->seq();
scripts/import/post_process.pl:        $ref_allele = '-' if(!$ref_allele);
scripts/import/post_process.pl:        $top_sr_id = $slice->get_seq_region_id();
scripts/import/post_process.pl:  $sth->finish();
scripts/import/post_process.pl:      print FH join("\t", $vf_id, $top_sr_id, $top_coord->start(),
scripts/import/post_process.pl:                        $top_coord->end(), $top_coord->strand(),
scripts/import/post_process.pl:   $dbVar->do("DELETE FROM variation_feature");
scripts/import/post_process.pl:  $dbVar->do("DROP TABLE tmp_map_weight");
scripts/import/post_process.pl:  my $slice_adaptor = $dbCore->get_SliceAdaptor();
scripts/import/post_process.pl:  my $update_sth = $dbVar->prepare
scripts/import/post_process.pl:  my $sth = $dbVar->prepare(qq{SELECT fs.variation_id, fs.up_seq, fs.down_seq,
scripts/import/post_process.pl:  $sth->execute();
scripts/import/post_process.pl:  $sth->bind_columns(\$var_id, \$up_seq, \$dn_seq, \$sr_id, \$sr_start,
scripts/import/post_process.pl:  while($sth->fetch()) {
scripts/import/post_process.pl:      $up_sr_start = $sr_start - $up_len;
scripts/import/post_process.pl:      $up_sr_end   = $sr_start - 1;
scripts/import/post_process.pl:      $dn_sr_start = $sr_start - $dn_len;
scripts/import/post_process.pl:      $dn_sr_end   = $sr_start - 1;
scripts/import/post_process.pl:    my $slice = $slice_adaptor->fetch_by_seq_region_id($sr_id);
scripts/import/post_process.pl:    my @wobble = (0, 1, -1);
scripts/import/post_process.pl:        my $up = $slice->subseq($up_sr_start+$w, $up_sr_end+$w, $sr_strand);
scripts/import/post_process.pl:        my $dn = $slice->subseq($dn_sr_start+$w, $dn_sr_end+$w, $sr_strand);
scripts/import/post_process.pl:      $update_sth->execute($up_seq, $dn_seq, $up_sr_start, $up_sr_end,
scripts/import/post_process.pl:  $sth->finish();
scripts/import/post_process.pl:  $update_sth->finish();
scripts/import/post_process.pl:  my $csa = $dbCore->get_CoordSystemAdaptor();
scripts/import/post_process.pl:  my $cs = $csa->fetch_by_name($csname);
scripts/import/post_process.pl:  my $sth = $dbVar->prepare
scripts/import/post_process.pl:  $sth->execute($table_name, $cs->dbID());
scripts/import/post_process.pl:  $sth->finish();
scripts/import/post_process.pl:  my $sth = $dbVar->prepare
scripts/import/post_process.pl:  my $sa = $dbCore->get_SliceAdaptor();
scripts/import/post_process.pl:  my $slices = $sa->fetch_all('toplevel', undef, $inc_non_ref);
scripts/import/post_process.pl:          $slice->seq_region_name(), "\n");
scripts/import/post_process.pl:    my $genes = $slice->get_all_Genes();
scripts/import/post_process.pl:      $sth->execute($slice->get_seq_region_id(),
scripts/import/post_process.pl:                    $g->seq_region_start() - $UPSTREAM,
scripts/import/post_process.pl:                    $g->seq_region_end()   + $DNSTREAM);
scripts/import/post_process.pl:      my $rows = $sth->fetchall_arrayref();
scripts/import/post_process.pl:      foreach my $tr (@{$g->get_all_Transcripts()}) {
scripts/import/post_process.pl:        next if(!$tr->translation()); # skip pseudogenes
scripts/import/post_process.pl:        my $utr3 = $tr->three_prime_utr();
scripts/import/post_process.pl:        my $utr5 = $tr->five_prime_utr();
scripts/import/post_process.pl:          $var{'vf_id'}  = $row->[0];
scripts/import/post_process.pl:          $var{'start'}  = $row->[1] - $slice->start() + 1;
scripts/import/post_process.pl:          $var{'end'}    = $row->[2] - $slice->start() + 1;
scripts/import/post_process.pl:          $var{'strand'} = $row->[3];
scripts/import/post_process.pl:          $var{'tr_id'}  = $tr->dbID();
scripts/import/post_process.pl:          my @alleles = split('/', $row->[4]);
scripts/import/post_process.pl:          if($var{'strand'} != $tr->strand()) {
scripts/import/post_process.pl:            $var{'strand'} = $tr->strand();
scripts/import/post_process.pl:            my @arr = ($v->{'tr_id'},
scripts/import/post_process.pl:                       $v->{'vf_id'},
scripts/import/post_process.pl:                       join("/", @{$v->{'aa_alleles'}||[]}),
scripts/import/post_process.pl:                       $v->{'aa_start'},
scripts/import/post_process.pl:                       $v->{'aa_end'},
scripts/import/post_process.pl:                       $v->{'cdna_start'},
scripts/import/post_process.pl:                       $v->{'cdna_end'},
scripts/import/post_process.pl:                       $v->{'type'});
scripts/import/post_process.pl:    my $sth = $dbVar->prepare(qq{SELECT distinct(i.population_id)
scripts/import/post_process.pl:    $sth->execute();
scripts/import/post_process.pl:    $sth->bind_columns(\$population_id);
scripts/import/post_process.pl:    while ($sth->fetch()){
scripts/import/post_process.pl:    $sth->finish;
scripts/import/post_process.pl:    my %seq_region; #hash containing the mapping between seq_region_id->name region
scripts/import/post_process.pl:    my $sth = $dbVar->prepare
scripts/import/post_process.pl:    $sth->execute($population_id);
scripts/import/post_process.pl:    $sth->bind_columns(\$variation_id, \$variation_feature_id, \$seq_region_id, \$seq_region_start, \$individual_id, \$allele_1,\$allele_2,\$seq_region_end);
scripts/import/post_process.pl:    while ($sth->fetch()){
scripts/import/post_process.pl:    $sth->finish();
scripts/import/post_process.pl:    @alleles_ordered = sort({$alleles_variation->{$b} <=> $alleles_variation->{$a}} keys %{$alleles_variation});
scripts/import/post_process.pl:	if ($genotype_information->{$individual_id}{allele_1} ne $genotype_information->{$individual_id}{allele_2}){
scripts/import/post_process.pl:	    $genotype_information->{$individual_id}{genotype} = 'Aa';
scripts/import/post_process.pl:	    if ($alleles_ordered[0] eq $genotype_information->{$individual_id}{allele_1}){
scripts/import/post_process.pl:		$genotype_information->{$individual_id}{genotype} = 'AA';
scripts/import/post_process.pl:		$genotype_information->{$individual_id}{genotype} = 'aa';
scripts/import/post_process.pl:  my $tm = $tr->get_TranscriptMapper();
scripts/import/post_process.pl:  my @coords = $tm->genomic2cdna($var->{'start'},
scripts/import/post_process.pl:                                 $var->{'end'},
scripts/import/post_process.pl:                                 $var->{'strand'});
scripts/import/post_process.pl:  # E.g. a single multi-base variation may be both intronic and coding
scripts/import/post_process.pl:      $new_var{'end'} = $var->{'start'} + $c->length() - 1;
scripts/import/post_process.pl:      $var->{'start'} = $new_var{'end'} + 1;
scripts/import/post_process.pl:  if($c->isa('Bio::EnsEMBL::Mapper::Gap')) {
scripts/import/post_process.pl:    if($var->{'end'} < $tr->start()) {
scripts/import/post_process.pl:      $var->{'type'} = ($tr->strand() == 1) ? 'UPSTREAM' : 'DOWNSTREAM';
scripts/import/post_process.pl:    if($var->{'start'} > $tr->end()) {
scripts/import/post_process.pl:      $var->{'type'} = ($tr->strand() == 1) ? 'DOWNSTREAM' : 'UPSTREAM';
scripts/import/post_process.pl:    $var->{'type'} = 'INTRONIC';
scripts/import/post_process.pl:  $var->{'cdna_start'} = $c->start();
scripts/import/post_process.pl:  $var->{'cdna_end'}   = $c->end();
scripts/import/post_process.pl:  @coords = $tm->genomic2cds($var->{'start'}, $var->{'end'},$var->{'strand'});
scripts/import/post_process.pl:      $new_var{'end'} = $var->{'start'} + $c->length() - 1;
scripts/import/post_process.pl:      $var->{'start'} = $new_var{'end'} + 1;
scripts/import/post_process.pl:  if($c->isa('Bio::EnsEMBL::Mapper::Gap')) {
scripts/import/post_process.pl:    if($var->{'end'} < $tr->coding_region_start()) {
scripts/import/post_process.pl:      $var->{'type'} = ($tr->strand() == 1) ? '5PRIME_UTR' : '3PRIME_UTR';
scripts/import/post_process.pl:    elsif($var->{'start'} > $tr->coding_region_end()) {
scripts/import/post_process.pl:      $var->{'type'} = ($tr->strand() == 1) ? '3PRIME_UTR' : '5PRIME_UTR';
scripts/import/post_process.pl:  $var->{'cds_start'} = $c->start();
scripts/import/post_process.pl:  $var->{'cds_end'}   = $c->end();
scripts/import/post_process.pl:  @coords = $tm->genomic2pep($var->{'start'}, $var->{'end'}, $var->{'strand'});
scripts/import/post_process.pl:  if(@coords != 1 || $coords[0]->isa('Bio::EnsEMBL::Mapper::Gap')) {
scripts/import/post_process.pl:  $var->{'aa_start'} = $c->start();
scripts/import/post_process.pl:  $var->{'aa_end'}   = $c->end();
scripts/import/post_process.pl:  my $peptide = $tr->translate->seq();
scripts/import/post_process.pl:  my $len = $var->{'aa_end'} - $var->{'aa_start'} + 1;
scripts/import/post_process.pl:  my $old_aa = substr($peptide, $var->{'aa_start'} -1 , $len);
scripts/import/post_process.pl:  my $codon_cds_start = $var->{'aa_start'} * 3 - 2;
scripts/import/post_process.pl:  my $codon_cds_end   = $var->{'aa_end'}   * 3;
scripts/import/post_process.pl:  my $codon_len = $codon_cds_end - $codon_cds_start + 1;
scripts/import/post_process.pl:  my @alleles = @{$var->{'alleles'}};
scripts/import/post_process.pl:  my $var_len = $var->{'cds_end'} - $var->{'cds_start'} + 1;
scripts/import/post_process.pl:    $a =~ s/\-//;
scripts/import/post_process.pl:    my $cds = $tr->translateable_seq();
scripts/import/post_process.pl:      if(abs(length($a) - $var_len) % 3) {
scripts/import/post_process.pl:        $var->{'type'} = 'FRAMESHIFT_CODING';
scripts/import/post_process.pl:        $aa_alleles[0] = '-';
scripts/import/post_process.pl:        $old_aa    = '-';
scripts/import/post_process.pl:      substr($cds, $var->{'cds_start'}, $var_len) = $a;
scripts/import/post_process.pl:      my $codon_str = substr($cds, $codon_cds_start-1, $codon_len);
scripts/import/post_process.pl:      my $codon_seq = Bio::Seq->new(-seq      => $codon_str,
scripts/import/post_process.pl:                                    -moltype  => 'dna',
scripts/import/post_process.pl:                                    -alphabet => 'dna');
scripts/import/post_process.pl:      $new_aa = $codon_seq->translate()->seq();
scripts/import/post_process.pl:      $new_aa = '-'; # deletion
scripts/import/post_process.pl:    $var->{'type'} = 'NON_SYNONYMOUS_CODING';
scripts/import/post_process.pl:    $var->{'type'} = 'SYNONYMOUS_CODING';
scripts/import/post_process.pl:  $var->{'aa_alleles'} = \@aa_alleles;
scripts/import/post_process.pl:    -chost <hostname>    hostname of core Ensembl MySQL database (default = ecs2)
scripts/import/post_process.pl:    -cuser <user>        username of core Ensembl MySQL database (default = ensro)
scripts/import/post_process.pl:    -cpass <pass>        password of core Ensembl MySQL database
scripts/import/post_process.pl:    -cport <port>        TCP port of core Ensembl MySQL database (default = 3364)
scripts/import/post_process.pl:    -cdbname <dbname>    dbname of core Ensembl MySQL database
scripts/import/post_process.pl:    -vhost <hostname>    hostname of variation MySQL database to write to
scripts/import/post_process.pl:    -vuser <user>        username of variation MySQL database to write to (default = ensadmin)
scripts/import/post_process.pl:    -vpass <pass>        password of variation MySQL database to write to
scripts/import/post_process.pl:    -vport <port>        TCP port of variation MySQL database to write to (default = 3306)
scripts/import/post_process.pl:    -vdbname <dbname>    dbname of variation MySQL database to write to
scripts/import/post_process.pl:    -limit <number>      limit the number of rows for testing
scripts/import/post_process.pl:    -tmpdir <dir>        temp directory to use (with lots of space!)
scripts/import/post_process.pl:    -tmpfile <filename>   name of temp file to use
scripts/import/make_index_files.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/make_index_files.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/make_index_files.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/make_index_files.pl:my $inx = Bio::Index::Fastq->new(-filename => $index_filename,
scripts/import/make_index_files.pl:				 -write_flag => 1);
scripts/import/make_index_files.pl:$inx->make_index(@ARGV);
scripts/import/compress_genotypes.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/compress_genotypes.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/compress_genotypes.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/compress_genotypes.pl:use constant MAX_SHORT => 2**16 -1;
scripts/import/compress_genotypes.pl:usage('-TMP_DIR argument is required') if(!$TMP_DIR);
scripts/import/compress_genotypes.pl:usage('-TMP_FILE argument is required') if(!$TMP_FILE);
scripts/import/compress_genotypes.pl:usage('-species argument is required') if(!$species);
scripts/import/compress_genotypes.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/import/compress_genotypes.pl:my $vdba = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/import/compress_genotypes.pl:my $dbCore = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/import/compress_genotypes.pl:my $dbVar = $vdba->dbc->db_handle;
scripts/import/compress_genotypes.pl:    my $sth = $dbVar->prepare(qq{SELECT STRAIGHT_JOIN vf.seq_region_id, vf.seq_region_start, vf.seq_region_end, vf.seq_region_strand, ig.allele_1, ig.allele_2, ig.sample_id, vf.allele_string, v.flipped
scripts/import/compress_genotypes.pl:    $sth->execute();
scripts/import/compress_genotypes.pl:    $sth->bind_columns(\$seq_region_id, \$seq_region_start, \$seq_region_end, \$seq_region_strand, \$allele_1, \$allele_2, \$sample_id, \$allele_string, \$flipped);
scripts/import/compress_genotypes.pl:    while ($sth->fetch){
scripts/import/compress_genotypes.pl:		my $dbVar_write = $vdba->dbc->db_handle;
scripts/import/compress_genotypes.pl:	next if (defined $genotypes->{$sample_id}->{region_end} && $seq_region_start == $genotypes->{$sample_id}->{region_end}); #same variation and individual but different genotype !!!
scripts/import/compress_genotypes.pl:	if (!defined $genotypes->{$sample_id}->{region_start}){
scripts/import/compress_genotypes.pl:	    $genotypes->{$sample_id}->{region_start} = $seq_region_start;
scripts/import/compress_genotypes.pl:	    $genotypes->{$sample_id}->{region_end} = $seq_region_end;
scripts/import/compress_genotypes.pl:	if ((abs($genotypes->{$sample_id}->{region_start} - $seq_region_start) > DISTANCE()) || (abs($seq_region_start - $genotypes->{$sample_id}->{region_end}) > MAX_SHORT)){
scripts/import/compress_genotypes.pl:	    delete $genotypes->{$sample_id}; #and remove the printed entry
scripts/import/compress_genotypes.pl:	    $genotypes->{$sample_id}->{region_start} = $seq_region_start;
scripts/import/compress_genotypes.pl:	if ($seq_region_start != $genotypes->{$sample_id}->{region_start}){
scripts/import/compress_genotypes.pl:	    $blob = pack ("n",$seq_region_start - $genotypes->{$sample_id}->{region_end} - 1);
scripts/import/compress_genotypes.pl:	    $genotypes->{$sample_id}->{genotypes} .= escape($blob) . $allele_1 . $allele_2;
scripts/import/compress_genotypes.pl:	    $genotypes->{$sample_id}->{genotypes} = $allele_1 . $allele_2;
scripts/import/compress_genotypes.pl:	$genotypes->{$sample_id}->{region_end} = $seq_region_start;    #to avoid nasty effects of indels coordinates
scripts/import/compress_genotypes.pl:    $sth->finish();
scripts/import/compress_genotypes.pl:	    print FH join("\t",$sample_id,$seq_region_id, $genotypes->{$sample_id}->{region_start}, $genotypes->{$sample_id}->{region_end}, 1, $genotypes->{$sample_id}->{genotypes}) . "\n";
scripts/import/compress_genotypes.pl:	print FH join("\t",$sample_id,$seq_region_id, $genotypes->{$sample_id}->{region_start}, $genotypes->{$sample_id}->{region_end}, 1, $genotypes->{$sample_id}->{genotypes}) . "\n";
scripts/import/compress_genotypes.pl:    my $csa = $dbCore->get_CoordSystemAdaptor();
scripts/import/compress_genotypes.pl:    my $cs = $csa->fetch_by_name($csname);
scripts/import/compress_genotypes.pl:    my $sth = $dbVar->prepare
scripts/import/compress_genotypes.pl:    $sth->execute($table_name, $cs->dbID(),DISTANCE+1);
scripts/import/compress_genotypes.pl:    $sth->finish();
scripts/import/compress_genotypes.pl:		elsif($flipped == 0 && $seq_region_strand == -1) {
scripts/import/compress_genotypes.pl:	# flipped column has not been set - use old behaviour
scripts/import/compress_genotypes.pl:		if($seq_region_strand == -1) {
scripts/import/compress_genotypes.pl:    -tmpdir <dir>        temp directory to use (with lots of space!)
scripts/import/compress_genotypes.pl:    -tmpfile <filename>   name of temp file to use
scripts/import/compress_genotypes.pl:    -species <species_name> name of the specie you want to compress the genotypes
scripts/import/url_pages_for_health_check:http://staging.ensembl.org/Homo_sapiens/Variation/Summary?r=21:14857547-14867547;v=rs2256965;vdb=variation #for haplotype chromosome
scripts/import/url_pages_for_health_check:http://staging.ensembl.org/Homo_sapiens/Location/SequenceAlignment?r=20:38084753-38104752 
scripts/import/url_pages_for_health_check:http://staging.ensembl.org/Homo_sapiens/Variation/Mappings?r=21:14862047-14863047;v=rs699;vdb=variation;vf=724 #for gene/transcriptSNPView
scripts/import/run_ssaha2.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/import/run_ssaha2.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/import/run_ssaha2.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/import/run_ssaha2.pl:##[exonerate_bin_dir]/exonerate-1.4.0 --query [ssaha_input_dir]/1_query_seq --target [blast_db_dir]/softmasked_dusted.fa --showalignment no --showvulgar yes
scripts/import/run_ssaha2.pl:##nathan's affy array parameters to ensure one mismatch : --bestn 100 --dnahspthreshold 116 --fsmmemory 256 --dnawordlen 25 --dnawordthreshold 11
scripts/import/run_ssaha2.pl:##my affy parameters to ensure full match : [exonerate_bin_dir]/exonerate-1.4.0 --query [ssaha_input_dir]/1_query_seq --target [blast_db_dir]/softmasked_dusted.fa --showalignment yes --showvulgar no --ryo "vulgar: %S %V %pi\n" --dnahspthreshold 156
scripts/import/run_ssaha2.pl:$seed = "2 -kmer 6 -ckmer 6 -cmatch 10 -tags 1 -score 12 -skip 1 -sense 1" if $input_dir =~ /array/;
scripts/import/run_ssaha2.pl:my $queue_long = "-q long -M10000000 -R'select[mem>10000] rusage[mem=10000]'";## for watson reads
scripts/import/run_ssaha2.pl:my $queue_normal = "-q normal -M6000000 -R'select[mem>6000] rusage[mem=6000]'"; ##for new farm abi reads
scripts/import/run_ssaha2.pl:  if (! -f "$subject\.body") {
scripts/import/run_ssaha2.pl:    my $ssaha2build = "bsub $queue_long -J 'ssaha2build' -o $target_file\_out $ssahabuild -kmer 12 -skip $skip -save $subject $target_file";
scripts/import/run_ssaha2.pl:    my $call = "bsub -q normal -K -w 'done('ssaha2build')' -J waiting_process sleep 1"; #waits until all variation features have finished to continue
scripts/import/run_ssaha2.pl:    #next if (-z "$input");
scripts/import/run_ssaha2.pl:      my $num = `grep "^\@" $input |grep -v -c "[?%*]"`;
scripts/import/run_ssaha2.pl:	  my $e = $n+$size-1;
scripts/import/run_ssaha2.pl:	  if (! -e "$output_dir/ssaha_out_$input_file\:$n") { #check for ssaha2_output is exists or not
scripts/import/run_ssaha2.pl:	my $e = $n+$size-1;
scripts/import/run_ssaha2.pl:my $call = "bsub -K -w 'done(ssaha_out*)' -J waiting_process sleep 1"; #waits until all ssaha jobs have finished to continue
scripts/import/run_ssaha2.pl:    next if (-z "$out_file");
scripts/import/run_ssaha2.pl:  #my $ssaha_command = "$ssaha2 -rtype 454 -best 1 -output cigar -name -save $subject $input_file";
scripts/import/run_ssaha2.pl:  #my $ssaha_command = "$ssaha2 -seeds 5 -cut 5000 -memory 300 -best 1 -output cigar -name -save $subject $input_file";
scripts/import/run_ssaha2.pl:  my $ssaha_command = "$ssaha2 -align 0 -kmer 12 -skip $skip -seeds $seed -cut 5000 -output vulgar -depth 5 -best 1 -tags 1 -name -save $subject $input_file";
scripts/import/run_ssaha2.pl:  my $call = "bsub -J'ssaha_out_[$start-$end]%50' $queue -e $output_dir/ssaha.%I.err -o $output_dir/ssaha.%I.out ";
scripts/import/run_ssaha2.pl:  #$ssaha_command = "$ssaha2 -align 0 -kmer 12 -seeds $seed -cut 5000 -output vulgar -depth 5 -best 1 -tags 1 -save $subject $input_file";
scripts/import/run_ssaha2.pl:  #$ssaha_command = "$ssaha2 -start $n -end $end -seeds 5 -score 250 -tags 1 -best 1 -output cigar -name -memory 300 -cut 5000 -save $subject $input_file";
scripts/import/run_ssaha2.pl:  #for 454 reads -454 = "-skip 5 -seeds 2 -score 30 -sense 1 -cmatch 10 -ckmer 6" (use skip 5 instead of skip 3 to save memory)
scripts/import/run_ssaha2.pl:  $ssaha_command = "$ssaha2 -start $n -end $e -skip 5 -seeds 2 -score 30 -sense 1 -cmatch 10 -ckmer 6 -best 1 -output cigar -name -save $subject $input_file";
scripts/import/run_ssaha2.pl:  #$ssaha_command = "$ssaha2 -start $n -end $e -seeds 5 -cut 5000 -memory 300 -best 1 -output cigar -name -save $subject $input_file";
scripts/import/run_ssaha2.pl:  #$ssaha_command = "$ssaha2 -start $n -end $end -seeds 15 -score 250 -tags 1 -best 1 -output sam -name -memory 300 -cut 5000 -save $subject $input_file";
scripts/import/run_ssaha2.pl:  #my $call = "bsub -J $input_dir\_ssaha_job_$start $queue -e $output_dir/error_ssaha_$start -o $output_dir/ssaha_out_$start ";
scripts/import/run_ssaha2.pl:  my $call = "bsub -J'ssaha_out_[$start-$end]%50' $queue -e $output_dir/ssaha.%I:$n.err -o $output_dir/ssaha.%I:$n.out ";
scripts/import/run_ssaha2.pl:    my ($fseq,$lseq) = split /[W\-\_]+/,$rec_seq{$name};
scripts/import/run_ssaha2.pl:    #my $tot_length = $snp_posf + $snp_posl-2;
scripts/import/run_ssaha2.pl:    if (/^vulgar\:\s+(\S+)\s+(\d+)\s+(\d+)\s+(\+|\-)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\+|\-)\s+(\d+)\s+(.*)$/) {
scripts/import/run_ssaha2.pl:      $h->{'q_id'} = $1;
scripts/import/run_ssaha2.pl:      $h->{'q_start'} = $2;
scripts/import/run_ssaha2.pl:      $h->{'q_end'} = $3;
scripts/import/run_ssaha2.pl:      $h->{'q_strand'} = $4;
scripts/import/run_ssaha2.pl:      $h->{'t_id'} = $5;
scripts/import/run_ssaha2.pl:      $h->{'t_start'} = $6;
scripts/import/run_ssaha2.pl:      $h->{'t_end'} = $7;
scripts/import/run_ssaha2.pl:      $h->{'t_strand'} = $8;
scripts/import/run_ssaha2.pl:      $h->{'score'} = $9;
scripts/import/run_ssaha2.pl:      $h->{'match'} = $10;
scripts/import/run_ssaha2.pl:      push @{$rec_find{$h->{'q_id'}}}, $h if $h->{'q_id'};
scripts/import/run_ssaha2.pl:    my @h = sort {$b->{'score'}<=>$a->{'score'}} @{$rec_find{$q_id}};
scripts/import/run_ssaha2.pl:    my @mappings = grep {$_->{'score'} == $h[0]->{'score'}} @h;
scripts/import/run_ssaha2.pl:    # Comment out the old code checking number of mappings etc. This should be done by the post-processing scripts
scripts/import/run_ssaha2.pl:    elsif ($h[0]->{'score'} > $h[1]->{'score'} and @h=>2) {
scripts/import/run_ssaha2.pl:    elsif ($h[0]->{'score'} == $h[1]->{'score'} and @h==2) {
scripts/import/run_ssaha2.pl:    elsif ($h[1]->{'score'} > $h[2]->{'score'} and @h=>3) {
scripts/import/run_ssaha2.pl:    elsif ($h[1]->{'score'} == $h[2]->{'score'} and @h==3) {
scripts/import/run_ssaha2.pl:    elsif ($h[2]->{'score'} > $h[3]->{'score'} and @h=>4) {
scripts/import/run_ssaha2.pl:    elsif (($h[3]->{'t_id'}=~/6|MHC/ and $h[3]->{'score'} <= $h[2]->{'score'} and @h==4) or ($h[4] and $h[4]->{'t_id'}=~/6|MHC/ and $h[4]->{'score'} <= $h[2]->{'score'} and @h==5) or ($h[5] and $h[5]->{'t_id'}=~/6|MHC/ and $h[5]->{'score'} <= $h[2]->{'score'} and @h==6) or ($h[6] and $h[6]->{'t_id'}=~/6|MHC/ and $h[6]->{'score'} <= $h[2]->{'score'} and @h==7) or ($h[7] and $h[7]->{'t_id'}=~/6|MHC/ and $h[7]->{'score'} <= $h[2]->{'score'} and @h ==8)) {
scripts/import/run_ssaha2.pl:    my $q_id = $h->{'q_id'};
scripts/import/run_ssaha2.pl:    my $q_start = $h->{'q_start'};
scripts/import/run_ssaha2.pl:    my $q_end = $h->{'q_end'};
scripts/import/run_ssaha2.pl:    my $q_strand = $h->{'q_strand'};
scripts/import/run_ssaha2.pl:    my $t_id = $h->{'t_id'};
scripts/import/run_ssaha2.pl:    my $t_start = $h->{'t_start'};
scripts/import/run_ssaha2.pl:    my $t_end = $h->{'t_end'};
scripts/import/run_ssaha2.pl:    my $t_strand = $h->{'t_strand'};
scripts/import/run_ssaha2.pl:    my $score = $h->{'score'};
scripts/import/run_ssaha2.pl:    my $match = $h->{'match'};
scripts/import/run_ssaha2.pl:        $new_q_start = $q_start + $query_match_length - 1 if ($type eq 'M');
scripts/import/run_ssaha2.pl:        $new_t_start = $t_start + $target_match_length -1 if ($type eq 'M');
scripts/import/run_ssaha2.pl:      elsif ($q_strand eq '-') {
scripts/import/run_ssaha2.pl:        $new_q_start = $q_start - $query_match_length + 1 if ($type eq 'M');
scripts/import/run_ssaha2.pl:        $new_q_start = $q_start - $query_match_length - 1 if ($type eq 'G');
scripts/import/run_ssaha2.pl:        $new_t_start = $t_start + $target_match_length -1 if ($type eq 'M');
scripts/import/run_ssaha2.pl:	  $snp_t_start = $t_start + abs($snp_q_pos-$q_start);
scripts/import/run_ssaha2.pl:          #print "abs is ",abs($snp_q_pos-$q_start),"\n";
scripts/import/run_ssaha2.pl:	    $snp_t_end = $snp_t_start -1;
scripts/python/download_cgc_file.py:Version: 1.0 (2022-08-22)
scripts/python/download_cgc_file.py:                    yield json.loads(line.decode("utf-8").rstrip())
scripts/python/download_cgc_file.py:    parser = argparse.ArgumentParser(description="Retrieve target - disease "
scripts/python/download_cgc_file.py:    parser.add_argument("-r", "--release",
scripts/python/download_cgc_file.py:    parser.add_argument("-d", "--dest_dir",
scripts/export/gvf_dumps/BaseGVFDumper.pm:Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/gvf_dumps/BaseGVFDumper.pm:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/gvf_dumps/BaseGVFDumper.pm:     http://www.apache.org/licenses/LICENSE-2.0
scripts/export/gvf_dumps/BaseGVFDumper.pm:		$self->{$attrib} = $params{$attrib};
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $fh = FileHandle->new($self->{'output'}, "w");
scripts/export/gvf_dumps/BaseGVFDumper.pm:    if ($self->{'include_failed'} || $self->{'just_failed'}) {
scripts/export/gvf_dumps/BaseGVFDumper.pm:        $self->include_failed_variations();
scripts/export/gvf_dumps/BaseGVFDumper.pm:    if ($self->{'include_svs'} || $self->{'just_failed'}) {
scripts/export/gvf_dumps/BaseGVFDumper.pm:        $svfa = $self->{'vdba'}->get_StructuralVariationFeatureAdaptor;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    if ($self->{'set_name'}) {
scripts/export/gvf_dumps/BaseGVFDumper.pm:        $self->init_set_name();
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $vfa           = $self->{'vdba'}->get_VariationFeatureAdaptor;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $slice_adaptor = $self->{'cdba'}->get_SliceAdaptor;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $chunk_size    = $self->{'chunk_size'};
scripts/export/gvf_dumps/BaseGVFDumper.pm:    if (@{$self->{'seq_region_names'}}) {
scripts/export/gvf_dumps/BaseGVFDumper.pm:        my @seq_region_names = @{$self->{'seq_region_names'}};
scripts/export/gvf_dumps/BaseGVFDumper.pm:            my $slice = $slice_adaptor->fetch_by_region('toplevel', $name)
scripts/export/gvf_dumps/BaseGVFDumper.pm:        $slices = $slice_adaptor->fetch_all('toplevel');
scripts/export/gvf_dumps/BaseGVFDumper.pm:	$sub_slice_start = $working_slice->start; 
scripts/export/gvf_dumps/BaseGVFDumper.pm:	$sub_slice_end = $sub_slice_start + $chunk_size - 1;
scripts/export/gvf_dumps/BaseGVFDumper.pm:	$slice_end = $working_slice->end;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    my $vdba = $self->{'vdba'};
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $vdba->include_failed_variations(1);
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $self->{'vdba'} = $vdba;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    my $dbh = $self->{'vdba'}->dbc->db_handle;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    my $sth = $dbh->prepare(qq{
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $sth->execute;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    while (my ($id, $desc) = $sth->fetchrow_array) {
scripts/export/gvf_dumps/BaseGVFDumper.pm:        $failed_descs->{$id} = $desc;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $sth = $dbh->prepare(qq{
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $sth->execute;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $sth->bind_columns(\$v_id, \$desc_id);
scripts/export/gvf_dumps/BaseGVFDumper.pm:    while ($sth->fetch) {
scripts/export/gvf_dumps/BaseGVFDumper.pm:        $failed_ids->{$v_id} = $desc_id;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $sth = $dbh->prepare(qq{
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $sth->execute;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $sth->bind_columns(\$v_id, \$desc_id);
scripts/export/gvf_dumps/BaseGVFDumper.pm:    while ($sth->fetch) {
scripts/export/gvf_dumps/BaseGVFDumper.pm:        $structural_failed_ids->{$v_id} = $desc_id;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    my $vsa = $self->{'vdba'}->get_VariationSetAdaptor;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $set = $vsa->fetch_by_name($self->{'set_name'})
scripts/export/gvf_dumps/BaseGVFDumper.pm:        or die "Didn't find set $self->{'set_name'}";
scripts/export/gvf_dumps/BaseGVFDumper.pm:    return unless($self->has_next_slice);
scripts/export/gvf_dumps/BaseGVFDumper.pm:		$sub_slice_start = $working_slice->start; 
scripts/export/gvf_dumps/BaseGVFDumper.pm:		$slice_end = $working_slice->end;
scripts/export/gvf_dumps/BaseGVFDumper.pm:	$sub_slice_end = $sub_slice_start + $chunk_size - 1;
scripts/export/gvf_dumps/BaseGVFDumper.pm:	$sub_slice_end = $working_slice->end if ($sub_slice_end > $working_slice->end);
scripts/export/gvf_dumps/BaseGVFDumper.pm:	my $sub_slice = $working_slice->sub_Slice($sub_slice_start, $sub_slice_end);
scripts/export/gvf_dumps/BaseGVFDumper.pm:	if ($self->{'use_iterator'}) { 
scripts/export/gvf_dumps/BaseGVFDumper.pm:        $vfs = $vfa->fetch_Iterator_by_Slice($slice);
scripts/export/gvf_dumps/BaseGVFDumper.pm:    elsif ($self->{'somatic'}) {
scripts/export/gvf_dumps/BaseGVFDumper.pm:		$vfs = $vfa->fetch_all_somatic_by_Slice_constraint_with_TranscriptVariations($slice);
scripts/export/gvf_dumps/BaseGVFDumper.pm:    elsif ($self->{'set'}) {
scripts/export/gvf_dumps/BaseGVFDumper.pm:		$vfs = $vfa->fetch_all_by_Slice_VariationSet($slice, $set);
scripts/export/gvf_dumps/BaseGVFDumper.pm:    elsif ($self->{'include_consequences'}) {
scripts/export/gvf_dumps/BaseGVFDumper.pm:		$vfs = $vfa->fetch_all_by_Slice_constraint_with_TranscriptVariations($slice);
scripts/export/gvf_dumps/BaseGVFDumper.pm:    	$vfs = $vfa->fetch_all_by_Slice($slice);
scripts/export/gvf_dumps/BaseGVFDumper.pm:    return $self->_generic_Iterator($vfs);	
scripts/export/gvf_dumps/BaseGVFDumper.pm:    my $svfs = $svfa->fetch_all_by_Slice($slice, 1);
scripts/export/gvf_dumps/BaseGVFDumper.pm:    return $self->_generic_Iterator($svfs);
scripts/export/gvf_dumps/BaseGVFDumper.pm:    my $iterator =  Bio::EnsEMBL::Utils::Iterator->new($vfs);   
scripts/export/gvf_dumps/BaseGVFDumper.pm:    print $fh $working_slice->gvf_header(%$header);
scripts/export/gvf_dumps/BaseGVFDumper.pm:    # print a sequence-region line in the GVF file for each slice @risk
scripts/export/gvf_dumps/BaseGVFDumper.pm:    print $fh '##sequence-region ', $working_slice->seq_region_name, ' ',$working_slice->start, ' ', $working_slice->end, "\n"; 
scripts/export/gvf_dumps/BaseGVFDumper.pm:        print $fh '##sequence-region ', $slice->seq_region_name, ' ',$slice->start, ' ', $slice->end, "\n"; 
scripts/export/gvf_dumps/BaseGVFDumper.pm:    if ($self->{'include_failed'} || $self->{'just_failed'}) {
scripts/export/gvf_dumps/BaseGVFDumper.pm:        my $desc = $self->failure_reason($vf->{_variation_id});
scripts/export/gvf_dumps/BaseGVFDumper.pm:            $attrs->{ensembl_failure_reason} = $desc;
scripts/export/gvf_dumps/BaseGVFDumper.pm:            return if $self->{'just_failed'};
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $attrs->{ID} = ++$id_count;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    my $gvf_line = $vf->to_gvf(
scripts/export/gvf_dumps/BaseGVFDumper.pm:                        include_consequences      => $self->{'include_consequences'},
scripts/export/gvf_dumps/BaseGVFDumper.pm:                        include_coding_details    => $self->{'include_coding_details'},
scripts/export/gvf_dumps/BaseGVFDumper.pm:                        include_global_maf        => $self->{'include_global_maf'},
scripts/export/gvf_dumps/BaseGVFDumper.pm:                        include_validation_states => $self->{'include_validation_states'},
scripts/export/gvf_dumps/BaseGVFDumper.pm:                        include_clinical_significance => $self->{'include_clinical_significance'},
scripts/export/gvf_dumps/BaseGVFDumper.pm:    return if $svf->var_class eq 'CNV_PROBE';
scripts/export/gvf_dumps/BaseGVFDumper.pm:   if ($self->{'include_failed'} || $self->{'just_failed'}) {
scripts/export/gvf_dumps/BaseGVFDumper.pm:        my $desc = $self->failure_reason($svf->{structural_variation_id});
scripts/export/gvf_dumps/BaseGVFDumper.pm:            $attrs->{ensembl_failure_reason} = $desc;
scripts/export/gvf_dumps/BaseGVFDumper.pm:            return if $self->{'just_failed'};
scripts/export/gvf_dumps/BaseGVFDumper.pm:    my $coords = join '-', $svf->seq_region_name, $svf->seq_region_start, $svf->seq_region_end; 
scripts/export/gvf_dumps/BaseGVFDumper.pm:    if (my $prev_coords = $prev_svs->{$svf->variation_name}) {
scripts/export/gvf_dumps/BaseGVFDumper.pm:        warn "repeated SV: ".$svf->variation_name." coords 1: $prev_coords, coords 2: $coords\n" if $prev_coords ne $coords;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    # feature's own identifier and we have to use a file-wide count as for
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $attrs->{ID} = ++$id_count;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    my $gvf_line = $svf->to_gvf(extra_attrs => $attrs);     
scripts/export/gvf_dumps/BaseGVFDumper.pm:    $prev_svs->{$svf->variation_name} = $coords if $gvf_line;
scripts/export/gvf_dumps/BaseGVFDumper.pm:    my $desc_id      = $failed_ids->{$variation_id};
scripts/export/gvf_dumps/BaseGVFDumper.pm:        $desc_id = $structural_failed_ids->{$variation_id};
scripts/export/gvf_dumps/BaseGVFDumper.pm:        return $failed_descs->{$desc_id};
scripts/export/gvf_dumps/gvf_dumps_settings.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/gvf_dumps/gvf_dumps_settings.pl:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/gvf_dumps/gvf_dumps_settings.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/export/gvf_dumps/gvf_dumps_settings.pl:# release_gvf.pl - Create GVF dumps for an ensembl release
scripts/export/gvf_dumps/gvf_dumps_settings.pl:die "--output_dir argument is required, try --help for usage" 
scripts/export/gvf_dumps/gvf_dumps_settings.pl:die "--registry argument is required, try --help for usage" 
scripts/export/gvf_dumps/gvf_dumps_settings.pl:my $default_rc = '-q normal -R"select[mem>1500] rusage[mem=1500]" -M1500000';
scripts/export/gvf_dumps/gvf_dumps_settings.pl:        argument => '--include_consequences',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:        argument => '--just_failed',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:        argument => '--just_structural_variations',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:        argument => '--somatic',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:        argument => '--somatic --include_consequences',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            rc => '-q normal -R"select[mem>4000] rusage[mem=4000]" -M4000000',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            #'CSHL-HAPMAP:HapMap-CEU'  => '',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            #'CSHL-HAPMAP:HapMap-HCB'  => '',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            #'CSHL-HAPMAP:HapMap-JPT'  => '',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            #'CSHL-HAPMAP:HapMap-YRI'  => '',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            #'CSHL-HAPMAP:HAPMAP-ASW'  => '',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            #'CSHL-HAPMAP:HAPMAP-CHB'  => '',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            #'CSHL-HAPMAP:HAPMAP-CHD'  => '',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            #'CSHL-HAPMAP:HAPMAP-GIH'  => '',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            #'CSHL-HAPMAP:HAPMAP-LWK'  => '',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            #'CSHL-HAPMAP:HAPMAP-MEX'  => '',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            #'CSHL-HAPMAP:HAPMAP-MKK'  => '',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            #'CSHL-HAPMAP:HAPMAP-TSI'  => '',
scripts/export/gvf_dumps/gvf_dumps_settings.pl:unless (-e $toplevel_dir || $test) {
scripts/export/gvf_dumps/gvf_dumps_settings.pl:my $normal_opts = "--species %s --registry %s --compress --chunk_size 1000 ";
scripts/export/gvf_dumps/gvf_dumps_settings.pl:    my $config = $species_config->{$species_name};
scripts/export/gvf_dumps/gvf_dumps_settings.pl:    #unless (-e $dir || $test) {
scripts/export/gvf_dumps/gvf_dumps_settings.pl:    unless (-e $dir) {
scripts/export/gvf_dumps/gvf_dumps_settings.pl:        if  ($data->{$type}->{all} || $config->{$type}) {
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            my $load_balance = $config->{settings}->{load_balance}->{$type} || 0;
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            my $rc = $config->{settings}->{rc} || $default_rc;
scripts/export/gvf_dumps/gvf_dumps_settings.pl:            my $name = $species_name . $data->{$type}->{postfix};
scripts/export/gvf_dumps/gvf_dumps_settings.pl:                for my $individual (keys %{ $config->{individuals} || {} }) {
scripts/export/gvf_dumps/gvf_dumps_settings.pl:                    make_cmd($individual, "--individual '$individual'", $dir, $rc, $load_balance);
scripts/export/gvf_dumps/gvf_dumps_settings.pl:                for my $population (keys %{ $config->{populations} || {} }) {
scripts/export/gvf_dumps/gvf_dumps_settings.pl:                    $name =~ s/:/-/g;
scripts/export/gvf_dumps/gvf_dumps_settings.pl:                    make_cmd($name, "--population '$population'", $dir, $rc, $load_balance);
scripts/export/gvf_dumps/gvf_dumps_settings.pl:                make_cmd($name, $data->{$type}->{argument}, $dir, $rc, $load_balance);
scripts/export/gvf_dumps/gvf_dumps_settings.pl:        my $job_arg = ' --load_balance ';
scripts/export/gvf_dumps/gvf_dumps_settings.pl:        $name = '"' . $name . '[1-12]%4"'; 
scripts/export/gvf_dumps/gvf_dumps_settings.pl:    $cmd = "bsub -o $out -e $err -J $name $rc perl $script $opts $extra_opts --output $gvf";
scripts/export/gvf_dumps/gvf_dumps_settings.pl:perl release_gvf.pl --output_dir /lustre/scratch110/ensembl/at7/Dumps/release_69_gvf/ --registry /lustre/scratch110/ensembl/at7/Dumps/ensembl.registry.69 --species Danio_rerio
scripts/export/gvf_dumps/gvf_dumps_settings.pl:release_gvf.pl --output_dir DIR [options]
scripts/export/gvf_dumps/gvf_dumps_settings.pl:  release_gvf.pl --output_dir /lustre/scratch103/ensembl/gr5/release_61_GVFs \
scripts/export/gvf_dumps/gvf_dumps_settings.pl:    --registry ensembl.registry
scripts/export/gvf_dumps/gvf_dumps_settings.pl:  release_gvf.pl --output_dir human_and_mouse_GVFs --species Mus_musculus --species Homo_sapiens
scripts/export/gvf_dumps/gvf_dumps_settings.pl:  release_gvf.pl --output_dir non_human_GVFs --ignore Homo_sapiens
scripts/export/gvf_dumps/gvf_dumps_settings.pl:  release_gvf.pl --output_dir human_GVFs --species Homo_sapiens --load_file load_balance.txt
scripts/export/gvf_dumps/gvf_dumps_settings.pl:=item B<--registry FILE>
scripts/export/gvf_dumps/gvf_dumps_settings.pl:=item B<--output_dir DIR>
scripts/export/gvf_dumps/gvf_dumps_settings.pl:Create the files under this directory, a sub-directory will be created for each 
scripts/export/gvf_dumps/gvf_dumps_settings.pl:=item B<--script NAME>
scripts/export/gvf_dumps/gvf_dumps_settings.pl:=item B<--test>
scripts/export/gvf_dumps/gvf_dumps_settings.pl:=item B<--species NAME>
scripts/export/gvf_dumps/gvf_dumps_settings.pl:=item B<--ignore NAME>
scripts/export/gvf_dumps/gvf_dumps_settings.pl:=item B<--help>
scripts/export/gvf_dumps/GVFDumper.pm:Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/gvf_dumps/GVFDumper.pm:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/gvf_dumps/GVFDumper.pm:     http://www.apache.org/licenses/LICENSE-2.0
scripts/export/gvf_dumps/GVFDumper.pm:	my $self = $class->SUPER::new(@_);
scripts/export/gvf_dumps/GVFDumper.pm:	$self->SUPER::init();
scripts/export/gvf_dumps/GVFDumper.pm:    $self->SUPER::print_gvf_header(\%header);
scripts/export/gvf_dumps/GVFDumper.pm:	while ($sub_slice = $self->SUPER::next_slice()) {
scripts/export/gvf_dumps/GVFDumper.pm:        #print "DEBUG ", $sub_slice->name, " ", $sub_slice->start, " ", $sub_slice->end, "\n";
scripts/export/gvf_dumps/GVFDumper.pm:        unless ($self->{'just_svs'}) {
scripts/export/gvf_dumps/GVFDumper.pm:            my $vfs = $self->SUPER::vfs_on_slice($sub_slice);
scripts/export/gvf_dumps/GVFDumper.pm:            VF : while ($vf = $vfs->next()) {
scripts/export/gvf_dumps/GVFDumper.pm:                $self->SUPER::print_variation($vf);
scripts/export/gvf_dumps/GVFDumper.pm:        if ($self->{'include_svs'}) {
scripts/export/gvf_dumps/GVFDumper.pm:            my $svfs = $self->SUPER::svfs_on_slice($sub_slice);
scripts/export/gvf_dumps/GVFDumper.pm:            while ($svf = $svfs->next()) {
scripts/export/gvf_dumps/GVFDumper.pm:                 $self->SUPER::print_structural_variation($svf); 
scripts/export/gvf_dumps/combine_load_balance.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/gvf_dumps/combine_load_balance.pl:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/gvf_dumps/combine_load_balance.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/export/gvf_dumps/combine_load_balance.pl:    '1000GENOMES-phase_1_AFR',
scripts/export/gvf_dumps/combine_load_balance.pl:    '1000GENOMES-phase_1_ASN',
scripts/export/gvf_dumps/combine_load_balance.pl:    '1000GENOMES-phase_1_AMR',
scripts/export/gvf_dumps/combine_load_balance.pl:    '1000GENOMES-phase_1_EUR',
scripts/export/gvf_dumps/combine_load_balance.pl:    my $fh   = FileHandle->new($gvf_dir . $file_name . '.gvf', 'w') ;
scripts/export/gvf_dumps/combine_load_balance.pl:    my $fh_1 = FileHandle->new($gvf_dir . 'completed/' . $file_name . ".1.gvf", 'r');
scripts/export/gvf_dumps/combine_load_balance.pl:        my $fh_tmp = FileHandle->new($gvf_dir . 'completed/' . $file_name . ".$i.gvf", 'r');
scripts/export/gvf_dumps/combine_load_balance.pl:                if (/^##sequence-region/) {
scripts/export/gvf_dumps/combine_load_balance.pl:        my $fh_tmp = FileHandle->new($gvf_dir . 'completed/' . $file_name . ".$i.gvf", 'r');
scripts/export/gvf_dumps/combine_load_balance.pl:combine_load_balance.pl --gvf_output FILE --header_file FILE --log_file FILE
scripts/export/gvf_dumps/combine_load_balance.pl:=item B<--gvf_output FILE>
scripts/export/gvf_dumps/combine_load_balance.pl:=item B<--header_file FILE>
scripts/export/gvf_dumps/combine_load_balance.pl:=item B<--log_file FILE>
scripts/export/gvf_dumps/combine_load_balance.pl:=item B<--help>
scripts/export/gvf_dumps/run_gvf_dumps.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/gvf_dumps/run_gvf_dumps.pl:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/gvf_dumps/run_gvf_dumps.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/export/gvf_dumps/run_gvf_dumps.pl:die "species argument required, try --help for usage instructions\n" unless $species;
scripts/export/gvf_dumps/run_gvf_dumps.pl:    $reg->load_registry_from_db(-host => $host, -user => $user, -port => $port);
scripts/export/gvf_dumps/run_gvf_dumps.pl:    $reg->load_all($registry);
scripts/export/gvf_dumps/run_gvf_dumps.pl:    push @seq_regions, @{$translate_to_seq_region->{$load_balance}};
scripts/export/gvf_dumps/run_gvf_dumps.pl:my $cdba = $reg->get_DBAdaptor($species, 'core') 
scripts/export/gvf_dumps/run_gvf_dumps.pl:my $vdba = $reg->get_DBAdaptor($species, 'variation') 
scripts/export/gvf_dumps/run_gvf_dumps.pl:    $dumper = IndividualGVFDumper->new(%arguments);
scripts/export/gvf_dumps/run_gvf_dumps.pl:    $dumper = PopulationGVFDumper->new(%arguments);
scripts/export/gvf_dumps/run_gvf_dumps.pl:    $dumper = GVFDumper->new(%arguments);
scripts/export/gvf_dumps/run_gvf_dumps.pl:$dumper->dump();
scripts/export/release_gvf.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/release_gvf.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/release_gvf.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/export/release_gvf.pl:# release_gvf.pl - Create GVF dumps for an ensembl release
scripts/export/release_gvf.pl:die "--output_dir argument is required, try --help for usage" 
scripts/export/release_gvf.pl:die "--registry argument is required, try --help for usage" 
scripts/export/release_gvf.pl:my $default_rc = '-q long';
scripts/export/release_gvf.pl:            '1000GENOMES:pilot_1_CEU_low_coverage_panel'    => '1000 genomes - Low coverage - CEU',
scripts/export/release_gvf.pl:            '1000GENOMES:pilot_1_CHB+JPT_low_coverage_panel'=> '1000 genomes - Low coverage - CHB+JPT',
scripts/export/release_gvf.pl:            '1000GENOMES:pilot_1_YRI_low_coverage_panel'    => '1000 genomes - Low coverage - YRI',
scripts/export/release_gvf.pl:            '1000GENOMES:pilot_3_CEU_exon_capture_panel'    => '1000 genomes - High coverage exons - CEU',
scripts/export/release_gvf.pl:            '1000GENOMES:pilot_3_CHB_exon_capture_panel'    => '1000 genomes - High coverage exons - CHB',
scripts/export/release_gvf.pl:            '1000GENOMES:pilot_3_CHD_exon_capture_panel'    => '1000 genomes - High coverage exons - CHD',
scripts/export/release_gvf.pl:            '1000GENOMES:pilot_3_JPT_exon_capture_panel'    => '1000 genomes - High coverage exons - JPT',
scripts/export/release_gvf.pl:            '1000GENOMES:pilot_3_LWK_exon_capture_panel'    => '1000 genomes - High coverage exons - LWK',
scripts/export/release_gvf.pl:            '1000GENOMES:pilot_3_TSI_exon_capture_panel'    => '1000 genomes - High coverage exons - TSI',
scripts/export/release_gvf.pl:            '1000GENOMES:pilot_3_YRI_exon_capture_panel'    => '1000 genomes - High coverage exons - YRI',
scripts/export/release_gvf.pl:            'CSHL-HAPMAP:HapMap-CEU'            => '',
scripts/export/release_gvf.pl:            'CSHL-HAPMAP:HapMap-HCB'            => '',
scripts/export/release_gvf.pl:            'CSHL-HAPMAP:HapMap-JPT'            => '',
scripts/export/release_gvf.pl:            'CSHL-HAPMAP:HapMap-YRI'            => '',
scripts/export/release_gvf.pl:            'CSHL-HAPMAP:HAPMAP-ASW'            => '',
scripts/export/release_gvf.pl:            'CSHL-HAPMAP:HAPMAP-CHB'            => '',
scripts/export/release_gvf.pl:            'CSHL-HAPMAP:HAPMAP-CHD'            => '',
scripts/export/release_gvf.pl:            'CSHL-HAPMAP:HAPMAP-GIH'            => '',
scripts/export/release_gvf.pl:            'CSHL-HAPMAP:HAPMAP-LWK'            => '',
scripts/export/release_gvf.pl:            'CSHL-HAPMAP:HAPMAP-MEX'            => '',
scripts/export/release_gvf.pl:            'CSHL-HAPMAP:HAPMAP-MKK'            => '',
scripts/export/release_gvf.pl:            'CSHL-HAPMAP:HAPMAP-TSI'            => '',
scripts/export/release_gvf.pl:        rc                      => '-q long -R"select[mem>15000] rusage[mem=15000]" -M15000000',
scripts/export/release_gvf.pl:unless (-e $toplevel_dir || $test) {
scripts/export/release_gvf.pl:my $normal_opts = "--species %s --registry %s --compress --chunk_size 100";
scripts/export/release_gvf.pl:    my $config = $species_config->{$species_name};
scripts/export/release_gvf.pl:    my $rc = $config->{rc} || $default_rc;
scripts/export/release_gvf.pl:    unless (-e $dir || $test) {
scripts/export/release_gvf.pl:    my $cmd_root =  "bsub $rc perl $script $opts --output";
scripts/export/release_gvf.pl:        my $cmd = "bsub -o $out -e $err -J $name $rc perl $script $opts $extra_opts --output $gvf";
scripts/export/release_gvf.pl:    push @cmds, $make_cmd->();
scripts/export/release_gvf.pl:    push @cmds, $make_cmd->('_incl_consequences', '--include_consequences');
scripts/export/release_gvf.pl:    push @cmds, $make_cmd->('_failed', '--just_failed');
scripts/export/release_gvf.pl:    if ($config->{somatic}) {
scripts/export/release_gvf.pl:        push @cmds, $make_cmd->('_somatic', '--somatic');
scripts/export/release_gvf.pl:        push @cmds, $make_cmd->('_somatic_incl_consequences', '--somatic --include_consequences');
scripts/export/release_gvf.pl:    if ($config->{structural_variations}) {
scripts/export/release_gvf.pl:        push @cmds, $make_cmd->('_structural_variations', '--just_structural_variations');
scripts/export/release_gvf.pl:    for my $ind (keys %{ $config->{individuals} || {} }) {
scripts/export/release_gvf.pl:        push @cmds, $make_cmd->($ind, "--individual '$ind'");
scripts/export/release_gvf.pl:        #my $set = $config->{individuals}->{$ind};
scripts/export/release_gvf.pl:        #push @cmds, $make_cmd->($ind, "--individual '$ind' --set '$set'");
scripts/export/release_gvf.pl:    for my $pop (keys %{ $config->{populations} || {} }) {
scripts/export/release_gvf.pl:        $name =~ s/:/-/g;
scripts/export/release_gvf.pl:        push @cmds, $make_cmd->($name, "--population '$pop'");
scripts/export/release_gvf.pl:        #my $set = $config->{populations}->{$pop};
scripts/export/release_gvf.pl:        #push @cmds, $make_cmd->($name, "--population '$pop' --set '$set'");
scripts/export/release_gvf.pl:release_gvf.pl --output_dir DIR [options]
scripts/export/release_gvf.pl:  release_gvf.pl --output_dir /lustre/scratch103/ensembl/gr5/release_61_GVFs \
scripts/export/release_gvf.pl:    --registry ensembl.registry
scripts/export/release_gvf.pl:  release_gvf.pl --output_dir human_and_mouse_GVFs --species Mus_musculus --species Homo_sapiens
scripts/export/release_gvf.pl:  release_gvf.pl --output_dir non_human_GVFs --ignore Homo_sapiens
scripts/export/release_gvf.pl:=item B<--registry FILE>
scripts/export/release_gvf.pl:=item B<--output_dir DIR>
scripts/export/release_gvf.pl:Create the files under this directory, a sub-directory will be created for each 
scripts/export/release_gvf.pl:=item B<--script NAME>
scripts/export/release_gvf.pl:=item B<--test>
scripts/export/release_gvf.pl:=item B<--species NAME>
scripts/export/release_gvf.pl:=item B<--ignore NAME>
scripts/export/release_gvf.pl:=item B<--help>
scripts/export/dump_hapmap_genotypes.pl:  Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/dump_hapmap_genotypes.pl:  Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/dump_hapmap_genotypes.pl:       http://www.apache.org/licenses/LICENSE-2.0
scripts/export/dump_hapmap_genotypes.pl:CSHL-HAPMAP:HAPMAP-ASW 90
scripts/export/dump_hapmap_genotypes.pl:CSHL-HAPMAP:HAPMAP-CHB 90
scripts/export/dump_hapmap_genotypes.pl:CSHL-HAPMAP:HAPMAP-CHD 100
scripts/export/dump_hapmap_genotypes.pl:CSHL-HAPMAP:HAPMAP-GIH 100
scripts/export/dump_hapmap_genotypes.pl:CSHL-HAPMAP:HAPMAP-LWK 100 
scripts/export/dump_hapmap_genotypes.pl:CSHL-HAPMAP:HAPMAP-MEX 90 
scripts/export/dump_hapmap_genotypes.pl:CSHL-HAPMAP:HAPMAP-MKK 180
scripts/export/dump_hapmap_genotypes.pl:CSHL-HAPMAP:HAPMAP-TSI 100
scripts/export/dump_hapmap_genotypes.pl:CSHL-HAPMAP:HapMap-CEU 185
scripts/export/dump_hapmap_genotypes.pl:CSHL-HAPMAP:HapMap-HCB 48
scripts/export/dump_hapmap_genotypes.pl:CSHL-HAPMAP:HapMap-JPT 93
scripts/export/dump_hapmap_genotypes.pl:CSHL-HAPMAP:HapMap-YRI 185
scripts/export/dump_hapmap_genotypes.pl:submitter_handle: CSHL-HAPMAP
scripts/export/dump_hapmap_genotypes.pl:  - dump distinct variation_id and subsnp_id from allele where frequency_submitter_handle=2 (CSHL-HAPMAP)
scripts/export/dump_hapmap_genotypes.pl:  - 5037297 variation_ids/subsnp_ids
scripts/export/dump_hapmap_genotypes.pl:  - use all sample ids from the set of hapmap populations
scripts/export/dump_hapmap_genotypes.pl:  - dump all genotypes from compressed_genotype_var if subsnp_id is linked to CSHL-HAPMAP and sample_id in set
scripts/export/dump_hapmap_genotypes.pl:  - dump per chrom
scripts/export/dump_hapmap_genotypes.pl:  - dump looks like this: variation_id subsnp_id sample_id genotype_code 
scripts/export/dump_hapmap_genotypes.pl:- fix problem with genotypes on Y chrom
scripts/export/dump_hapmap_genotypes.pl:  - dump population allele frequencies per hapmap population (ASW, CHB, ..)
scripts/export/dump_hapmap_genotypes.pl:  - dump data from the allele table if frequency_submitter_handle=2  
scripts/export/dump_hapmap_genotypes.pl:  - this is dumped and added to the final vcf file info field
scripts/export/dump_hapmap_genotypes.pl:  - use Homo_sapiens.gvf which contains variation_ids in attributes column
scripts/export/dump_hapmap_genotypes.pl:  - create new gvf file HAPMAP.gvf containing only hapmap variants retrieved from previous steps
scripts/export/dump_hapmap_genotypes.pl:  - add population allele frequencies to HAPMAP.gvf, only report frequency for alt alleles
scripts/export/dump_hapmap_genotypes.pl:19      344053  rs4897853       T       C       .       .       dbSNP_147;TSA=SNV;E_Freq;E_Hapmap;E_1000G;ASW-ALT=C;ASW-REF=T;ASW-FREQ=0.897959;CHB-ALT=C;CHB-REF=T;CHB-FREQ=0.634146;CHD-ALT=C;CHD-REF=T;CHD-FREQ=0.682353;GIH-ALT=C;GIH-REF=T;GIH-FREQ=0.840909;LWK-ALT=C;LWK-REF=T;LWK-FREQ=0.955556;MEX-ALT=C;MEX-REF=T;MEX-FREQ=0.83;MKK-ALT=C;MKK-REF=T;MKK-FREQ=0.891608;TSI-ALT=C;TSI-REF=T;TSI-FREQ=0.727273;CEU-ALT=C;CEU-REF=T;CEU-FREQ=0.761062;HCB-ALT=C;HCB-REF=T;HCB-FREQ=0.651163;JPT-ALT=C;JPT-REF=T;JPT-FREQ=0.773256;YRI-ALT=C;YRI-REF=T;YRI-FREQ=0.902655;Reference_seq=T;Variant_seq=C;variation_id=3279699;allele_string=T,C;AA=C 
scripts/export/dump_hapmap_genotypes.pl:gvf2vcf use script: ensembl-variation/scripts/misc/release/gvf2vcf.pl
scripts/export/dump_hapmap_genotypes.pl:  - parse HAPMAP.gvf to HAPMAP.vcf
scripts/export/dump_hapmap_genotypes.pl:  - add genotypes to vcf file
scripts/export/dump_hapmap_genotypes.pl:if ($config->{registry}) {
scripts/export/dump_hapmap_genotypes.pl:  $registry->load_all($config->{registry});
scripts/export/dump_hapmap_genotypes.pl:  $registry->load_registry_from_db(
scripts/export/dump_hapmap_genotypes.pl:    -host => $config->{host},
scripts/export/dump_hapmap_genotypes.pl:    -port => $config->{port},
scripts/export/dump_hapmap_genotypes.pl:    -user => $config->{user},
scripts/export/dump_hapmap_genotypes.pl:my $species = $config->{species} || 'human';
scripts/export/dump_hapmap_genotypes.pl:my $dbc = $registry->get_DBAdaptor($species, 'variation')->dbc;
scripts/export/dump_hapmap_genotypes.pl:print_subsnp_ids('CSHL-HAPMAP') if ($config->{mode} eq 'print_subsnp_ids');
scripts/export/dump_hapmap_genotypes.pl:dump_genotypes('CSHL-HAPMAP') if ($config->{mode} eq 'dump_genotypes');
scripts/export/dump_hapmap_genotypes.pl:correct_ychrom_genotypes() if ($config->{mode} eq 'correct_ychrom_genotypes');
scripts/export/dump_hapmap_genotypes.pl:dump_allele_frequencies('CSHL-HAPMAP') if ($config->{mode} eq 'dump_allele_frequencies');
scripts/export/dump_hapmap_genotypes.pl:dump_gvf() if ($config->{mode} eq 'dump_gvf');
scripts/export/dump_hapmap_genotypes.pl:add_genotypes_to_vcf() if ($config->{mode} eq 'add_genotypes_to_vcf');
scripts/export/dump_hapmap_genotypes.pl:  my $fh = FileHandle->new($config->{dir} . 'Subsnp_ids.txt', 'w');
scripts/export/dump_hapmap_genotypes.pl:  my $sth = $dbc->prepare(qq{
scripts/export/dump_hapmap_genotypes.pl:  $sth->execute($handle);
scripts/export/dump_hapmap_genotypes.pl:  $sth->bind_columns(\$variation_id, \$subsnp_id);
scripts/export/dump_hapmap_genotypes.pl:  while ($sth->fetch) {
scripts/export/dump_hapmap_genotypes.pl:  $sth->finish;
scripts/export/dump_hapmap_genotypes.pl:  $fh->close;
scripts/export/dump_hapmap_genotypes.pl:  my $fh = FileHandle->new($config->{dir}. "/Subsnp_ids.txt", 'r'); 
scripts/export/dump_hapmap_genotypes.pl:    $subsnp_ids->{$subsnp_id} = 1;
scripts/export/dump_hapmap_genotypes.pl:  $fh->close();
scripts/export/dump_hapmap_genotypes.pl:  my $slice_adaptor = $registry->get_adaptor($species, 'core', 'slice');
scripts/export/dump_hapmap_genotypes.pl:  my $seq_regions = $slice_adaptor->fetch_all('chromosome');
scripts/export/dump_hapmap_genotypes.pl:  my $population_adaptor = $registry->get_adaptor($species, 'variation', 'population');
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-ASW' => 'ASW',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-CHB' => 'CHB',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-CHD' => 'CHD',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-GIH' => 'GIH',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-LWK' => 'LWK',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-MEX' => 'MEX',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-MKK' => 'MKK',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-TSI' => 'TSI',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HapMap-CEU' => 'CEU',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HapMap-HCB' => 'HCB',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HapMap-JPT' => 'JPT',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HapMap-YRI' => 'YRI',
scripts/export/dump_hapmap_genotypes.pl:    my $population = $population_adaptor->fetch_by_name($population_name);
scripts/export/dump_hapmap_genotypes.pl:    my @samples = @{$population->get_all_Samples};
scripts/export/dump_hapmap_genotypes.pl:      $sample_ids->{$sample->dbID} = 1;
scripts/export/dump_hapmap_genotypes.pl:  my $sth = $dbc->prepare(qq{
scripts/export/dump_hapmap_genotypes.pl:  my $dir = $config->{dir};
scripts/export/dump_hapmap_genotypes.pl:    my $seq_region_name = $seq_region->seq_region_name;
scripts/export/dump_hapmap_genotypes.pl:    my $fh = FileHandle->new($config->{dir} . "/genotypes/$seq_region_name.txt", 'w');
scripts/export/dump_hapmap_genotypes.pl:    $sth->execute($seq_region_name);
scripts/export/dump_hapmap_genotypes.pl:    $sth->bind_columns(\($variation_id, $subsnp_id, $genotypes));
scripts/export/dump_hapmap_genotypes.pl:    while ($sth->fetch) {
scripts/export/dump_hapmap_genotypes.pl:      next if (!$subsnp_ids->{$subsnp_id});
scripts/export/dump_hapmap_genotypes.pl:        if ($sample_ids->{$sample_id}) {
scripts/export/dump_hapmap_genotypes.pl:    $fh->close();
scripts/export/dump_hapmap_genotypes.pl:  my $ychrom = $config->{dir} . "/genotypes/Y.txt";
scripts/export/dump_hapmap_genotypes.pl:  my $prevYchrom = $config->{dir} . "/genotypes/prevY.txt";
scripts/export/dump_hapmap_genotypes.pl:  my $gtc_adaptor = $registry->get_adaptor($species, 'variation', 'genotypecode');
scripts/export/dump_hapmap_genotypes.pl:  my $fh = FileHandle->new($prevYchrom, 'r');
scripts/export/dump_hapmap_genotypes.pl:    $gtcodes->{$gt_code_id} = 1;
scripts/export/dump_hapmap_genotypes.pl:  $fh->close;
scripts/export/dump_hapmap_genotypes.pl:    my $gtc = $gtc_adaptor->fetch_by_dbID($gtcode_id);
scripts/export/dump_hapmap_genotypes.pl:    my @gt_alleles = @{$gtc->genotype};
scripts/export/dump_hapmap_genotypes.pl:      $map_gtcodes->{$gt_alleles[0]} = $gtcode_id;
scripts/export/dump_hapmap_genotypes.pl:  $gtcodes = $gtc_adaptor->fetch_all;
scripts/export/dump_hapmap_genotypes.pl:    my @gt_alleles = @{$gtcode->genotype};
scripts/export/dump_hapmap_genotypes.pl:      if ($map_gtcodes->{$gt_alleles[0]}) {
scripts/export/dump_hapmap_genotypes.pl:        $old2new->{$map_gtcodes->{$gt_alleles[0]}} = $gtcode->dbID;
scripts/export/dump_hapmap_genotypes.pl:  my $fh_new = FileHandle->new($ychrom, 'w');
scripts/export/dump_hapmap_genotypes.pl:  $fh = FileHandle->new($prevYchrom, 'r');
scripts/export/dump_hapmap_genotypes.pl:    if ($old2new->{$gt_code_id}) {
scripts/export/dump_hapmap_genotypes.pl:      my $new_code_id = $old2new->{$gt_code_id};
scripts/export/dump_hapmap_genotypes.pl:  $fh->close;
scripts/export/dump_hapmap_genotypes.pl:  $fh_new->close;
scripts/export/dump_hapmap_genotypes.pl:  my $pa = $registry->get_adaptor($species, 'variation', 'population');
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-ASW' => 'ASW',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-CHB' => 'CHB',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-CHD' => 'CHD',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-GIH' => 'GIH',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-LWK' => 'LWK',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-MEX' => 'MEX',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-MKK' => 'MKK',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-TSI' => 'TSI',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HapMap-CEU' => 'CEU',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HapMap-HCB' => 'HCB',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HapMap-JPT' => 'JPT',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HapMap-YRI' => 'YRI',
scripts/export/dump_hapmap_genotypes.pl:    my $short_name = $populations->{$name};
scripts/export/dump_hapmap_genotypes.pl:    my $population = $pa->fetch_by_name($name);
scripts/export/dump_hapmap_genotypes.pl:    my $dbid = $population->dbID();
scripts/export/dump_hapmap_genotypes.pl:    my $fh = FileHandle->new( $config->{dir} . "/allele_frequencies/$short_name.txt", 'w');
scripts/export/dump_hapmap_genotypes.pl:    $fhs->{$dbid} = $fh;
scripts/export/dump_hapmap_genotypes.pl:  my $sth = $dbc->prepare(qq{
scripts/export/dump_hapmap_genotypes.pl:  $sth->execute($handle);
scripts/export/dump_hapmap_genotypes.pl:  $sth->bind_columns(\($variation_id, $allele, $frequency, $population_id));
scripts/export/dump_hapmap_genotypes.pl:  while ($sth->fetch) {
scripts/export/dump_hapmap_genotypes.pl:      if ($fhs->{$population_id}) {
scripts/export/dump_hapmap_genotypes.pl:        my $fh = $fhs->{$population_id};
scripts/export/dump_hapmap_genotypes.pl:    my $fh = $fhs->{$dbid};
scripts/export/dump_hapmap_genotypes.pl:    $fh->close;
scripts/export/dump_hapmap_genotypes.pl:  my $in_vcf_file = $config->{in_vcf_file};
scripts/export/dump_hapmap_genotypes.pl:  my $out_vcf_file = $config->{out_vcf_file};
scripts/export/dump_hapmap_genotypes.pl:  my $genotype_cache_dir = $config->{genotype_cache_dir};
scripts/export/dump_hapmap_genotypes.pl:  my $population_adaptor = $registry->get_adaptor($species, 'variation', 'population');
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-ASW' => 'ASW',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-CHB' => 'CHB',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-CHD' => 'CHD',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-GIH' => 'GIH',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-LWK' => 'LWK',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-MEX' => 'MEX',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-MKK' => 'MKK',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HAPMAP-TSI' => 'TSI',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HapMap-CEU' => 'CEU',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HapMap-HCB' => 'HCB',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HapMap-JPT' => 'JPT',
scripts/export/dump_hapmap_genotypes.pl:    'CSHL-HAPMAP:HapMap-YRI' => 'YRI',
scripts/export/dump_hapmap_genotypes.pl:    my $population = $population_adaptor->fetch_by_name($population_name);
scripts/export/dump_hapmap_genotypes.pl:    my @samples = @{$population->get_all_Samples};
scripts/export/dump_hapmap_genotypes.pl:      $sample_ids->{$sample->dbID} = 1;
scripts/export/dump_hapmap_genotypes.pl:      $sample_id_2_name->{$sample->dbID} = $sample->name;
scripts/export/dump_hapmap_genotypes.pl:      $sample_name_2_id->{$sample->name} = $sample->dbID;
scripts/export/dump_hapmap_genotypes.pl:  my $gtc_adaptor = $registry->get_adaptor($species, 'variation', 'genotypecode');
scripts/export/dump_hapmap_genotypes.pl:  my $prev_chrom = -1;
scripts/export/dump_hapmap_genotypes.pl:  my $fh_in = FileHandle->new($in_vcf_file, 'r');
scripts/export/dump_hapmap_genotypes.pl:  my $fh_out = FileHandle->new($out_vcf_file, 'w');
scripts/export/dump_hapmap_genotypes.pl:    '##source=Genotypes for samples in HAPMAP populations: CSHL-HAPMAP:HAPMAP-ASW,CSHL-HAPMAP:HAPMAP-CHB,CSHL-HAPMAP:HAPMAP-CHD,CSHL-HAPMAP:HAPMAP-GIH,CSHL-HAPMAP:HAPMAP-LWK,CSHL-HAPMAP:HAPMAP-MEX,CSHL-HAPMAP:HAPMAP-MKK,CSHL-HAPMAP:HAPMAP-TSI,CSHL-HAPMAP:HapMap-CEU,CSHL-HAPMAP:HapMap-HCB,CSHL-HAPMAP:HapMap-JPT,CSHL-HAPMAP:HapMap-YRI',
scripts/export/dump_hapmap_genotypes.pl:    my $variation_id = $info->{variation_id};
scripts/export/dump_hapmap_genotypes.pl:    my $allele_string = $info->{allele_string};
scripts/export/dump_hapmap_genotypes.pl:    my $sample_gts = $cache->{$variation_id};
scripts/export/dump_hapmap_genotypes.pl:      my $sample_id = $sample_name_2_id->{$sample};
scripts/export/dump_hapmap_genotypes.pl:      my $gt_code = $sample_gts->{$sample_id};
scripts/export/dump_hapmap_genotypes.pl:        my $gtc = $gtcs->{$gt_code};
scripts/export/dump_hapmap_genotypes.pl:          $gtc = $gtc_adaptor->fetch_by_dbID($gt_code);
scripts/export/dump_hapmap_genotypes.pl:          $gtcs->{$gt_code} = $gtc;
scripts/export/dump_hapmap_genotypes.pl:        my $sep = ($gtc->phased) ? '|' : '/';
scripts/export/dump_hapmap_genotypes.pl:        my @gt_alleles = @{$gtc->genotype};
scripts/export/dump_hapmap_genotypes.pl:  $fh_in->close;
scripts/export/dump_hapmap_genotypes.pl:  $fh_out->close;
scripts/export/dump_hapmap_genotypes.pl:      $hash->{$key} = $value;
scripts/export/dump_hapmap_genotypes.pl:  my $fh = FileHandle->new($cache_file, 'r');
scripts/export/dump_hapmap_genotypes.pl:    $cache->{$variation_id}->{$sample_id} = $gt_code;
scripts/export/dump_hapmap_genotypes.pl:  $fh->close();
scripts/export/dump_hapmap_genotypes.pl:  my $human_gvf_file = $config->{human_gvf_file};
scripts/export/dump_hapmap_genotypes.pl:  my $population_gvf_file = $config->{population_gvf_file};
scripts/export/dump_hapmap_genotypes.pl:  my $variation_ids_dir = $config->{variation_ids_dir};
scripts/export/dump_hapmap_genotypes.pl:  my $prev_seq_id = -1;
scripts/export/dump_hapmap_genotypes.pl:  my $fh_gvf = FileHandle->new($human_gvf_file, 'r');
scripts/export/dump_hapmap_genotypes.pl:  my $fh_out = FileHandle->new($population_gvf_file, 'w');
scripts/export/dump_hapmap_genotypes.pl:      my $seq_id = $gvf_line->{seq_id};
scripts/export/dump_hapmap_genotypes.pl:      my $allele_string = $gvf_line->{attributes}->{allele_string};
scripts/export/dump_hapmap_genotypes.pl:      my $variation_id  = $gvf_line->{attributes}->{variation_id};
scripts/export/dump_hapmap_genotypes.pl:      next unless ($cache->{$variation_id});
scripts/export/dump_hapmap_genotypes.pl:      if (my $population_allele_hash = $cache->{$variation_id}) {
scripts/export/dump_hapmap_genotypes.pl:          my $allele_hash = $population_allele_hash->{$short_name};
scripts/export/dump_hapmap_genotypes.pl:            my $freq = $allele_hash->{$allele};
scripts/export/dump_hapmap_genotypes.pl:              $gvf_line->{attributes}->{"$short_name-REF"} = $allele;
scripts/export/dump_hapmap_genotypes.pl:          $gvf_line->{attributes}->{"$short_name-ALT"} = join(',', @alleles);
scripts/export/dump_hapmap_genotypes.pl:            $gvf_line->{attributes}->{"$short_name-FREQ"} = join(',', @freqs);
scripts/export/dump_hapmap_genotypes.pl:    delete $gvf_line->{attributes}->{global_minor_allele_frequency};
scripts/export/dump_hapmap_genotypes.pl:    $line = join("\t", map {$gvf_line->{$_}} (
scripts/export/dump_hapmap_genotypes.pl:      my $attributes = join(";", map{"$_=$gvf_line->{attributes}->{$_}"} keys %{$gvf_line->{attributes}});
scripts/export/dump_hapmap_genotypes.pl:  $fh_gvf->close();
scripts/export/dump_hapmap_genotypes.pl:  $fh_out->close();
scripts/export/dump_hapmap_genotypes.pl:  my $fh_var_ids = FileHandle->new($seq_id_file, 'r');
scripts/export/dump_hapmap_genotypes.pl:    $variation_ids->{$variation_id} = 1;
scripts/export/dump_hapmap_genotypes.pl:  $fh_var_ids->close();
scripts/export/dump_hapmap_genotypes.pl:  my $frequency_dir = $config->{frequency_dir};
scripts/export/dump_hapmap_genotypes.pl:    my $fh = FileHandle->new("$frequency_dir/$short_name.txt", 'r');
scripts/export/dump_hapmap_genotypes.pl:      if ($variation_ids->{$variation_id}) {
scripts/export/dump_hapmap_genotypes.pl:        $cache->{$variation_id}->{$short_name}->{$allele} = $frequency;
scripts/export/dump_hapmap_genotypes.pl:    $fh->close();
scripts/export/dump_hapmap_genotypes.pl:    $gvf_line->{$header_names[$i]} = $header_values[$i];
scripts/export/dump_hapmap_genotypes.pl:      $gvf_line->{attributes}->{$key} = $value;
scripts/export/dump_vep.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/dump_vep.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/dump_vep.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/export/dump_vep.pl:  'homo_sapiens'      => ' --sift b --polyphen b --regulatory'.
scripts/export/dump_vep.pl:                         ' --freq_file /nfs/ensembl/wm2/VEP/cache/ALL_1KG_ESP_freqs_with_alleles.txt,AFR,AMR,ASN,EUR,AA,EA',
scripts/export/dump_vep.pl:  'mus_musculus'      => ' --regulatory --sift b',
scripts/export/dump_vep.pl:  'bos_taurus'        => ' --sift b',
scripts/export/dump_vep.pl:  'canis_familiaris'  => ' --sift b',
scripts/export/dump_vep.pl:  'danio_rerio'       => ' --sift b',
scripts/export/dump_vep.pl:  'equus_caballus'    => ' --sift b',
scripts/export/dump_vep.pl:  'gallus_gallus'     => ' --sift b',
scripts/export/dump_vep.pl:  'rattus_norvegicus' => ' --sift b',
scripts/export/dump_vep.pl:  'sus_scrofa'        => ' --sift b',
scripts/export/dump_vep.pl:  'triticum_aestivum' => ' --sift b',
scripts/export/dump_vep.pl:$config->{hosts}    ||= 'ens-staging,ens-staging2';
scripts/export/dump_vep.pl:$config->{user}     ||= 'ensro';
scripts/export/dump_vep.pl:$config->{port}     ||= 3306;
scripts/export/dump_vep.pl:$config->{dir}      ||= $ENV{'HOME'}.'/.vep/';
scripts/export/dump_vep.pl:$config->{command}  ||= 'perl variant_effect_predictor.pl --build all';
scripts/export/dump_vep.pl:$config->{mem}      ||= 12000;
scripts/export/dump_vep.pl:$config->{queue}    ||= 'normal';
scripts/export/dump_vep.pl:die "ERROR: Dump directory ".$config->{dir}." does not exist\n" unless -e $config->{dir};
scripts/export/dump_vep.pl:die "ERROR: No Ensembl DB version defined - use --version [version]\n" unless defined($config->{version});
scripts/export/dump_vep.pl:die "ERROR: Supplied command doesn't look right, it should look something like:\n\nperl -I /include/perl/libs/ /path/to/variant_effect_predictor.pl --build all\n\n"
scripts/export/dump_vep.pl:  unless $config->{command} =~ /variant_effect_predictor.+\-build (all|\w+)/;
scripts/export/dump_vep.pl:$config->{hosts} = [split /\,/, $config->{hosts}];
scripts/export/dump_vep.pl:foreach my $host(@{$config->{hosts}}) {
scripts/export/dump_vep.pl:    my ($species, $assembly) = ($species_hash->{species}, $species_hash->{assembly});
scripts/export/dump_vep.pl:      $config->{port}
scripts/export/dump_vep.pl:  my $dbc = DBI->connect(
scripts/export/dump_vep.pl:      $connection_string, $config->{user}, $config->{password}
scripts/export/dump_vep.pl:  my $version = $config->{version};
scripts/export/dump_vep.pl:  my $sth = $dbc->prepare(qq{
scripts/export/dump_vep.pl:  $sth->execute();
scripts/export/dump_vep.pl:  $sth->bind_columns(\$db);
scripts/export/dump_vep.pl:  push @dbs, $db while $sth->fetch;
scripts/export/dump_vep.pl:  $sth->finish;
scripts/export/dump_vep.pl:  if(defined($config->{refseq})) {
scripts/export/dump_vep.pl:    $sth = $dbc->prepare(qq{
scripts/export/dump_vep.pl:    $sth->execute();
scripts/export/dump_vep.pl:    $sth->bind_columns(\$db);
scripts/export/dump_vep.pl:    push @dbs, $db while $sth->fetch;
scripts/export/dump_vep.pl:    $sth->finish;
scripts/export/dump_vep.pl:  my $pattern = $config->{pattern};
scripts/export/dump_vep.pl:  my $exclude = $config->{exclude_pattern};
scripts/export/dump_vep.pl:      $sth = $dbc->prepare("select meta_value from ".$current_db_name.".meta where meta_key='assembly.default';");
scripts/export/dump_vep.pl:      $sth->execute();
scripts/export/dump_vep.pl:      my $assembly = $sth->fetchall_arrayref()->[0]->[0];
scripts/export/dump_vep.pl:      $sth = $dbc->prepare(qq{
scripts/export/dump_vep.pl:      $sth->execute;
scripts/export/dump_vep.pl:      $sth->bind_columns(\$count);
scripts/export/dump_vep.pl:      $sth->fetch;
scripts/export/dump_vep.pl:        $current_db_name =~ s/^([a-z]+\_[a-z,1-9]+)(\_[a-z]+)?(.+)/$1$2/;
scripts/export/dump_vep.pl:      $sth = $dbc->prepare("select species_id, meta_key, meta_value from ".$current_db_name.".meta where meta_key in ('assembly.default', 'species.production_name');");
scripts/export/dump_vep.pl:      $sth->execute();
scripts/export/dump_vep.pl:      $sth->bind_columns(\$species_id, \$key, \$value);
scripts/export/dump_vep.pl:      $by_species->{$species_id}->{$key} = $value while $sth->fetch();
scripts/export/dump_vep.pl:      $sth->finish();
scripts/export/dump_vep.pl:        next unless $hash->{'assembly.default'} && $hash->{'species.production_name'};
scripts/export/dump_vep.pl:        push @species, { species => $hash->{'species.production_name'}, assembly => $hash->{'assembly.default'}};
scripts/export/dump_vep.pl:  if(!defined($config->{overwrite}) && -e $config->{dir}.'/'.$sp.'/'.$config->{version}.'_'.$ass) {
scripts/export/dump_vep.pl:    debug("Existing dump directory found for $sp $ass, skipping (use --overwrite to overwrite)\n");
scripts/export/dump_vep.pl:      'bsub -K -J %s_%s -M %i -R"select[mem>%i] rusage[mem=%i]" -q %s -o %s -e %s',
scripts/export/dump_vep.pl:      $config->{mem},
scripts/export/dump_vep.pl:      $config->{mem},
scripts/export/dump_vep.pl:      $config->{mem},
scripts/export/dump_vep.pl:      $config->{queue},
scripts/export/dump_vep.pl:      $config->{dir}.'/'.$sp.'_'.$ass.'_vep_dump.farmout',
scripts/export/dump_vep.pl:      $config->{dir}.'/'.$sp.'_'.$ass.'_vep_dump.farmerr',
scripts/export/dump_vep.pl:    $config->{command},
scripts/export/dump_vep.pl:    "--no_adaptor",
scripts/export/dump_vep.pl:    "--species ".$species,
scripts/export/dump_vep.pl:    "--host ".$host,
scripts/export/dump_vep.pl:    "--user ".$config->{user},
scripts/export/dump_vep.pl:    "--port ".$config->{port},
scripts/export/dump_vep.pl:    "--dir ".$config->{dir},
scripts/export/dump_vep.pl:    defined $config->{password} ? "--password ".$config->{password} : "",
scripts/export/dump_vep.pl:    $refseq ? '--refseq' : '',
scripts/export/dump_vep.pl:  debug("Use \"tail -f ".$config->{dir}.'/'.$species.'_vep_dump.farmout'."\" to check progress");
scripts/export/dump_vep.pl:  my $tar_file = $config->{dir}."/".$species."_vep_".$config->{version}."_".$assembly.".tar.gz";
scripts/export/dump_vep.pl:  if(!defined($config->{overwrite}) && -e $tar_file) {
scripts/export/dump_vep.pl:    debug("Existing dump file found for $species, skipping (use --overwrite to overwrite)\n");
scripts/export/dump_vep.pl:  my $root_dir = $config->{dir};
scripts/export/dump_vep.pl:  my $sub_dir  = $species."/".$config->{version}."_".$assembly;
scripts/export/dump_vep.pl:  die("ERROR: VEP dump directory $root_dir/$sub_dir not found") unless -e $root_dir.'/'.$sub_dir;
scripts/export/dump_vep.pl:  my $command = "tar -cz -C $root_dir -f $tar_file $sub_dir";
scripts/export/dump_vep.pl:    ($time[5] + 1900)."-".
scripts/export/dump_vep.pl:    $time[4]."-".
scripts/export/dump_vep.pl:  print $time." - ".$text.($text =~ /\n$/ ? "" : "\n");
scripts/export/check_gvfs.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/check_gvfs.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/check_gvfs.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/export/check_gvfs.pl:    warn "Must supply --output_dir argument\n" unless $help;
scripts/export/check_gvfs.pl:    warn "Must supply --release argument\n" unless $help;
scripts/export/check_gvfs.pl:    print "Usage: $0 --output_dir <name> --server <name> --release <num> --path <path> --wiggle <num> --help\n";
scripts/export/check_gvfs.pl:$release--;
scripts/export/check_gvfs.pl:$path = "/pub/release-${release}/variation/gvf/" unless $path;
scripts/export/check_gvfs.pl:my $ftp = Net::FTP->new($server) or die "Failed to connect to '$server:' $@";
scripts/export/check_gvfs.pl:$ftp->login;
scripts/export/check_gvfs.pl:$ftp->cwd($path) or die "Failed to cwd to '$path', is the path correct?";
scripts/export/check_gvfs.pl:for my $species ($ftp->ls) {
scripts/export/check_gvfs.pl:    $ftp->cwd("$path/$species") or die "Failed to cwd to $species directory?";
scripts/export/check_gvfs.pl:    for my $gvf ($ftp->ls) {
scripts/export/check_gvfs.pl:        if (-e $curr_file) {
scripts/export/check_gvfs.pl:            my $ftp_size = $ftp->size("$path/$species/$gvf");
scripts/export/check_gvfs.pl:            my $curr_size = -s $curr_file;
scripts/export/check_gvfs.pl:            if ($curr_size < ($ftp_size * (1 - $wiggle)) ) {
scripts/export/check_gvfs.pl:$ftp->quit;
scripts/export/dump_compressed_genotypes.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/dump_compressed_genotypes.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/dump_compressed_genotypes.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/export/dump_compressed_genotypes.pl:  Re-import to compressed_genotype_region using
scripts/export/dump_compressed_genotypes.pl:  ensembl-variation/scripts/import/compress_genotypes_by_region_from_file.pl
scripts/export/dump_compressed_genotypes.pl:) or die "ERROR: Failed to parse command-line flags\n";
scripts/export/dump_compressed_genotypes.pl:  die("ERROR: No $_ defined (--$_)") unless defined($config->{$_});
scripts/export/dump_compressed_genotypes.pl:$config->{port} ||= 3306;
scripts/export/dump_compressed_genotypes.pl:$config->{user} ||= 'ensro';
scripts/export/dump_compressed_genotypes.pl:Bio::EnsEMBL::Registry->load_registry_from_db(
scripts/export/dump_compressed_genotypes.pl:  -host       => $config->{host},
scripts/export/dump_compressed_genotypes.pl:  -user       => $config->{user},
scripts/export/dump_compressed_genotypes.pl:  -pass       => $config->{password},
scripts/export/dump_compressed_genotypes.pl:  -port       => $config->{port},
scripts/export/dump_compressed_genotypes.pl:  $config->{host},
scripts/export/dump_compressed_genotypes.pl:  $config->{port},
scripts/export/dump_compressed_genotypes.pl:  $config->{database}
scripts/export/dump_compressed_genotypes.pl:my $dbc = DBI->connect(
scripts/export/dump_compressed_genotypes.pl:  $connection_string, $config->{user}, $config->{password}
scripts/export/dump_compressed_genotypes.pl:my $sth = $dbc->prepare(qq{
scripts/export/dump_compressed_genotypes.pl:$sth->execute();
scripts/export/dump_compressed_genotypes.pl:$sth->bind_columns(\$sr_id);
scripts/export/dump_compressed_genotypes.pl:push @sr_ids, $sr_id while $sth->fetch();
scripts/export/dump_compressed_genotypes.pl:$sth->finish();
scripts/export/dump_compressed_genotypes.pl:$sth = $dbc->prepare(qq{
scripts/export/dump_compressed_genotypes.pl:  $sth->execute($sr_id);
scripts/export/dump_compressed_genotypes.pl:  $sth->bind_columns(\$n, \$i, \$s, \$e, \$r, \$v, \$ss, \$g);
scripts/export/dump_compressed_genotypes.pl:	while($sth->fetch) {
scripts/export/dump_compressed_genotypes.pl:  $sth->finish();
scripts/export/dump_GO_terms.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/dump_GO_terms.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/dump_GO_terms.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/export/dump_GO_terms.pl:  print STDERR "> Error! Please give an Ensembl version, using the option '-v' \n";
scripts/export/dump_GO_terms.pl:  print STDERR "> Error! Please give an output directory for the dumps, using the option '-o' \n";
scripts/export/dump_GO_terms.pl:  print STDERR "> Error! Please give a database user name, using the option '-user' \n";
scripts/export/dump_GO_terms.pl:  print STDERR "> Error! Please give the host name where the databases are stored using the option '-hname'\n";
scripts/export/dump_GO_terms.pl:#VEP-config
scripts/export/dump_GO_terms.pl:my $cfg = Bio::EnsEMBL::VEP::Config->new({testing => 'hello'});
scripts/export/dump_GO_terms.pl:$registry->load_registry_from_db(
scripts/export/dump_GO_terms.pl:    -host       => $host,
scripts/export/dump_GO_terms.pl:    -port       => $port,
scripts/export/dump_GO_terms.pl:    -user       => $user,
scripts/export/dump_GO_terms.pl:    -pass       => '',
scripts/export/dump_GO_terms.pl:    -db_version => $e_version,
scripts/export/dump_GO_terms.pl:while (my ($dbname) = $sth_h->fetchrow_array) {
scripts/export/dump_GO_terms.pl:  print STDERR "\n# $s_name - [ $dbcore ]\n";
scripts/export/dump_GO_terms.pl:  my ($count) = $sth_go->fetchrow_array();
scripts/export/dump_GO_terms.pl:  # Run GO.pm plugin to export GFF-formatted GO terms
scripts/export/dump_GO_terms.pl:  mkdir $output_dir unless -d $output_dir;
scripts/export/dump_GO_terms.pl:  if ( -e $dumpFile & !$force ) {
scripts/export/dump_GO_terms.pl:    warn "Skipping $dumpFile. Use --force to override the existing file\n";
scripts/export/dump_GO_terms.pl:$sth_h->finish;
scripts/export/dump_GO_terms.pl:  my $dbh = DBI->connect($dsn, $user) or die "Connection failed";
scripts/export/dump_GO_terms.pl:  my $sth = $dbh->prepare($sql);
scripts/export/dump_GO_terms.pl:  $sth->execute;
scripts/export/dump_GO_terms.pl:    $sth->finish;
scripts/export/dump_GO_terms.pl:    -help             Print this message
scripts/export/dump_GO_terms.pl:    -output_dir|o     Output directory for the GFF dumps (Required)
scripts/export/dump_GO_terms.pl:    -force|f          Force to override any pre-existing dumps
scripts/export/dump_GO_terms.pl:    -quiet|q          Suppress warning messages. Not used by default
scripts/export/dump_GO_terms.pl:    -species|s        Only export the species in the list,
scripts/export/dump_GO_terms.pl:    -user|u           Database login user name (Required)
scripts/export/dump_GO_terms.pl:    -v                Ensembl version, e.g. 96 (Required)
scripts/export/dump_GO_terms.pl:    -hname            The host name (with port) where the databases are stored,
scripts/export/release/dump_gvf.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/release/dump_gvf.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/release/dump_gvf.pl:     http://www.apache.org/licenses/LICENSE-2.0
scripts/export/release/dump_gvf.pl:) or die "Error: Failed to parse command-line args.\n";
scripts/export/release/dump_gvf.pl:init_variation_set($config) if (defined $config->{set_name});
scripts/export/release/dump_gvf.pl:init_failed_variations($config) if (defined $config->{failed});
scripts/export/release/dump_gvf.pl:init_sample_data($config) if (defined $config->{individual} || defined $config->{population} || $config->{sample});
scripts/export/release/dump_gvf.pl:$config->{sample} = $config->{individual} if (defined $config->{individual});
scripts/export/release/dump_gvf.pl:init_consequence_data($config) if ($config->{incl_consequences});
scripts/export/release/dump_gvf.pl:if( -e $config->{gvf_file} && !-z $config->{gvf_file}){
scripts/export/release/dump_gvf.pl:  unlink($config->{gvf_file}) or die $config->{gvf_file} . " already exists and can not delete it\n";
scripts/export/release/dump_gvf.pl:$config->{fh} = FileHandle->new($config->{gvf_file}, 'w');
scripts/export/release/dump_gvf.pl:if ($config->{structural_variations}) {
scripts/export/release/dump_gvf.pl:my $fh = $config->{fh};
scripts/export/release/dump_gvf.pl:$fh->close();
scripts/export/release/dump_gvf.pl:        die "Argument --$arg required, try --help for usage instructions\n" unless $config->{$arg};
scripts/export/release/dump_gvf.pl:  $config->{slice_piece_size} ||= 1e6;
scripts/export/release/dump_gvf.pl:  my $registry_file = $config->{registry};
scripts/export/release/dump_gvf.pl:  die "Could not find registry_file $registry_file" unless (-e $registry_file);
scripts/export/release/dump_gvf.pl:  $registry->load_all($registry_file);
scripts/export/release/dump_gvf.pl:  my $vdba = $registry->get_DBAdaptor($config->{species}, 'variation') || usage('Cannot connect to variation db.');
scripts/export/release/dump_gvf.pl:  if ($config->{failed}) {
scripts/export/release/dump_gvf.pl:    $vdba->include_failed_variations(1);
scripts/export/release/dump_gvf.pl:  my $cdba = $registry->get_DBAdaptor($config->{species}, 'core') || usage('Cannot connect to core db.');
scripts/export/release/dump_gvf.pl:  $config->{vdba} = $vdba;
scripts/export/release/dump_gvf.pl:  $config->{cdba} = $cdba;
scripts/export/release/dump_gvf.pl:  $config->{slice_adaptor} = $cdba->get_SliceAdaptor;
scripts/export/release/dump_gvf.pl:  $config->{sample_gt_adaptor} = $vdba->get_SampleGenotypeAdaptor;
scripts/export/release/dump_gvf.pl:  $config->{sample_adaptor} = $vdba->get_SampleAdaptor;
scripts/export/release/dump_gvf.pl:  $config->{vf_adaptor}  = $vdba->get_VariationFeatureAdaptor;
scripts/export/release/dump_gvf.pl:  $config->{tv_adaptor}  = $vdba->get_TranscriptVariationAdaptor;
scripts/export/release/dump_gvf.pl:  $config->{variation_set_adaptor} = $vdba->get_VariationSetAdaptor;
scripts/export/release/dump_gvf.pl:  $config->{src_adaptor} = $vdba->get_SourceAdaptor;
scripts/export/release/dump_gvf.pl:  $config->{svf_adaptor} = $vdba->get_StructuralVariationFeatureAdaptor;
scripts/export/release/dump_gvf.pl:  $config->{sv_adaptor} = $vdba->get_StructuralVariationAdaptor;
scripts/export/release/dump_gvf.pl:  my $src_adaptor = $config->{src_adaptor};
scripts/export/release/dump_gvf.pl:  my $sources = $src_adaptor->fetch_all;
scripts/export/release/dump_gvf.pl:    $lookup->{$source->dbID}->{name} = $source->name;
scripts/export/release/dump_gvf.pl:    $lookup->{$source->dbID}->{version} = $source->version;
scripts/export/release/dump_gvf.pl:  my $variation_set_name = $config->{set_name};
scripts/export/release/dump_gvf.pl:    $variation_set_name = 'All phenotype/disease-associated variants';
scripts/export/release/dump_gvf.pl:  my $vsa = $config->{variation_set_adaptor};
scripts/export/release/dump_gvf.pl:  my $variation_set = $vsa->fetch_by_name($variation_set_name);
scripts/export/release/dump_gvf.pl:  $config->{variation_set} = $variation_set;
scripts/export/release/dump_gvf.pl:  my $vdba = $config->{vdba};
scripts/export/release/dump_gvf.pl:  my $dbh = $vdba->dbc->db_handle;
scripts/export/release/dump_gvf.pl:  my $sth = $dbh->prepare(qq{
scripts/export/release/dump_gvf.pl:  $sth->execute();
scripts/export/release/dump_gvf.pl:  $sth->bind_columns(\($variation_id, $desc));
scripts/export/release/dump_gvf.pl:  while ($sth->fetch()) {
scripts/export/release/dump_gvf.pl:    $failed_variations->{$variation_id}->{$desc} = 1;
scripts/export/release/dump_gvf.pl:  $sth->finish();
scripts/export/release/dump_gvf.pl:  $config->{failed_variations} = $failed_variations;
scripts/export/release/dump_gvf.pl:    if ($config->{sample}) {
scripts/export/release/dump_gvf.pl:        my $name = $config->{sample};
scripts/export/release/dump_gvf.pl:        my $sa = $config->{sample_adaptor};
scripts/export/release/dump_gvf.pl:        my $samples = $sa->fetch_all_by_name($name);
scripts/export/release/dump_gvf.pl:        $config->{_sample} = $samples->[0];
scripts/export/release/dump_gvf.pl:    if ($config->{sift} || $config->{polyphen}) {
scripts/export/release/dump_gvf.pl:        $config->{protein_coding_details} = 1;
scripts/export/release/dump_gvf.pl:        push @protein_func_pred_tools, 'sift' if ($config->{sift});
scripts/export/release/dump_gvf.pl:        push @protein_func_pred_tools, 'polyphen' if ($config->{polyphen});
scripts/export/release/dump_gvf.pl:    $config->{protein_func_pred_tools} = \@protein_func_pred_tools;
scripts/export/release/dump_gvf.pl:  my $sa = $config->{slice_adaptor};
scripts/export/release/dump_gvf.pl:  if ($config->{seq_region_ids_file}) {
scripts/export/release/dump_gvf.pl:    my $seq_region_file = $config->{seq_region_ids_file};
scripts/export/release/dump_gvf.pl:    die "Could not find seq_region_file $seq_region_file" unless (-e $seq_region_file);
scripts/export/release/dump_gvf.pl:    my $fh = FileHandle->new($seq_region_file, 'r');
scripts/export/release/dump_gvf.pl:      my $slice = $sa->fetch_by_seq_region_id($_);
scripts/export/release/dump_gvf.pl:    $fh->close();
scripts/export/release/dump_gvf.pl:  } elsif ($config->{is_slice_piece}) {
scripts/export/release/dump_gvf.pl:    my $seq_name = $config->{seq_region_name};
scripts/export/release/dump_gvf.pl:    my $start = $config->{slice_piece_start};
scripts/export/release/dump_gvf.pl:    my $end = $config->{slice_piece_end};
scripts/export/release/dump_gvf.pl:    my $slice = $sa->fetch_by_region('toplevel', $seq_name, $start, $end, 1);
scripts/export/release/dump_gvf.pl:    $slices = $sa->fetch_all('toplevel', undef, 0, 1);
scripts/export/release/dump_gvf.pl:  $config->{slices} = $slices;
scripts/export/release/dump_gvf.pl:    my $slices = $config->{slices};
scripts/export/release/dump_gvf.pl:    my $svfa = $config->{svf_adaptor};
scripts/export/release/dump_gvf.pl:    my $sva = $config->{sv_adaptor};
scripts/export/release/dump_gvf.pl:        my $svfs = $svfa->fetch_all_by_Slice($slice, 1);
scripts/export/release/dump_gvf.pl:            next if ($svf->seq_region_start <= $slice->start); # avoid duplicated lines caused by vf overlapping two slice pieces
scripts/export/release/dump_gvf.pl:            next if $svf->var_class eq 'CNV_PROBE';
scripts/export/release/dump_gvf.pl:            $gvf_line->{seqid} = $svf->slice->seq_region_name;
scripts/export/release/dump_gvf.pl:            my $start = $svf->seq_region_start;
scripts/export/release/dump_gvf.pl:            my $end   = $svf->seq_region_end;
scripts/export/release/dump_gvf.pl:            $gvf_line->{start}  = $start;
scripts/export/release/dump_gvf.pl:            $gvf_line->{end}    = $end;
scripts/export/release/dump_gvf.pl:            $gvf_line->{strand} = $svf->strand == 1 ? '+' : ($svf->strand == -1 ? '-' : '.');
scripts/export/release/dump_gvf.pl:            $gvf_line->{type}   = $svf->class_SO_term;
scripts/export/release/dump_gvf.pl:            my $source_id       = $svf->{_source_id};
scripts/export/release/dump_gvf.pl:            my $source_name     = $source_lookup->{$source_id}->{name};
scripts/export/release/dump_gvf.pl:            my $source_version  = $source_lookup->{$source_id}->{version};
scripts/export/release/dump_gvf.pl:            $gvf_line->{source} = $source_name;
scripts/export/release/dump_gvf.pl:            $gvf_line->{attributes}->{Dbxref} = "$source_name:" . $svf->variation_name;
scripts/export/release/dump_gvf.pl:            $gvf_line->{score} = '.';
scripts/export/release/dump_gvf.pl:            $gvf_line->{phase} = '.';
scripts/export/release/dump_gvf.pl:            my $coords = join('-', $svf->seq_region_name, $svf->seq_region_start, $svf->seq_region_end);
scripts/export/release/dump_gvf.pl:            if (my $prev_coords = $prev_svs->{$svf->variation_name}) {
scripts/export/release/dump_gvf.pl:                warn "repeated SV: " . $svf->variation_name . " coords 1: $prev_coords, coords 2: $coords\n" if $prev_coords ne $coords;
scripts/export/release/dump_gvf.pl:            my $sv = $svf->structural_variation;
scripts/export/release/dump_gvf.pl:            if ($config->{clinical_significance}) {
scripts/export/release/dump_gvf.pl:            $gvf_line->{attributes}->{study_accession} = $svf->study->name if $svf->study;
scripts/export/release/dump_gvf.pl:            if ((defined $svf->inner_start) && (defined $svf->outer_start) && ($svf->inner_start != $svf->outer_start)) {
scripts/export/release/dump_gvf.pl:                $gvf_line->{attributes}->{Start_range} = join(',', $svf->outer_start, $svf->inner_start);
scripts/export/release/dump_gvf.pl:            if ((defined $svf->inner_end) && (defined $svf->outer_end) && ($svf->inner_end != $svf->outer_end)) {
scripts/export/release/dump_gvf.pl:                $gvf_line->{attributes}->{End_range} = join(',', $svf->inner_end, $svf->outer_end);
scripts/export/release/dump_gvf.pl:                    if (my $parents = $sva->fetch_all_by_supporting_evidence($sv)) {
scripts/export/release/dump_gvf.pl:                        $gvf_line->{attributes}->{Parent} = join(',', map { $_->variation_name } @$parents);
scripts/export/release/dump_gvf.pl:            # feature's own identifier and we have to use a file-wide count as for
scripts/export/release/dump_gvf.pl:            $gvf_line->{attributes}->{ID} = ++$id_count;
scripts/export/release/dump_gvf.pl:            $prev_svs->{$svf->variation_name} = $coords if $gvf_line;
scripts/export/release/dump_gvf.pl:    my $vfa = $config->{vf_adaptor};
scripts/export/release/dump_gvf.pl:    my $slice_adaptor = $config->{slice_adaptor};
scripts/export/release/dump_gvf.pl:    my $slices = $config->{slices};
scripts/export/release/dump_gvf.pl:    my $max_length = $config->{slice_piece_size};
scripts/export/release/dump_gvf.pl:      my $full_slice = $slice_adaptor->fetch_by_seq_region_id($slice->get_seq_region_id);
scripts/export/release/dump_gvf.pl:      my $slice_end = $full_slice->seq_region_end;
scripts/export/release/dump_gvf.pl:          my $slice_piece_start = $slice_piece->seq_region_start;
scripts/export/release/dump_gvf.pl:          my $slice_piece_end = $slice_piece->seq_region_end;
scripts/export/release/dump_gvf.pl:            if ($config->{sample}) { 
scripts/export/release/dump_gvf.pl:            if ($config->{somatic}) {
scripts/export/release/dump_gvf.pl:                my $vfs = $vfa->fetch_all_somatic_by_Slice($slice_piece);
scripts/export/release/dump_gvf.pl:                $vf_it = Bio::EnsEMBL::Utils::Iterator->new($vfs);
scripts/export/release/dump_gvf.pl:            } elsif ($config->{set_name}) {
scripts/export/release/dump_gvf.pl:                my $variation_set = $config->{variation_set};
scripts/export/release/dump_gvf.pl:                my $vfs = $variation_set->get_all_VariationFeatures_by_Slice($slice_piece);
scripts/export/release/dump_gvf.pl:                $vf_it = Bio::EnsEMBL::Utils::Iterator->new($vfs);
scripts/export/release/dump_gvf.pl:                $vf_it = $vfa->fetch_Iterator_by_Slice($slice_piece);
scripts/export/release/dump_gvf.pl:            if ($config->{incl_consequences} || $config->{protein_coding_details}) {
scripts/export/release/dump_gvf.pl:                while (my $vf = $vf_it->next) {
scripts/export/release/dump_gvf.pl:                  my $vf_start = $vf->seq_region_start;
scripts/export/release/dump_gvf.pl:                  my $vf_end = $vf->seq_region_end;
scripts/export/release/dump_gvf.pl:                    if ((!$vf_it->peek) || $count == 1000) {
scripts/export/release/dump_gvf.pl:                        if ($config->{incl_consequences}) {
scripts/export/release/dump_gvf.pl:                        } elsif ($config->{population}) {
scripts/export/release/dump_gvf.pl:                  if ($config->{incl_consequences}) {
scripts/export/release/dump_gvf.pl:                  } elsif ($config->{population}) {
scripts/export/release/dump_gvf.pl:                while (my $vf = $vf_it->next) {
scripts/export/release/dump_gvf.pl:                  my $vf_start = $vf->seq_region_start;
scripts/export/release/dump_gvf.pl:                  my $vf_end = $vf->seq_region_end;
scripts/export/release/dump_gvf.pl:#                   slice_piece_start = 1 slice_piece_end = 5 vf is insertion vf_start = 5 vf_end = 4 -> not included in next slice_piece slice_piece_start = 5 slice_piece_end = 9  
scripts/export/release/dump_gvf.pl:#                   slice_piece_start = 1 slice_piece_end = 5 vf is deletion vf_start = 4 vf_end = 5 -> included in next slice_piece slice_piece_start = 5 slice_piece_end = 9 -> need to be filtered out
scripts/export/release/dump_gvf.pl:            last if ($config->{debug});                      
scripts/export/release/dump_gvf.pl:        my $gvf_line = $gvf_lines->{$vf_id};
scripts/export/release/dump_gvf.pl:        my $vf = $gvf_lines->{$vf_id}->{vf};
scripts/export/release/dump_gvf.pl:    if ($config->{failed}) {
scripts/export/release/dump_gvf.pl:        my $failed_variations = $config->{failed_variations};
scripts/export/release/dump_gvf.pl:        return unless (exists $failed_variations->{$vf->{_variation_id}});
scripts/export/release/dump_gvf.pl:        my $failed_descs = join(',', keys %{ $failed_variations->{ $vf->{_variation_id} } });
scripts/export/release/dump_gvf.pl:        $gvf_line->{attributes}->{ensembl_failure_reason} = $failed_descs;
scripts/export/release/dump_gvf.pl:    $gvf_line->{type} = $vf->class_SO_term;
scripts/export/release/dump_gvf.pl:    $gvf_line->{score} = '.';
scripts/export/release/dump_gvf.pl:    $gvf_line->{phase} = '.';
scripts/export/release/dump_gvf.pl:    if ($config->{sample}) {
scripts/export/release/dump_gvf.pl:    if ($config->{ancestral_allele}) {
scripts/export/release/dump_gvf.pl:    if ($config->{evidence}) {
scripts/export/release/dump_gvf.pl:    if ($config->{clinical_significance}) {
scripts/export/release/dump_gvf.pl:    if ($config->{global_maf}) {
scripts/export/release/dump_gvf.pl:    if (defined $gvf_line->{attributes}->{invalid_variant_strings}) {
scripts/export/release/dump_gvf.pl:        $gvf_line->{attributes}->{ID} = ++$config->{id_count};
scripts/export/release/dump_gvf.pl:    my $source_id = $vf->{_source_id};
scripts/export/release/dump_gvf.pl:    my $source_name = $source_lookup->{$source_id}->{name};
scripts/export/release/dump_gvf.pl:    $gvf_line->{source} = $source_name;
scripts/export/release/dump_gvf.pl:    my $source_version = $source_lookup->{$source_id}->{version};
scripts/export/release/dump_gvf.pl:    $gvf_line->{attributes}->{Dbxref} = "$source_name:" . $vf->variation_name;
scripts/export/release/dump_gvf.pl:    $gvf_line->{seqid} = $vf->slice->seq_region_name;
scripts/export/release/dump_gvf.pl:    my $start = $vf->seq_region_start;
scripts/export/release/dump_gvf.pl:    my $end = $vf->seq_region_end;
scripts/export/release/dump_gvf.pl:    $gvf_line->{start} = $start;
scripts/export/release/dump_gvf.pl:    $gvf_line->{end} = $end;
scripts/export/release/dump_gvf.pl:    $gvf_line->{strand} = $vf->strand == 1 ? '+' : ($vf->strand == -1 ? '-' : '.');
scripts/export/release/dump_gvf.pl:    my @alleles = split /\//, $vf->allele_string;
scripts/export/release/dump_gvf.pl:    $gvf_line->{allele_string} = join('/', @alleles);
scripts/export/release/dump_gvf.pl:    if ($vf->allele_string eq 'HGMD_MUTATION') {
scripts/export/release/dump_gvf.pl:        $gvf_line->{attributes}->{'comment'} = 'HGMD_MUTATION';
scripts/export/release/dump_gvf.pl:        if ($vf->var_class eq 'deletion') {
scripts/export/release/dump_gvf.pl:            push @alleles, '-';
scripts/export/release/dump_gvf.pl:        } elsif ($vf->var_class eq 'insertion') {
scripts/export/release/dump_gvf.pl:            $ref_seq = '-';
scripts/export/release/dump_gvf.pl:    my $Variant_seq_regex = qr/^([A-DGHKMNR-WY]+| # Any valid IUPAC Nucleotide
scripts/export/release/dump_gvf.pl:                                    [.\-!^\*] # Any [.-!^*]
scripts/export/release/dump_gvf.pl:        $gvf_line->{attributes}->{invalid_variant_strings} = join(',', @invalid_variant_strings);
scripts/export/release/dump_gvf.pl:    $gvf_line->{attributes}->{Variant_seq} = join ',', @alleles;
scripts/export/release/dump_gvf.pl:    my $Reference_seq_regex = qr/^([A-DGHKMNR-WY]+|~\d*|[.\-])$/i; # from gvf_validator
scripts/export/release/dump_gvf.pl:    my $sa = $config->{slice_adaptor};
scripts/export/release/dump_gvf.pl:        $gvf_line->{attributes}->{invalid_ref_seq} = $ref_seq;
scripts/export/release/dump_gvf.pl:        my $location = $gvf_line->{seqid} . ':' . $gvf_line->{start} . '-' . $gvf_line->{end};
scripts/export/release/dump_gvf.pl:        my $ref_seq_slice = $sa->fetch_by_toplevel_location($location);
scripts/export/release/dump_gvf.pl:        $ref_seq = $ref_seq_slice->seq;
scripts/export/release/dump_gvf.pl:    $gvf_line->{attributes}->{Reference_seq} = $ref_seq;
scripts/export/release/dump_gvf.pl:    if (defined($vf->ancestral_allele)) {
scripts/export/release/dump_gvf.pl:        $gvf_line->{attributes}->{ancestral_allele} = $vf->ancestral_allele;
scripts/export/release/dump_gvf.pl:    my $variation = $vf->variation;
scripts/export/release/dump_gvf.pl:    my $values = $variation->get_all_evidence_values();
scripts/export/release/dump_gvf.pl:        $gvf_line->{attributes}->{evidence_values} = join(',', @$values);
scripts/export/release/dump_gvf.pl:    my $variation = $vf->variation;
scripts/export/release/dump_gvf.pl:    my @states = @{$variation->get_all_clinical_significance_states};
scripts/export/release/dump_gvf.pl:        $gvf_line->{attributes}->{clinical_significance} = join(',', @states);
scripts/export/release/dump_gvf.pl:    my @states = @{$sv->get_all_clinical_significance_states};
scripts/export/release/dump_gvf.pl:        $gvf_line->{attributes}->{clinical_significance} = join(',', @states);
scripts/export/release/dump_gvf.pl:    my $variation = $vf->variation;
scripts/export/release/dump_gvf.pl:    if ( defined( $variation->minor_allele_frequency)) {
scripts/export/release/dump_gvf.pl:        my @alleles = split /\//, $gvf_line->{allele_string};
scripts/export/release/dump_gvf.pl:        my $allele_idx = first { $alleles[$_] eq $variation->minor_allele } 0..$#alleles;
scripts/export/release/dump_gvf.pl:            $gvf_line->{attributes}->{global_minor_allele_frequency} =
scripts/export/release/dump_gvf.pl:                    $variation->minor_allele_frequency,
scripts/export/release/dump_gvf.pl:                    $variation->minor_allele_count,);
scripts/export/release/dump_gvf.pl:    my $tva = $config->{tv_adaptor};
scripts/export/release/dump_gvf.pl:        my $vf_id = $vf->dbID;
scripts/export/release/dump_gvf.pl:        $gvf_lines->{$vf_id}->{vf} = $vf;
scripts/export/release/dump_gvf.pl:    foreach my $tv (@{$tva->fetch_all_by_VariationFeatures($vfs)}) {
scripts/export/release/dump_gvf.pl:        my $tv_stable_id = $tv->transcript_stable_id;
scripts/export/release/dump_gvf.pl:        my $vf = $tv->variation_feature;
scripts/export/release/dump_gvf.pl:        my $vf_id = $vf->dbID;
scripts/export/release/dump_gvf.pl:        $gvf_lines->{$vf_id}->{vf} = $vf;
scripts/export/release/dump_gvf.pl:        my @alleles = split /\//, $vf->allele_string;
scripts/export/release/dump_gvf.pl:        if ($config->{protein_coding_details}) {
scripts/export/release/dump_gvf.pl:            my $ref_tva = $tv->get_reference_TranscriptVariationAllele;
scripts/export/release/dump_gvf.pl:            if (my $pep = $ref_tva->peptide) {
scripts/export/release/dump_gvf.pl:                $gvf_lines->{$vf_id}->{attributes}->{reference_peptide} = $pep;
scripts/export/release/dump_gvf.pl:        foreach my $tv_allele (@{$tv->get_all_alternate_TranscriptVariationAlleles}) {
scripts/export/release/dump_gvf.pl:            my $allele_idx = first { $alleles[$_] eq $tv_allele->variation_feature_seq } 0..$#alleles;
scripts/export/release/dump_gvf.pl:              print STDERR "Missing allele_idx for VF_id $vf_id transcript_stable_id $tv_stable_id and TV_allele " ,  $tv_allele->variation_feature_seq, "\n"; 
scripts/export/release/dump_gvf.pl:            if ($config->{incl_consequences}) {
scripts/export/release/dump_gvf.pl:                for my $oc (@{$tv_allele->get_all_OverlapConsequences}) {
scripts/export/release/dump_gvf.pl:                    push @{ $gvf_lines->{$vf_id}->{attributes}->{Variant_effect} ||= [] },
scripts/export/release/dump_gvf.pl:                        join(' ', $oc->SO_term,
scripts/export/release/dump_gvf.pl:                                  $oc->feature_SO_term,
scripts/export/release/dump_gvf.pl:            if ($config->{protein_coding_details}) {
scripts/export/release/dump_gvf.pl:                if ($tv_allele->pep_allele_string) {
scripts/export/release/dump_gvf.pl:                    push @{ $gvf_lines->{$vf_id}->{attributes}->{variant_peptide} ||= [] },
scripts/export/release/dump_gvf.pl:                            $tv_allele->peptide,
scripts/export/release/dump_gvf.pl:                    for my $tool (@{$config->{protein_func_pred_tools}}) {
scripts/export/release/dump_gvf.pl:                        if (my $pred = $tv_allele->$pred_meth) {
scripts/export/release/dump_gvf.pl:                            push @{ $gvf_lines->{$vf_id}->{attributes}->{"$tool\_prediction"} ||= [] },
scripts/export/release/dump_gvf.pl:                                    $tv_allele->$score_meth,
scripts/export/release/dump_gvf.pl:    my $sgta = $config->{sample_gt_adaptor};
scripts/export/release/dump_gvf.pl:    my $sample = $config->{_sample};
scripts/export/release/dump_gvf.pl:    my $sgts = $sgta->fetch_all_by_Slice($slice, $sample);
scripts/export/release/dump_gvf.pl:            $sgt->slice->seq_region_name,
scripts/export/release/dump_gvf.pl:            $sgt->seq_region_start,
scripts/export/release/dump_gvf.pl:            $sgt->seq_region_end,
scripts/export/release/dump_gvf.pl:        my $gts = $gt_hash->{$key} ||= [];
scripts/export/release/dump_gvf.pl:                if (($gt->allele1 eq $sgt->allele1 && $gt->allele2 eq $sgt->allele2) ||
scripts/export/release/dump_gvf.pl:                    ($gt->allele1 eq $sgt->allele2 && $gt->allele2 eq $sgt->allele1)) {
scripts/export/release/dump_gvf.pl:    $config->{gts} = $gt_hash;
scripts/export/release/dump_gvf.pl:    my $gt_hash = $config->{gts};
scripts/export/release/dump_gvf.pl:    my $key = join('_', $vf->slice->seq_region_name, $vf->seq_region_start, $vf->seq_region_end,);
scripts/export/release/dump_gvf.pl:    my @gts = @{ $gt_hash->{$key} || [] };
scripts/export/release/dump_gvf.pl:        my $gt1 = $gt->allele1;
scripts/export/release/dump_gvf.pl:        my $gt2 = $gt->allele2;
scripts/export/release/dump_gvf.pl:        unless ($vf->strand == $gt->strand) {
scripts/export/release/dump_gvf.pl:        my @alleles = split /\//, $vf->allele_string;
scripts/export/release/dump_gvf.pl:            my $gt_incl_indel = ($gt1 eq '-' || $gt eq '-');
scripts/export/release/dump_gvf.pl:            my $vf_is_indel = ($vf->var_class eq 'deletion' || $vf->var_class eq 'insertion');
scripts/export/release/dump_gvf.pl:            my $vf_is_sub = $vf->var_class eq 'substitution';
scripts/export/release/dump_gvf.pl:            next GT if ($gt->variation->name ne $vf->variation_name);
scripts/export/release/dump_gvf.pl:        $gvf_line->{attributes}->{Variant_seq} = $variant_seq;
scripts/export/release/dump_gvf.pl:        $gvf_line->{attributes}->{Zygosity} = $hom ? 'homozygous' : 'heterozygous';
scripts/export/release/dump_gvf.pl:        $gvf_line->{attributes}->{Genotype} = $genotype;
scripts/export/release/dump_gvf.pl:    unless ($gvf_line->{attributes}->{Zygosity}) {
scripts/export/release/dump_gvf.pl:    my $gff_version = '##gff-version 3';
scripts/export/release/dump_gvf.pl:    my $gvf_version = '##gvf-version 1.07';
scripts/export/release/dump_gvf.pl:    my $date = sprintf "%4d-%02d-%02d", $year, $mon, $mday;
scripts/export/release/dump_gvf.pl:    my $slices = $config->{slices};
scripts/export/release/dump_gvf.pl:    my $assembly = $slices->[0]->coord_system->version;
scripts/export/release/dump_gvf.pl:    my $mca = $slices->[0]->adaptor->db->get_MetaContainerAdaptor;
scripts/export/release/dump_gvf.pl:    my $tax_id = $mca->get_taxonomy_id;
scripts/export/release/dump_gvf.pl:    my $gff_header = "##file-date $date\n"
scripts/export/release/dump_gvf.pl:    . "##genome-build ensembl $assembly\n"
scripts/export/release/dump_gvf.pl:    my $schema_version = $mca->get_schema_version;
scripts/export/release/dump_gvf.pl:    my $species_name = $mca->get_scientific_name;
scripts/export/release/dump_gvf.pl:    my ($division) = @{$mca->list_value_by_key('species.division')};
scripts/export/release/dump_gvf.pl:    my $gvf_header = "##feature-ontology http://song.cvs.sourceforge.net/viewvc/song/ontology/so.obo?revision=1.283\n"
scripts/export/release/dump_gvf.pl:    . "##data-source Source=ensembl;version=$schema_version;url=$url\n"
scripts/export/release/dump_gvf.pl:    . "##file-version $schema_version\n";
scripts/export/release/dump_gvf.pl:    if ($config->{sample}) {
scripts/export/release/dump_gvf.pl:        $gvf_header .= "##sample-id " . $config->{sample};
scripts/export/release/dump_gvf.pl:    if ($config->{population}) {
scripts/export/release/dump_gvf.pl:        $gvf_header .= "##population " . $config->{population};
scripts/export/release/dump_gvf.pl:    my $fh = $config->{fh};
scripts/export/release/dump_gvf.pl:        print $fh join(' ', '##sequence-region', $slice->seq_region_name, $slice->start, $slice->end), "\n";
scripts/export/release/dump_gvf.pl:    my $fh = $config->{fh};  
scripts/export/release/dump_gvf.pl:    my $line = join("\t", $gvf_line->{seqid}, $gvf_line->{source}, $gvf_line->{type}, $gvf_line->{start},
scripts/export/release/dump_gvf.pl:            $gvf_line->{end}, $gvf_line->{score}, $gvf_line->{strand}, $gvf_line->{phase});
scripts/export/release/dump_gvf.pl:    if ($gvf_line->{attributes}) {
scripts/export/release/dump_gvf.pl:        for my $key (keys %{$gvf_line->{attributes}}) {
scripts/export/release/dump_gvf.pl:            my $val = $gvf_line->{attributes}->{$key};
scripts/export/dump_phenotypes_wormbase.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/dump_phenotypes_wormbase.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/dump_phenotypes_wormbase.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/export/dump_phenotypes_wormbase.pl:  print STDERR "> Error! Please give a WormBase ParaSite version, using the option '-pv' \n";
scripts/export/dump_phenotypes_wormbase.pl:  print STDERR "> Error! Please give an Ensembl version, using the option '-v' \n";
scripts/export/dump_phenotypes_wormbase.pl:  print STDERR "> Error! Please give an output directory for the dumps, using the option '-o' \n";
scripts/export/dump_phenotypes_wormbase.pl:  print STDERR "> Error! Please give a database user name, using the option '-user' \n";
scripts/export/dump_phenotypes_wormbase.pl:  print STDERR "> Error! Please give the host name where the databases are stored using the option '-hname'\n";
scripts/export/dump_phenotypes_wormbase.pl:#VEP-config
scripts/export/dump_phenotypes_wormbase.pl:my $cfg = Bio::EnsEMBL::VEP::Config->new({testing => 'hello'});
scripts/export/dump_phenotypes_wormbase.pl:$registry->load_registry_from_db(
scripts/export/dump_phenotypes_wormbase.pl:    -host       => $host,
scripts/export/dump_phenotypes_wormbase.pl:    -port       => $port,
scripts/export/dump_phenotypes_wormbase.pl:    -user       => $user,
scripts/export/dump_phenotypes_wormbase.pl:    -pass       => '',
scripts/export/dump_phenotypes_wormbase.pl:    -db_version => $e_version,
scripts/export/dump_phenotypes_wormbase.pl:while (my ($dbname) = $sth_h->fetchrow_array) {
scripts/export/dump_phenotypes_wormbase.pl:  next if ($dbname !~ /^[a-z]+_[a-z]+_[a-z0-9]+_variation_\d+_\d+_\d+$/i);
scripts/export/dump_phenotypes_wormbase.pl:  my $ftpfilename = ProductionMysql::core_db_to_local_ftp_filename(ProductionMysql->staging, $cdbname);
scripts/export/dump_phenotypes_wormbase.pl:  print STDERR "# $s_name - [ $dbname ]\n";
scripts/export/dump_phenotypes_wormbase.pl:  my ($count) = $sth_pf->fetchrow_array();
scripts/export/dump_phenotypes_wormbase.pl:  die ("Phenotype file $dumpFile already exists. Specify a different output folder or use --force to override the existing one\n") if -e $dumpFile & !$force ;
scripts/export/dump_phenotypes_wormbase.pl:$sth_h->finish;
scripts/export/dump_phenotypes_wormbase.pl:  my $dbh = DBI->connect($dsn, $user) or die "Connection failed";
scripts/export/dump_phenotypes_wormbase.pl:  my $sth = $dbh->prepare($sql);
scripts/export/dump_phenotypes_wormbase.pl:  $sth->execute;
scripts/export/dump_phenotypes_wormbase.pl:    $sth->finish;
scripts/export/dump_phenotypes_wormbase.pl:    -help             Print this message
scripts/export/dump_phenotypes_wormbase.pl:    -output_dir|o     Output directory for the GVF dumps (Required)
scripts/export/dump_phenotypes_wormbase.pl:    -force|f          Force to override any pre-existing dumps
scripts/export/dump_phenotypes_wormbase.pl:    -quiet|q          Suppress warning messages.Not used by default
scripts/export/dump_phenotypes_wormbase.pl:    -species|s        Only export the species in the list,
scripts/export/dump_phenotypes_wormbase.pl:    -user|u           Database login user name (Required)
scripts/export/dump_phenotypes_wormbase.pl:    -v                Ensembl version, e.g. 96 (Required)
scripts/export/dump_phenotypes_wormbase.pl:    -pv               WormBase ParaSite Version, e.g. 16 (Required)       
scripts/export/dump_phenotypes_wormbase.pl:    -hname            The host name (with port) where the databases are stored,
scripts/export/dump_phenotypes.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/dump_phenotypes.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/dump_phenotypes.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/export/dump_phenotypes.pl:  print STDERR "> Error! Please give an Ensembl version, using the option '-v' \n";
scripts/export/dump_phenotypes.pl:  print STDERR "> Error! Please give an output directory for the dumps, using the option '-o' \n";
scripts/export/dump_phenotypes.pl:  print STDERR "> Error! Please give a database user name, using the option '-user' \n";
scripts/export/dump_phenotypes.pl:  print STDERR "> Error! Please give the host name where the databases are stored using the option '-hname'\n";
scripts/export/dump_phenotypes.pl:#VEP-config
scripts/export/dump_phenotypes.pl:my $cfg = Bio::EnsEMBL::VEP::Config->new({testing => 'hello'});
scripts/export/dump_phenotypes.pl:$registry->load_registry_from_db(
scripts/export/dump_phenotypes.pl:    -host       => $host,
scripts/export/dump_phenotypes.pl:    -port       => $port,
scripts/export/dump_phenotypes.pl:    -user       => $user,
scripts/export/dump_phenotypes.pl:    -pass       => '',
scripts/export/dump_phenotypes.pl:    -db_version => $e_version,
scripts/export/dump_phenotypes.pl:while (my ($dbname) = $sth_h->fetchrow_array) {
scripts/export/dump_phenotypes.pl:  next if ($dbname !~ /^[a-z]+_[a-z]+_variation_\d+_\d+$/i &&
scripts/export/dump_phenotypes.pl:  print STDERR "# $s_name - [ $dbname ]\n";
scripts/export/dump_phenotypes.pl:  my ($count) = $sth_pf->fetchrow_array();
scripts/export/dump_phenotypes.pl:  die ("Phenotype file $dumpFile already exists. Specify a different output folder or use --force to override the existing one\n") if -e $dumpFile & !$force ;
scripts/export/dump_phenotypes.pl:$sth_h->finish;
scripts/export/dump_phenotypes.pl:  my $dbh = DBI->connect($dsn, $user) or die "Connection failed";
scripts/export/dump_phenotypes.pl:  my $sth = $dbh->prepare($sql);
scripts/export/dump_phenotypes.pl:  $sth->execute;
scripts/export/dump_phenotypes.pl:    $sth->finish;
scripts/export/dump_phenotypes.pl:    -help             Print this message
scripts/export/dump_phenotypes.pl:    -output_dir|o     Output directory for the GVF dumps (Required)
scripts/export/dump_phenotypes.pl:    -force|f          Force to override any pre-existing dumps
scripts/export/dump_phenotypes.pl:    -quiet|q          Suppress warning messages.Not used by default
scripts/export/dump_phenotypes.pl:    -species|s        Only export the species in the list,
scripts/export/dump_phenotypes.pl:    -user|u           Database login user name (Required)
scripts/export/dump_phenotypes.pl:    -v                Ensembl version, e.g. 96 (Required)
scripts/export/dump_phenotypes.pl:    -hname            The host name (with port) where the databases are stored,
scripts/export/tidy_gvf_dumps.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/export/tidy_gvf_dumps.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/export/tidy_gvf_dumps.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/export/tidy_gvf_dumps.pl:# tidy_gvf_dumps.pl - Tidy up the GVF dump directory before a release 
scripts/export/tidy_gvf_dumps.pl:die "Usage: $0 --output_dir DIR\n" unless $toplevel_dir;
scripts/export/tidy_gvf_dumps.pl:    `rm -f $dir/*.out`;
scripts/export/tidy_gvf_dumps.pl:    `rm -f $dir/*.err`;
scripts/export/tidy_gvf_dumps.pl:simple tab-delimited format derived from GFF3 which shows the location of 
scripts/export/tidy_gvf_dumps.pl:-----
scripts/export/tidy_gvf_dumps.pl:##gff-version 3
scripts/export/tidy_gvf_dumps.pl:##file-date 2011-01-31
scripts/export/tidy_gvf_dumps.pl:##genome-build ensembl GRCh37
scripts/export/tidy_gvf_dumps.pl:##gvf-version 1.05
scripts/export/tidy_gvf_dumps.pl:##feature-ontology http://song.cvs.sourceforge.net/viewvc/song/ontology/so.obo?revision=1.283
scripts/export/tidy_gvf_dumps.pl:##data-source Source=ensembl;version=61;url=http://e61.ensembl.org/Homo_sapiens
scripts/export/tidy_gvf_dumps.pl:##file-version 61
scripts/export/tidy_gvf_dumps.pl:##sequence-region 11 1 135006516
scripts/export/tidy_gvf_dumps.pl:11	dbSNP	SNV	70135	70135	.	-	.	ID=8;Variant_seq=A;Dbxref=dbSNP_132:rs4120101;Reference_seq=C
scripts/export/tidy_gvf_dumps.pl:11	dbSNP	SNV	70146	70146	.	-	.	ID=9;Variant_seq=C;Dbxref=dbSNP_132:rs4120100;Reference_seq=A
scripts/ssahaSNP/bsub_ssahaSNP.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/ssahaSNP/bsub_ssahaSNP.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/ssahaSNP/bsub_ssahaSNP.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/ssahaSNP/bsub_ssahaSNP.pl:#perl ./bsub_ssahaSNP.pl -reads_dir [reads_dir] -output_dir [out_dir] -target_file [target_dir]/chimp_repeat_masked.fa
scripts/ssahaSNP/bsub_ssahaSNP.pl:my $queue = "hugemem -R 'select[mem>6000] rusage[mem=6000]'";
scripts/ssahaSNP/bsub_ssahaSNP.pl:my $tar_file = $tar[-1];
scripts/ssahaSNP/bsub_ssahaSNP.pl:my @files = grep(/perlegen-mouse-chip-111/,readdir(DIRENTRY));
scripts/ssahaSNP/bsub_ssahaSNP.pl:#@files = ("perlegen-mouse-chip-1114058134.fastq");
scripts/ssahaSNP/bsub_ssahaSNP.pl:    my $end = $n+$size-1;
scripts/ssahaSNP/bsub_ssahaSNP.pl:    #my $call = "bsub -q $queue -e $output_dir/ssaha_out\_$file\_$n.err -o $output_dir/ssaha_out\_$file\_$n $ssahaSNP $reads_dir/$file $target_file";# -start $n -end $end -cut 100 -depth 10 -best 1";
scripts/ssahaSNP/bsub_ssahaSNP.pl:    my $call = "bsub -q $queue -J 'ssahaSNP_$n' -e $output_dir/ssaha_out\_$file\_$n.err -o $output_dir/ssaha_out\_$file\_$n\_$tar_file $ssahaSNP $reads_dir/$file  $target_file -start $n -end $end -output cigar -NQS 1 -tags 1 -quality 23 -memory 2000";
scripts/ssahaSNP/compFastq_all:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/ssahaSNP/compFastq_all:Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/ssahaSNP/compFastq_all:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/ssahaSNP/compFastq_all:      elsif (/^[A-Za-z]/) {
scripts/ssahaSNP/compFastq_all:          $seq_n{$n}{'seq'}=join '',@seqs[$n..$n+2000-1];
scripts/ssahaSNP/compFastq_all:          $seq_n{$n}{'qual'}=join '',@quals[$n..$n+2000-1];
scripts/ssahaSNP/run_pileup.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/ssahaSNP/run_pileup.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/ssahaSNP/run_pileup.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/ssahaSNP/run_pileup.pl:#usage('-species argument is required') if(!$species);
scripts/ssahaSNP/run_pileup.pl:Bio::EnsEMBL::Registry->load_all( $registry_file );
scripts/ssahaSNP/run_pileup.pl:my $cdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'core');
scripts/ssahaSNP/run_pileup.pl:my $vdb = Bio::EnsEMBL::Registry->get_DBAdaptor($species,'variation');
scripts/ssahaSNP/run_pileup.pl:my $dbCore = $cdb->dbc;
scripts/ssahaSNP/run_pileup.pl:my $dbVar = $vdb->dbc;
scripts/ssahaSNP/run_pileup.pl:my $slice_adaptor = $cdb->get_SliceAdaptor;
scripts/ssahaSNP/run_pileup.pl:my $sth = $dbCore->prepare(qq{SELECT sr.seq_region_id, sr.name
scripts/ssahaSNP/run_pileup.pl:$sth->execute();
scripts/ssahaSNP/run_pileup.pl:while (my ($seq_region_id,$seq_region_name) = $sth->fetchrow_array()) {
scripts/ssahaSNP/run_pileup.pl:  #system("cat $output_dir/ssaha_out*hash |egrep cigar >$output_dir/genome-cigar-raw.dat");
scripts/ssahaSNP/run_pileup.pl:  #system("$ssaha_command_dir/ssaha_cigar $output_dir/genome-cigar-raw.dat $output_dir/genome-cigar.dat");
scripts/ssahaSNP/run_pileup.pl:  $cigar_file ||="$output_dir/genome-cigar.dat";
scripts/ssahaSNP/run_pileup.pl:      #cigar: gnl|ti|904511325 0 778 + 8-1-129041809 73391177 73391953 + 762 M 754 I 1 M 16 I 1 M 6
scripts/ssahaSNP/run_pileup.pl:    ($target_name1) = $target_name =~ /^(.*)\-.*\-.*$/ if ($target_name =~ /\-/);
scripts/ssahaSNP/run_pileup.pl:    $query_strand = ($query_strand eq "+") ? 1 : -1;
scripts/ssahaSNP/run_pileup.pl:    $target_strand = ($target_strand eq "+") ? 1 : -1;
scripts/ssahaSNP/run_pileup.pl:  my $tab_name_ref1 = $dbVar->db_handle->selectall_arrayref(qq{show tables like "ssahaSNP_feature%"});  
scripts/ssahaSNP/run_pileup.pl:  if ($tab_name_ref1->[0][0]) {
scripts/ssahaSNP/run_pileup.pl:  my $match_tab_ref = $dbVar->db_handle->selectall_arrayref(qq{show tables like "query_match%"});
scripts/ssahaSNP/run_pileup.pl:  if ($match_tab_ref->[0][0]) {
scripts/ssahaSNP/run_pileup.pl:  my $tmp_dir = $self->{'tmpdir'};
scripts/ssahaSNP/run_pileup.pl:  my $tmp_file = $self->{'tmpfile'};
scripts/ssahaSNP/run_pileup.pl:    my $job = "bsub -q normal -J parallel_jobs_$fastq_file -o $pileup_dir/out_parallel_$fastq_file $ssaha_command_dir/parallel_pileup.pl -pileup_dir $pileup_dir -output_dir $output_dir -fastq_dir $fastq_dir -fastq_file $fastq_file";
scripts/ssahaSNP/run_pileup.pl:  my $call = "bsub -q long -K -w 'done(parallel_jobs*)' -J waiting_process sleep 1"; #waits until all variation features have finished to continue
scripts/ssahaSNP/run_pileup.pl:  system("cat $pileup_dir/*cigar.dat >$pileup_dir/genome-cigar.dat");
scripts/ssahaSNP/run_pileup.pl:  system("cat $pileup_dir/*fastq.dat >$pileup_dir/genome-reads.fastq");
scripts/ssahaSNP/run_pileup.pl:  #system("bsub -q hugemem -R'select[mem>55000] rusage[mem=55000]' -o $pileup_dir/out_SNP -f \"$pileup_dir/genome-cigar.dat > /tmp/genome-cigar.dat\" -f \"$pileup_dir/genome-reads.fastq > /tmp/genome-reads.fastq\" -f \"$target_dir/tetraodon.faa > /tmp/tetraodon.faa\" $ssaha_command_dir/ssaha_pileup-turing /tmp/genome-cigar.dat /tmp/tetraodon.faa /tmp/genome-reads.fastq");
scripts/ssahaSNP/run_pileup.pl:  system("bsub -q normal -M7000000 -R'select[mem>7000] rusage[mem=7000]' -o $pileup_dir/out_SNP $ssaha_command_dir/ssaha_pileup $pileup_dir/genome-cigar.dat $pileup_dir/tetraodon.faa $pileup_dir/genome-reads.fastq");
scripts/ssahaSNP/run_pileup.pl:    #SNP_hez: 1-1-229942017 30 23995820  6       T C/G 0      3      2      1      0      0     0   0   2   1
scripts/ssahaSNP/run_pileup.pl:    my ($chr,$start,$end) = split /\-/, $target_name;
scripts/ssahaSNP/run_pileup.pl:    my $seq_region_start = $pos + $start -1; #most chr start =1, but haplotype chr start >1
scripts/ssahaSNP/run_pileup.pl:	      if ($num_cap_base1-$num_small_base1>1 and $num_cap_base2-$num_small_base2>1 ) {
scripts/ssahaSNP/run_pileup.pl:	      elsif ($num_cap_base1-$num_small_base1>0 or $num_cap_base1>1 and $num_cap_base2-$num_small_base2>0 or $num_cap_base2>1 ) {#one big allele or two small alleles, use ratio to decide homo or hetero
scripts/ssahaSNP/run_pileup.pl:  $dbVar->do(qq{CREATE TABLE IF NOT EXISTS pileup_snp LIKE pileup_snp_$strain_name});
scripts/ssahaSNP/run_pileup.pl:  $dbVar->do(qq{INSERT INTO pileup_snp SELECT * FROM pileup_snp_$strain_name});
scripts/ssahaSNP/run_pileup.pl:  $dbVar->do(qq{INSERT INTO pileup_snp SELECT * FROM pileup_snp_same_base_$strain_name});
scripts/ssahaSNP/run_pileup.pl:  $dbVar->do(qq{CREATE TABLE IF NOT EXISTS pileup_snp_merge (
scripts/ssahaSNP/run_pileup.pl:  $dbVar->do(qq{INSERT INTO pileup_snp_merge (name,chr,seq_region_id,seq_region_start,allele_string,individual_name) 
scripts/ssahaSNP/run_pileup.pl:  my $sth = $dbVar->prepare(qq{SELECT variation_id,allele_string FROM pileup_snp_merge
scripts/ssahaSNP/run_pileup.pl:  $sth->execute();
scripts/ssahaSNP/run_pileup.pl:  $sth->bind_columns(\$variation_id,\$allele_string);
scripts/ssahaSNP/run_pileup.pl:  while($sth->fetch()) {
scripts/ssahaSNP/run_pileup.pl:    $dbVar->do(qq{UPDATE pileup_snp_merge SET allele_string = "$allele_string_new"
scripts/ssahaSNP/run_pileup.pl:  $dbVar->do(qq{INSERT INTO sample (name,description) values ("$ind_pop_name","$ind_sample_pop_desc")});
scripts/ssahaSNP/run_pileup.pl:  my $population_ind_sample_id = $dbVar->db_handle->{'mysql_insertid'};
scripts/ssahaSNP/run_pileup.pl:  $dbVar->do(qq{INSERT INTO population (sample_id) values ($population_ind_sample_id)});
scripts/ssahaSNP/run_pileup.pl:    $dbVar->do(qq{INSERT INTO sample (name,size,description) values ("$strain_name",NULL,"$ind_sample_desc")});
scripts/ssahaSNP/run_pileup.pl:    my $individual_sample_id = $dbVar->db_handle->{'mysql_insertid'};
scripts/ssahaSNP/run_pileup.pl:    $dbVar->do(qq{INSERT INTO individual (sample_id,individual_type_id) values ($individual_sample_id, $individual_type_id)});
scripts/ssahaSNP/run_pileup.pl:    $dbVar->do(qq{INSERT INTO individual_population (individual_sample_id,population_sample_id) values ($individual_sample_id,$population_ind_sample_id)});
scripts/ssahaSNP/run_pileup.pl:    $dbVar->do(qq{INSERT INTO source (name) values ("$source_name")});
scripts/ssahaSNP/run_pileup.pl:    my $source_id = $dbVar->{'mysql_insertid'};
scripts/ssahaSNP/run_pileup.pl:    $dbVar->do(qq{ALTER TABLE variation add column internal_name varchar(50) unique key});
scripts/ssahaSNP/run_pileup.pl:    $dbVar->do(qq{INSERT IGNORE INTO variation (variation_id,source_id,name,internal_name) select snp.variation_id,s.source_id as source_id,concat(snp.name,snp.variation_id) as name,concat("$source_name\_",snp.chr,"-",snp.seq_region_start) as internal_name from source s, pileup_snp_merge snp});
scripts/ssahaSNP/run_pileup.pl: $dbVar->do(qq{INSERT INTO variation_feature (seq_region_id,seq_region_start,seq_region_end,seq_region_strand,variation_id,allele_string,variation_name,map_weight,flags,source_id,validation_status,consequence_type)
scripts/ssahaSNP/run_pileup.pl:#   $dbVar->do(qq{create table vf_y_top select * from variation_feature where seq_region_id=226054 and seq_region_start>=1 and seq_region_start<=2709520});
scripts/ssahaSNP/run_pileup.pl:#   $dbVar->do(qq{insert into vf_y_top select * from variation_feature where seq_region_id=226054 and seq_region_start>=57443438 and seq_region_start<=57772954});
scripts/ssahaSNP/run_pileup.pl:#   $dbVar->do(qq{update vf_y_top set seq_region_id=226031});
scripts/ssahaSNP/run_pileup.pl:#   $dbVar->do(qq{insert into variation_feature (seq_region_id,seq_region_start,seq_region_end,seq_region_strand,variation_id,allele_string,variation_name,map_weight,flags,source_id,validation_status,consequence_type) select seq_region_id,seq_region_start,seq_region_end,seq_region_strand,variation_id,allele_string,variation_name,map_weight,flags,source_id,validation_status,consequence_type from vf_y_top});
scripts/ssahaSNP/run_pileup.pl:  $dbVar->do(qq{INSERT IGNORE INTO flanking_sequence (variation_id,up_seq,down_seq,up_seq_region_start,up_seq_region_end,down_seq_region_start,down_seq_region_end,seq_region_id,seq_region_strand)
scripts/ssahaSNP/run_pileup.pl:              SELECT vf.variation_id,NULL,NULL,if(vf.seq_region_start-101<1,1,vf.seq_region_start-101),vf.seq_region_start-1,vf.seq_region_end+1,if(vf.seq_region_end+101>sr.seq_region_length,sr.seq_region_length,vf.seq_region_end+101),vf.seq_region_id,vf.seq_region_strand
scripts/ssahaSNP/run_pileup.pl:  $dbVar->do(qq{CREATE UNIQUE INDEX unique_allele_idx ON allele (variation_id,allele(2),frequency,sample_id)});
scripts/ssahaSNP/run_pileup.pl:    $dbVar->do(qq{INSERT IGNORE INTO allele (variation_id,allele,sample_id)
scripts/ssahaSNP/run_pileup.pl:  $dbVar->do(qq{DELETE FROM allele WHERE allele ="";});
scripts/ssahaSNP/run_pileup.pl:  #$dbVar->do("DROP INDEX unique_allele_idx ON allele"); need it in the following par regions
scripts/ssahaSNP/run_pileup.pl:    $dbVar->do(qq{CREATE TABLE IF NOT EXISTS tmp_individual_genotype_single_bp (
scripts/ssahaSNP/run_pileup.pl:    $dbVar->do(qq{create table pileup_snp_new select m.variation_id,p.allele_1,p.allele_2,p.individual_name from pileup_snp p, pileup_snp_merge m where p.seq_region_id=m.seq_region_id and p.seq_region_start=m.seq_region_start});
scripts/ssahaSNP/run_pileup.pl:    $dbVar->do(qq{INSERT INTO tmp_individual_genotype_single_bp (variation_id,allele_1,allele_2,sample_id)
scripts/ssahaSNP/run_pileup.pl:  my $ae_adaptor =  $cdb->get_AssemblyExceptionFeatureAdaptor( $species, 'Core', 'AssemblyExceptionFeature' );
scripts/ssahaSNP/run_pileup.pl:  my $slice = $slice_adaptor->fetch_by_region( 'Chromosome', 'Y' );
scripts/ssahaSNP/run_pileup.pl:  my @exceptions = @{ $ae_adaptor->fetch_all_by_Slice($slice) }; #get the PAR regions between chr Y->X
scripts/ssahaSNP/run_pileup.pl:#   $dbVar->do($sql);
scripts/ssahaSNP/run_pileup.pl:#   $dbVar->do($sql);
scripts/ssahaSNP/run_pileup.pl:#  $dbVar->do(qq{CREATE TABLE IF NOT EXISTS tmp_varid (
scripts/ssahaSNP/run_pileup.pl:    my $target_seq_region_id = $exception->slice->get_seq_region_id();
scripts/ssahaSNP/run_pileup.pl:    my $target_start = $exception->start(); #Y coordinates
scripts/ssahaSNP/run_pileup.pl:    my $target_end = $exception->end();
scripts/ssahaSNP/run_pileup.pl:    my $seq_region_id = $exception->alternate_slice->get_seq_region_id();
scripts/ssahaSNP/run_pileup.pl:    my $start = $exception->alternate_slice()->start(); #X coordinates
scripts/ssahaSNP/run_pileup.pl:    my $end = $exception->alternate_slice()->end();
scripts/ssahaSNP/run_pileup.pl:    my $sth = $dbVar->prepare(qq{SELECT variation_id,variation_name,seq_region_start,seq_region_strand,allele_string FROM variation_feature WHERE seq_region_id = ? and seq_region_start >= ? and seq_region_end <= ? and seq_region_start <= ?});
scripts/ssahaSNP/run_pileup.pl:    $sth->bind_param(1,$seq_region_id);
scripts/ssahaSNP/run_pileup.pl:    $sth->bind_param(2,$start);
scripts/ssahaSNP/run_pileup.pl:    $sth->bind_param(3,$end);
scripts/ssahaSNP/run_pileup.pl:    $sth->bind_param(4,$end);
scripts/ssahaSNP/run_pileup.pl:    $sth->execute();
scripts/ssahaSNP/run_pileup.pl:    $sth->bind_columns(\$variation_id,\$variation_name,\$seq_region_start,\$seq_region_strand,\$allele_string);
scripts/ssahaSNP/run_pileup.pl:    while ($sth->fetch){
scripts/ssahaSNP/run_pileup.pl:        $snp_pos = $seq_region_start - $start; #the position of the snp relative to the beginning of the PAR region
scripts/ssahaSNP/run_pileup.pl:        #write_file("flanking_sequence.txt",$last_variation_id+1,$snp_pos+$target_start - 1 - 100,$snp_pos+$target_start - 1,$snp_pos+$target_start  +1, $snp_pos+$target_start + 1 + 100,$target_seq_region_id,$seq_region_strand);
scripts/ssahaSNP/run_pileup.pl:	#$dbVar->do(qq{INSERT INTO tmp_varid (variation_id,variation_id_new) values($variation_id,$last_variation_id)});
scripts/ssahaSNP/run_pileup.pl:  $dbVar->do(qq{INSERT INTO allele (variation_id,allele,sample_id)
scripts/ssahaSNP/run_pileup.pl:  $dbVar->do(qq{INSERT INTO tmp_individual_genotype_single_bp (variation_id,allele_1,allele_2,sample_id)
scripts/ssahaSNP/run_pileup.pl:    my $sth = $dbVar->prepare(qq{SELECT MAX($tablename\_id) from $tablename});
scripts/ssahaSNP/run_pileup.pl:    $sth->execute();
scripts/ssahaSNP/run_pileup.pl:    $sth->bind_columns(\$max_id);
scripts/ssahaSNP/run_pileup.pl:    $sth->fetch;
scripts/ssahaSNP/run_pileup.pl:    $sth->finish();
scripts/ssahaSNP/run_pileup.pl:    my $sth = $dbVar->prepare(qq{SELECT max(round(substring(name,7))) from variation});
scripts/ssahaSNP/run_pileup.pl:    $sth->execute();
scripts/ssahaSNP/run_pileup.pl:    $sth->bind_columns(\$max_id);
scripts/ssahaSNP/run_pileup.pl:    $sth->fetch;
scripts/ssahaSNP/run_pileup.pl:    $sth->finish();
scripts/ssahaSNP/run_pileup.pl:      #cigar: gnl|ti|904511325 0 778 + 8-1-129041809 73391177 73391953 + 762 M 754 I 1 M 16 I 1 M 6
scripts/ssahaSNP/run_pileup.pl:      ($chr) = split /\-/, $target_name if $target_name =~ /\-/;
scripts/ssahaSNP/run_pileup.pl:      if ($dbVar->dbname =~ /platypus/) {
scripts/ssahaSNP/run_pileup.pl:            print FH $buffer->{ $file };
scripts/ssahaSNP/run_pileup.pl:        $buffer->{ $filename } .= $text;
scripts/ssahaSNP/run_pileup.pl:        if( length( $buffer->{ $filename } ) > 10_000 ) {
scripts/ssahaSNP/run_pileup.pl:            print FH $buffer->{ $filename };
scripts/ssahaSNP/run_pileup.pl:            $buffer->{ $filename } = '';
scripts/ssahaSNP/fastq.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/ssahaSNP/fastq.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/ssahaSNP/fastq.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/ssahaSNP/fastq.pl:  next if (-e "$fname\.fastq");
scripts/ssahaSNP/fastq.pl:	if(-e "$fasta_dir/$fname") {
scripts/ssahaSNP/fastq.pl:	} elsif (-e "$fasta_dir/$fname.Z") {
scripts/ssahaSNP/fastq.pl:		open INA,"gunzip -c $fasta_dir/$fname.Z |" or return;
scripts/ssahaSNP/fastq.pl:	      } elsif (-e "$fasta_dir/$fname\.gz") {
scripts/ssahaSNP/fastq.pl:		open INA,"gunzip -c $fasta_dir/$fname\.gz |" or return;
scripts/ssahaSNP/fastq.pl:	if(-e "$qual_dir/$fname.qual") {
scripts/ssahaSNP/fastq.pl:	} elsif (-e "$qual_dir/$fname.qual.Z") {
scripts/ssahaSNP/fastq.pl:		open INQ,"gunzip -c $qual_dir/$fname.qual.Z |" or return;
scripts/ssahaSNP/fastq.pl:	} elsif (-e "$qual_dir/$fname\.qual.gz") {
scripts/ssahaSNP/fastq.pl:		open INQ,"gunzip -c $qual_dir/$fname\.qual.gz |" or return;
scripts/ssahaSNP/fastq.pl:		$totalbases += length($fasta)-1;
scripts/ssahaSNP/make_alignment_file.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/ssahaSNP/make_alignment_file.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/ssahaSNP/make_alignment_file.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/ssahaSNP/make_alignment_file.pl:  LINE : while (<$file_dir/cra-homo_sapiens-wgs-*\.TRACEINFO.xml.gz>) {
scripts/ssahaSNP/make_alignment_file.pl:    $_ =~ /cra-homo_sapiens-wgs-(\d+)\.TRACEINFO.xml.gz/;
scripts/ssahaSNP/make_alignment_file.pl:    open IN, "gunzip -c $file |" or die "can't open $file : $!";
scripts/ssahaSNP/make_alignment_file.pl:    open IN, "gunzip -c $file |" or die "can't open $file : $!";
scripts/ssahaSNP/make_alignment_file.pl:    open IN, "gunzip -c $file |" or die "can't open $file : $!";
scripts/ssahaSNP/make_alignment_file.pl:    #my ($file_number) = $_ =~ /cra-homo_sapiens-wgs-(\d+)\.fasta/;
scripts/remap_gnomad/filter_mapping_results.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/filter_mapping_results.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/filter_mapping_results.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/filter_mapping_results.pl:$registry->load_all($dir . '/remap_gnomad/genomes/ensembl.registry');
scripts/remap_gnomad/filter_mapping_results.pl:my $dbh = $registry->get_DBAdaptor('human', 'variation')->dbc->db_handle;
scripts/remap_gnomad/filter_mapping_results.pl:  my $fh = FileHandle->new($dir . '/remap_gnomad/genomes/multi_mapping_results.txt', 'w');
scripts/remap_gnomad/filter_mapping_results.pl:  my $sth = $dbh->prepare(qq{
scripts/remap_gnomad/filter_mapping_results.pl:  $sth->execute();
scripts/remap_gnomad/filter_mapping_results.pl:  while (my $row = $sth->fetchrow_arrayref) {
scripts/remap_gnomad/filter_mapping_results.pl:  $sth->finish();
scripts/remap_gnomad/filter_mapping_results.pl:  $fh->close();
scripts/remap_gnomad/filter_mapping_results.pl:    my $fh = FileHandle->new("$dir/remap_gnomad/genomes/unique_mappings/chrom$chrom.txt", 'w');
scripts/remap_gnomad/filter_mapping_results.pl:    my $sth = $dbh->prepare(qq{
scripts/remap_gnomad/filter_mapping_results.pl:    $sth->execute($chrom);
scripts/remap_gnomad/filter_mapping_results.pl:    while (my $row = $sth->fetchrow_arrayref) {
scripts/remap_gnomad/filter_mapping_results.pl:    $sth->finish();
scripts/remap_gnomad/filter_mapping_results.pl:    $fh->close();
scripts/remap_gnomad/run_unique_mapping_results_to_VCF.sh:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/run_unique_mapping_results_to_VCF.sh:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/run_unique_mapping_results_to_VCF.sh:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/run_unique_mapping_results_to_VCF.sh:bsub -J "append_gnomad_g[6,9,10,11,15,17,21]%13" \
scripts/remap_gnomad/run_unique_mapping_results_to_VCF.sh:-o ${dir}/append_gnomad_g.%I.out \
scripts/remap_gnomad/run_unique_mapping_results_to_VCF.sh:-e ${dir}/append_gnomad_g.%I.err \
scripts/remap_gnomad/cross_map.sh:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/cross_map.sh:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/cross_map.sh:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/run_final_append_job_array.sh:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/run_final_append_job_array.sh:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/run_final_append_job_array.sh:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/run_final_append_job_array.sh:bsub -J "append_gnomad_e[12,14,15,16,17]%5" \
scripts/remap_gnomad/run_final_append_job_array.sh:-o ${dir}/append_gnomad_g.%I.out \
scripts/remap_gnomad/run_final_append_job_array.sh:-e ${dir}/append_gnomad_g.%I.err \
scripts/remap_gnomad/final_variant_count_genomes.sh:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/final_variant_count_genomes.sh:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/final_variant_count_genomes.sh:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/final_variant_count_genomes.sh:  i_37=`bcftools index --nrecords $dir/grch37/genomes/gnomad.genomes.r2.1.sites.chr${chr}_noVEP.vcf.gz`
scripts/remap_gnomad/final_variant_count_genomes.sh:  i_unmap=`bcftools index --nrecords /hps/nobackup2/production/ensembl/anja/gnomad/Genomes/mapping_results/unmapped/gnomad.genomes.r2.1.sites.grch38.chr${chr}_noVEP.vcf.unmap.gz`
scripts/remap_gnomad/final_variant_count_genomes.sh:  i_crossmap_mapped=`bcftools index --nrecords /hps/nobackup2/production/ensembl/anja/gnomad/Genomes/mapping_results/unmapped/gnomad.genomes.r2.1.sites.grch38.chr${chr}_noVEP.vcf.gz`
scripts/remap_gnomad/final_variant_count_genomes.sh:  i_ensembl_unique_map=`wc -l < /hps/nobackup2/production/ensembl/anja/release_96/human/remap_gnomad/genomes/unique_mappings/chrom${chr}.txt`
scripts/remap_gnomad/final_variant_count_genomes.sh:  i_end_file=`bcftools index --nrecords $dir/grch38/genomes/gnomad.genomes.r2.1.sites.grch38.chr${chr}_noVEP.vcf.gz`
scripts/remap_gnomad/final_variant_count_genomes.sh:  i_gnomad_unmapped=$((i_unmap-i_ensembl_unique_map))
scripts/remap_gnomad/bgzip_mapping_results.sh:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/bgzip_mapping_results.sh:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/bgzip_mapping_results.sh:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/bgzip_mapping_results.sh:vcf-sort -t ${dir} < $vcf_file | bgzip > $vcf_file_gz
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:$registry->load_registry_from_db(
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:  -host => 'ensembldb.ensembl.org',
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:  -user => 'anonymous',
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:  -DB_VERSION => 95
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:my $vdba = $registry->get_DBAdaptor('human', 'variation');
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:$vdba->dbc->reconnect_when_lost(1);
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:my $cdba = $registry->get_DBAdaptor('human', 'core');
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:$cdba->dbc->reconnect_when_lost(1);
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:my $vfa = $vdba->get_VariationFeatureAdaptor;
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:my $slice_adaptor = $cdba->get_SliceAdaptor;
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:my $fh = FileHandle->new("/remap_gnomad/genomes/unique_mappings/chrom$chrom.txt", 'r');
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:my $fh_results =  FileHandle->new("/remap_gnomad/genomes/unique_mappings/$chrom.vcf", 'w');
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:$fh->close();
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:$fh_results->close();
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:  ($start, $end) = ($start - 1, $end + 1) if ($start > $end);
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:  my $parser = Bio::EnsEMBL::IO::Parser::VCF4Tabix->open($vcf_file);
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:  $parser->seek($chrom, $start, $end);
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:  while ($parser->next) {
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:      $parser->get_reference,
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:      $parser->get_alternatives,
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:      $parser->get_raw_info,
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:      $parser->get_seqname,
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:      $parser->get_raw_start,
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:      $parser->get_raw_start,
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:    $end += length($ref) - 1;
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:        # ignore "*"-types
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:          $ref = substr($ref, 1) || '-';
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:            $alt_allele = '-' if $alt_allele eq '';
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:      if(substr($ref, 0, 1) eq substr($alts->[0], 0, 1)) {
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:        $ref = substr($ref, 1) || '-';
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:        $alts->[0] = substr($alts->[0], 1) || '-';
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:      my $ids = $parser->get_raw_IDs;
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:      my $qual = $parser->get_raw_score;
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:      my $filter = $parser->get_raw_filter_results;
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:      $parser->close;
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:  $parser->close;
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:  my $slice = $slice_adaptor->fetch_by_region('chromosome', $chrom);
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:  my $vf = Bio::EnsEMBL::Variation::VariationFeature->new_fast({
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:  my $line = $vf->to_VCF_record();
scripts/remap_gnomad/unique_mapping_results_to_VCF.pl:  my ($vcf_pos, $vcf_ref, $vcf_alt) = ($line->[1], $line->[3], $line->[4]);
scripts/remap_gnomad/rename_trimmed_files.sh:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/rename_trimmed_files.sh:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/rename_trimmed_files.sh:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/README:    - GRCh38 reference genome: https://ftp.ensembl.org/pub/release-95/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.primary_assembly.fa.gz
scripts/remap_gnomad/README:    - Chain file: https://ftp.ensembl.org/pub/assembly_mapping/homo_sapiens/GRCh37_to_GRCh38.chain.gz
scripts/remap_gnomad/trim_gnomad_files.sh:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/trim_gnomad_files.sh:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/trim_gnomad_files.sh:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/trim_gnomad_files.sh:bcftools annotate -x INFO/vep $dir/gnomad.genomes.r2.1.sites.chr${i}.vcf.bgz | bgzip > $dir/gnomad.genomes.r2.1.sites.chr${i}.vcf.gz
scripts/remap_gnomad/run_bgzip_mapping_results.sh:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/run_bgzip_mapping_results.sh:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/run_bgzip_mapping_results.sh:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/run_bgzip_mapping_results.sh:  bsub -J sort_bgzip$i -o $dir/sort_bgzip${i}.out -e $dir/sort_bgzip${i}.err sh bgzip_mapping_results.sh $i $dir
scripts/remap_gnomad/run_trim_gnomad_files.sh:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/run_trim_gnomad_files.sh:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/run_trim_gnomad_files.sh:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/run_trim_gnomad_files.sh:  bsub -J trim_chr${i} -o $dir/trim_reports/trim_chr${i}.out -e $dir/trim_reports/trim_chr${i}.err sh trim_gnomad_files.sh $i $dir
scripts/remap_gnomad/append_to_crossmap_results.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/append_to_crossmap_results.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/append_to_crossmap_results.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/append_to_crossmap_results.pl:my $fh = FileHandle->new("$grch38_ensembl_mappings/$chrom.vcf", 'r');
scripts/remap_gnomad/append_to_crossmap_results.pl:$fh->close;
scripts/remap_gnomad/append_to_crossmap_results.pl:my $cmd = "vcf-sort -t $tmpdir < $vcf_file | bgzip > $vcf_file.gz";
scripts/remap_gnomad/tabix.sh:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/tabix.sh:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/tabix.sh:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/tabix.sh:  bsub -J tabix_chr$i -o $dir/tabix_chr${i}.out -e $dir/tabix_chr${i}.err tabix ${dir}/gnomad.genomes.r2.1.sites.chr${i}_noVEP.vcf.gz
scripts/remap_gnomad/wget_gnomad_files.sh:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/wget_gnomad_files.sh:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/wget_gnomad_files.sh:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/wget_gnomad_files.sh:  bsub -J wget_chr$i -o $dir/wget_chr${i}.out -e $dir/wget_chr${i}.err wget https://storage.googleapis.com/gnomad-public/release/2.1/vcf/genomes/gnomad.genomes.r2.1.sites.chr${i}.vcf.bgz -P $dir
scripts/remap_gnomad/write_unmapped_variants.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/write_unmapped_variants.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/write_unmapped_variants.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/write_unmapped_variants.pl:$registry->load_registry_from_db(
scripts/remap_gnomad/write_unmapped_variants.pl:  -host => 'ensembldb.ensembl.org',
scripts/remap_gnomad/write_unmapped_variants.pl:  -user => 'anonymous',
scripts/remap_gnomad/write_unmapped_variants.pl:  -port => 3337,
scripts/remap_gnomad/write_unmapped_variants.pl:  -db_version => 95
scripts/remap_gnomad/write_unmapped_variants.pl:my $slice_adaptor = $registry->get_adaptor($species, 'core', 'slice');
scripts/remap_gnomad/write_unmapped_variants.pl:my $fh = FileHandle->new("$dir/write_gnomad_genomes_unmapped.txt", 'w');
scripts/remap_gnomad/write_unmapped_variants.pl:  my $parser = Bio::EnsEMBL::IO::Parser::VCF4Tabix->open($vcf_file);
scripts/remap_gnomad/write_unmapped_variants.pl:  my $chrom_slice = $slice_adaptor->fetch_by_region('chromosome', $chrom);
scripts/remap_gnomad/write_unmapped_variants.pl:  my $seq_region_id = $chrom_slice->get_seq_region_id;
scripts/remap_gnomad/write_unmapped_variants.pl:  my $seq_region_start = $chrom_slice->seq_region_start;
scripts/remap_gnomad/write_unmapped_variants.pl:  my $seq_region_end = $chrom_slice->seq_region_end;
scripts/remap_gnomad/write_unmapped_variants.pl:  $parser->seek($chrom, $seq_region_start, $seq_region_end);
scripts/remap_gnomad/write_unmapped_variants.pl:  while ($parser->next) {
scripts/remap_gnomad/write_unmapped_variants.pl:      $parser->get_reference,
scripts/remap_gnomad/write_unmapped_variants.pl:      $parser->get_alternatives,
scripts/remap_gnomad/write_unmapped_variants.pl:      $parser->get_info,
scripts/remap_gnomad/write_unmapped_variants.pl:      $parser->get_seqname,
scripts/remap_gnomad/write_unmapped_variants.pl:      $parser->get_raw_start,
scripts/remap_gnomad/write_unmapped_variants.pl:      $parser->get_raw_start,
scripts/remap_gnomad/write_unmapped_variants.pl:      $parser->get_IDs,
scripts/remap_gnomad/write_unmapped_variants.pl:    $end += length($ref) - 1;
scripts/remap_gnomad/write_unmapped_variants.pl:        # ignore "*"-types
scripts/remap_gnomad/write_unmapped_variants.pl:          $ref = substr($ref, 1) || '-';
scripts/remap_gnomad/write_unmapped_variants.pl:            $alt_allele = '-' if $alt_allele eq '';
scripts/remap_gnomad/write_unmapped_variants.pl:      if(substr($ref, 0, 1) eq substr($alts->[0], 0, 1)) {
scripts/remap_gnomad/write_unmapped_variants.pl:        $ref = substr($ref, 1) || '-';
scripts/remap_gnomad/write_unmapped_variants.pl:        $alts->[0] = substr($alts->[0], 1) || '-';
scripts/remap_gnomad/write_unmapped_variants.pl:  $parser->close;
scripts/remap_gnomad/write_unmapped_variants.pl:$fh->close;
scripts/remap_gnomad/run_cross_map.sh:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/run_cross_map.sh:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/run_cross_map.sh:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/run_cross_map.sh:  bsub -J crossmap_chr${i} -o $log_dir/crossmap_chr${i}.out -e $log_dir/crossmap_chr${i}.err sh cross_map.sh $i $dir
scripts/remap_gnomad/load_unmapped_variation.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/remap_gnomad/load_unmapped_variation.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/remap_gnomad/load_unmapped_variation.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/remap_gnomad/load_unmapped_variation.pl:$registry->load_all($dir . '/remap_gnomad/genomes/ensembl.registry');
scripts/remap_gnomad/load_unmapped_variation.pl:my $dbh = $registry->get_DBAdaptor('human', 'variation')->dbc->db_handle;
scripts/remap_gnomad/load_unmapped_variation.pl:my $fh = FileHandle->new("$dir/write_gnomad_exomes_unmapped.txt", 'r');
scripts/remap_gnomad/load_unmapped_variation.pl:  $dbh->do(qq{
scripts/remap_gnomad/load_unmapped_variation.pl:  }) or die $dbh->errstr;
scripts/remap_gnomad/load_unmapped_variation.pl:$fh->close;
scripts/misc/test_chrom_coverage_in_cache_files.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/test_chrom_coverage_in_cache_files.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/test_chrom_coverage_in_cache_files.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/test_chrom_coverage_in_cache_files.pl:if ($config->{help}) {
scripts/misc/test_chrom_coverage_in_cache_files.pl:if (!$config->{version}) {
scripts/misc/test_chrom_coverage_in_cache_files.pl:  die "Version is missing. Set version with --version.";
scripts/misc/test_chrom_coverage_in_cache_files.pl:my $version = $config->{version};
scripts/misc/test_chrom_coverage_in_cache_files.pl:  'homo_sapiens_merged' => '--merged',
scripts/misc/test_chrom_coverage_in_cache_files.pl:  'homo_sapiens_refseq' => '--refseq',
scripts/misc/test_chrom_coverage_in_cache_files.pl:  if (! $config->{$dir_name}) {
scripts/misc/test_chrom_coverage_in_cache_files.pl:  if (!(-d $config->{$dir_name})) {
scripts/misc/test_chrom_coverage_in_cache_files.pl:    die "$dir_name: ", $config->{$dir_name}, " is not a directory.";
scripts/misc/test_chrom_coverage_in_cache_files.pl:my $script_dir = $config->{script_dir};
scripts/misc/test_chrom_coverage_in_cache_files.pl:die "script_dir is missing file variant_effect_predictor.pl" unless (-f "$script_dir/variant_effect_predictor.pl");
scripts/misc/test_chrom_coverage_in_cache_files.pl:$config->{vep_input} ||= "$script_dir/t/testdata/test_vep_input.txt.gz";
scripts/misc/test_chrom_coverage_in_cache_files.pl:die "vep_input: ", $config->{vep_input}, " is not a file." unless (-f $config->{vep_input});
scripts/misc/test_chrom_coverage_in_cache_files.pl:$config->{cache_dir} ||= $ENV{HOME} . '/.vep';
scripts/misc/test_chrom_coverage_in_cache_files.pl:cleanup($config) unless($config->{no_cleanup});
scripts/misc/test_chrom_coverage_in_cache_files.pl:  my $root_cache_dir = $config->{cache_dir};
scripts/misc/test_chrom_coverage_in_cache_files.pl:      if (!(-d $dir)) {
scripts/misc/test_chrom_coverage_in_cache_files.pl:  my $script_dir = $config->{script_dir};
scripts/misc/test_chrom_coverage_in_cache_files.pl:  my $input = $config->{vep_input};
scripts/misc/test_chrom_coverage_in_cache_files.pl:  my $root_cache_dir = $config->{cache_dir};
scripts/misc/test_chrom_coverage_in_cache_files.pl:  my $version = $config->{version};
scripts/misc/test_chrom_coverage_in_cache_files.pl:      if (-d $dir) {
scripts/misc/test_chrom_coverage_in_cache_files.pl:        my $params = $cache_dirs->{$cache_dir} . " --assembly $assembly";
scripts/misc/test_chrom_coverage_in_cache_files.pl:        $output_files->{$vep_run_name}->{vep_output} = $output;
scripts/misc/test_chrom_coverage_in_cache_files.pl:        $output_files->{$vep_run_name}->{err} = $err_file;
scripts/misc/test_chrom_coverage_in_cache_files.pl:        $output_files->{$vep_run_name}->{out} = $out_file;
scripts/misc/test_chrom_coverage_in_cache_files.pl:        # -cache_version
scripts/misc/test_chrom_coverage_in_cache_files.pl:        my $cmd = "perl $script_dir/variant_effect_predictor.pl --cache_version $version --cache --offline --dir $root_cache_dir -i $input -o $output --force_overwrite --no_stats --regulatory --sift b --polyphen b $params";
scripts/misc/test_chrom_coverage_in_cache_files.pl:  $config->{output_files} = $output_files;
scripts/misc/test_chrom_coverage_in_cache_files.pl:  my $output_files = $config->{output_files};
scripts/misc/test_chrom_coverage_in_cache_files.pl:    my $vep_out_file = $output_files->{$vep_run_name}->{vep_output};
scripts/misc/test_chrom_coverage_in_cache_files.pl:    my $fh = FileHandle->new($vep_out_file, 'r');
scripts/misc/test_chrom_coverage_in_cache_files.pl:      $covered_chroms->{$chrom} = 1;
scripts/misc/test_chrom_coverage_in_cache_files.pl:          $has_annotation->{$annotation} = 1;
scripts/misc/test_chrom_coverage_in_cache_files.pl:    $fh->close();
scripts/misc/test_chrom_coverage_in_cache_files.pl:      if (!$covered_chroms->{$chrom}) {
scripts/misc/test_chrom_coverage_in_cache_files.pl:      if (!$has_annotation->{$annotation}) {
scripts/misc/test_chrom_coverage_in_cache_files.pl:  my $output_files = $config->{output_files};
scripts/misc/test_chrom_coverage_in_cache_files.pl:      my $file = $output_files->{$vep_run_name}->{$file_type};
scripts/misc/test_chrom_coverage_in_cache_files.pl:to the cache file directory (--cache_dir).
scripts/misc/test_chrom_coverage_in_cache_files.pl:bsub -J test_chrom_coverage -o out -e err -R"select[mem>2500] rusage[mem=2500]" -M2500 perl test_chrom_coverage_in_cache_files.pl -version 78 -cache_dir /lustre/scratch110/ensembl/at7/vep/ -script_dir ~/DEV/ensembl-tools/scripts/variant_effect_predictor/
scripts/misc/test_chrom_coverage_in_cache_files.pl:--help       Display this message and quit
scripts/misc/test_chrom_coverage_in_cache_files.pl:--version    Set the version for the new release
scripts/misc/test_chrom_coverage_in_cache_files.pl:--script_dir Location of variant_effect_predictor.pl script
scripts/misc/test_chrom_coverage_in_cache_files.pl:--cache_dir  Cache file directory
scripts/misc/test_chrom_coverage_in_cache_files.pl:--no_cleanup Don't clean up err, out, vep_output files
scripts/misc/hc_reports.php:    Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/hc_reports.php:    Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/hc_reports.php:      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/hc_reports.php:      1- The HTML files should be name like this <specis_or_group>_<ensembl_release>.html or <specis_or_group>_<ensembl_release_<assembly>.html
scripts/misc/hc_reports.php:      2- This PHP file and the HTML files should be stored in the same directory
scripts/misc/hc_reports.php:    https://github.com/Ensembl/ensj-healthcheck/blob/master/healthcheck_txt2html.pl
scripts/misc/hc_reports.php:      <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css">
scripts/misc/hc_reports.php:        $label_array[0] = $label_array[1].' -';
scripts/misc/hc_reports.php:  <div style="padding:2px 6px;background-color:#000">
scripts/misc/hc_reports.php:    <div class="glyphicon glyphicon glyphicon-list" style="float:left;color:#FFF;padding:6px 8px 6px 2px;font-size:18px"></div>
scripts/misc/hc_reports.php:    <div style="float:left;padding:6px 0px;margin-left:10px">
scripts/misc/hc_reports.php:      <form style="margin-bottom:0px">
scripts/misc/hc_reports.php:  echo "<option value=\"\">-</option>";
scripts/misc/hc_reports.php:      echo "<h4><span class=\"glyphicon glyphicon-chevron-right\"></span> Release <b>$version</b></h4>";
scripts/misc/hc_reports.php:        if (preg_match("/^$version\s-\s(\w+\s*\w+)$/",$report_label,$matches2)) {
scripts/misc/generate_configuration_file.pl:$config->{user} ||= 'ensro';
scripts/misc/generate_configuration_file.pl:$config->{port} ||= 3306;
scripts/misc/generate_configuration_file.pl:die 'Argument \'host\' is missing' unless ($config->{host});
scripts/misc/generate_configuration_file.pl:die 'Argument \'save_config_file\' is missing' unless ($config->{save_config_file});
scripts/misc/generate_configuration_file.pl:		'1000GENOMES:phase_1_AFR'   => '1000GENOMES-phase_1_AFR',
scripts/misc/generate_configuration_file.pl:		'1000GENOMES:phase_1_AMR'   => '1000GENOMES-phase_1_AMR',
scripts/misc/generate_configuration_file.pl:		'1000GENOMES:phase_1_ASN'   => '1000GENOMES-phase_1_ASN',
scripts/misc/generate_configuration_file.pl:		'1000GENOMES:phase_1_EUR'   => '1000GENOMES-phase_1_EUR',
scripts/misc/generate_configuration_file.pl:		'CSHL-HAPMAP:HAPMAP-ASW'    => 'CSHL-HAPMAP-HAPMAP-ASW',
scripts/misc/generate_configuration_file.pl:		'CSHL-HAPMAP:HAPMAP-CHB'    => 'CSHL-HAPMAP-HAPMAP-CHB',
scripts/misc/generate_configuration_file.pl:		'CSHL-HAPMAP:HAPMAP-CHD'    => 'CSHL-HAPMAP-HAPMAP-CHD',
scripts/misc/generate_configuration_file.pl:		'CSHL-HAPMAP:HAPMAP-GIH'    => 'CSHL-HAPMAP-HAPMAP-GIH',
scripts/misc/generate_configuration_file.pl:		'CSHL-HAPMAP:HAPMAP-LWK'    => 'CSHL-HAPMAP-HAPMAP-LWK',
scripts/misc/generate_configuration_file.pl:		'CSHL-HAPMAP:HAPMAP-MEX'    => 'CSHL-HAPMAP-HAPMAP-MEX',
scripts/misc/generate_configuration_file.pl:		'CSHL-HAPMAP:HAPMAP-MKK'    => 'CSHL-HAPMAP-HAPMAP-MKK',
scripts/misc/generate_configuration_file.pl:		'CSHL-HAPMAP:HAPMAP-TSI'    => 'CSHL-HAPMAP-HAPMAP-TSI',
scripts/misc/generate_configuration_file.pl:		'CSHL-HAPMAP:HapMap-CEU'    => 'CSHL-HAPMAP-HapMap-CEU',
scripts/misc/generate_configuration_file.pl:		'CSHL-HAPMAP:HapMap-HCB'    => 'CSHL-HAPMAP-HapMap-HCB',
scripts/misc/generate_configuration_file.pl:		'CSHL-HAPMAP:HapMap-JPT'    => 'CSHL-HAPMAP-HapMap-JPT',
scripts/misc/generate_configuration_file.pl:		'CSHL-HAPMAP:HapMap-YRI'    => 'CSHL-HAPMAP-HapMap-YRI',
scripts/misc/generate_configuration_file.pl:		'ESP6500:African_American'  => 'ESP6500-African_American',
scripts/misc/generate_configuration_file.pl:		'ESP6500:European_American' => 'ESP6500-European_American',
scripts/misc/generate_configuration_file.pl:		'all phenotype-associated variants' => 'phenotype_associated',
scripts/misc/generate_configuration_file.pl:if ($config->{debug}) {
scripts/misc/generate_configuration_file.pl:	my $all_species = $config->{species};
scripts/misc/generate_configuration_file.pl:	my $species = $config->{species};
scripts/misc/generate_configuration_file.pl:		if ($species_with_aa->{$species}) {
scripts/misc/generate_configuration_file.pl:		if ($species_with_sift_predictions->{$species}) {
scripts/misc/generate_configuration_file.pl:			$dump_configuration->{$species}->{individuals} = $individuals->{$species};
scripts/misc/generate_configuration_file.pl:			$dump_configuration->{$species}->{populations} = $populations->{$species};
scripts/misc/generate_configuration_file.pl:			$dump_configuration->{$species}->{sets} = $sets->{$species};
scripts/misc/generate_configuration_file.pl:			$dump_configuration->{$species}->{$types->{SOMATIC}} = $parameter . ',somatic';
scripts/misc/generate_configuration_file.pl:			$dump_configuration->{$species}->{$types->{SOMATIC_INC_CONS}} = $protein_function_prediction . ',somatic';
scripts/misc/generate_configuration_file.pl:		$dump_configuration->{$species}->{$types->{GENERIC}} = $parameter; 
scripts/misc/generate_configuration_file.pl:		$dump_configuration->{$species}->{$types->{INC_CONS}} = $protein_function_prediction;
scripts/misc/generate_configuration_file.pl:		$dump_configuration->{$species}->{$types->{FAILED}} = 'failed'; 
scripts/misc/generate_configuration_file.pl:		if ($species_with_svs_data->{$species}) {
scripts/misc/generate_configuration_file.pl:			$dump_configuration->{$species}->{$types->{SVS}} = 'structural_variations';
scripts/misc/generate_configuration_file.pl:	my $fh_config = FileHandle->new($config->{save_config_file}, 'w');
scripts/misc/generate_configuration_file.pl:	my $json = JSON->new->allow_nonref;
scripts/misc/generate_configuration_file.pl:	print $fh_config $json->encode($dump_configuration);
scripts/misc/generate_configuration_file.pl:	$fh_config->close();
scripts/misc/generate_configuration_file.pl:	if ($config->{db_name}) {
scripts/misc/generate_configuration_file.pl:		foreach my $db_name (split(',', $config->{db_name})) {
scripts/misc/generate_configuration_file.pl:			if ($config->{version}) {
scripts/misc/generate_configuration_file.pl:				my $version = $config->{version};
scripts/misc/generate_configuration_file.pl:					$db_name_2_species_name->{$db_name} = get_species_name($db_name);
scripts/misc/generate_configuration_file.pl:				$db_name_2_species_name->{$db_name} = get_species_name($db_name);
scripts/misc/generate_configuration_file.pl:		my $user = $config->{user};
scripts/misc/generate_configuration_file.pl:		my $port = $config->{port};
scripts/misc/generate_configuration_file.pl:		foreach my $host (split(',', $config->{host})) {
scripts/misc/generate_configuration_file.pl:			my $dbc = DBI->connect("DBI:mysql:host=$host;port=$port;user=$user", {RaiseError => 1});
scripts/misc/generate_configuration_file.pl:			my $sth = $dbc->prepare(qq{show databases like '%variation%'});
scripts/misc/generate_configuration_file.pl:			$sth->execute();
scripts/misc/generate_configuration_file.pl:			$sth->bind_columns(\$db);
scripts/misc/generate_configuration_file.pl:			while ($sth->fetch) {
scripts/misc/generate_configuration_file.pl:					if ($config->{version}) {
scripts/misc/generate_configuration_file.pl:						my $version = $config->{version};
scripts/misc/generate_configuration_file.pl:							$db_name_2_species_name->{$db} = get_species_name($db);
scripts/misc/generate_configuration_file.pl:						$db_name_2_species_name->{$db} = get_species_name($db);
scripts/misc/generate_configuration_file.pl:			$sth->finish();
scripts/misc/generate_configuration_file.pl:	$config->{db2species} = $db_name_2_species_name;
scripts/misc/generate_configuration_file.pl:	$config->{species} = \%species;
scripts/misc/generate_configuration_file.pl:	my $hosts = $config->{host};
scripts/misc/generate_configuration_file.pl:	my $user = $config->{user};
scripts/misc/generate_configuration_file.pl:	my $port = $config->{port};
scripts/misc/generate_configuration_file.pl:		foreach my $db_name (keys %{$config->{db2species}})	 {
scripts/misc/generate_configuration_file.pl:			my $dbc = DBI->connect("DBI:mysql:database=$db_name;host=$host;port=$port;user=$user", {RaiseError => 1});
scripts/misc/generate_configuration_file.pl:			my $sth = $dbc->prepare($query);
scripts/misc/generate_configuration_file.pl:			$sth->execute();
scripts/misc/generate_configuration_file.pl:			while (my @row = $sth->fetchrow_array) {
scripts/misc/generate_configuration_file.pl:					my $species_name = $config->{db2species}->{$db_name};
scripts/misc/generate_configuration_file.pl:					$species_names->{$species_name} = 1;				
scripts/misc/generate_configuration_file.pl:			$sth->finish();
scripts/misc/generate_clin_significance_tables.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/generate_clin_significance_tables.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/generate_clin_significance_tables.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/generate_clin_significance_tables.pl:$registry->load_registry_from_db(
scripts/misc/generate_clin_significance_tables.pl:    -host => $host,
scripts/misc/generate_clin_significance_tables.pl:    -port => $port,
scripts/misc/generate_clin_significance_tables.pl:    -user => 'ensro',
scripts/misc/generate_clin_significance_tables.pl:    -db_version => $db_version,
scripts/misc/generate_clin_significance_tables.pl:my $vdb = $registry->get_DBAdaptor($species,'variation');
scripts/misc/generate_clin_significance_tables.pl:my $dbVar = $vdb->dbc->db_handle;
scripts/misc/generate_clin_significance_tables.pl:my $border_left = qq{ style="border-left:1px solid #BBB"};
scripts/misc/generate_clin_significance_tables.pl:  my $sth = $dbVar->prepare($type_stmt);
scripts/misc/generate_clin_significance_tables.pl:  $sth->execute();
scripts/misc/generate_clin_significance_tables.pl:  while (my ($vals) = $sth->fetchrow_array()){
scripts/misc/generate_clin_significance_tables.pl:  $sth->finish;
scripts/misc/generate_clin_significance_tables.pl:     $icon_label =~ s/ /-/g;
scripts/misc/generate_clin_significance_tables.pl:  my $icon_col = qq{<td style="text-align:center"><img src="$icon_path$icon_label.png" title="$cs_term"/></td>};
scripts/misc/generate_clin_significance_tables.pl:# Four-star rating
scripts/misc/generate_clin_significance_tables.pl:    $stars .= qq{<img style="vertical-align:top" src="/i/val/$star_color\_star.png" alt="$star_color"/>};
scripts/misc/generate_clin_significance_tables.pl:<p>We use the <a href="http://www.ncbi.nlm.nih.gov/clinvar/docs/details/#interpretation">ClinVar "four-star" rating</a> system to indicate the quality of classification/validation of the variant:</p>
scripts/misc/generate_clin_significance_tables.pl:  my $sth = $dbVar->prepare($stmt);
scripts/misc/generate_clin_significance_tables.pl:  $sth->execute($value);
scripts/misc/generate_clin_significance_tables.pl:  return $sth->fetchrow_array;
scripts/misc/generate_clin_significance_tables.pl:  my $var = (execute_stmt_one_result($data->{'query'}->[$order],$value))[0];
scripts/misc/generate_clin_significance_tables.pl:  my $example = (defined($var)) ? sprintf (qq{<a href="%s%s">%s</a>},$data->{'link'}->[$order],$var,$var) : '-';
scripts/misc/generate_clin_significance_tables.pl:  Update the clinical significance tables in "data_description.html" (under public-plugins/ensembl/htdocs/info/genome/variation/).
scripts/misc/generate_clin_significance_tables.pl:    -help           Print this message
scripts/misc/generate_clin_significance_tables.pl:    -v              Ensembl version, e.g. 65 (Required)
scripts/misc/generate_clin_significance_tables.pl:    -o              An HTML output file name (Required)
scripts/misc/generate_clin_significance_tables.pl:    -host           Host of the human database (Required)
scripts/misc/generate_clin_significance_tables.pl:    -port           Human database port (Required)
scripts/misc/generate_clin_significance_tables.pl:    -species        Species name (Required)
scripts/misc/generate_vep_examples.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/generate_vep_examples.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/generate_vep_examples.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/generate_vep_examples.pl:die "Error: provide the Ensembl version with option '-v'\n" if !$version;
scripts/misc/generate_vep_examples.pl:  $reg->load_all($registry);
scripts/misc/generate_vep_examples.pl:  $reg->load_registry_from_db(
scripts/misc/generate_vep_examples.pl:    -host       => $host,
scripts/misc/generate_vep_examples.pl:    -user       => $user,
scripts/misc/generate_vep_examples.pl:    -pass       => $pass,
scripts/misc/generate_vep_examples.pl:    -port       => $port,
scripts/misc/generate_vep_examples.pl:    -db_version => $version,
scripts/misc/generate_vep_examples.pl:    -species    => $chosen_species
scripts/misc/generate_vep_examples.pl:my @all_species = sort @{$reg->get_all_species()};
scripts/misc/generate_vep_examples.pl:  my $sa = $reg->get_adaptor($species, 'core', 'slice');
scripts/misc/generate_vep_examples.pl:  my $ta = $reg->get_adaptor($species, 'core', 'transcript');
scripts/misc/generate_vep_examples.pl:  my ($highest_cs) = @{$reg->get_adaptor($species, 'core', 'coordsystem')->fetch_all()};
scripts/misc/generate_vep_examples.pl:  my $assembly = $highest_cs->version();
scripts/misc/generate_vep_examples.pl:  my $vfa = Bio::EnsEMBL::Variation::DBSQL::VariationFeatureAdaptor->new_fake($species);
scripts/misc/generate_vep_examples.pl:  my $real_vfa = $reg->get_adaptor($species, 'variation', 'variationfeature');
scripts/misc/generate_vep_examples.pl:  my $div_bacteria = $sa->dbc->dbname() =~ /^bacteria.*/ ? 1 : 0;
scripts/misc/generate_vep_examples.pl:    my $sth = $real_vfa->db->dbc->prepare(qq{
scripts/misc/generate_vep_examples.pl:      $sth->execute('%'.$type.'%');
scripts/misc/generate_vep_examples.pl:      $sth->bind_columns(\$name);
scripts/misc/generate_vep_examples.pl:      $sth->fetch();
scripts/misc/generate_vep_examples.pl:    $sth->finish(); 
scripts/misc/generate_vep_examples.pl:    $files{$format} = FileHandle->new;
scripts/misc/generate_vep_examples.pl:    $files{$format}->open('>'.$fn) or die("ERROR: Could not open file $fn\n");
scripts/misc/generate_vep_examples.pl:    $b->seq_region_name =~ /^[\d+]$/ <=> $a->seq_region_name =~ /^[\d+]$/ ||
scripts/misc/generate_vep_examples.pl:    $b->seq_region_name =~ /^[MXY+]$/ <=> $a->seq_region_name =~ /^[MXY+]$/ ||
scripts/misc/generate_vep_examples.pl:    $b->length <=> $a->length} @{$sa->fetch_all('toplevel')
scripts/misc/generate_vep_examples.pl:  # b) VariationFeature with seq_region_start/end defined for non-bacteria species returning different results than with them left out
scripts/misc/generate_vep_examples.pl:    my $pos_snp = $tr->coding_region_start + 3;
scripts/misc/generate_vep_examples.pl:    my $sub_slice_snp = $slice->sub_Slice($pos_snp, $pos_snp);
scripts/misc/generate_vep_examples.pl:    my $ref_seq_snp = $sub_slice_snp->seq;
scripts/misc/generate_vep_examples.pl:    my $tmp_vf_snp = Bio::EnsEMBL::Variation::VariationFeature->new_fast({
scripts/misc/generate_vep_examples.pl:      seq_region_start => $slice->seq_region_start,
scripts/misc/generate_vep_examples.pl:      seq_region_end   => $slice->seq_region_end
scripts/misc/generate_vep_examples.pl:    my $pos_fs = $tr->coding_region_start + 3;
scripts/misc/generate_vep_examples.pl:    my $sub_slice_fs = $slice->sub_Slice($pos_fs, $pos_fs);
scripts/misc/generate_vep_examples.pl:    my $ref_seq_fs = $sub_slice_fs->seq;
scripts/misc/generate_vep_examples.pl:    my $tmp_vf_fs = Bio::EnsEMBL::Variation::VariationFeature->new_fast({
scripts/misc/generate_vep_examples.pl:      allele_string  => $ref_seq_fs.'/-',
scripts/misc/generate_vep_examples.pl:      seq_region_start => $slice->seq_region_start,
scripts/misc/generate_vep_examples.pl:      seq_region_end   => $slice->seq_region_end
scripts/misc/generate_vep_examples.pl:  my $pos = $tr->coding_region_start + 3;
scripts/misc/generate_vep_examples.pl:  my $sub_slice = $slice->sub_Slice($pos, $pos);
scripts/misc/generate_vep_examples.pl:  my $ref_seq = $sub_slice->seq;
scripts/misc/generate_vep_examples.pl:    $tmp_vf = Bio::EnsEMBL::Variation::VariationFeature->new_fast({
scripts/misc/generate_vep_examples.pl:    $con = join ",", @{$tmp_vf->consequence_type};
scripts/misc/generate_vep_examples.pl:    # printf("%s %s %i %i %s\/%s 1\n", $species, $slice->seq_region_name, $pos, $pos, $ref_seq, $alt);
scripts/misc/generate_vep_examples.pl:  my @introns = @{$tr->get_all_Introns};
scripts/misc/generate_vep_examples.pl:    $pos = $intron->start + 15;
scripts/misc/generate_vep_examples.pl:    $sub_slice = $slice->sub_Slice($pos, $pos);
scripts/misc/generate_vep_examples.pl:    $ref_seq = $sub_slice->seq;
scripts/misc/generate_vep_examples.pl:    $tmp_vf = Bio::EnsEMBL::Variation::VariationFeature->new_fast({
scripts/misc/generate_vep_examples.pl:    $con = join ",", @{$tmp_vf->consequence_type};
scripts/misc/generate_vep_examples.pl:    # printf("%s %s %i %i %s\/%s 1\n", $species, $slice->seq_region_name, $pos, $pos, $ref_seq, $alt);
scripts/misc/generate_vep_examples.pl:  $pos = $tr->coding_region_start + 3;
scripts/misc/generate_vep_examples.pl:    $sub_slice = $slice->sub_Slice($pos, $pos);
scripts/misc/generate_vep_examples.pl:    $ref_seq = $sub_slice->seq;
scripts/misc/generate_vep_examples.pl:    $tmp_vf = Bio::EnsEMBL::Variation::VariationFeature->new_fast({
scripts/misc/generate_vep_examples.pl:      allele_string  => $ref_seq.'/-',
scripts/misc/generate_vep_examples.pl:    $con = join ",", @{$tmp_vf->consequence_type};
scripts/misc/generate_vep_examples.pl:    # printf("%s %s %i %i %s\/%s 1\n", $species, $slice->seq_region_name, $pos, $pos, $ref_seq, '-');
scripts/misc/generate_vep_examples.pl:    print OUT sprintf("%-17s = %s\n", $key, join('\n', @values));
scripts/misc/generate_vep_examples.pl:    my $file = $files->{$format};
scripts/misc/generate_vep_examples.pl:    push @{$web_data->{"VEP_".uc($format)}}, join(" ", @ret);
scripts/misc/generate_vep_examples.pl:    $biotype = $tr->biotype;
scripts/misc/generate_vep_examples.pl:    $strand = $tr->seq_region_strand;
scripts/misc/generate_vep_examples.pl:    $crs = $tr->coding_region_start;
scripts/misc/generate_vep_examples.pl:    $intron_count = ($div_bacteria == 1 ? 1 : scalar @{$tr->get_all_Introns});
scripts/misc/generate_vep_examples.pl:  print STDERR "Chose transcript ".$tr->stable_id."\n";
scripts/misc/generate_vep_examples.pl:  my $ta = $slices->[0]->adaptor->db->get_TranscriptAdaptor;
scripts/misc/generate_vep_examples.pl:    $trs = $ta->fetch_all_by_Slice($slice);
scripts/misc/generate_vep_examples.pl:  print STDERR "Chose slice ".$slice->seq_region_name."\n";
scripts/misc/generate_vep_examples.pl:    $vf->{chr} || $vf->seq_region_name,
scripts/misc/generate_vep_examples.pl:    $vf->start,
scripts/misc/generate_vep_examples.pl:    $vf->end,
scripts/misc/generate_vep_examples.pl:    $vf->allele_string,
scripts/misc/generate_vep_examples.pl:    $vf->strand,
scripts/misc/generate_vep_examples.pl:    $vf->variation_name
scripts/misc/generate_vep_examples.pl:  my @alleles = split /\//, $vf->allele_string;
scripts/misc/generate_vep_examples.pl:    $allele =~ s/\-//g;
scripts/misc/generate_vep_examples.pl:    if($vf->allele_string =~ /\-/) {
scripts/misc/generate_vep_examples.pl:      if($alleles[0] eq '-') {
scripts/misc/generate_vep_examples.pl:          $alleles[$i] =~ s/\-//g;
scripts/misc/generate_vep_examples.pl:        @alleles = grep {$_ ne '-'} @alleles;
scripts/misc/generate_vep_examples.pl:          $alleles[$i] =~ s/\-//g;
scripts/misc/generate_vep_examples.pl:          $alleles[$i] = '-'.$alleles[$i];
scripts/misc/generate_vep_examples.pl:      @alleles = grep {$_ ne '-' && $_ ne '+'} @alleles;
scripts/misc/generate_vep_examples.pl:        $vf->{chr} || $vf->seq_region_name,
scripts/misc/generate_vep_examples.pl:        $vf->start - 1,
scripts/misc/generate_vep_examples.pl:      warn "WARNING: Unable to convert variant to pileup format on line number ", $config->{line_number} unless defined($config->{quiet});
scripts/misc/generate_vep_examples.pl:      $vf->{chr} || $vf->seq_region_name,
scripts/misc/generate_vep_examples.pl:      $vf->start,
scripts/misc/generate_vep_examples.pl:  # $vf->{slice} ||= get_slice($config, $vf->{chr}, undef, 1);
scripts/misc/generate_vep_examples.pl:  my $tvs = $vf->get_all_TranscriptVariations;
scripts/misc/generate_vep_examples.pl:  my @return;# = values %{$vf->get_all_hgvs_notations()};
scripts/misc/generate_vep_examples.pl:    push @return, map {values %{$vf->get_all_hgvs_notations($_->transcript, 'c')}} @$tvs;
scripts/misc/generate_vep_examples.pl:    # push @return, map {values %{$vf->get_all_hgvs_notations($_->transcript, 'p')}} @$tvs;
scripts/misc/generate_vep_examples.pl:  if($vf->isa('Bio::EnsEMBL::Variation::VariationFeature')) {
scripts/misc/generate_vep_examples.pl:    my @alleles = split /\//, $vf->allele_string;
scripts/misc/generate_vep_examples.pl:    map {reverse_comp(\$_)} @alleles if $vf->strand < 0;
scripts/misc/generate_vep_examples.pl:      $allele =~ s/\-//g;
scripts/misc/generate_vep_examples.pl:      if(defined($vf->slice)) {
scripts/misc/generate_vep_examples.pl:        my $slice = $vf->slice->sub_Slice($vf->start - 1, $vf->start - 1);
scripts/misc/generate_vep_examples.pl:        $prev_base = $slice->seq if defined($slice);
scripts/misc/generate_vep_examples.pl:        $alleles[$i] =~ s/\-//g;
scripts/misc/generate_vep_examples.pl:        $vf->{chr} || $vf->seq_region_name,
scripts/misc/generate_vep_examples.pl:        $vf->start - 1,
scripts/misc/generate_vep_examples.pl:        $vf->variation_name || '.',
scripts/misc/generate_vep_examples.pl:        $vf->{chr} || $vf->seq_region_name,
scripts/misc/generate_vep_examples.pl:        $vf->start,
scripts/misc/generate_vep_examples.pl:        $vf->variation_name || '.',
scripts/misc/generate_vep_examples.pl:    my $alt = '<'.($terms{$vf->class_SO_term} || $vf->class_SO_term).'>';
scripts/misc/generate_vep_examples.pl:      $vf->{chr} || $vf->seq_region_name,
scripts/misc/generate_vep_examples.pl:      $vf->start,
scripts/misc/generate_vep_examples.pl:      $vf->variation_name || '.',
scripts/misc/generate_vep_examples.pl:  my $tvs = $vf->get_all_TranscriptVariations;
scripts/misc/generate_vep_examples.pl:    push @return, map {values %{$vf->spdi_genomic()}} @$tvs;
scripts/misc/generate_vep_examples.pl:  my $mca = $reg->get_adaptor($species, 'core', 'MetaContainer');
scripts/misc/generate_vep_examples.pl:    $mca->delete_key($meta_key);
scripts/misc/generate_vep_examples.pl:    $mca->store_key_value($meta_key, $meta_value);
scripts/misc/generate_vep_examples.pl:  Usage: perl generate_vep_examples.pl -v [VERSION] [OPTIONS]
scripts/misc/generate_vep_examples.pl:    -v            Ensembl version, e.g. 108 (Required)
scripts/misc/generate_vep_examples.pl:    -dir          Directory where to write output (default: current directory)
scripts/misc/generate_vep_examples.pl:    -write_to_db  Write generated VEP examples to 'meta' table from the core
scripts/misc/generate_vep_examples.pl:    -formats      Comma-separated list of formats to output; prints all formats
scripts/misc/generate_vep_examples.pl:    -species      Filter by species (deafult: uses all species in database)
scripts/misc/generate_vep_examples.pl:    -help         Print this message
scripts/misc/generate_vep_examples.pl:    -registry     Registry file
scripts/misc/generate_vep_examples.pl:  Load database from parameters (ignored when using -registry):
scripts/misc/generate_vep_examples.pl:    -host         Host
scripts/misc/generate_vep_examples.pl:    -port         Port number
scripts/misc/generate_vep_examples.pl:    -user         MySQL user name
scripts/misc/generate_vep_examples.pl:    -pass         MySQL password
scripts/misc/allele_flipper.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/allele_flipper.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/allele_flipper.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/allele_flipper.pl:	# get sequence-y bits
scripts/misc/allele_flipper.pl:	while($_ =~ m/([ACGTN-]+)/g) {
scripts/misc/healthchecks.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/healthchecks.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/healthchecks.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/healthchecks.pl:    my $dbh = DBI->connect( "dbi:mysql:$db_name\:$host\:$port", $user, undef, undef) ||die "Failed to connect to $db_name\n";
scripts/misc/healthchecks.pl:    my $var_ext_sth  = $dbh->prepare(qq[ select variation_id 
scripts/misc/healthchecks.pl:    my $varf_ext_sth = $dbh->prepare(qq[ select variation_id, variation_feature_id 
scripts/misc/healthchecks.pl:    my $trv_ext_sth  = $dbh->prepare(qq[ select variation_feature_id 
scripts/misc/healthchecks.pl:    my $varf_check_sth = $dbh->prepare(qq[ select variation_feature_id, $column from variation_feature where variation_id = ?]);
scripts/misc/healthchecks.pl:    my $trv_check_sth  = $dbh->prepare(qq[ select $column from transcript_variation where variation_feature_id = ?]);
scripts/misc/healthchecks.pl:    $var_ext_sth->execute()||die;
scripts/misc/healthchecks.pl:    my $var = $var_ext_sth->fetchall_arrayref();
scripts/misc/healthchecks.pl:      $variation{$l->[0]} = 1;
scripts/misc/healthchecks.pl:    $varf_ext_sth->execute()||die;
scripts/misc/healthchecks.pl:    my $varf = $varf_ext_sth->fetchall_arrayref();
scripts/misc/healthchecks.pl:      print "$db_name variation_feature.$column different to variation.$column : $l->[0]\n" 
scripts/misc/healthchecks.pl:        unless defined $variation{$l->[0]};
scripts/misc/healthchecks.pl:      $checked_var{$l->[0]} = 1;
scripts/misc/healthchecks.pl:      $variation_feature{$l->[1]} = 1;
scripts/misc/healthchecks.pl:      ## already checked - skip
scripts/misc/healthchecks.pl:      $varf_check_sth->execute($var);
scripts/misc/healthchecks.pl:      my $unchecked_var = $varf_check_sth->fetchall_arrayref();
scripts/misc/healthchecks.pl:        if defined $unchecked_var->[0]->[0];
scripts/misc/healthchecks.pl:    $trv_ext_sth->execute()||die;
scripts/misc/healthchecks.pl:    my $trv = $trv_ext_sth->fetchall_arrayref();
scripts/misc/healthchecks.pl:      print "$db_name transcript_variation.$column different to variation_feature.$column : $l->[0]\n" 
scripts/misc/healthchecks.pl:        unless defined $variation_feature{$l->[0]};
scripts/misc/healthchecks.pl:      $checked_varf{$l->[0]} = 1;
scripts/misc/healthchecks.pl:      ## already checked - skip
scripts/misc/healthchecks.pl:      $trv_check_sth->execute($varf);
scripts/misc/healthchecks.pl:      my $unchecked_varf = $trv_check_sth->fetchall_arrayref();
scripts/misc/healthchecks.pl:        if defined $unchecked_varf->[0]->[0];
scripts/misc/healthchecks.pl:    my $dbh = DBI->connect("dbi:mysql:information_schema:$host:$port", $user, undef, undef) || die "Failed to look up available databases\n";
scripts/misc/healthchecks.pl:    my $db_ext_sth = $dbh->prepare(qq[ show databases like '%variation%']);
scripts/misc/healthchecks.pl:    $db_ext_sth->execute()||die;
scripts/misc/healthchecks.pl:    my $db_list = $db_ext_sth->fetchall_arrayref();
scripts/misc/healthchecks.pl:        next if $l->[0] =~/master/;
scripts/misc/healthchecks.pl:        push @databases, $l->[0] ;
scripts/misc/healthchecks.pl:  die "\n\thealthchecks.pl -host [host] 
scripts/misc/healthchecks.pl:                        -user [read-user name] 
scripts/misc/healthchecks.pl:                        -mode [display|somatic|both]\n
scripts/misc/healthchecks.pl:\t\tOptions: -db [database name]    default: all variation databases on the host
scripts/misc/create_config_consts.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/create_config_consts.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/create_config_consts.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/create_config_consts.pl:    print "Usage: $0 --config <module> --help > Constants.pm\n";
scripts/misc/create_config_consts.pl:    $config->import(qw(
scripts/misc/create_config_consts.pl:    my $type_code = delete $attrib_type->{code} or die "code required for attrib_type";
scripts/misc/create_config_consts.pl:    next if $to_export->{attrib_types}->{$const};
scripts/misc/create_config_consts.pl:    $to_export->{attrib_types}->{$const} = 1;
scripts/misc/create_config_consts.pl:    my $term = $class_set->{SO_term};
scripts/misc/create_config_consts.pl:    next if $to_export->{SO_class_terms}->{$const};
scripts/misc/create_config_consts.pl:    $to_export->{SO_class_terms}->{$const} = 1;
scripts/misc/create_config_consts.pl:    delete $class_set->{SO_term};
scripts/misc/create_config_consts.pl:    $class_set->{display_term} ||= $term;
scripts/misc/create_config_consts.pl:    my $display_term = $class_set->{display_term};
scripts/misc/create_config_consts.pl:    if ($display_term =~ /^[A-Z][a-z]+/) {
scripts/misc/create_config_consts.pl:    $class_set->{somatic_display_term} ||= 'somatic '.$display_term;
scripts/misc/create_config_consts.pl:    my $term = $cons_set->{SO_term};
scripts/misc/create_config_consts.pl:    $cons_set->{rank} ||= '999';
scripts/misc/create_config_consts.pl:    $code .= "use constant $const => '$term';\n" unless $to_export->{SO_consequence_terms}->{$const} || $to_export->{SO_class_terms}->{$const};
scripts/misc/create_config_consts.pl:    $to_export->{SO_consequence_terms}->{$const} = 1;
scripts/misc/create_config_consts.pl:    if ($cons_set->{is_default}) {
scripts/misc/create_config_consts.pl:        $default_consequence_code = "our \$DEFAULT_OVERLAP_CONSEQUENCE = $OVERLAP_CONSEQUENCE_CLASS->new_fast(".Dumper($cons_set).");\n";
scripts/misc/create_config_consts.pl:        $cons_code .= "'$term' => $OVERLAP_CONSEQUENCE_CLASS->new_fast(".Dumper($cons_set)."),\n";
scripts/misc/create_config_consts.pl:    for my $export (keys %{ $to_export->{$type} }) {
scripts/misc/create_config_consts.pl:        $all_to_export->{$export} = 1;
scripts/misc/create_config_consts.pl:    $hdr .= "$key => [qw(".(join ' ', keys %{ $to_export->{$key} }).")], "
scripts/misc/update_web_vep_plugins_documentation.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/update_web_vep_plugins_documentation.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/update_web_vep_plugins_documentation.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/update_web_vep_plugins_documentation.pl:usage("Ensembl release version must be specified (-version)") unless ($version);
scripts/misc/update_web_vep_plugins_documentation.pl:usage("Path to the VEP_plugins directory must be specified (-git_dir)") unless ($git_dir);
scripts/misc/update_web_vep_plugins_documentation.pl:usage("VEP plugin documentation input file must be specified (-i)") unless ($input_file);
scripts/misc/update_web_vep_plugins_documentation.pl:usage("Output file must be specified (-o)") unless ($output_file);
scripts/misc/update_web_vep_plugins_documentation.pl:  'LoFtool' => 'Loss-of-function',
scripts/misc/update_web_vep_plugins_documentation.pl:        <th style="max-width:50%">Description</th>
scripts/misc/update_web_vep_plugins_documentation.pl:    '<tr class="%s plugin_row" data-category="%s">'.
scripts/misc/update_web_vep_plugins_documentation.pl:    '<td><div style="font-weight:bold"><a rel="external" href="%s">%s</a></div>%s</td>'.
scripts/misc/update_web_vep_plugins_documentation.pl:    '<td><div class="vdoc_dtype_count" style="float:left;padding:2px 6px;cursor:default;background-color:%s">%s</div></td>'.
scripts/misc/update_web_vep_plugins_documentation.pl:    ($plugin_extended_names{$plugin_name}) ? '<div style="margin-top:6px"><small>'.$plugin_extended_names{$plugin_name}.'</small></div>' : '',
scripts/misc/update_web_vep_plugins_documentation.pl:    ($data{$file}{'libs'} && scalar(keys(%{$data{$file}{'libs'}})) != 0) ? ((scalar(keys(%{$data{$file}{'libs'}})) > 1) ? '<ul style="padding-left:1em"><li>'.join('</li><li>',values(%{$data{$file}{'libs'}})).'</li></ul>' : (values(%{$data{$file}{'libs'}}))[0]) : '-',
scripts/misc/update_web_vep_plugins_documentation.pl:    scalar(@{$data{$file}{'developer'}}) > 1 ? '<ul style="padding-left:1em"><li>'.join("</li><li>",@{$data{$file}{'developer'}})."</li></ul>" : $data{$file}{'developer'}->[0]
scripts/misc/update_web_vep_plugins_documentation.pl:    <span style="padding-right:8px">Select categories:</span>
scripts/misc/update_web_vep_plugins_documentation.pl:`rm -f $tmp_file`;
scripts/misc/update_web_vep_plugins_documentation.pl:          @developer = ("Ensembl") if ($line =~ /Copyright\s+.+\s+EMBL-European\s+Bioinformatics\s+Institute/);
scripts/misc/update_web_vep_plugins_documentation.pl:            if ($line =~ /^\s*\.\/(filter|vep)/ || $line =~ /^\s*--plugin/) {
scripts/misc/update_web_vep_plugins_documentation.pl:  my $anchor = "<!-- $section - $type -->";
scripts/misc/update_web_vep_plugins_documentation.pl:  my $line = `grep -m1 -n '$anchor' $tmp_file`;
scripts/misc/update_web_vep_plugins_documentation.pl:    $content = `head -n$line_number $tmp_file`;
scripts/misc/update_web_vep_plugins_documentation.pl:    my $lines_count = (split(' ',`wc -l $tmp_file`))[0];
scripts/misc/update_web_vep_plugins_documentation.pl:    $line_number = $lines_count - $line_number + 1;
scripts/misc/update_web_vep_plugins_documentation.pl:    $content = `tail -n$line_number $tmp_file`;
scripts/misc/update_web_vep_plugins_documentation.pl:  Update the page "vep_plugins.html" (under public-plugins/docs/htdocs/info/docs/tools/vep/script/).
scripts/misc/update_web_vep_plugins_documentation.pl:    -help           Print this message
scripts/misc/update_web_vep_plugins_documentation.pl:    -v              Ensembl version, e.g. 65 (Required)
scripts/misc/update_web_vep_plugins_documentation.pl:    -i              Input file, e.g. vep_plugins.html (Required)
scripts/misc/update_web_vep_plugins_documentation.pl:    -o              Output file (Required)
scripts/misc/update_web_vep_plugins_documentation.pl:    -git_dir        Path to the VEP_plugins repository - used to fetch information about the VEP plugins (Required)
scripts/misc/update_match_seq_region_ids.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/update_match_seq_region_ids.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/update_match_seq_region_ids.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/update_match_seq_region_ids.pl:usage() if ($config->{help});
scripts/misc/update_match_seq_region_ids.pl:die ('A registry file is required (--registry)') unless (defined($config->{registry}));
scripts/misc/update_match_seq_region_ids.pl:$registry->load_all($config->{registry});
scripts/misc/update_match_seq_region_ids.pl:my $cdbas = $registry->get_all_DBAdaptors(-group => 'core');
scripts/misc/update_match_seq_region_ids.pl:my $vdbas_tmp = $registry->get_all_DBAdaptors(-group => 'variation');
scripts/misc/update_match_seq_region_ids.pl:  my $species = $vdba->species;
scripts/misc/update_match_seq_region_ids.pl:  $vdbas->{$species} = $vdba;
scripts/misc/update_match_seq_region_ids.pl:  my $species = $cdba->species;
scripts/misc/update_match_seq_region_ids.pl:  die ("Species not found") if (!$vdbas->{$species});
scripts/misc/update_match_seq_region_ids.pl:  my $dbh = $cdba->dbc->db_handle;
scripts/misc/update_match_seq_region_ids.pl:  my $cd_dbname = $cdba->dbc->dbname;
scripts/misc/update_match_seq_region_ids.pl:  my $sth = $dbh->prepare("SELECT seq_region_id, name FROM seq_region;");
scripts/misc/update_match_seq_region_ids.pl:  $sth->execute();
scripts/misc/update_match_seq_region_ids.pl:  while (my @row = $sth->fetchrow_array) {
scripts/misc/update_match_seq_region_ids.pl:    $id_mapping->{$external_seq_region_name} = $external_seq_region_id;     
scripts/misc/update_match_seq_region_ids.pl:  $sth->finish();
scripts/misc/update_match_seq_region_ids.pl:  my $vdba = $vdbas->{$species};
scripts/misc/update_match_seq_region_ids.pl:  my $vdbh = $vdba->dbc->db_handle;
scripts/misc/update_match_seq_region_ids.pl:  my $vd_dbname = $vdba->dbc->dbname;
scripts/misc/update_match_seq_region_ids.pl:  $sth = $vdbh->prepare("SELECT seq_region_id, name FROM seq_region;");
scripts/misc/update_match_seq_region_ids.pl:  $sth->execute();
scripts/misc/update_match_seq_region_ids.pl:  while (my @row = $sth->fetchrow_array) {
scripts/misc/update_match_seq_region_ids.pl:    die "ERROR: '$internal_seq_region_name' is not listed in $cd_dbname.seq_region name column\n." unless defined($id_mapping->{$internal_seq_region_name});
scripts/misc/update_match_seq_region_ids.pl:    next if (defined($id_mapping->{$internal_seq_region_name}) && $id_mapping->{$internal_seq_region_name} eq $internal_seq_region_id);
scripts/misc/update_match_seq_region_ids.pl:  $sth->finish();
scripts/misc/update_match_seq_region_ids.pl:  unless (defined($config->{dry_run})) {
scripts/misc/update_match_seq_region_ids.pl:    $vdbh->do("ALTER TABLE seq_region drop seq_region_id;") or die $dbh->errstr;
scripts/misc/update_match_seq_region_ids.pl:    $vdbh->do("ALTER TABLE seq_region ADD seq_region_id INT UNSIGNED NOT NULL FIRST") or die $dbh->errstr;
scripts/misc/update_match_seq_region_ids.pl:    $need_ids->{$table} = \@ids;
scripts/misc/update_match_seq_region_ids.pl:    my $new_seq_region_id = $id_mapping->{$prev_seq_region_name};
scripts/misc/update_match_seq_region_ids.pl:    if ($config->{dry_run}) {
scripts/misc/update_match_seq_region_ids.pl:        next if ( ! grep $_ eq $old_seq_region_id, @{$need_ids->{$table}});
scripts/misc/update_match_seq_region_ids.pl:      $vdbh->do("Update seq_region SET seq_region_id=$new_seq_region_id WHERE name='$prev_seq_region_name'") or die $dbh->errstr;
scripts/misc/update_match_seq_region_ids.pl:        next if ( ! grep $_ eq $old_seq_region_id, @{$need_ids->{$table}});
scripts/misc/update_match_seq_region_ids.pl:        $vdbh->do("Update $table SET seq_region_id=$new_seq_region_id WHERE seq_region_id='$old_seq_region_id'") or die $dbh->errstr;
scripts/misc/update_match_seq_region_ids.pl:  unless (defined($config->{dry_run})) {
scripts/misc/update_match_seq_region_ids.pl:    $vdbh->do("ALTER TABLE seq_region ADD PRIMARY KEY (seq_region_id);") or die $dbh->errstr;
scripts/misc/update_match_seq_region_ids.pl:  Usage: perl update_seq_region_ids.pl -registry [registry_file] [OPTIONS]
scripts/misc/update_match_seq_region_ids.pl:    -help    Print this message
scripts/misc/update_match_seq_region_ids.pl:    -dry_run Print update statements
scripts/misc/update_match_seq_region_ids.pl:  my $helper = $vdba->dbc()->sql_helper();
scripts/misc/update_match_seq_region_ids.pl:   my $count = $helper->execute_single_result(-SQL => $sql);
scripts/misc/update_match_seq_region_ids.pl:  my $sth = $vdbh->prepare("SELECT DISTINCT seq_region_id FROM $table;");
scripts/misc/update_match_seq_region_ids.pl:  $sth->execute();
scripts/misc/update_match_seq_region_ids.pl:  while (my @row = $sth->fetchrow_array) {
scripts/misc/update_match_seq_region_ids.pl:  $sth->finish();
scripts/misc/veplotyper.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/veplotyper.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/veplotyper.pl:     http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/veplotyper.pl:  ) or die "ERROR: Failed to parse command-line flags\n";
scripts/misc/veplotyper.pl:  if(defined($config->{help}) || !$args) {
scripts/misc/veplotyper.pl:  $config->{rest}              ||= 'http://rest.ensembl.org';
scripts/misc/veplotyper.pl:  $config->{vcf_file}          ||= 'https://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20110521/ALL.chr###CHR###.phase1_release_v3.20101123.snps_indels_svs.genotypes.vcf.gz';
scripts/misc/veplotyper.pl:  $config->{cache_region_size} ||= 1000000;
scripts/misc/veplotyper.pl:  $config->{chunk_size}        ||= 50000;
scripts/misc/veplotyper.pl:  $config->{compress}          ||= 'zcat';
scripts/misc/veplotyper.pl:  $config->{terms}             ||= 'SO';
scripts/misc/veplotyper.pl:  $config->{cache}             ||= 1;
scripts/misc/veplotyper.pl:  $config->{format}            ||= 'vcf';
scripts/misc/veplotyper.pl:  $config->{polyphen_analysis} ||= 'humvar';
scripts/misc/veplotyper.pl:  $config->{sift}              ||= 1;
scripts/misc/veplotyper.pl:  $config->{polyphen}          ||= 1;
scripts/misc/veplotyper.pl:  $config->{species}           ||= 'homo_sapiens';
scripts/misc/veplotyper.pl:  $config->{individual}        ||= 'all';
scripts/misc/veplotyper.pl:  $config->{output_file}       ||= 'veplotyper_out.xml';
scripts/misc/veplotyper.pl:  $config->{individual} = [split(',', $config->{individual})];
scripts/misc/veplotyper.pl:  $config->{vfa}  = Bio::EnsEMBL::Variation::DBSQL::VariationFeatureAdaptor->new_fake($config->{species});
scripts/misc/veplotyper.pl:  $config->{tva}  = Bio::EnsEMBL::Variation::DBSQL::TranscriptVariationAdaptor->new_fake($config->{species});
scripts/misc/veplotyper.pl:  $config->{reg} = 'Bio::EnsEMBL::Registry';
scripts/misc/veplotyper.pl:  if(defined($config->{registry})) {
scripts/misc/veplotyper.pl:    $config->{reg}->load_all($config->{registry});
scripts/misc/veplotyper.pl:  elsif(defined($config->{host})) {
scripts/misc/veplotyper.pl:    $config->{reg}->load_registry_from_db(
scripts/misc/veplotyper.pl:      -host       => $config->{host},
scripts/misc/veplotyper.pl:      -user       => $config->{user},
scripts/misc/veplotyper.pl:      -pass       => $config->{password},
scripts/misc/veplotyper.pl:      -port       => $config->{port},
scripts/misc/veplotyper.pl:      -db_version => $config->{version},
scripts/misc/veplotyper.pl:      -species    => $config->{species} =~ /^[a-z]+\_[a-z]+/i ? $config->{species} : undef,
scripts/misc/veplotyper.pl:    $config->{db} = $config->{reg}->get_adaptor($config->{species}, 'variation', 'variation')->db;
scripts/misc/veplotyper.pl:    $config->{pfpma} = $config->{reg}->get_adaptor($config->{species}, 'variation', 'proteinfunctionpredictionmatrix');
scripts/misc/veplotyper.pl:  $config->{dir} ||= $config->{dir_cache} || join '/', ($ENV{'HOME'}, '.vep');  
scripts/misc/veplotyper.pl:  $config->{dir} .= '/'.(
scripts/misc/veplotyper.pl:      $config->{species},
scripts/misc/veplotyper.pl:      $config->{cache_version} || $config->{reg}->software_version
scripts/misc/veplotyper.pl:  my $vcf_file = $config->{vcf_file};
scripts/misc/veplotyper.pl:      my $remote_test = `tabix -f $vcf_file 1:1-1 2>&1`;
scripts/misc/veplotyper.pl:      die "ERROR: Custom annotation file $vcf_file not found\n" unless -e $vcf_file;
scripts/misc/veplotyper.pl:      die "ERROR: Tabix index file $vcf_file\.tbi not found - perhaps you need to create it first?\n" unless -e $vcf_file.'.tbi';
scripts/misc/veplotyper.pl:  die("ERROR: output file ".$config->{output_file}." already exists") if -e $config->{output_file} && !defined($config->{force_overwrite});
scripts/misc/veplotyper.pl:  my $oh = FileHandle->new(">".$config->{output_file});
scripts/misc/veplotyper.pl:  $config->{out_handle} = $oh;
scripts/misc/veplotyper.pl:  my $tr = fetch_transcript($config, $config->{transcript});
scripts/misc/veplotyper.pl:  my $gts = fetch_genotypes($config, $tr->{chr}, $tr->{start}, $tr->{end});
scripts/misc/veplotyper.pl:  my $c = Bio::EnsEMBL::Variation::TranscriptHaplotypeContainer->new($tr, $gts, $config->{db});
scripts/misc/veplotyper.pl:  foreach my $p(sort {$b->count <=> $a->count} @{$c->get_all_ProteinHaplotypes}) {
scripts/misc/veplotyper.pl:    my $f = $p->get_all_population_frequencies;
scripts/misc/veplotyper.pl:      100 * ($f->{AFR} || $f->{'1000GENOMES:phase_1_AFR'}),
scripts/misc/veplotyper.pl:      100 * ($f->{AMR} || $f->{'1000GENOMES:phase_1_AMR'}),
scripts/misc/veplotyper.pl:      100 * ($f->{ASN} || $f->{'1000GENOMES:phase_1_ASN'}),
scripts/misc/veplotyper.pl:      100 * ($f->{EUR} || $f->{'1000GENOMES:phase_1_EUR'}),
scripts/misc/veplotyper.pl:      100 * $p->frequency,
scripts/misc/veplotyper.pl:      $p->mean_sift_score,
scripts/misc/veplotyper.pl:      $p->name
scripts/misc/veplotyper.pl:  my $name = $c->transcript->stable_id;
scripts/misc/veplotyper.pl:  my $json = JSON->new;
scripts/misc/veplotyper.pl:  my $oh = $config->{out_handle};
scripts/misc/veplotyper.pl:  print $oh $json->allow_blessed->convert_blessed->pretty->encode($c);
scripts/misc/veplotyper.pl:  if(defined($config->{host})) {
scripts/misc/veplotyper.pl:  $config->{ta} ||= $config->{reg}->get_adaptor($config->{species}, 'core', 'transcript');
scripts/misc/veplotyper.pl:  my $tr = $config->{ta}->fetch_by_stable_id($tr_id);
scripts/misc/veplotyper.pl:  $tr->{chr} = $tr->seq_region_name;
scripts/misc/veplotyper.pl:  my $c = $tr_rest->{seq_region_name};
scripts/misc/veplotyper.pl:  my $s = int($tr_rest->{start} / $config->{cache_region_size});
scripts/misc/veplotyper.pl:  $s  = ($s * $config->{cache_region_size}) + 1;
scripts/misc/veplotyper.pl:  $e *= $config->{cache_region_size};
scripts/misc/veplotyper.pl:  my $q = $config->{quiet};
scripts/misc/veplotyper.pl:  $config->{quiet} = 1;
scripts/misc/veplotyper.pl:  my $tr_cache = load_dumped_transcript_cache($config, $c, "$s-$e");
scripts/misc/veplotyper.pl:  $config->{quiet} = $q;
scripts/misc/veplotyper.pl:  my ($tr) = grep {$_->stable_id eq $tr_id} @{$tr_cache->{$c}};
scripts/misc/veplotyper.pl:  $tr->{chr} = $c;
scripts/misc/veplotyper.pl:  if(defined($config->{collection})) {
scripts/misc/veplotyper.pl:  $Bio::EnsEMBL::Variation::DBSQL::VCFCollectionAdaptor::CONFIG_FILE = $config->{collection};
scripts/misc/veplotyper.pl:  if(defined($config->{host})) {
scripts/misc/veplotyper.pl:    $ca = $config->{reg}->get_adaptor($config->{species}, 'variation', 'vcfcollection');
scripts/misc/veplotyper.pl:    $sa = $config->{reg}->get_adaptor($config->{species}, 'core', 'slice');
scripts/misc/veplotyper.pl:    $slice = $sa->fetch_by_region('chromosome', @_);
scripts/misc/veplotyper.pl:    $ca = Bio::EnsEMBL::Variation::DBSQL::VCFCollectionAdaptor->new();
scripts/misc/veplotyper.pl:    $slice = Bio::EnsEMBL::Slice->new_fast({
scripts/misc/veplotyper.pl:  $_->use_db(0) for @{$ca->fetch_all};
scripts/misc/veplotyper.pl:  foreach my $c(@{$ca->fetch_all}) {
scripts/misc/veplotyper.pl:    my $hash = $c->_get_Population_Individual_hash;
scripts/misc/veplotyper.pl:    my $pops = $c->get_all_Populations();
scripts/misc/veplotyper.pl:    my $inds = $c->get_all_Individuals();
scripts/misc/veplotyper.pl:    my %pop_dbID_map = map {$_->dbID => $_} @$pops;
scripts/misc/veplotyper.pl:    my %ind_dbID_map = map {$_->dbID => $_} @$inds;
scripts/misc/veplotyper.pl:      foreach my $ind_id(keys %{$hash->{$pop_id}}) {  
scripts/misc/veplotyper.pl:        push @{$ind->{populations}}, $pop;
scripts/misc/veplotyper.pl:  my @gts = map {@{$_->get_all_IndividualGenotypeFeatures_by_Slice($slice, undef, 1)}} @{$ca->fetch_all};
scripts/misc/veplotyper.pl:    my $ref = (split '/', $gt->variation_feature->allele_string)[0];
scripts/misc/veplotyper.pl:    my @gt = @{$gt->genotype};
scripts/misc/veplotyper.pl:  my $sa = $config->{reg}->get_adaptor($config->{species}, 'core', 'slice');
scripts/misc/veplotyper.pl:  my $slice = $sa->fetch_by_region('chromosome', @_);
scripts/misc/veplotyper.pl:  my %vfs = map {$_->{_variation_id} => $_} @{$slice->get_all_VariationFeatures};
scripts/misc/veplotyper.pl:  my $gta = $config->{reg}->get_adaptor($config->{species}, 'variation', 'individualgenotypefeature');
scripts/misc/veplotyper.pl:    grep {$_->{variation_feature}}
scripts/misc/veplotyper.pl:    map {$_->{variation_feature} = $vfs{$_->{_variation_id}}; $_}
scripts/misc/veplotyper.pl:    @{$gta->fetch_all_by_Slice($slice)}
scripts/misc/veplotyper.pl:  my $file = $config->{vcf_file};
scripts/misc/veplotyper.pl:  open VARS, "tabix -f $file $c:$s-$e |"
scripts/misc/veplotyper.pl:    push @vars, grep {!defined($_->{hom_ref}) && !$_->isa('Bio::EnsEMBL::Variation::StructuralVariationFeature')} @{parse_line($config, $_)};
scripts/misc/veplotyper.pl:  my $prefix = $config->{individual_prefix} || '';
scripts/misc/veplotyper.pl:    Bio::EnsEMBL::Variation::IndividualGenotypeFeature->new_fast({
scripts/misc/veplotyper.pl:      genotype => $_->{genotype},
scripts/misc/veplotyper.pl:      individual => Bio::EnsEMBL::Variation::Individual->new_fast({
scripts/misc/veplotyper.pl:        name => $_->{individual},
scripts/misc/veplotyper.pl:        populations => [map {$config->{pops}->{$_}} keys %{$config->{ind_pops}->{$_->{individual}}}],
scripts/misc/veplotyper.pl:  } grep {$_->{phased}} @vars;
scripts/misc/veplotyper.pl:  if(!defined($config->{ind_cols})) {
scripts/misc/veplotyper.pl:    open IN, "tabix -hf $vcf 1:1-1 |";
scripts/misc/veplotyper.pl:        my $prefix = $config->{individual_prefix} || '';
scripts/misc/veplotyper.pl:        if(scalar @{$config->{individual}} == 1 && $config->{individual}->[0] =~ /^all$/i) {
scripts/misc/veplotyper.pl:          $config->{ind_cols} = \%ind_cols;
scripts/misc/veplotyper.pl:          foreach my $ind(@{$config->{individual}}) {
scripts/misc/veplotyper.pl:          $config->{ind_cols} = \%new_ind_cols;
scripts/misc/veplotyper.pl:  return $config->{ind_cols};
scripts/misc/veplotyper.pl:  if(!defined($config->{ind_pops})) {
scripts/misc/veplotyper.pl:    if(defined($config->{panel})) {
scripts/misc/veplotyper.pl:      open IN, $config->{panel} or die("ERROR: Could not read from panel file ".$config->{panel}."\n");
scripts/misc/veplotyper.pl:        #next unless defined($config->{ind_cols}->{$i});
scripts/misc/veplotyper.pl:          $config->{pop_counts}->{$p}++;
scripts/misc/veplotyper.pl:          $config->{pops}->{$p} ||= Bio::EnsEMBL::Variation::Population->new_fast({name => $p});
scripts/misc/veplotyper.pl:    elsif(defined($config->{host})) {
scripts/misc/veplotyper.pl:      my $ia = $config->{reg}->get_adaptor($config->{species}, 'variation', 'individual');
scripts/misc/veplotyper.pl:      my $prefix = $config->{individual_prefix} || '';
scripts/misc/veplotyper.pl:      my %ind_names_by_dbID = map {$_->dbID => $_->name} @{$ia->fetch_all_by_name_list([keys %{$config->{ind_cols}}])};
scripts/misc/veplotyper.pl:      my $pa = $config->{reg}->get_adaptor($config->{species}, 'variation', 'population');
scripts/misc/veplotyper.pl:      my $hash = $pa->_get_individual_population_hash([keys %ind_names_by_dbID]);
scripts/misc/veplotyper.pl:      my @pops = @{$pa->fetch_all_by_dbID_list([keys %$hash])};
scripts/misc/veplotyper.pl:      my %pop_names_by_dbID = map {$_->dbID => $_->name} @pops;
scripts/misc/veplotyper.pl:      %{$config->{pops}} = map {$_->name => $_} @pops;
scripts/misc/veplotyper.pl:        $populations{$_}{$p} = 1 for map {$ind_names_by_dbID{$_}} keys %{$hash->{$p_id}};
scripts/misc/veplotyper.pl:      %{$config->{pop_counts}} = map {$pop_names_by_dbID{$_} => scalar keys %{$hash->{$_}}} keys %$hash;
scripts/misc/veplotyper.pl:    $config->{ind_pops} = \%populations;
scripts/misc/veplotyper.pl:  return $config->{ind_pops};
scripts/misc/veplotyper.pl:    $config->{rest}.'/'.
scripts/misc/veplotyper.pl:    '?content-type=application/json;'.
scripts/misc/veplotyper.pl:  my $response = HTTP::Tiny->new()->get($url);
scripts/misc/veplotyper.pl:  die "ERROR: Failed to fetch transcript $config->{transcript} from $url\n" unless $response->{success};
scripts/misc/veplotyper.pl:  return decode_json($response->{content});
scripts/misc/veplotyper.pl:  return if defined($config->{quiet});
scripts/misc/veplotyper.pl:  print STDERR get_time().' - '.$msg;
scripts/misc/veplotyper.pl:    ($time[5] + 1900)."-".
scripts/misc/veplotyper.pl:    $time[4]."-".
scripts/misc/veplotyper.pl:  print qq{#---------------#
scripts/misc/veplotyper.pl:#---------------#
scripts/misc/veplotyper.pl:--help               -h   Print usage message and exit
scripts/misc/check_variant_ini-files_example.pl:# Copyright [2018-2022] EMBL-European Bioinformatics Institute
scripts/misc/check_variant_ini-files_example.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/check_variant_ini-files_example.pl:  print "> Error! Please give an Ensembl version, using the option '-v' \n";
scripts/misc/check_variant_ini-files_example.pl:  print "> Error! Please give the list of host names where the new databases are stored using the option '-hlist'\n";
scripts/misc/check_variant_ini-files_example.pl:  print "> Error! Please give user name using the option '-user'\n";
scripts/misc/check_variant_ini-files_example.pl:  print "> Error! Please give the path to your clone of the public_plugins Git repo, using the option '-git_dir'\n";
scripts/misc/check_variant_ini-files_example.pl:my $ini_files_dir = 'ensembl/conf/ini-files';
scripts/misc/check_variant_ini-files_example.pl:  while (my ($dbname) = $sth->fetchrow_array) {
scripts/misc/check_variant_ini-files_example.pl:    my $var_report = '  - Variation: ';
scripts/misc/check_variant_ini-files_example.pl:          $sth_var_3->finish();
scripts/misc/check_variant_ini-files_example.pl:        $sth_var_2->finish();
scripts/misc/check_variant_ini-files_example.pl:    my $sv_report = '  - SV: ';
scripts/misc/check_variant_ini-files_example.pl:          $sth_sv_3->finish();
scripts/misc/check_variant_ini-files_example.pl:        $sth_sv_2->finish();
scripts/misc/check_variant_ini-files_example.pl:    my $phe_report = '  - Phenotype: ';
scripts/misc/check_variant_ini-files_example.pl:        my $db_phe_desc = $sth_phe_2->fetchrow_array;
scripts/misc/check_variant_ini-files_example.pl:        $sth_phe_2->finish();
scripts/misc/check_variant_ini-files_example.pl:            my $count = $sth_phe_3->fetchrow_array;
scripts/misc/check_variant_ini-files_example.pl:            $sth_phe_3->finish();
scripts/misc/check_variant_ini-files_example.pl:  my $dbh = DBI->connect($dsn, $user, $pswd) or die "Connection failed";
scripts/misc/check_variant_ini-files_example.pl:  my $sth = $dbh->prepare($sql);
scripts/misc/check_variant_ini-files_example.pl:    $sth->execute(join(',',@$params));
scripts/misc/check_variant_ini-files_example.pl:    $sth->execute();
scripts/misc/check_variant_ini-files_example.pl:  Usage: perl check_variant_ini-files_example.pl [OPTION]
scripts/misc/check_variant_ini-files_example.pl:  Check variant, structural variant and phenotype entries in the ini-files (public_plugins)
scripts/misc/check_variant_ini-files_example.pl:    -help           Print this message
scripts/misc/check_variant_ini-files_example.pl:    -v              Ensembl version, e.g. 92 (Required)   
scripts/misc/check_variant_ini-files_example.pl:    -hlist          The list of host names (with port) where the new databases are stored, separated by a coma,
scripts/misc/check_variant_ini-files_example.pl:    -user           MySQL user name (Required)
scripts/misc/check_variant_ini-files_example.pl:    -git_dir        Path to your local copy of the  public_plugins Git repository, to check the ini-files,
scripts/misc/generate_consequence_table.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/generate_consequence_table.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/generate_consequence_table.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/generate_consequence_table.pl:  print "> Error! Please give an output file name using the option '-output_file'\n";
scripts/misc/generate_consequence_table.pl:if (!$web_colour_file || !-e $web_colour_file) {
scripts/misc/generate_consequence_table.pl:  print "> Error! Please give a valid colour file name using the option '-colour_file'\n";
scripts/misc/generate_consequence_table.pl:    my $so_term  = $cons_set->{SO_term};
scripts/misc/generate_consequence_table.pl:    my $so_acc   = $cons_set->{SO_accession};
scripts/misc/generate_consequence_table.pl:    my $so_label = $cons_set->{label};
scripts/misc/generate_consequence_table.pl:    my $so_desc  = $cons_set->{description};
scripts/misc/generate_consequence_table.pl:    my $impact   = $cons_set->{impact};
scripts/misc/generate_consequence_table.pl:    my $rank     = $cons_set->{rank};
scripts/misc/generate_consequence_table.pl:    <th style="width:5px;padding-left:0px;padding-right:0px;text-align:center">*</th>
scripts/misc/generate_consequence_table.pl:my $border_top = ';border-top:1px solid #FFF';
scripts/misc/generate_consequence_table.pl:  $cons_line .= (defined($c)) ? qq{    <td style="padding:0px;margin:0px;background-color:$c$border"></td>} : qq{    <td></td>};
scripts/misc/generate_consequence_table.pl:      if (-e $web_mapping_colour) {
scripts/misc/generate_consequence_table.pl:        my $line = `grep -w "'$c'" $web_mapping_colour`;
scripts/misc/generate_consequence_table.pl:    -help           Print this message
scripts/misc/generate_consequence_table.pl:    -output_file    An HTML output file name (Required)      
scripts/misc/generate_consequence_table.pl:    -colour_file    If you want to use directly the colours from the web colours configuration file
scripts/misc/generate_consequence_table.pl:                    instead of the almost-up-to-date-colour-hash \%colour hash. (optional)
scripts/misc/generate_consequence_table.pl:                    ensembl-webcode/conf/ini-files/COLOUR.ini 
scripts/misc/generate_consequence_table.pl:    -mapping_file   Web module to map the colour names to the corresponding hexadecimal code. (optional)
scripts/misc/generate_consequence_table.pl:                    ensembl-webcode/modules/EnsEMBL/Draw/Utils/NamedColours.pm
scripts/misc/strip_vcf.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/strip_vcf.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/strip_vcf.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/strip_vcf.pl:if($config->{help}) {
scripts/misc/strip_vcf.pl:$config->{$_} = [split(/\,/, ($config->{$_} || ''))] for qw(keep_headers delete_fields);
scripts/misc/strip_vcf.pl:if($config->{input_file}) {
scripts/misc/strip_vcf.pl:  my $file = $config->{input_file};
scripts/misc/strip_vcf.pl:  die("ERROR: Input file not found\n") unless -e $file;
scripts/misc/strip_vcf.pl:  $in = FileHandle->new();
scripts/misc/strip_vcf.pl:  if($file =~ /\.gz$/ || -B $file) {
scripts/misc/strip_vcf.pl:    $in->open('gzip -dc '.$file.' | ') or die("ERROR: Could not read from input file ".$file."\n");
scripts/misc/strip_vcf.pl:    die("ERROR: Input file looks like a binary (is it gzipped but not named [file].gz?)\n") if -B $file;
scripts/misc/strip_vcf.pl:    $in->open($file) or die("ERROR: Could not read from input file ".$file."\n");
scripts/misc/strip_vcf.pl:if($config->{output_file}) {
scripts/misc/strip_vcf.pl:  my $file = $config->{output_file};
scripts/misc/strip_vcf.pl:  $out = FileHandle->new();
scripts/misc/strip_vcf.pl:    $out->open('| bgzip -c > '.$file) or die("ERROR: Could not write to output file ".$file."\n");
scripts/misc/strip_vcf.pl:    $out->open('> '.$file) or die("ERROR: Could not write to output file ".$file."\n");
scripts/misc/strip_vcf.pl:      $headers->{$data[$_]} = $_ for (0..$#data);
scripts/misc/strip_vcf.pl:    if(scalar @{$config->{keep_headers}} && $config->{keep_headers}->[0] eq 'ALL') {
scripts/misc/strip_vcf.pl:    foreach my $inc(@{$config->{keep_headers}}) {
scripts/misc/strip_vcf.pl:    if(!exists($meta->{has_genotypes})) {
scripts/misc/strip_vcf.pl:      $meta->{has_genotypes} = 0;
scripts/misc/strip_vcf.pl:      if($headers->{FORMAT}) {
scripts/misc/strip_vcf.pl:        foreach my $part(split(/\:/, $data[$headers->{FORMAT}] || '')) {
scripts/misc/strip_vcf.pl:          $meta->{has_genotypes} = ++$part_num if $part eq 'GT';
scripts/misc/strip_vcf.pl:    $data[$headers->{$_}] = '.' for @{$config->{delete_fields}};
scripts/misc/strip_vcf.pl:    # remove non-genotype bits
scripts/misc/strip_vcf.pl:    if($meta->{has_genotypes}) {
scripts/misc/strip_vcf.pl:      $data[$headers->{FORMAT}] = 'GT';
scripts/misc/strip_vcf.pl:      my $from = $headers->{FORMAT} + 1;
scripts/misc/strip_vcf.pl:      my $gt_part = $meta->{has_genotypes} - 1;
scripts/misc/strip_vcf.pl:-h | --help            Display this message and quit
scripts/misc/strip_vcf.pl:-i | --input_file      Input file (reads from STDIN if not specified)
scripts/misc/strip_vcf.pl:-o | --output_file     Output file (writes to STDOUT if not specified)
scripts/misc/strip_vcf.pl:-k | --keep_headers    Comma separated list of header line keys to keep
scripts/misc/strip_vcf.pl:-d | --delete_fields   Comma separated list of fields/columns to "blank" i.e. set to "."
scripts/misc/healthcheck_vep_caches.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/healthcheck_vep_caches.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/healthcheck_vep_caches.pl:     http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/healthcheck_vep_caches.pl:) or die "ERROR: Failed to parse command-line flags\n";
scripts/misc/healthcheck_vep_caches.pl:do { usage(); exit(0); } if $config->{help};
scripts/misc/healthcheck_vep_caches.pl:$config->{reg} = 'Bio::EnsEMBL::Registry';
scripts/misc/healthcheck_vep_caches.pl:$config->{reg}->no_version_check(1);
scripts/misc/healthcheck_vep_caches.pl:$config->{dir}           ||= $ENV{HC_VEP_DIR}           || $ENV{HOME}.'/.vep/';
scripts/misc/healthcheck_vep_caches.pl:$config->{version}       ||= $ENV{HC_VEP_VERSION}       || $config->{reg}->software_version;
scripts/misc/healthcheck_vep_caches.pl:$config->{cache_version} ||= $ENV{HC_VEP_CACHE_VERSION} || $config->{version};
scripts/misc/healthcheck_vep_caches.pl:$config->{species}       ||= $ENV{HC_VEP_SPECIES}       || 'all';
scripts/misc/healthcheck_vep_caches.pl:$config->{host}          ||= $ENV{HC_VEP_HOST}          || 'ens-staging1,ens-staging2';
scripts/misc/healthcheck_vep_caches.pl:$config->{user}          ||= $ENV{HC_VEP_USER}          || 'ensro';
scripts/misc/healthcheck_vep_caches.pl:$config->{port}          ||= $ENV{HC_VEP_PORT}          || 3306;
scripts/misc/healthcheck_vep_caches.pl:$config->{password}      ||= $ENV{HC_VEP_PASS}          || undef;
scripts/misc/healthcheck_vep_caches.pl:$config->{no_fasta}      ||= $ENV{HC_VEP_NO_FASTA}      || undef;
scripts/misc/healthcheck_vep_caches.pl:$config->{max_vars}      ||= $ENV{HC_VEP_MAX_VARS}      || 100;
scripts/misc/healthcheck_vep_caches.pl:if(!defined($config->{random})) {
scripts/misc/healthcheck_vep_caches.pl:    $config->{random} = $ENV{HC_VEP_RANDOM};
scripts/misc/healthcheck_vep_caches.pl:    $config->{random} = 0;
scripts/misc/healthcheck_vep_caches.pl:$config->{cache_region_size} = 1e6;
scripts/misc/healthcheck_vep_caches.pl:if(defined($config->{random})) {
scripts/misc/healthcheck_vep_caches.pl:  die("ERROR: --random must be between 0 and 1\n") unless $config->{random} >= 0 && $config->{random} <= 1;
scripts/misc/healthcheck_vep_caches.pl:if($config->{species} ne 'all') {
scripts/misc/healthcheck_vep_caches.pl:  $match_species{$_} = 1 for split(/\,/, $config->{species});
scripts/misc/healthcheck_vep_caches.pl:foreach my $host(split /\,/, $config->{host}) {
scripts/misc/healthcheck_vep_caches.pl:  if($config->{species} eq 'all') {
scripts/misc/healthcheck_vep_caches.pl:    $match_species{$_} = 1 for map {$_->{species}} @$species_list;
scripts/misc/healthcheck_vep_caches.pl:  $config->{reg}->load_registry_from_db(
scripts/misc/healthcheck_vep_caches.pl:    -host       => $host,
scripts/misc/healthcheck_vep_caches.pl:    -user       => $config->{user},
scripts/misc/healthcheck_vep_caches.pl:    -pass       => $config->{password},
scripts/misc/healthcheck_vep_caches.pl:    -port       => $config->{port},
scripts/misc/healthcheck_vep_caches.pl:    -db_version => $config->{version},
scripts/misc/healthcheck_vep_caches.pl:    my ($species, $assembly) = ($species_hash->{species}, $species_hash->{assembly});
scripts/misc/healthcheck_vep_caches.pl:    $config->{tests}->{$species} = {};
scripts/misc/healthcheck_vep_caches.pl:    $config->{current} = $config->{tests}->{$species};
scripts/misc/healthcheck_vep_caches.pl:    my $dir = $config->{dir}.'/'.$species.'/'.$config->{cache_version}.($config->{version} >= 76 ? '_'.$assembly : '');
scripts/misc/healthcheck_vep_caches.pl:    ok(-d $config->{dir}.'/'.$species, "\[$species\] species dir exists");
scripts/misc/healthcheck_vep_caches.pl:    ok(-d $dir, "\[$species\] version dir exists");
scripts/misc/healthcheck_vep_caches.pl:    ok(-e $dir.'/info.txt', "\[$species\] info.txt exists");
scripts/misc/healthcheck_vep_caches.pl:      ok(/all/, "--build all used") if /^build/;
scripts/misc/healthcheck_vep_caches.pl:      $config->{current}->{expect_sift} = 1 if /sift_version/i;
scripts/misc/healthcheck_vep_caches.pl:      $config->{current}->{expect_polyphen} = 1 if /polyphen_version/i;
scripts/misc/healthcheck_vep_caches.pl:      $config->{current}->{variation_cols} = [split(",", (split("\t", $v))[-1])];
scripts/misc/healthcheck_vep_caches.pl:      $config->{current}->{vdb} = $config->{reg}->get_adaptor($sp, 'variation', 'variation')->db->dbc;
scripts/misc/healthcheck_vep_caches.pl:    my $sa = $config->{reg}->get_adaptor($sp, $refseq ? 'otherfeatures' : 'core', 'slice');
scripts/misc/healthcheck_vep_caches.pl:    my @slices = @{$sa->fetch_all('toplevel')};
scripts/misc/healthcheck_vep_caches.pl:    my $sth = $sa->{dbc}->prepare(qq{
scripts/misc/healthcheck_vep_caches.pl:    $sth->execute();
scripts/misc/healthcheck_vep_caches.pl:    $sth->bind_columns(\$sr_id, \$count);
scripts/misc/healthcheck_vep_caches.pl:    $counts{$sr_id} += $count while $sth->fetch;
scripts/misc/healthcheck_vep_caches.pl:    $sth->finish;
scripts/misc/healthcheck_vep_caches.pl:      $sth = $config->{current}->{vdb}->prepare(qq{
scripts/misc/healthcheck_vep_caches.pl:      $sth->execute();
scripts/misc/healthcheck_vep_caches.pl:      $sth->bind_columns(\$sr_id, \$count);
scripts/misc/healthcheck_vep_caches.pl:      $counts{$sr_id} += $count while $sth->fetch;
scripts/misc/healthcheck_vep_caches.pl:      $sth->finish;
scripts/misc/healthcheck_vep_caches.pl:      # printf("\r - checking chromosome dirs %i / %i", ++$i, scalar @slices);
scripts/misc/healthcheck_vep_caches.pl:      my $chr = $slice->seq_region_name;
scripts/misc/healthcheck_vep_caches.pl:      next unless $counts{$slice->get_seq_region_id};
scripts/misc/healthcheck_vep_caches.pl:      if(!-d $dir.'/'.$chr) {
scripts/misc/healthcheck_vep_caches.pl:      my $start = 1 + ($config->{cache_region_size} * int($slice->start / $config->{cache_region_size}));
scripts/misc/healthcheck_vep_caches.pl:      my $end   = ($start - 1) + $config->{cache_region_size};
scripts/misc/healthcheck_vep_caches.pl:      my $region_count = int($config->{random} * $slice->end / $config->{cache_region_size}) + 1;
scripts/misc/healthcheck_vep_caches.pl:      while($start < $slice->end) {
scripts/misc/healthcheck_vep_caches.pl:          my $file = $dir.'/'.$chr.'/'.$start.'-'.$end.$type.'.gz';
scripts/misc/healthcheck_vep_caches.pl:          push @missing_files, $file unless -e $file;
scripts/misc/healthcheck_vep_caches.pl:        if($config->{random} && ($checked_count < $region_count) && (rand() < $config->{random})) {
scripts/misc/healthcheck_vep_caches.pl:        $start += $config->{cache_region_size};
scripts/misc/healthcheck_vep_caches.pl:        $end += $config->{cache_region_size};
scripts/misc/healthcheck_vep_caches.pl:        push @tabix_broken, $chr unless -e $dir.'/'.$chr.'/all_vars.gz';
scripts/misc/healthcheck_vep_caches.pl:        push @tabix_broken, $chr.' (index)' unless -e $dir.'/'.$chr.'/all_vars.gz.tbi';
scripts/misc/healthcheck_vep_caches.pl:          my $result = `tabix $filepath 1:1-1 2>&1`;
scripts/misc/healthcheck_vep_caches.pl:          if($config->{random}) {
scripts/misc/healthcheck_vep_caches.pl:            my $pid = open3(\*OUT, \*IN, \*ERR, "gzip -qdc $filepath");
scripts/misc/healthcheck_vep_caches.pl:              next unless rand() < $config->{random};
scripts/misc/healthcheck_vep_caches.pl:              if(++$vs > $config->{max_vars}) {
scripts/misc/healthcheck_vep_caches.pl:                kill -9, $pid;
scripts/misc/healthcheck_vep_caches.pl:    @missing_dirs = (@missing_dirs[0..4], "...and ".(scalar @missing_dirs - 5)." more...") if scalar @missing_dirs > 5;
scripts/misc/healthcheck_vep_caches.pl:    @missing_files = (@missing_files[0..4], "...and ".(scalar @missing_files - 5)." more...") if scalar @missing_files > 5;
scripts/misc/healthcheck_vep_caches.pl:    @tabix_broken = (@tabix_broken[0..4], "...and ".(scalar @tabix_broken - 5)." more...") if scalar @tabix_broken > 5;
scripts/misc/healthcheck_vep_caches.pl:        or diag("Tabix-based variation cache broken for the following chromosome names:\n".join(", ", @tabix_broken)."\n");
scripts/misc/healthcheck_vep_caches.pl:    if($config->{current}->{found_protein_coding}) {
scripts/misc/healthcheck_vep_caches.pl:      foreach my $tool(grep {$config->{current}->{'expect_'.$_}} qw(sift polyphen)) {
scripts/misc/healthcheck_vep_caches.pl:        ok($config->{current}->{'found_'.$tool}, "found $tool data");
scripts/misc/healthcheck_vep_caches.pl:    unless($config->{no_fasta}) {
scripts/misc/healthcheck_vep_caches.pl:      ok($fa =~ /\.$config->{version}\./, "\[$species\] FASTA file matches version") if($idx);
scripts/misc/healthcheck_vep_caches.pl:            Bio::DB::Fasta->new($dir.'/'.$fa);
scripts/misc/healthcheck_vep_caches.pl:    $config->{port}
scripts/misc/healthcheck_vep_caches.pl:  $config->{dbc} = DBI->connect(
scripts/misc/healthcheck_vep_caches.pl:    $connection_string, $config->{user}, $config->{password}
scripts/misc/healthcheck_vep_caches.pl:  my $version = $config->{cache_version};
scripts/misc/healthcheck_vep_caches.pl:  my $sth = $config->{dbc}->prepare(qq{
scripts/misc/healthcheck_vep_caches.pl:  $sth->execute();
scripts/misc/healthcheck_vep_caches.pl:  $sth->bind_columns(\$db);
scripts/misc/healthcheck_vep_caches.pl:  push @dbs, $db while $sth->fetch;
scripts/misc/healthcheck_vep_caches.pl:  $sth->finish;
scripts/misc/healthcheck_vep_caches.pl:  $sth = $config->{dbc}->prepare(qq{
scripts/misc/healthcheck_vep_caches.pl:  $sth->execute();
scripts/misc/healthcheck_vep_caches.pl:  $sth->bind_columns(\$db);
scripts/misc/healthcheck_vep_caches.pl:  push @dbs, $db while $sth->fetch;
scripts/misc/healthcheck_vep_caches.pl:  $sth->finish;
scripts/misc/healthcheck_vep_caches.pl:  my $pattern = $config->{pattern};
scripts/misc/healthcheck_vep_caches.pl:  my $dbc = $config->{dbc};
scripts/misc/healthcheck_vep_caches.pl:      $sth = $dbc->prepare("SELECT version FROM ".$current_db_name.".coord_system ORDER BY rank LIMIT 1;");
scripts/misc/healthcheck_vep_caches.pl:      $sth->execute();
scripts/misc/healthcheck_vep_caches.pl:      my $assembly = $sth->fetchall_arrayref()->[0]->[0];
scripts/misc/healthcheck_vep_caches.pl:      $sth = $config->{dbc}->prepare(qq{
scripts/misc/healthcheck_vep_caches.pl:      $sth->execute;
scripts/misc/healthcheck_vep_caches.pl:      $sth->bind_columns(\$count);
scripts/misc/healthcheck_vep_caches.pl:      $sth->fetch;
scripts/misc/healthcheck_vep_caches.pl:        $current_db_name =~ s/^([a-z]+\_[a-z,1-9]+)(\_[a-z]+)?(.+)/$1$2/;
scripts/misc/healthcheck_vep_caches.pl:      $sth = $dbc->prepare("select species_id, meta_value from ".$current_db_name.".meta where meta_key = 'species.production_name';");
scripts/misc/healthcheck_vep_caches.pl:      $sth->execute();
scripts/misc/healthcheck_vep_caches.pl:      $sth->bind_columns(\$species_id, \$value);
scripts/misc/healthcheck_vep_caches.pl:      $species_ids->{$species_id} = $value while $sth->fetch();
scripts/misc/healthcheck_vep_caches.pl:      $sth->finish();
scripts/misc/healthcheck_vep_caches.pl:        $sth = $dbc->prepare("SELECT version FROM ".$current_db_name.".coord_system WHERE species_id = ".$species_id." ORDER BY rank LIMIT 1;");
scripts/misc/healthcheck_vep_caches.pl:        $sth->execute();
scripts/misc/healthcheck_vep_caches.pl:        $sth->bind_columns(\$assembly);
scripts/misc/healthcheck_vep_caches.pl:        $sth->execute();
scripts/misc/healthcheck_vep_caches.pl:        $sth->fetch();
scripts/misc/healthcheck_vep_caches.pl:        $species_hash{species} = $species_ids->{$species_id};
scripts/misc/healthcheck_vep_caches.pl:        $sth->finish();
scripts/misc/healthcheck_vep_caches.pl:  my $version = $config->{cache_version};
scripts/misc/healthcheck_vep_caches.pl:  my $sth = $config->{dbc}->prepare(qq{
scripts/misc/healthcheck_vep_caches.pl:  $sth->execute();
scripts/misc/healthcheck_vep_caches.pl:  $sth->bind_columns(\$db);
scripts/misc/healthcheck_vep_caches.pl:  $sth->fetch;
scripts/misc/healthcheck_vep_caches.pl:  $sth->finish;
scripts/misc/healthcheck_vep_caches.pl:  my $version = $config->{cache_version};
scripts/misc/healthcheck_vep_caches.pl:  my $sth = $config->{dbc}->prepare(qq{
scripts/misc/healthcheck_vep_caches.pl:  $sth->execute();
scripts/misc/healthcheck_vep_caches.pl:  $sth->bind_columns(\$db);
scripts/misc/healthcheck_vep_caches.pl:  $sth->fetch;
scripts/misc/healthcheck_vep_caches.pl:  $sth->finish;
scripts/misc/healthcheck_vep_caches.pl:  my $v = $config->{dbc}->selectall_arrayref(qq{
scripts/misc/healthcheck_vep_caches.pl:  })->[0]->[0];
scripts/misc/healthcheck_vep_caches.pl:    my $short_name = $chr.'/'.$start.'-'.$end.$type.'.gz';
scripts/misc/healthcheck_vep_caches.pl:      my $pid = open3(\*OUT, \*IN, \*ERR, "gzip -qdc $file");
scripts/misc/healthcheck_vep_caches.pl:        next unless rand() < $config->{random};
scripts/misc/healthcheck_vep_caches.pl:        if(++$vs > $config->{max_vars}) {
scripts/misc/healthcheck_vep_caches.pl:          kill -9, $pid;
scripts/misc/healthcheck_vep_caches.pl:      open my $fh, "gzip -dc $file |";
scripts/misc/healthcheck_vep_caches.pl:        ok($data->{$chr}, "Cache file has chr key") or diag("expected $chr, got ".join(",", keys %$data));
scripts/misc/healthcheck_vep_caches.pl:        my $chr_data = $data->{$chr};
scripts/misc/healthcheck_vep_caches.pl:            my $val = $chr_data->{$key};
scripts/misc/healthcheck_vep_caches.pl:  my $n = $ref->{dbID} || $ref->{variation_name};
scripts/misc/healthcheck_vep_caches.pl:  ok($ref->{start}, "Object has start") or diag(Dumper $ref);
scripts/misc/healthcheck_vep_caches.pl:  ok($ref->{end}, "Object has end") or diag(Dumper $ref);
scripts/misc/healthcheck_vep_caches.pl:  ok($ref->{dbID} || $ref->{variation_name}, "Object has ID") or diag(Dumper $ref);
scripts/misc/healthcheck_vep_caches.pl:  ok(defined($ref->{strand}) || defined($ref->{seq_region_strand}), "Object has strand") or diag(Dumper $ref);
scripts/misc/healthcheck_vep_caches.pl:  my $n = $v->{variation_name};
scripts/misc/healthcheck_vep_caches.pl:  if($v->{minor_allele}) {
scripts/misc/healthcheck_vep_caches.pl:    ok($v->{minor_allele} =~ /^[ACGTN-]+$/, "minor allele is valid allele") or diag("minor allele ".$v->{minor_allele});
scripts/misc/healthcheck_vep_caches.pl:    ok($v->{minor_allele_freq} =~ /^[0-9\.]+$/ && $v->{minor_allele_freq} >= 0 && $v->{minor_allele_freq} <= 0.5, "$n 0 <= frequency <= 0.5") or diag("$n freq ".$v->{minor_allele_freq});
scripts/misc/healthcheck_vep_caches.pl:    if($v->{$p}) {
scripts/misc/healthcheck_vep_caches.pl:      foreach my $set(split(',', $v->{$p})) {
scripts/misc/healthcheck_vep_caches.pl:          ok($a =~ /^[ACGTN-]+$/, "$p allele is valid allele") or diag("$n $p minor allele $a");
scripts/misc/healthcheck_vep_caches.pl:        ok($f =~ /^[0-9\.]+$/ && $f >= 0 && $f <= 1, "0 <= frequency <= 1") or diag("$n $p freq $f");
scripts/misc/healthcheck_vep_caches.pl:  if($v->{clin_sig}) {
scripts/misc/healthcheck_vep_caches.pl:    for(split(',', $v->{clin_sig})) {
scripts/misc/healthcheck_vep_caches.pl:      ok(exists($valid->{$_}), "clin_sig is valid") or diag("$n clin_sig $_");
scripts/misc/healthcheck_vep_caches.pl:  if($v->{pubmed}) {
scripts/misc/healthcheck_vep_caches.pl:    ok($v->{pubmed} =~ /^([0-9]+\,?)+$/, "pubmed looks ok") or diag("$n pubmed ".$v->{pubmed});
scripts/misc/healthcheck_vep_caches.pl:  ok($rf->isa('Bio::EnsEMBL::Funcgen::'.$type), "RF type check") or diag("expected Bio::EnsEMBL::Funcgen::".$type." got ".$rf);
scripts/misc/healthcheck_vep_caches.pl:    ok($rf->{display_label}, "motif feature has display_label");
scripts/misc/healthcheck_vep_caches.pl:    if($rf->{binding_matrix}) {
scripts/misc/healthcheck_vep_caches.pl:      ok($rf->{binding_matrix}->isa('Bio::EnsEMBL::Funcgen::BindingMatrix'), "binding matrix check");
scripts/misc/healthcheck_vep_caches.pl:    ok($rf->{_variation_effect_feature_cache} && $rf->{_variation_effect_feature_cache}->{seq}, "motif feature has cached sequence");
scripts/misc/healthcheck_vep_caches.pl:  ok($tr->isa('Bio::EnsEMBL::Transcript'), "tr type check") or diag("expected Bio::EnsEMBL::Transcript got ".$tr);
scripts/misc/healthcheck_vep_caches.pl:  ok($tr->{_variation_effect_feature_cache}, "tr has _variation_effect_feature_cache key") or diag(Dumper $tr);
scripts/misc/healthcheck_vep_caches.pl:  ok($tr->{_variation_effect_feature_cache}->{mapper} && $tr->{_variation_effect_feature_cache}->{mapper}->isa('Bio::EnsEMBL::TranscriptMapper'), "tr has mapper") or diag(Dumper $tr->{_variation_effect_feature_cache});
scripts/misc/healthcheck_vep_caches.pl:  if($tr->{biotype} eq 'protein_coding') {
scripts/misc/healthcheck_vep_caches.pl:    $config->{current}->{found_protein_coding} = 1;
scripts/misc/healthcheck_vep_caches.pl:    ok($tr->{_variation_effect_feature_cache}->{translateable_seq}, "tr has translateable_seq") or diag(Dumper $tr);
scripts/misc/healthcheck_vep_caches.pl:    ok($tr->{_variation_effect_feature_cache}->{peptide}, "tr has peptide") or diag(Dumper $tr);
scripts/misc/healthcheck_vep_caches.pl:    if($tr->{_variation_effect_feature_cache}->{protein_function_predictions}) {
scripts/misc/healthcheck_vep_caches.pl:      $config->{current}->{'found_'.$_} = 1 for map {s/\_.+//g; $_} keys %{$tr->{_variation_effect_feature_cache}->{protein_function_predictions}};
scripts/misc/healthcheck_vep_caches.pl:  my @cols = @{$config->{current}->{variation_cols}};
scripts/misc/healthcheck_vep_caches.pl:  if(!exists($config->{current}->{clinsig_values})) {
scripts/misc/healthcheck_vep_caches.pl:    my $sth = $config->{current}->{vdb}->prepare(qq{
scripts/misc/healthcheck_vep_caches.pl:    $sth->execute();
scripts/misc/healthcheck_vep_caches.pl:    my $v = $sth->fetchall_hashref('Field')->{clinical_significance}->{Type};
scripts/misc/healthcheck_vep_caches.pl:    $sth->finish();
scripts/misc/healthcheck_vep_caches.pl:    $config->{current}->{clinsig_values} = \%valid;
scripts/misc/healthcheck_vep_caches.pl:  return $config->{current}->{clinsig_values};
scripts/misc/healthcheck_vep_caches.pl:--dir | -d           Root directory of VEP caches (\$HOME/.vep/)
scripts/misc/healthcheck_vep_caches.pl:--version | -v       Version to check (current API version)
scripts/misc/healthcheck_vep_caches.pl:--cache_version | -c Cache version, can be EG version (current API version)
scripts/misc/healthcheck_vep_caches.pl:--species | -s       Species to check (all species found on hosts)
scripts/misc/healthcheck_vep_caches.pl:--hosts | -h      Database host(s), comma-separated (ens-staging1,ens-staging2)
scripts/misc/healthcheck_vep_caches.pl:--user | -u       Database username (ensro)
scripts/misc/healthcheck_vep_caches.pl:--password        Database password
scripts/misc/healthcheck_vep_caches.pl:--port | -p       Database port (3306)
scripts/misc/healthcheck_vep_caches.pl:--no_fasta | -nf  Don't look for and check FASTA file
scripts/misc/healthcheck_vep_caches.pl:--random | -r [n] Check content of fraction n cache per chromosome (0)
scripts/misc/healthcheck_vep_caches.pl:                  Use --random 1 to check everything!!!
scripts/misc/healthcheck_vep_caches.pl:--max_vars | -m   Maximum number of variants to check per cache file (100)
scripts/misc/update_seq_region_ids.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/update_seq_region_ids.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/update_seq_region_ids.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/update_seq_region_ids.pl:usage() if ($config->{help});
scripts/misc/update_seq_region_ids.pl:die ('A registry file is required (--registry)') unless (defined($config->{registry}));
scripts/misc/update_seq_region_ids.pl:$registry->load_all($config->{registry});
scripts/misc/update_seq_region_ids.pl:my $cdbas = $registry->get_all_DBAdaptors(-group => 'core');
scripts/misc/update_seq_region_ids.pl:my $vdbas_tmp = $registry->get_all_DBAdaptors(-group => 'variation');
scripts/misc/update_seq_region_ids.pl:  my $species = $vdba->species;
scripts/misc/update_seq_region_ids.pl:  $vdbas->{$species} = $vdba;
scripts/misc/update_seq_region_ids.pl:  my $dbname = $cdba->dbc->dbname;
scripts/misc/update_seq_region_ids.pl:  my $species = $cdba->species;
scripts/misc/update_seq_region_ids.pl:  next if (!$vdbas->{$species});
scripts/misc/update_seq_region_ids.pl:  my $dbh = $cdba->dbc->db_handle;
scripts/misc/update_seq_region_ids.pl:  my $sth = $dbh->prepare("SELECT external_seq_region_id, internal_seq_region_id FROM seq_region_mapping WHERE mapping_set_id=$max_mapping_set_id;");
scripts/misc/update_seq_region_ids.pl:  $sth->execute();
scripts/misc/update_seq_region_ids.pl:  while (my @row = $sth->fetchrow_array) {
scripts/misc/update_seq_region_ids.pl:    $id_mapping->{$external_seq_region_id} = $internal_seq_region_id;     
scripts/misc/update_seq_region_ids.pl:  $sth->finish();
scripts/misc/update_seq_region_ids.pl:  my $vdba = $vdbas->{$species};
scripts/misc/update_seq_region_ids.pl:  my $vdbh = $vdba->dbc->db_handle;
scripts/misc/update_seq_region_ids.pl:    my $new_seq_region_id = $id_mapping->{$prev_seq_region_id};
scripts/misc/update_seq_region_ids.pl:    if ($config->{dry_run}) {
scripts/misc/update_seq_region_ids.pl:      $vdbh->do("Update seq_region SET seq_region_id=$new_seq_region_id WHERE seq_region_id=$prev_seq_region_id") or die $dbh->errstr;
scripts/misc/update_seq_region_ids.pl:  my $sth_mapping = $dbh->prepare("select max(mapping_set_id) from $dbname.mapping_set");
scripts/misc/update_seq_region_ids.pl:  $sth_mapping->execute();
scripts/misc/update_seq_region_ids.pl:  my ($max_mapping_set_id) = $sth_mapping->fetchrow_array();
scripts/misc/update_seq_region_ids.pl:  Usage: perl update_seq_region_ids.pl -registry [registry_file] [OPTIONS]
scripts/misc/update_seq_region_ids.pl:    -help    Print this message
scripts/misc/update_seq_region_ids.pl:    -dry_run Print update statements
scripts/misc/update_meta_coord.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/update_meta_coord.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/update_meta_coord.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/update_meta_coord.pl:my $cli_helper = Bio::EnsEMBL::Utils::CliHelper->new();
scripts/misc/update_meta_coord.pl:my $opts = $cli_helper->process_args( $optsd, \&usage );
scripts/misc/update_meta_coord.pl:if (defined $opts->{dbname}) {
scripts/misc/update_meta_coord.pl:  die "Variation database required" unless ($opts->{dbname} =~ m/variation/);
scripts/misc/update_meta_coord.pl:  $opts->{dbname} =~ s/variation/core/;
scripts/misc/update_meta_coord.pl:  my $version = $opts->{version};
scripts/misc/update_meta_coord.pl:  $opts->{pattern} = 'variation_'.$version.'_\d+$';
scripts/misc/update_meta_coord.pl:  $opts->{pattern} = 'core_'.$version.'_\d+$';
scripts/misc/update_meta_coord.pl:  my $vdba = $variation_dbas->{$variation_dbname};
scripts/misc/update_meta_coord.pl:  my $file = $vdba->dbc()->dbname() . "_meta_coord.backup";
scripts/misc/update_meta_coord.pl:  my $fh = FileHandle->new($file, 'w');
scripts/misc/update_meta_coord.pl:  my $dbh = $vdba->dbc->db_handle;
scripts/misc/update_meta_coord.pl:  my $sth = $dbh->prepare(q/SELECT * FROM meta_coord/);
scripts/misc/update_meta_coord.pl:  $sth->execute;
scripts/misc/update_meta_coord.pl:  while ( my @row = $sth->fetchrow_array() ) {
scripts/misc/update_meta_coord.pl:  $sth->finish;
scripts/misc/update_meta_coord.pl:  $fh->close;
scripts/misc/update_meta_coord.pl:  $vdba->dbc()->sql_helper()->execute_update(-SQL => "DELETE FROM meta_coord", -PARAMS => []);
scripts/misc/update_meta_coord.pl:        . "MAX( 1 + cast( t.seq_region_end as signed) - cast( t.seq_region_start as signed) ) "
scripts/misc/update_meta_coord.pl:    $vdba->dbc()->sql_helper()->execute_update(
scripts/misc/update_meta_coord.pl:      -SQL => $sql,
scripts/misc/update_meta_coord.pl:      -PARAMS => [ $vdba->species_id() ] );
scripts/misc/update_meta_coord.pl:  for my $db_args ( @{ $cli_helper->get_dba_args_for_opts( $opts, 0 ) } ) {
scripts/misc/update_meta_coord.pl:    my $dbname = $dba->dbc()->dbname();
scripts/misc/update_meta_coord.pl:    $dbas->{$dbname} = $dba;
scripts/misc/update_meta_coord.pl:    my $opt = join '|', @{$_->{args}};
scripts/misc/update_meta_coord.pl:    $opt . $_->{type};
scripts/misc/update_meta_coord.pl:  $0 --dbhost=XhostX [--dbport=3306] \\
scripts/misc/update_meta_coord.pl:  \t--dbuser=XuserX --dbpass=XXX \\
scripts/misc/update_meta_coord.pl:  $0 \$(XserverX details script_db) --dbname XdbnameX
scripts/misc/update_meta_coord.pl:  $0 \$(XserverX details script_db) --version Xrelease-versionX
scripts/misc/update_meta_coord.pl:  $0 --help
scripts/misc/update_meta_coord.pl:  --help        Displays this help text.
scripts/misc/sources2html.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/sources2html.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/sources2html.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/sources2html.pl:  print STDERR "> Error! Please give an Ensembl version, using the option '-v' \n";
scripts/misc/sources2html.pl:  print STDERR "> Error! Please give an output file using the option '-o'\n";
scripts/misc/sources2html.pl:  print STDERR "> Error! Please give host name where the previous databases are stored using the option '-phost'\n";
scripts/misc/sources2html.pl:  print STDERR "> Error! Please give the list of host names where the new databases are stored using the option '-hlist'\n";
scripts/misc/sources2html.pl:my $eva_url = 'https://www.ebi.ac.uk/eva/?eva-study=###ID###';
scripts/misc/sources2html.pl:  'PRJEB26368'  => 'Genotyping-by-sequencing of 2,496 mink from Aarhus University farm',
scripts/misc/sources2html.pl:my $img_class    = "badge-48";
scripts/misc/sources2html.pl:my $img_class_sm = "badge-16";
scripts/misc/sources2html.pl:    <h1 style="margin-top:15px">Ensembl Variation - Data sources</h1>
scripts/misc/sources2html.pl:    <h2>List of data sources for each species - $ecaption $e_version</h2>
scripts/misc/sources2html.pl:    <p style="margin-bottom:20px">
scripts/misc/sources2html.pl:browser go to a species Location page (e.g. <a href="/Homo_sapiens/Location/View?r=6:133017695-133161157">for human</a>), and click on
scripts/misc/sources2html.pl:the <i>'Configure this page'</i> link on the left-hand side. The <i>'Variation'</i> and <i>'Somatic mutations'</i> sections contain a track list of all the sources of variant data for that species.
scripts/misc/sources2html.pl:    <div style="margin-bottom:20px">
scripts/misc/sources2html.pl:  while (my ($dbname) = $sth->fetchrow_array) {
scripts/misc/sources2html.pl:    next if ($dbname !~ /^[a-z][a-z_]*_[a-z]+_variation_\d+_\d+$/i);
scripts/misc/sources2html.pl:    if ($etype) { # EG site - need to filter out species
scripts/misc/sources2html.pl:      my $img_thumb = sprintf qq{eg-plugins/%s/htdocs/img/species/thumb_%s.png}, $etype, ucfirst($s_name);
scripts/misc/sources2html.pl:      if (! -e $img_thumb) {
scripts/misc/sources2html.pl:      $display_name = $sth_core->fetchrow_array;  
scripts/misc/sources2html.pl:  print STDERR "- $display_name ($s_name) ...";
scripts/misc/sources2html.pl:  my $db_vcf = $sth_var->fetchrow_array;
scripts/misc/sources2html.pl:  $sth2->bind_columns(\$source_id,\$source,\$s_version,\$s_description,\$s_url,\$s_type,\$s_status,\$s_data_types,\$s_order);
scripts/misc/sources2html.pl:  $sth2b->bind_columns(\$set_id,\$set_name,\$set_description);
scripts/misc/sources2html.pl:  my $p_version = $e_version-1;
scripts/misc/sources2html.pl:  my $p_dbname = $sth3->fetchrow_array;
scripts/misc/sources2html.pl:    while (my @p = $sth4->fetchrow_array) {
scripts/misc/sources2html.pl:    while (my @s = $sth4b->fetchrow_array) {
scripts/misc/sources2html.pl:    <div style="background-color:#F0F0F0;margin:50px 0px 25px;padding:5px;border-top:2px solid #336;border-bottom:1px solid #336">
scripts/misc/sources2html.pl:  my $html = qq{<!-- $display_name ($species) -->};
scripts/misc/sources2html.pl:    <div style="padding-left:0px;padding-bottom:1px">
scripts/misc/sources2html.pl:      <a href="/$s_name/Info/Index" title="$display_name Ensembl Home page" style="vertical-align:middle" target="_blank"><img src="/i/species/$s_name.png" alt="$display_name" class="$img_class" style="float:none;margin-right:4px;padding:2px;vertical-align:middle;background-color:#00F" /></a>
scripts/misc/sources2html.pl:      <h2 id="$s_name_id" style="display:inline;color:#333">$display_name<span class="small vdoc_species_sci_name"> ($species)</span></h2><span style="padding-left:20px;color:#00F;font-weight:bold">New species!</span>
scripts/misc/sources2html.pl:    <div style="padding-left:0px;padding-bottom:3px">
scripts/misc/sources2html.pl:      <a href="/$s_name/Info/Index" title="$display_name Ensembl Home page" style="vertical-align:middle" target="_blank"><img src="/i/species/$s_name.png" alt="$display_name" class="$img_class" style="float:none;margin-right:4px;vertical-align:middle" /></a>
scripts/misc/sources2html.pl:    #need Source name, version =-, Description  + data_types
scripts/misc/sources2html.pl:    my $vcf_sample = $sth3->fetchrow_array;
scripts/misc/sources2html.pl:    my $s_description = $vcf_desc{$vcf_sample} // '-';
scripts/misc/sources2html.pl:    $vcf_sample = qq{<a href="$source_url" style="text-decoration:none" target="_blank">$vcf_sample</a>};
scripts/misc/sources2html.pl:    my $row = set_row($s_header,$vcf_sample,'-',$s_description,$vcf_info,'','');
scripts/misc/sources2html.pl:  while ($sth->fetch) {
scripts/misc/sources2html.pl:    elsif ($p_list->{$source} ne $s_version){
scripts/misc/sources2html.pl:      my $borders = ";border-top:1px solid #FFF;border-bottom:1px solid #FFF";
scripts/misc/sources2html.pl:      $s_header .= ';background-color:'.$colours{$s_new_type};
scripts/misc/sources2html.pl:      $source = qq{<a href="$s_url" style="text-decoration:none" target="_blank">$source</a>};
scripts/misc/sources2html.pl:        my $dt_phe_title = ($phe_types->{$dt}{$source_id}) ? "Provides ".$phe_types->{$dt}{$source_id}." phenotype association data" : $phe_title;
scripts/misc/sources2html.pl:        $s_phenotype = qq{<img src="$phen_icon" style="border-radius:5px;border:1px solid #000" alt="$dt_phe_title" title="$dt_phe_title" />};
scripts/misc/sources2html.pl:        $data_type_string .= qq{\n$spaces  <div class="$type_class"><span class="_ht ht" title="$data_type_label - Some/all variants already exist in an other source, or are redundant in this source, with different IDs">Synonym</span></div>};
scripts/misc/sources2html.pl:      my $count = $counts_species->{$dt}{$source_id};
scripts/misc/sources2html.pl:    my ($source_var_set_id) = $sth5->fetchrow_array;
scripts/misc/sources2html.pl:      $data_type_string .= qq{\n$spaces<div class="$dt_class">\n$spaces  <div class="$type_class"><span class="_ht ht" title="Variation set - Existing variants from 1 or several sources have been associated with this variation set">Set</span></div>};
scripts/misc/sources2html.pl:    $data_type_string = '-' if ($data_type_string eq '');
scripts/misc/sources2html.pl:    $other_flag{$s_type} = 1 if ($s_phenotype ne '' || $s_somatic_status ne '-');
scripts/misc/sources2html.pl:  while ($sth_set->fetch) {
scripts/misc/sources2html.pl:      my $borders = ";border-top:1px solid #FFF;border-bottom:1px solid #FFF";
scripts/misc/sources2html.pl:      $s_header .= ';background-color:'.$colours{$s_new_type};
scripts/misc/sources2html.pl:    my $data_type_string = qq{\n$spaces<div class="$dt_class">\n$spaces  <div class="$type_class"><span class="_ht ht" title="Variation set - Existing variants from 1 or several sources have been associated with this variation set">Set</span></div>};
scripts/misc/sources2html.pl:    $version = '-';
scripts/misc/sources2html.pl:  my $dbh = DBI->connect($dsn, $login, $pswd) or die "Connection failed";
scripts/misc/sources2html.pl:  my $sth = $dbh->prepare($sql);
scripts/misc/sources2html.pl:    $sth->execute(join(',',@$params));
scripts/misc/sources2html.pl:    $sth->execute;
scripts/misc/sources2html.pl:  <!-- Right hand side menu -->
scripts/misc/sources2html.pl:      <img src="/i/16/info.png" style="vertical-align:top" alt="info" /> 
scripts/misc/sources2html.pl:    $html .= qq{    <div><span class="$v_colour vdoc_source_count" style="margin-left:5px">#</span><small> : $v_label</small></div>};
scripts/misc/sources2html.pl:    $html .= qq{    <div><span class="$s_colour vdoc_source_count" style="margin-left:5px">#</span><small> : $s_label</small></div>};
scripts/misc/sources2html.pl:    <!-- Legend header -->
scripts/misc/sources2html.pl:        <img src="/i/16/info.png" style="vertical-align:top" />
scripts/misc/sources2html.pl:        <a href="#top" style="text-decoration:none">[Top]</a>
scripts/misc/sources2html.pl:    <!-- Main legend -->
scripts/misc/sources2html.pl:        <td style="padding-top:6px;text-align:center">
scripts/misc/sources2html.pl:        <td style="padding-top:4px"><b>New version</b> of the data<br />source in this release<br />for the species</td>
scripts/misc/sources2html.pl:        <td style="padding-top:6px;text-align:center">
scripts/misc/sources2html.pl:        <td style="padding-top:4px"><b>New data source</b> in this<br />release for the species</td>
scripts/misc/sources2html.pl:        <td style="padding-top:6px;text-align:center;">
scripts/misc/sources2html.pl:          <img src="$phen_icon" style="margin-left:auto;margin-right:auto;border-radius:5px;border:1px solid #000;margin-right:1px" alt="Provides phenotype data" title="Provides phenotype data"/>
scripts/misc/sources2html.pl:        <td style="padding-top:4px">Source which provides<br />phenotype association data</td>
scripts/misc/sources2html.pl:        <td style="padding-top:6px;text-align:center">%s   </td>
scripts/misc/sources2html.pl:        <td style="padding-top:4px">The source contains only<br />germline data</td>
scripts/misc/sources2html.pl:        <td style="padding-top:6px;text-align:center">%s    </td>
scripts/misc/sources2html.pl:        <td style="padding-top:4px">The source contains only<br />somatic data</td>
scripts/misc/sources2html.pl:        <td style="padding-top:6px;text-align:center">%s    </td>
scripts/misc/sources2html.pl:        <td style="padding-top:4px">The source contains both<br />germline and somatic data</td>
scripts/misc/sources2html.pl:    <!-- Variant and structural variant count colour legend -->
scripts/misc/sources2html.pl:    <div style="border-top:1px dotted #336;margin-top:2px;padding:4px 0px 0px">
scripts/misc/sources2html.pl:      <span style="padding-left:4px;font-weight:bold">Data types - entries count:</span>
scripts/misc/sources2html.pl:          <td style="padding-top:4px;text-align:center">
scripts/misc/sources2html.pl:          <td style="padding-top:4px">greater than 100 million</td>
scripts/misc/sources2html.pl:          <td style="padding-top:4px;text-align:center">
scripts/misc/sources2html.pl:          <td style="padding-top:4px">from 10 to 99.9 million</td>
scripts/misc/sources2html.pl:          <td style="padding-top:4px;text-align:center">
scripts/misc/sources2html.pl:          <td style="padding-top:4px">from 1 million to 9.9 million</td>
scripts/misc/sources2html.pl:          <td style="padding-top:3px;text-align:center">
scripts/misc/sources2html.pl:          <td style="padding-top:3px">from 1,000 to 999,999</td>
scripts/misc/sources2html.pl:          <td style="padding-top:3px;text-align:center">
scripts/misc/sources2html.pl:          <td style="padding-top:3px">less than 1,000</td>
scripts/misc/sources2html.pl:    <!-- Javascript used to fix the legend on the right handside when you scroll down -->
scripts/misc/sources2html.pl:        if (window.pageYOffset-80 > legend_element_pos)  {
scripts/misc/sources2html.pl:  my $name    = $species->{name};
scripts/misc/sources2html.pl:  my $display = $species->{display};
scripts/misc/sources2html.pl:  my $s_name  = $species->{s_name};
scripts/misc/sources2html.pl:  my $anchor  = $species->{anchor};
scripts/misc/sources2html.pl:  if ($species_news{$species->{name}}) {
scripts/misc/sources2html.pl:      next if (!$species_news{$species->{name}}{$type});
scripts/misc/sources2html.pl:      my $count_type = $species_news{$species->{name}}{$type};
scripts/misc/sources2html.pl:      my $label_desc = "$count_type ".lc($desc->{$type});
scripts/misc/sources2html.pl:      <img src="/i/species/$s_name.png" alt="$display" class="$img_class_sm" style="margin-right:4px;vertical-align:middle" />
scripts/misc/sources2html.pl:      <a href="#$anchor" style="margin-right:3px;text-decoration:none;vertical-align:middle" title="$name">$display</a>
scripts/misc/sources2html.pl:          <div style="color:$color;font-size:0.8em;text-align:center;margin:0px auto 0px auto;padding:0px">
scripts/misc/sources2html.pl:            <span style="text-align:center;margin:0px;padding:0px">New</span><br /><span style="text-align:center;margin:0px;padding:0px">$type</span>
scripts/misc/sources2html.pl:          <div class="_ht" style="margin-left:auto;margin-right:auto;border-radius:5px;border:1px solid #000;width:20px;height:20px;background-color:#00C;" title="$type data"></div>
scripts/misc/sources2html.pl:          <div class="_ht" style="margin-left:auto;margin-right:auto;border-radius:5px;border:1px solid #000;width:20px;height:20px;background-color:#C00;" title="$type data"></div>
scripts/misc/sources2html.pl:          <div class="_ht" style="margin-left:auto;margin-right:auto;border-radius:5px;border:1px solid #000;width:20px;height:20px;background-color:#00C;" title="$type data">
scripts/misc/sources2html.pl:            <div style="width:0px;height:0px;border-style:solid;border-width:0 0 20px 20px;border-color:transparent transparent #C00 transparent"></div>
scripts/misc/sources2html.pl:   return '-';
scripts/misc/sources2html.pl:  my $border_color = qq{style="border-color:#336"};
scripts/misc/sources2html.pl:    <th colspan=2 style="width:56px;text-align:center;border-left:1px solid #CCC;background-color:#BBB">
scripts/misc/sources2html.pl:     <th class="vdoc_data_types vdoc_extra_column" style="background-color:#BBB">Data type(s)
scripts/misc/sources2html.pl:         <div class="vdoc_type_style" style="text-align:center"><span class="_ht ht" $border_color title="Data type"><small>Type</small></div>
scripts/misc/sources2html.pl:         <div class="vdoc_count_style" style="text-align:center"><span class="_ht ht" $border_color title="Entries count"><small>Count</small></span></div>
scripts/misc/sources2html.pl:        <tr><th colspan="2">$name</th><th>Version</th><th style="max-width:800px">Description</th>$data_type_header</th>$header_col</tr>
scripts/misc/sources2html.pl:        <td style="font-weight:bold">$source</td>
scripts/misc/sources2html.pl:        <td style="max-width:800px">$desc</td>
scripts/misc/sources2html.pl:        <td style="text-align:center;width:22px;padding:2px 3px;border-left:1px solid #CCC">$phenotype</td>
scripts/misc/sources2html.pl:        <td style="width:160px;text-align:center;width:22px;padding:2px 3px;border-left:1px solid #DDD">$somatic_status</td>
scripts/misc/sources2html.pl:    my $sql = $data_types->{$type}{'count_spe'};
scripts/misc/sources2html.pl:      while (my ($source_id,$count) = $sth->fetchrow_array) {
scripts/misc/sources2html.pl:      $sth->finish();
scripts/misc/sources2html.pl:  my $sql = $data_types->{$type}{'types'};
scripts/misc/sources2html.pl:    while (my ($source_id,$types) = $sth->fetchrow_array) {
scripts/misc/sources2html.pl:    $sth->finish();
scripts/misc/sources2html.pl:    my @result = $sth->fetchrow_array;
scripts/misc/sources2html.pl:  return '-'; 
scripts/misc/sources2html.pl:    my @result  = $sth->fetchrow_array;
scripts/misc/sources2html.pl:    -help           Print this message
scripts/misc/sources2html.pl:    -v              Ensembl version, e.g. 65 (Required)
scripts/misc/sources2html.pl:    -o              An HTML output file name (Required)      
scripts/misc/sources2html.pl:    -phost          Host name (with port) where the previous databases are stored, with their port, e.g. ensembldb.ensembl.org:3306  (Required)
scripts/misc/sources2html.pl:    -hlist          The list of host names (with port) where the new databases are stored, separated by a coma,
scripts/misc/sources2html.pl:    -skip_name      Flag to avoid the connection to the Core databases (use to retrieve the species display name, e.g. Human).
scripts/misc/sources2html.pl:    -site           The URL of the website (optional)
scripts/misc/sources2html.pl:    -etype          The type of Ensembl, e.g. Plant (optional)
scripts/misc/mart_variation_effect.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/mart_variation_effect.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/mart_variation_effect.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/mart_variation_effect.pl:  die("ERROR: $_ not defined, use --$_\n") unless defined $config->{$_};
scripts/misc/mart_variation_effect.pl:if(!defined($config->{db})) {
scripts/misc/mart_variation_effect.pl:  push @db_list, $config->{db};
scripts/misc/mart_variation_effect.pl:die "ERROR: no suitable databases found on host ".$config->{host}."\n" unless scalar @db_list;
scripts/misc/mart_variation_effect.pl:if (lc($config->{table}) eq 'all') {
scripts/misc/mart_variation_effect.pl:  $config->{table} = 'transcript_variation motif_feature_variation regulatory_feature_variation';
scripts/misc/mart_variation_effect.pl:  $config->{table} ||= 'transcript_variation';
scripts/misc/mart_variation_effect.pl:my $table_input = $config->{table};
scripts/misc/mart_variation_effect.pl:  my $TMP_DIR = $config->{tmpdir};
scripts/misc/mart_variation_effect.pl:  my $TMP_FILE = $config->{tmpfile};
scripts/misc/mart_variation_effect.pl:    my $dbc = Bio::EnsEMBL::DBSQL::DBConnection->new(
scripts/misc/mart_variation_effect.pl:      -user   => $config->{user},
scripts/misc/mart_variation_effect.pl:      -dbname => $db,
scripts/misc/mart_variation_effect.pl:      -host   => $config->{host},
scripts/misc/mart_variation_effect.pl:      -pass   => $config->{password},
scripts/misc/mart_variation_effect.pl:      -driver => 'mysql',
scripts/misc/mart_variation_effect.pl:      -port   => $config->{port},
scripts/misc/mart_variation_effect.pl:    my $sth = $dbc->prepare(qq{
scripts/misc/mart_variation_effect.pl:    $sth->execute();
scripts/misc/mart_variation_effect.pl:    my $create_sth = $sth->fetchall_arrayref->[0]->[1];
scripts/misc/mart_variation_effect.pl:    $sth->finish;
scripts/misc/mart_variation_effect.pl:    $dbc->do($create_sth);
scripts/misc/mart_variation_effect.pl:    $sth = $dbc->prepare(qq{
scripts/misc/mart_variation_effect.pl:    $sth->execute();
scripts/misc/mart_variation_effect.pl:    my @cols = map {$_->[0]} @{$sth->fetchall_arrayref};
scripts/misc/mart_variation_effect.pl:    $sth->finish;
scripts/misc/mart_variation_effect.pl:    $sth = $dbc->prepare(qq{ SELECT count(*) FROM $source_table });
scripts/misc/mart_variation_effect.pl:    $sth->execute();
scripts/misc/mart_variation_effect.pl:    my $row_count = $sth->fetchall_arrayref->[0]->[0];
scripts/misc/mart_variation_effect.pl:    $sth->finish;
scripts/misc/mart_variation_effect.pl:    $sth = $dbc->prepare(qq{ SELECT * FROM $source_table
scripts/misc/mart_variation_effect.pl:    $sth->execute();
scripts/misc/mart_variation_effect.pl:    while(my $row = $sth->fetchrow_hashref()) {
scripts/misc/mart_variation_effect.pl:      my $cons = $row->{consequence_types};
scripts/misc/mart_variation_effect.pl:    $sth->finish;
scripts/misc/mart_variation_effect.pl:  my $dbc = DBI->connect(
scripts/misc/mart_variation_effect.pl:        $config->{host},
scripts/misc/mart_variation_effect.pl:        $config->{port}
scripts/misc/mart_variation_effect.pl:        ), $config->{user}, $config->{password}
scripts/misc/mart_variation_effect.pl:  my $version = $config->{version};
scripts/misc/mart_variation_effect.pl:  my $sth = $dbc->prepare(qq{ SHOW DATABASES LIKE '%\_variation\_$version%' });
scripts/misc/mart_variation_effect.pl:  $sth->execute();
scripts/misc/mart_variation_effect.pl:  $sth->bind_columns(\$db);
scripts/misc/mart_variation_effect.pl:  push @dbs, $db while $sth->fetch;
scripts/misc/mart_variation_effect.pl:  $sth->finish;
scripts/misc/mart_variation_effect.pl:  my $pattern = $config->{pattern};
scripts/misc/mart_variation_effect.pl:  #$_ =~ s/^([a-z]+\_[a-z]+)(.+)/$1/ for @dbs;
scripts/misc/mart_variation_effect.pl:    my $dbc = DBI->connect(
scripts/misc/mart_variation_effect.pl:          $config->{host},
scripts/misc/mart_variation_effect.pl:          $config->{port},
scripts/misc/mart_variation_effect.pl:          ), $config->{user}, $config->{password});
scripts/misc/mart_variation_effect.pl:    my $sth = $dbc->prepare(qq{SELECT * FROM $table LIMIT 1;});
scripts/misc/mart_variation_effect.pl:    $sth->execute();
scripts/misc/mart_variation_effect.pl:    while (my @row = $sth->fetchrow_array) {
scripts/misc/mart_variation_effect.pl:    $sth->finish();
scripts/misc/create_attrib_sql.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/create_attrib_sql.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/create_attrib_sql.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/create_attrib_sql.pl:    print "Usage: $0 --config <module> --host <host> --port <port> --user <user> --pass <pass> --db <database> --no_model --help > attrib_entries.sql\n";
scripts/misc/create_attrib_sql.pl:    $config->import(qw(
scripts/misc/create_attrib_sql.pl:# these hashes store the existing IDs from the database, if --no_model
scripts/misc/create_attrib_sql.pl:    my $dbh = DBI->connect(
scripts/misc/create_attrib_sql.pl:    my $get_types_sth = $dbh->prepare(qq{
scripts/misc/create_attrib_sql.pl:    $get_types_sth->execute;
scripts/misc/create_attrib_sql.pl:    while (my ($code, $id) = $get_types_sth->fetchrow_array) {
scripts/misc/create_attrib_sql.pl:        $existing_attrib_type->{$code} = $id;
scripts/misc/create_attrib_sql.pl:    my $get_attribs_sth = $dbh->prepare(qq{
scripts/misc/create_attrib_sql.pl:    $get_attribs_sth->execute;
scripts/misc/create_attrib_sql.pl:    while (my ($type_id, $value, $id) = $get_attribs_sth->fetchrow_array) {
scripts/misc/create_attrib_sql.pl:        $existing_attrib->{$type_id}->{$value} = $id;
scripts/misc/create_attrib_sql.pl:    my $get_sets_sth = $dbh->prepare(qq{
scripts/misc/create_attrib_sql.pl:    $get_sets_sth->execute;
scripts/misc/create_attrib_sql.pl:    while (my ($set_id, $attrib_id) = $get_sets_sth->fetchrow_array) {
scripts/misc/create_attrib_sql.pl:        $existing_set->{$set_id}->{$attrib_id} = 1;
scripts/misc/create_attrib_sql.pl:    my $id = $existing_attrib_type->{$code};
scripts/misc/create_attrib_sql.pl:        $existing_attrib_type->{$code} = $id
scripts/misc/create_attrib_sql.pl:    my $id = $existing_attrib->{$type_id}->{$value};
scripts/misc/create_attrib_sql.pl:        $existing_attrib->{$type_id}->{$value} = $id
scripts/misc/create_attrib_sql.pl:            return 0 unless $s1->{$e};
scripts/misc/create_attrib_sql.pl:        my $set = $existing_set->{$set_id};
scripts/misc/create_attrib_sql.pl:        if ($is_subset->($set, $new_set) || $is_subset->($new_set, $set)) {
scripts/misc/create_attrib_sql.pl:    map { $existing_set->{$last_attrib_set_id}->{$_} = 1 } keys %$new_set;
scripts/misc/create_attrib_sql.pl:    my $code        = delete $attrib_type->{code} or die "code required for attrib_type";
scripts/misc/create_attrib_sql.pl:    my $name        = delete $attrib_type->{name};
scripts/misc/create_attrib_sql.pl:    my $description = delete $attrib_type->{description};
scripts/misc/create_attrib_sql.pl:    $attrib_type_ids->{$code} = $attrib_type_id;
scripts/misc/create_attrib_sql.pl:# second, take the entries from the ATTRIBS and add them as single-element hashes to the @ATTRIB_SETS array
scripts/misc/create_attrib_sql.pl:        my $attrib_type_id = $attrib_type_ids->{$type} or next;
scripts/misc/order_tvs.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/order_tvs.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/order_tvs.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/order_tvs.pl:      $tid_hash{$prevtid}->{end} = $last-1;
scripts/misc/order_tvs.pl:  #    print "$prevtid " . $tid_hash{$prevtid}->{start} . " " . $tid_hash{$prevtid}->{end} . "\n";
scripts/misc/order_tvs.pl:    $tid_hash{$tid}->{start} = $last;
scripts/misc/order_tvs.pl:$tid_hash{$prevtid}->{end} = $last;
scripts/misc/order_tvs.pl:#print "$prevtid " . $tid_hash{$prevtid}->{start} . " " . $tid_hash{$prevtid}->{end} . "\n";
scripts/misc/order_tvs.pl:    seek(FP,$tid_hash{$id}->{start},0);
scripts/misc/order_tvs.pl:    read(FP, $data, $tid_hash{$id}->{end} - $tid_hash{$id}->{start} + 1);
scripts/misc/generate_mart_tables.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/generate_mart_tables.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/generate_mart_tables.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/generate_mart_tables.pl:# perl generate_mart_tables --host ensexa-03 --user ensadmin --port 3306 --database at7_pig_71_sift -password
scripts/misc/generate_mart_tables.pl:    die ("ERROR: $_ not defined, use --$_\n") unless defined $config->{$_};
scripts/misc/generate_mart_tables.pl:my $dbc = DBI->connect(sprintf("DBI:mysql(RaiseError=>1):host=%s;port=%s;db=%s",
scripts/misc/generate_mart_tables.pl:                        $config->{host},
scripts/misc/generate_mart_tables.pl:                        $config->{port},
scripts/misc/generate_mart_tables.pl:                        $config->{database}), $config->{user}, $config->{password});
scripts/misc/generate_mart_tables.pl:my $sth = $dbc->prepare(qq{SHOW TABLES LIKE 'MTMP_%'});
scripts/misc/generate_mart_tables.pl:$sth->execute();
scripts/misc/generate_mart_tables.pl:$sth->bind_columns(\$table);
scripts/misc/generate_mart_tables.pl:$tables->{$table} = 1 while $sth->fetch;
scripts/misc/generate_mart_tables.pl:$sth->finish;
scripts/misc/generate_mart_tables.pl:$sth = $dbc->prepare(qq{SHOW TABLES LIKE '%subsnp_map%'});
scripts/misc/generate_mart_tables.pl:$sth->execute();
scripts/misc/generate_mart_tables.pl:$sth->bind_columns(\$table);
scripts/misc/generate_mart_tables.pl:$tables->{$table} = 1 while $sth->fetch;
scripts/misc/generate_mart_tables.pl:$sth->finish;
scripts/misc/generate_mart_tables.pl:    if ($tables->{$mtmp_table}) {
scripts/misc/generate_mart_tables.pl:        $dbc->do(qq{DROP TABLE $mtmp_table;});
scripts/misc/generate_mart_tables.pl:    print $mtmp_tables->{$mtmp_table}->{'create'}, "\n";
scripts/misc/generate_mart_tables.pl:    $dbc->do($mtmp_tables->{$mtmp_table}->{'create'});
scripts/misc/generate_mart_tables.pl:    $dbc->do(qq{ALTER TABLE $mtmp_table DISABLE KEYS;});
scripts/misc/generate_mart_tables.pl:    print $mtmp_tables->{$mtmp_table}->{'insert'}, "\n";
scripts/misc/generate_mart_tables.pl:    $dbc->do($mtmp_tables->{$mtmp_table}->{'insert'});
scripts/misc/generate_mart_tables.pl:    $dbc->do(qq{ALTER TABLE $mtmp_table ENABLE KEYS;});
scripts/misc/generate_mart_tables.pl:    if ($mtmp_tables->{$mtmp_table}->{'index'}) {
scripts/misc/generate_mart_tables.pl:        $dbc->do($mtmp_tables->{$mtmp_table}->{'index'});
scripts/misc/release/gvf2vcf.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/release/gvf2vcf.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/release/gvf2vcf.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/release/gvf2vcf.pl:pod2usage(1) if ($config->{'help'} || !$args);
scripts/misc/release/gvf2vcf.pl:  if ($config->{'fasta_file'}) {
scripts/misc/release/gvf2vcf.pl:    my $fai_index = Bio::DB::HTS::Faidx->new($config->{'fasta_file'});
scripts/misc/release/gvf2vcf.pl:    $config->{fasta_index} = $fai_index;
scripts/misc/release/gvf2vcf.pl:    my $fh_vcf = FileHandle->new('> ' . $config->{vcf_file});
scripts/misc/release/gvf2vcf.pl:    $config->{fh} = $fh_vcf;
scripts/misc/release/gvf2vcf.pl:    my $fh = $config->{fh};
scripts/misc/release/gvf2vcf.pl:    $fh->close();
scripts/misc/release/gvf2vcf.pl:    my $registry_file = $config->{registry};
scripts/misc/release/gvf2vcf.pl:    die "Could not find registry_file $registry_file" unless (-e $registry_file);
scripts/misc/release/gvf2vcf.pl:    $registry->load_all($registry_file);
scripts/misc/release/gvf2vcf.pl:    my $ontology = $registry->get_adaptor( 'Multi', 'Ontology', 'OntologyTerm' );
scripts/misc/release/gvf2vcf.pl:    my $vdba = $registry->get_DBAdaptor($config->{species}, 'variation');
scripts/misc/release/gvf2vcf.pl:    my $cdba = $registry->get_DBAdaptor($config->{species}, 'core');
scripts/misc/release/gvf2vcf.pl:    $config->{vdba} = $vdba;
scripts/misc/release/gvf2vcf.pl:    $config->{cdba} = $cdba;
scripts/misc/release/gvf2vcf.pl:    $config->{slice_adaptor} = $cdba->get_SliceAdaptor;
scripts/misc/release/gvf2vcf.pl:    $config->{ontology_adaptor} = $ontology if ($ontology); 
scripts/misc/release/gvf2vcf.pl:    my $vdba = $config->{vdba};
scripts/misc/release/gvf2vcf.pl:    my $dbh = $vdba->dbc->db_handle;
scripts/misc/release/gvf2vcf.pl:    my $source_adaptor = $vdba->get_SourceAdaptor;   
scripts/misc/release/gvf2vcf.pl:    my $sources = $source_adaptor->fetch_all;
scripts/misc/release/gvf2vcf.pl:    if ($config->{structural_variations}) {
scripts/misc/release/gvf2vcf.pl:      my @source_data_types = @{$source->get_all_data_types};
scripts/misc/release/gvf2vcf.pl:        my $name = $source->name;
scripts/misc/release/gvf2vcf.pl:        my $desc = $source->description;
scripts/misc/release/gvf2vcf.pl:        my $version = $source->version;
scripts/misc/release/gvf2vcf.pl:        $source_to_desc->{$name} = $desc;
scripts/misc/release/gvf2vcf.pl:      my $sth = $dbh->prepare(qq{
scripts/misc/release/gvf2vcf.pl:      $sth->execute();
scripts/misc/release/gvf2vcf.pl:      $sth->bind_columns(\($source_name, $source_version, $source_desc));
scripts/misc/release/gvf2vcf.pl:      while ($sth->fetch) {
scripts/misc/release/gvf2vcf.pl:          $source_to_desc->{$source} = $source_desc;
scripts/misc/release/gvf2vcf.pl:      $sth->finish(); 
scripts/misc/release/gvf2vcf.pl:    $config->{source_to_desc} = $source_to_desc;
scripts/misc/release/gvf2vcf.pl:    $config->{abbr_to_evidence_value} = {
scripts/misc/release/gvf2vcf.pl:    $config->{evidence_value_to_abbr} = {
scripts/misc/release/gvf2vcf.pl:    $config->{clin_significance_to_abbr} = {
scripts/misc/release/gvf2vcf.pl:    $config->{abbr_to_clin_significance} = {
scripts/misc/release/gvf2vcf.pl:    $config->{svs_gvf2vcf} = {};
scripts/misc/release/gvf2vcf.pl:    if ($config->{structural_variations}) {
scripts/misc/release/gvf2vcf.pl:      my $sth = $dbh->prepare(qq/select distinct a.value from attrib a, structural_variation_feature svf where svf.class_attrib_id = a.attrib_id;/);
scripts/misc/release/gvf2vcf.pl:      $sth->execute() or die $sth->errstr;
scripts/misc/release/gvf2vcf.pl:      while (my $row = $sth->fetchrow_arrayref) {
scripts/misc/release/gvf2vcf.pl:        $sv_var_class_names->{$row->[0]} = 1;
scripts/misc/release/gvf2vcf.pl:      $sth->finish;
scripts/misc/release/gvf2vcf.pl:      my $ontology = $config->{ontology_adaptor};
scripts/misc/release/gvf2vcf.pl:        $config->{svs_gvf2vcf}->{$name} = $name;
scripts/misc/release/gvf2vcf.pl:          my $terms = $ontology->fetch_all_by_name($name, 'SO');
scripts/misc/release/gvf2vcf.pl:            $definition = $term->definition;
scripts/misc/release/gvf2vcf.pl:        $config->{header_sv_class}->{$name} = $definition;
scripts/misc/release/gvf2vcf.pl:    if ($config->{protein_coding_details}) {
scripts/misc/release/gvf2vcf.pl:    if ($config->{sift}) {
scripts/misc/release/gvf2vcf.pl:    if ($config->{polyhen}) {
scripts/misc/release/gvf2vcf.pl:    $config->{vep} = \@vep_consequence_info;
scripts/misc/release/gvf2vcf.pl:    if ($config->{ancestral_allele_file}) {
scripts/misc/release/gvf2vcf.pl:      my $ancestral_fai_index = Bio::DB::HTS::Faidx->new($config->{ancestral_allele_file});
scripts/misc/release/gvf2vcf.pl:      my $ancestral_allele_utils = Bio::EnsEMBL::Variation::Utils::AncestralAllelesUtils->new(-fasta_db => $ancestral_fai_index);
scripts/misc/release/gvf2vcf.pl:      $config->{ancestral_allele_utils} = $ancestral_allele_utils;  
scripts/misc/release/gvf2vcf.pl:  my $gvf_file = $config->{gvf_file};
scripts/misc/release/gvf2vcf.pl:    while ($fh_gvf->gzreadline($_) > 0) {
scripts/misc/release/gvf2vcf.pl:    $fh_gvf->gzclose(); 
scripts/misc/release/gvf2vcf.pl:    my $fh_gvf = FileHandle->new($gvf_file, 'r') or die "Error reading $gvf_file $!\n";
scripts/misc/release/gvf2vcf.pl:    $fh_gvf->close(); 
scripts/misc/release/gvf2vcf.pl:    $vcf_line->{'QUAL'} = '.';
scripts/misc/release/gvf2vcf.pl:    $vcf_line->{'FILTER'} = '.';
scripts/misc/release/gvf2vcf.pl:    my @dbxref = split(':', $gvf_line->{Dbxref}, 2);
scripts/misc/release/gvf2vcf.pl:    $vcf_line->{'ID'} = $variation_id;
scripts/misc/release/gvf2vcf.pl:    push @{$vcf_line->{INFO}}, $db;
scripts/misc/release/gvf2vcf.pl:    if ($config->{structural_variations}) {
scripts/misc/release/gvf2vcf.pl:    my $type_of_sequence_alteration = $gvf_line->{type};
scripts/misc/release/gvf2vcf.pl:    push @{$vcf_line->{INFO}}, "TSA=$type_of_sequence_alteration";
scripts/misc/release/gvf2vcf.pl:    if ($gvf_line->{evidence_values}) {
scripts/misc/release/gvf2vcf.pl:        push @{$vcf_line->{INFO}}, map { $config->{evidence_value_to_abbr}->{$_} } split(',', $gvf_line->{evidence_values});
scripts/misc/release/gvf2vcf.pl:    if ($gvf_line->{clinical_significance}) {
scripts/misc/release/gvf2vcf.pl:        push @{$vcf_line->{INFO}}, map { $config->{clin_significance_to_abbr}->{$_} } split(',', $gvf_line->{clinical_significance});
scripts/misc/release/gvf2vcf.pl:    if ($gvf_line->{global_minor_allele_frequency}) {
scripts/misc/release/gvf2vcf.pl:    if ($gvf_line->{Genotype}) {
scripts/misc/release/gvf2vcf.pl:    if ($config->{incl_consequences} && (!defined $gvf_line->{Variant_effect}) ) {
scripts/misc/release/gvf2vcf.pl:        push @{$vcf_line->{INFO}}, 'VE=intergenic_variant';
scripts/misc/release/gvf2vcf.pl:        if (defined $gvf_line->{$attribute}) {
scripts/misc/release/gvf2vcf.pl:            my $value = $gvf_line->{$attribute};
scripts/misc/release/gvf2vcf.pl:    if ($config->{incl_consequences}) {
scripts/misc/release/gvf2vcf.pl:    $gvf_line->{seq_id} = $seq_id;
scripts/misc/release/gvf2vcf.pl:    $gvf_line->{source} = $source;
scripts/misc/release/gvf2vcf.pl:    $gvf_line->{type} = $type;
scripts/misc/release/gvf2vcf.pl:    $gvf_line->{start} = $start;
scripts/misc/release/gvf2vcf.pl:    $gvf_line->{end} = $end;
scripts/misc/release/gvf2vcf.pl:    $gvf_line->{strand} = $strand;
scripts/misc/release/gvf2vcf.pl:        $gvf_line->{$key} = $value;
scripts/misc/release/gvf2vcf.pl:    my $sa = $config->{slice_adaptor};
scripts/misc/release/gvf2vcf.pl:    my $ref = $gvf_line->{Reference_seq};
scripts/misc/release/gvf2vcf.pl:    my $alt = $gvf_line->{Variant_seq};
scripts/misc/release/gvf2vcf.pl:    my $start = $gvf_line->{start};
scripts/misc/release/gvf2vcf.pl:    my $end = $gvf_line->{end};
scripts/misc/release/gvf2vcf.pl:    my $id = $gvf_line->{Dbxref};
scripts/misc/release/gvf2vcf.pl:    my $seq_region_name = $gvf_line->{seq_id};
scripts/misc/release/gvf2vcf.pl:    my $vf = Bio::EnsEMBL::Variation::VariationFeature->new(
scripts/misc/release/gvf2vcf.pl:        -start   => $start,
scripts/misc/release/gvf2vcf.pl:        -end     => $end,
scripts/misc/release/gvf2vcf.pl:        -slice => $slice,
scripts/misc/release/gvf2vcf.pl:        -strand  => 1,
scripts/misc/release/gvf2vcf.pl:        -allele_string => "$ref/$alt",
scripts/misc/release/gvf2vcf.pl:        -map_weight  => 1,
scripts/misc/release/gvf2vcf.pl:    my $vcf_record = $vf->to_VCF_record;
scripts/misc/release/gvf2vcf.pl:    my ($vcf_start, $vcf_ref, $vcf_alt) = ($vcf_record->[1], $vcf_record->[3], $vcf_record->[4]);
scripts/misc/release/gvf2vcf.pl:    my $ancestral_allele = $gvf_line->{ancestral_allele};
scripts/misc/release/gvf2vcf.pl:      if ($ancestral_allele && $config->{ancestral_allele_file}) {
scripts/misc/release/gvf2vcf.pl:        my $ancestral_allele_utils = $config->{ancestral_allele_utils};
scripts/misc/release/gvf2vcf.pl:        my $ancestral_allele_end = $start + length($vcf_ref) - 1;
scripts/misc/release/gvf2vcf.pl:        my $vcf_ancestral_allele = $ancestral_allele_utils->assign($seq_region_name, $start, $ancestral_allele_end);
scripts/misc/release/gvf2vcf.pl:        $gvf_line->{ancestral_allele} = $vcf_ancestral_allele;
scripts/misc/release/gvf2vcf.pl:    $vcf_line->{'#CHROM'} = $gvf_line->{seq_id};
scripts/misc/release/gvf2vcf.pl:    $vcf_line->{POS} = $vcf_start;
scripts/misc/release/gvf2vcf.pl:    $vcf_line->{REF} = $vcf_ref;
scripts/misc/release/gvf2vcf.pl:    $vcf_line->{ALT} = $vcf_alt;
scripts/misc/release/gvf2vcf.pl:    $vcf_line->{look_up} = ();
scripts/misc/release/gvf2vcf.pl:  my $region = "$seq_region_name:$start-$end";
scripts/misc/release/gvf2vcf.pl:  if ($config->{fasta_index}) {
scripts/misc/release/gvf2vcf.pl:    my $fasta_index = $config->{fasta_index};
scripts/misc/release/gvf2vcf.pl:    $seq = $fasta_index->get_sequence_no_length($region);
scripts/misc/release/gvf2vcf.pl:    my $sa = $config->{slice_adaptor};
scripts/misc/release/gvf2vcf.pl:    my $slice = $sa->fetch_by_toplevel_location($region);
scripts/misc/release/gvf2vcf.pl:    $seq = $slice->seq();
scripts/misc/release/gvf2vcf.pl:    my $repeat = ($end - $start + 1);
scripts/misc/release/gvf2vcf.pl:  my $slice = $config->{slice}->{$seq_region_name};
scripts/misc/release/gvf2vcf.pl:    my $sa = $config->{slice_adaptor};
scripts/misc/release/gvf2vcf.pl:    my $slice = $sa->fetch_by_toplevel_location($seq_region_name);
scripts/misc/release/gvf2vcf.pl:    $config->{slice}->{$seq_region_name} = $slice;
scripts/misc/release/gvf2vcf.pl:  return $config->{slice}->{$seq_region_name};
scripts/misc/release/gvf2vcf.pl:    my ($index, $frequency, $count) = split("\\|", $gvf_line->{global_minor_allele_frequency});
scripts/misc/release/gvf2vcf.pl:            $minor_allele = $vcf_line->{REF};
scripts/misc/release/gvf2vcf.pl:            my @alleles = split(',', $gvf_line->{Variant_seq});
scripts/misc/release/gvf2vcf.pl:            $minor_allele = $alleles[$index - 1];
scripts/misc/release/gvf2vcf.pl:        push @{$vcf_line->{INFO}}, ("MA=$minor_allele", "MAF=$frequency", "MAC=$count");
scripts/misc/release/gvf2vcf.pl:    my @gvf_alleles = split(',', $gvf_line->{Variant_seq});
scripts/misc/release/gvf2vcf.pl:    my @gvf_genotype_idxs = split(':', $gvf_line->{Genotype});
scripts/misc/release/gvf2vcf.pl:    my $look_up = $vcf_line->{look_up};
scripts/misc/release/gvf2vcf.pl:    my $ref = $vcf_line->{REF};
scripts/misc/release/gvf2vcf.pl:    my $alt = $vcf_line->{ALT};
scripts/misc/release/gvf2vcf.pl:        if ($look_up->{$a}) {
scripts/misc/release/gvf2vcf.pl:            $look_up_pos{$look_up->{$a}} = $i;
scripts/misc/release/gvf2vcf.pl:    $vcf_line->{FORMAT} = 'GT';
scripts/misc/release/gvf2vcf.pl:    $vcf_line->{SAMPLE} = $genotypes;
scripts/misc/release/gvf2vcf.pl:  my @alleles = split(',', $gvf_line->{Variant_seq});  
scripts/misc/release/gvf2vcf.pl:  my $id = $vcf_line->{ID};
scripts/misc/release/gvf2vcf.pl:  my @values = split(',', ($gvf_line->{Variant_effect} || ''));
scripts/misc/release/gvf2vcf.pl:        $allele2consequence->{$allele}->{$feature_id}->{Consequence} = $consequence;
scripts/misc/release/gvf2vcf.pl:        $allele2consequence->{$allele}->{$feature_id}->{Feature_type} = $feature_type;
scripts/misc/release/gvf2vcf.pl:        $allele2consequence->{$allele}->{$feature_id}->{Allele} = $allele;
scripts/misc/release/gvf2vcf.pl:        $allele2consequence->{$allele}->{$feature_id}->{Feature} = $feature_id;
scripts/misc/release/gvf2vcf.pl:  @values = split(',', ($gvf_line->{sift_prediction} || ''));
scripts/misc/release/gvf2vcf.pl:        $allele2consequence->{$allele}->{$feature_id}->{SIFT} = "$prediction($numerical_value)";
scripts/misc/release/gvf2vcf.pl:  @values = split(',', ($gvf_line->{polyphen_prediction} || ''));
scripts/misc/release/gvf2vcf.pl:        $allele2consequence->{$allele}->{$feature_id}->{PolyPhen} = "$prediction($numerical_value)";
scripts/misc/release/gvf2vcf.pl:  my $ref_pep = $gvf_line->{reference_peptide};
scripts/misc/release/gvf2vcf.pl:  @values = split(',', ($gvf_line->{variant_peptide} || ''));
scripts/misc/release/gvf2vcf.pl:        $allele2consequence->{$allele}->{$feature_id}->{Amino_acids} = "$ref_pep/$amino_acid";
scripts/misc/release/gvf2vcf.pl:  my @vep_consequence_info = @{$config->{vep}};
scripts/misc/release/gvf2vcf.pl:      foreach my $feature_id (keys %{$allele2consequence->{$allele}}) {
scripts/misc/release/gvf2vcf.pl:          my $field_value = $allele2consequence->{$allele}->{$feature_id}->{$info_field} || '';
scripts/misc/release/gvf2vcf.pl:          push @{$vcf_line->{INFO}}, "$key=$values";
scripts/misc/release/gvf2vcf.pl:          push @{$vcf_line->{INFO}}, "$key=$value";
scripts/misc/release/gvf2vcf.pl:    my $seq_region_name = $gvf_line->{seq_id};
scripts/misc/release/gvf2vcf.pl:    my $start = $gvf_line->{start};
scripts/misc/release/gvf2vcf.pl:    my $end = $gvf_line->{end};
scripts/misc/release/gvf2vcf.pl:    my $pos = $start - 1 ;
scripts/misc/release/gvf2vcf.pl:    $vcf_line->{'#CHROM'} = $gvf_line->{seq_id};
scripts/misc/release/gvf2vcf.pl:    $vcf_line->{REF} = $base;
scripts/misc/release/gvf2vcf.pl:    $vcf_line->{POS} = $pos;
scripts/misc/release/gvf2vcf.pl:    my $gvf_svs_type = $gvf_line->{type};
scripts/misc/release/gvf2vcf.pl:    my $vcf_svs_type = $config->{svs_gvf2vcf}->{$gvf_svs_type};
scripts/misc/release/gvf2vcf.pl:    $vcf_line->{ALT} = '<' . $vcf_svs_type . '>';
scripts/misc/release/gvf2vcf.pl:    push @{$vcf_line->{INFO}}, ("SVTYPE=$vcf_svs_type", "END=$end");
scripts/misc/release/gvf2vcf.pl:    if ($gvf_line->{study_accession}) {
scripts/misc/release/gvf2vcf.pl:        my $study_acc = $gvf_line->{study_accession};
scripts/misc/release/gvf2vcf.pl:        push @{$vcf_line->{INFO}}, "ST_ACC=$study_acc";
scripts/misc/release/gvf2vcf.pl:    if ($gvf_line->{Parent}) {
scripts/misc/release/gvf2vcf.pl:        my $parent = $gvf_line->{Parent};
scripts/misc/release/gvf2vcf.pl:        push @{$vcf_line->{INFO}}, "Parent=$parent";
scripts/misc/release/gvf2vcf.pl:    if ($gvf_line->{End_range} || $gvf_line->{Start_range}) {
scripts/misc/release/gvf2vcf.pl:         push @{$vcf_line->{INFO}}, "IMPRECISE";
scripts/misc/release/gvf2vcf.pl:    my $fh = $config->{fh};
scripts/misc/release/gvf2vcf.pl:        $all_fields_defined = 0 unless (defined $vcf_line->{$abbr});
scripts/misc/release/gvf2vcf.pl:        push @output, $vcf_line->{$abbr};
scripts/misc/release/gvf2vcf.pl:    my $info = join(';', @{$vcf_line->{INFO}}) || '';
scripts/misc/release/gvf2vcf.pl:    if ($vcf_line->{FORMAT}) {
scripts/misc/release/gvf2vcf.pl:            push @output, $vcf_line->{$abbr};
scripts/misc/release/gvf2vcf.pl:    my $fh = $config->{fh};
scripts/misc/release/gvf2vcf.pl:    my $sa = $config->{slice_adaptor};
scripts/misc/release/gvf2vcf.pl:    my $slices = $sa->fetch_all('toplevel', undef, 0, 1);
scripts/misc/release/gvf2vcf.pl:    my $mca = $slices->[0]->adaptor->db->get_MetaContainerAdaptor;
scripts/misc/release/gvf2vcf.pl:    my $schema_version = $mca->get_schema_version;
scripts/misc/release/gvf2vcf.pl:    my $species_name = $mca->get_scientific_name;
scripts/misc/release/gvf2vcf.pl:    my ($division) = @{$mca->list_value_by_key('species.division')};
scripts/misc/release/gvf2vcf.pl:    my $reference_info = "https://ftp.ensembl.org/pub/release-$schema_version/fasta/$species_name/dna/";
scripts/misc/release/gvf2vcf.pl:    # Meta-information
scripts/misc/release/gvf2vcf.pl:    while (my ($source, $desc) = each %{$config->{source_to_desc}}) {
scripts/misc/release/gvf2vcf.pl:    unless ($config->{structural_variations}) {
scripts/misc/release/gvf2vcf.pl:    if ($config->{evidence}) {
scripts/misc/release/gvf2vcf.pl:        while (my($abbr, $evidence_value) = each %{$config->{abbr_to_evidence_value}}) {
scripts/misc/release/gvf2vcf.pl:    if ($config->{clinical_significance}) {
scripts/misc/release/gvf2vcf.pl:        while (my($abbr, $clin_significance) = each %{$config->{abbr_to_clin_significance}}) {
scripts/misc/release/gvf2vcf.pl:    if ($config->{global_maf}) {
scripts/misc/release/gvf2vcf.pl:    if ($config->{ancestral_allele}) {
scripts/misc/release/gvf2vcf.pl:    if ($config->{incl_consequences}) {
scripts/misc/release/gvf2vcf.pl:        $consequence_desc->{'VE'} = {
scripts/misc/release/gvf2vcf.pl:    if ($config->{protein_coding_details}) {
scripts/misc/release/gvf2vcf.pl:        $consequence_desc->{'VarPep'} = {
scripts/misc/release/gvf2vcf.pl:        $consequence_desc->{'RefPep'} = {
scripts/misc/release/gvf2vcf.pl:    if ($config->{sift}) {
scripts/misc/release/gvf2vcf.pl:        $consequence_desc->{'Sift'} = {
scripts/misc/release/gvf2vcf.pl:    if ($config->{polyphen}) {
scripts/misc/release/gvf2vcf.pl:        $consequence_desc->{'Polyphen'} = {
scripts/misc/release/gvf2vcf.pl:        if ($consequence_desc->{$abbr}) {
scripts/misc/release/gvf2vcf.pl:            my $type = $consequence_desc->{$abbr}->{Type};
scripts/misc/release/gvf2vcf.pl:            my $number = $consequence_desc->{$abbr}->{Number};
scripts/misc/release/gvf2vcf.pl:            my $desc = $consequence_desc->{$abbr}->{Desc};
scripts/misc/release/gvf2vcf.pl:    if ($config->{incl_consequences}) { 
scripts/misc/release/gvf2vcf.pl:      my @vep_fields = @{$config->{vep}};
scripts/misc/release/gvf2vcf.pl:    if ($config->{structural_variations}) {
scripts/misc/release/gvf2vcf.pl:        foreach my $name (sort keys %{$config->{header_sv_class}}) {
scripts/misc/release/gvf2vcf.pl:          my $definition = $config->{header_sv_class}->{$name};
scripts/misc/release/gvf2vcf.pl:    if ($config->{individual}) {
scripts/misc/release/gvf2vcf.pl:=item B<--help>
scripts/misc/release/gvf2vcf.pl:=item B<--gvf_file FILE>
scripts/misc/release/gvf2vcf.pl:=item B<--vcf_file FILE>
scripts/misc/release/gvf2vcf.pl:=item B<--species >
scripts/misc/release/gvf2vcf.pl:=item B<--registry FILE>
scripts/misc/release/gvf2vcf.pl:=item B<--fasta_file FILE>
scripts/misc/release/gvf2vcf.pl:=item B<--ancestral_allele|aa>
scripts/misc/release/gvf2vcf.pl:=item B<--ancestral_allele_file FILE>
scripts/misc/release/gvf2vcf.pl:=item B<--global_maf>
scripts/misc/release/gvf2vcf.pl:=item B<--evidence>
scripts/misc/release/gvf2vcf.pl:=item B<--clinical_significance>
scripts/misc/release/gvf2vcf.pl:=item B<--structural_variations|svs>
scripts/misc/release/gvf2vcf.pl:=item B<--incl_consequences>
scripts/misc/release/gvf2vcf.pl:=item B<--protein_coding_details>
scripts/misc/release/gvf2vcf.pl:=item B<--sift>
scripts/misc/release/gvf2vcf.pl:=item B<--polyphen>
scripts/misc/release/gvf2vcf.pl:=item B<--individual STRING>
scripts/misc/phensources2html.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/phensources2html.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/phensources2html.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/phensources2html.pl:  print STDERR "> Error! Please give an Ensembl version, using the option '-v' \n";
scripts/misc/phensources2html.pl:  print STDERR "> Error! Please give an output file using the option '-o'\n";
scripts/misc/phensources2html.pl:  print STDERR "> Error! Please give host name where the previous databases are stored using the option '-phost'\n";
scripts/misc/phensources2html.pl:  print STDERR "> Error! Please give the list of host names where the new databases are stored using the option '-hlist'\n";
scripts/misc/phensources2html.pl:my $img_class    = "badge-48";
scripts/misc/phensources2html.pl:my $img_class_sm = "badge-16";
scripts/misc/phensources2html.pl:    <h1 style="margin-top:15px">Ensembl Variation - Phenotype sources</h1>
scripts/misc/phensources2html.pl:    <h2>List of sources providing phenotype/disease/trait associations for each species - $ecaption $e_version</h2>
scripts/misc/phensources2html.pl:    <div style="margin-bottom:20px">
scripts/misc/phensources2html.pl:  while (my ($dbname) = $sth->fetchrow_array) {
scripts/misc/phensources2html.pl:    next if ($dbname !~ /^[a-z][a-z_]*_[a-z]+_variation_\d+_\d+$/i);
scripts/misc/phensources2html.pl:    if ($etype) { # EG site - need to filter out species
scripts/misc/phensources2html.pl:      my $img_thumb = sprintf qq{eg-plugins/%s/htdocs/img/species/thumb_%s.png}, $etype, ucfirst($s_name);
scripts/misc/phensources2html.pl:      if (! -e $img_thumb) {
scripts/misc/phensources2html.pl:      $display_name = $sth_core->fetchrow_array;  
scripts/misc/phensources2html.pl:  print STDERR "- $display_name ($s_name) ...";
scripts/misc/phensources2html.pl:  $sth2->bind_columns(\$source_id,\$source,\$s_version,\$s_description,\$s_url,\$s_type,\$s_status,\$s_data_types,\$s_order);
scripts/misc/phensources2html.pl:  my $p_version = $e_version-1;
scripts/misc/phensources2html.pl:  my $p_dbname = $sth3->fetchrow_array;
scripts/misc/phensources2html.pl:    while (my @p = $sth4->fetchrow_array) {
scripts/misc/phensources2html.pl:    <div style="background-color:#F0F0F0;margin:50px 0px 25px;padding:5px;border-top:2px solid #22949b;border-bottom:1px solid #22949b">
scripts/misc/phensources2html.pl:  my $html = qq{<!-- $display_name ($species) -->};
scripts/misc/phensources2html.pl:    <div style="padding-bottom:1px">
scripts/misc/phensources2html.pl:        <a href="/$s_name/Info/Index" title="$display_name Ensembl Home page" style="vertical-align:middle" target="_blank"><img src="/i/species/$s_name.png" alt="$display_name" class="$img_class" style="float:none;margin-right:0px;padding-right:0px;vertical-align:middle;background-color:#00F" /></a><h2 id="$s_name_id" style="display:inline;vertical-align:middle;margin-left:5px;padding:8px;background-color:#F0F0F0;color:#22949b">$display_name<span class="small vdoc_species_sci_name"> ($species)</span></h2><span style="padding-left:20px;color:#00F;font-weight:bold">New species!</span>
scripts/misc/phensources2html.pl:        <img src="$phen_icon" style="border-radius:5px;border:1px solid #000;vertical-align:middle"/>
scripts/misc/phensources2html.pl:        <span style="font-weight:bold;vertical-align:middle;margin-left:5px;color:#333" class="_ht ht" title="$count_phen phenotype(s)/disease(s)/trait(s) available for $display_name">$count_phen</span></span>
scripts/misc/phensources2html.pl:    <div style="padding-bottom:3px">
scripts/misc/phensources2html.pl:        <a target="_blank" href="/$s_name/Info/Index" title="$display_name Ensembl Home page" style="vertical-align:middle"><img src="/i/species/$s_name.png" alt="$display_name" class="$img_class" style="float:none;margin-right:0px;padding-right:0px;vertical-align:middle;border-color:#22949b" /></a><h2 id="$s_name_id" style="display:inline;vertical-align:middle;margin-left:5px;padding:8px;background-color:#F0F0F0;color:#22949b">$display_name<span class="small vdoc_species_sci_name"> ($species)</span></h2>
scripts/misc/phensources2html.pl:        <img src="$phen_icon" style="border-radius:5px;border:1px solid #000;vertical-align:middle"/>
scripts/misc/phensources2html.pl:        <span style="font-weight:bold;vertical-align:middle;margin-left:5px;color:#333" class="_ht ht" title="$count_phen phenotype(s) available for $display_name">$count_phen</span></span>
scripts/misc/phensources2html.pl:  while ($sth->fetch) {
scripts/misc/phensources2html.pl:    elsif ($p_list->{$source} ne $s_version){
scripts/misc/phensources2html.pl:      my $borders = ";border-top:1px solid #FFF;border-bottom:1px solid #FFF";
scripts/misc/phensources2html.pl:      $s_header .= ';background-color:'.$colours{$s_new_type};
scripts/misc/phensources2html.pl:      $source = qq{<a href="$s_url" style="text-decoration:none" target="_blank">$source</a>};
scripts/misc/phensources2html.pl:    foreach my $type (keys %{$counts_species->{$source_id}}) {
scripts/misc/phensources2html.pl:      my $count = $counts_species->{$source_id}{$type};
scripts/misc/phensources2html.pl:    $data_type_string = '-' if ($data_type_string eq '');
scripts/misc/phensources2html.pl:    $version = '-';
scripts/misc/phensources2html.pl:  my $dbh = DBI->connect($dsn, $login, $pswd) or die "Connection failed";
scripts/misc/phensources2html.pl:  my $sth = $dbh->prepare($sql);
scripts/misc/phensources2html.pl:    $sth->execute(@$params);
scripts/misc/phensources2html.pl:    $sth->execute;
scripts/misc/phensources2html.pl:  <!-- Right hand side menu -->
scripts/misc/phensources2html.pl:        <img src="/i/16/info.png" style="vertical-align:top" alt="info" /> 
scripts/misc/phensources2html.pl:    $html .= qq{    <div><span class="$v_colour vdoc_source_count" style="margin-left:5px">#</span><small> : $v_label</small></div>};
scripts/misc/phensources2html.pl:    $html .= qq{    <div><span class="$s_colour vdoc_source_count" style="margin-left:5px">#</span><small> : $s_label</small></div>};
scripts/misc/phensources2html.pl:    <!-- Legend header -->
scripts/misc/phensources2html.pl:        <img src="/i/16/info.png" style="vertical-align:top" />
scripts/misc/phensources2html.pl:        <a href="#top" style="text-decoration:none">[Top]</a>
scripts/misc/phensources2html.pl:    <!-- Main legend -->
scripts/misc/phensources2html.pl:        <td style="padding-top:6px;text-align:center;width:25px">
scripts/misc/phensources2html.pl:        <td style="padding-top:4px"><b>New version</b> of the data<br />source in this release<br />for the species</td>
scripts/misc/phensources2html.pl:        <td style="padding-top:6px;text-align:center;width:25px">
scripts/misc/phensources2html.pl:        <td style="padding-top:4px"><b>New data source</b> in this<br />release for the species</td>
scripts/misc/phensources2html.pl:    <!-- Phenotype associations count colour legend -->
scripts/misc/phensources2html.pl:    <div style="border-top:1px dotted #22949b;margin-top:2px;padding:4px 0px 0px">
scripts/misc/phensources2html.pl:      <span style="padding-left:4px;font-weight:bold">Associations count:</span>
scripts/misc/phensources2html.pl:          <td style="padding-top:4px;text-align:center">
scripts/misc/phensources2html.pl:          <td style="padding-top:4px">greater than 100 million</td>
scripts/misc/phensources2html.pl:          <td style="padding-top:4px;text-align:center">
scripts/misc/phensources2html.pl:          <td style="padding-top:4px">from 10 to 99.9 million</td>
scripts/misc/phensources2html.pl:          <td style="padding-top:4px;text-align:center">
scripts/misc/phensources2html.pl:          <td style="padding-top:4px">from 1 million to 9.9 million</td>
scripts/misc/phensources2html.pl:          <td style="padding-top:3px;text-align:center">
scripts/misc/phensources2html.pl:          <td style="padding-top:3px">from 1,000 to 999,999</td>
scripts/misc/phensources2html.pl:          <td style="padding-top:3px;text-align:center">
scripts/misc/phensources2html.pl:          <td style="padding-top:3px">less than 1,000</td>
scripts/misc/phensources2html.pl:    <!-- Javascript used to fix the legend on the right handside when you scroll down -->
scripts/misc/phensources2html.pl:        if (window.pageYOffset-80 > legend_element_pos)  {
scripts/misc/phensources2html.pl:  my $name    = $species->{name};
scripts/misc/phensources2html.pl:  my $display = $species->{display};
scripts/misc/phensources2html.pl:  my $s_name  = $species->{s_name};
scripts/misc/phensources2html.pl:  my $anchor  = $species->{anchor};
scripts/misc/phensources2html.pl:  if ($species_news{$species->{name}}) {
scripts/misc/phensources2html.pl:      next if (!$species_news{$species->{name}}{$type});
scripts/misc/phensources2html.pl:      my $count_type = $species_news{$species->{name}}{$type};
scripts/misc/phensources2html.pl:      my $label_desc = "$count_type ".lc($desc->{$type});
scripts/misc/phensources2html.pl:      <img src="/i/species/$s_name.png" alt="$display" class="$img_class_sm" style="margin-right:4px;vertical-align:middle" />
scripts/misc/phensources2html.pl:      <a href="#$anchor" style="margin-right:3px;text-decoration:none;vertical-align:middle" title="$name">$display</a>
scripts/misc/phensources2html.pl:          <div style="color:$color;font-size:0.8em;text-align:center;margin:0px auto 0px auto;padding:0px">
scripts/misc/phensources2html.pl:            <span style="text-align:center;margin:0px;padding:0px">New</span><br /><span style="text-align:center;margin:0px;padding:0px">$type</span>
scripts/misc/phensources2html.pl:  my $border_color = qq{style="border-color:#22949b"};
scripts/misc/phensources2html.pl:     <th class="vdoc_data_types vdoc_extra_column" style="background-color:#BBB">Phenotype/Disease/Trait
scripts/misc/phensources2html.pl:         <div class="vdoc_type_style" style="text-align:center"><span class="_ht ht" $border_color title="Feature type association"><small>Type</small></span></div>
scripts/misc/phensources2html.pl:         <div class="vdoc_count_style" style="text-align:center"><span class="_ht ht" $border_color title="Phenotype associations count"><small>Count</small></span></div>
scripts/misc/phensources2html.pl:        <tr><th colspan="2">$name</th><th>Version</th><th style="max-width:800px">Description</th>$data_type_header</th></tr>
scripts/misc/phensources2html.pl:        <td style="font-weight:bold">$source</td>
scripts/misc/phensources2html.pl:        <td style="max-width:800px">$desc</td>
scripts/misc/phensources2html.pl:  my $sql = $data_types->{'count_spe'};
scripts/misc/phensources2html.pl:    while (my ($source_id,$type,$count) = $sth->fetchrow_array) {
scripts/misc/phensources2html.pl:    $sth->finish();
scripts/misc/phensources2html.pl:  my $sql = $data_types->{'count'};
scripts/misc/phensources2html.pl:    $count = ($sth->fetchrow_array)[0];
scripts/misc/phensources2html.pl:    $sth->finish();
scripts/misc/phensources2html.pl:    my @result  = $sth->fetchrow_array;
scripts/misc/phensources2html.pl:    -help           Print this message
scripts/misc/phensources2html.pl:    -v              Ensembl version, e.g. 65 (Required)
scripts/misc/phensources2html.pl:    -o              An HTML output file name (Required)      
scripts/misc/phensources2html.pl:    -phost          Host name (with port) where the previous databases are stored, e.g. ensembldb.ensembl.org:3306  (Required)
scripts/misc/phensources2html.pl:    -hlist          The list of host names (with port) where the new databases are stored, separated by a coma,
scripts/misc/phensources2html.pl:    -skip_name      Flag to avoid the connection to the Core databases (use to retrieve the species display name, e.g. Human).
scripts/misc/phensources2html.pl:    -site           The URL of the website (optional)
scripts/misc/phensources2html.pl:    -etype          The type of Ensembl, e.g. Plant (optional)
scripts/misc/rationalise_phenotypes.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/rationalise_phenotypes.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/rationalise_phenotypes.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/rationalise_phenotypes.pl:if($config->{help}) {
scripts/misc/rationalise_phenotypes.pl:$config->{port} ||= 3306;
scripts/misc/rationalise_phenotypes.pl:  die "ERROR: --$_ not defined\n" unless defined($config->{$_});
scripts/misc/rationalise_phenotypes.pl:  $config->{db},
scripts/misc/rationalise_phenotypes.pl:  $config->{host},
scripts/misc/rationalise_phenotypes.pl:  $config->{port}
scripts/misc/rationalise_phenotypes.pl:my $dbc = DBI->connect(
scripts/misc/rationalise_phenotypes.pl:  $config->{user},
scripts/misc/rationalise_phenotypes.pl:  $config->{password},
scripts/misc/rationalise_phenotypes.pl:my $sth = $dbc->prepare("SELECT phenotype_id, LCASE(description) FROM phenotype");
scripts/misc/rationalise_phenotypes.pl:$sth->execute();
scripts/misc/rationalise_phenotypes.pl:$sth->bind_columns(\$id, \$desc);
scripts/misc/rationalise_phenotypes.pl:$descs{$id} = $desc while($sth->fetch());
scripts/misc/rationalise_phenotypes.pl:$sth->finish();
scripts/misc/rationalise_phenotypes.pl:$sth = $dbc->prepare("SELECT phenotype_id, LCASE(name) FROM phenotype WHERE name is not null AND name!=description");
scripts/misc/rationalise_phenotypes.pl:$sth->execute();
scripts/misc/rationalise_phenotypes.pl:$sth->bind_columns(\$id2, \$name);
scripts/misc/rationalise_phenotypes.pl:$names{$id2} = $name while($sth->fetch());
scripts/misc/rationalise_phenotypes.pl:$sth->finish();
scripts/misc/rationalise_phenotypes.pl:$dbc->do(qq{
scripts/misc/rationalise_phenotypes.pl:# $dbc->do(qq{TRUNCATE TABLE $table_phe_map});
scripts/misc/rationalise_phenotypes.pl:$sth = $dbc->prepare("INSERT INTO $table_phe_map (old_phenotype_id, new_phenotype_id) VALUES (?, ?)");
scripts/misc/rationalise_phenotypes.pl:  my $entry = (scalar @{$denormalised{$normal}} > 1) ? $normal : $denormalised{$normal}->[0];
scripts/misc/rationalise_phenotypes.pl:    @sort = map {$_->{string}} sort {$a->{string} <=> $b->{string} || $a->{length} <=> $b->{length}} @sort;
scripts/misc/rationalise_phenotypes.pl:      $sth->execute($id_by_desc{$_}, $new_id);
scripts/misc/rationalise_phenotypes.pl:    $sth->execute($id_by_desc{$entry}, $new_id);
scripts/misc/rationalise_phenotypes.pl:$sth->finish();
scripts/misc/rationalise_phenotypes.pl:  $dbc->do(qq{
scripts/misc/rationalise_phenotypes.pl:  $dbc->do(qq{
scripts/misc/rationalise_phenotypes.pl:  $dbc->do(qq{
scripts/misc/rationalise_phenotypes.pl:  $dbc->do(qq{
scripts/misc/rationalise_phenotypes.pl:  $dbc->do(qq{
scripts/misc/rationalise_phenotypes.pl:  $dbc->do(qq{
scripts/misc/rationalise_phenotypes.pl:  $a = $dbc->do(qq{
scripts/misc/rationalise_phenotypes.pl:  $a = $dbc->do(qq{
scripts/misc/rationalise_phenotypes.pl:  $a = $dbc->do(qq{
scripts/misc/rationalise_phenotypes.pl:  $a = $dbc->do(qq{
scripts/misc/rationalise_phenotypes.pl:  $dbc->do(qq{DROP TABLE $table_phe_map});
scripts/misc/rationalise_phenotypes.pl:  my $sthc = $dbc->prepare("SELECT count(*) FROM $table");
scripts/misc/rationalise_phenotypes.pl:  $sthc->execute();
scripts/misc/rationalise_phenotypes.pl:  my $count = ($sthc->fetchrow_array)[0];
scripts/misc/rationalise_phenotypes.pl:  $sthc->finish();
scripts/misc/rationalise_phenotypes.pl:#---------------------------#
scripts/misc/rationalise_phenotypes.pl:#---------------------------#
scripts/misc/rationalise_phenotypes.pl:perl rationalise_phenotypes.pl -h [host] -u [user] -p [pass] -P [port] -d [database]
scripts/misc/create_MTMP_tables.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/create_MTMP_tables.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/create_MTMP_tables.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/create_MTMP_tables.pl:## evidence tables are always re-created even if present (may change)
scripts/misc/create_MTMP_tables.pl:##    - the population genotype table is not created for human
scripts/misc/create_MTMP_tables.pl:    my $dbh = Bio::EnsEMBL::DBSQL::DBConnection->new(
scripts/misc/create_MTMP_tables.pl:      -user   => $user,
scripts/misc/create_MTMP_tables.pl:      -dbname => $db_name,
scripts/misc/create_MTMP_tables.pl:      -host   => $host,
scripts/misc/create_MTMP_tables.pl:      -pass => $pass,
scripts/misc/create_MTMP_tables.pl:      -driver => 'mysql',
scripts/misc/create_MTMP_tables.pl:      -port => $port,
scripts/misc/create_MTMP_tables.pl:    $dbh->do(qq[drop table if exists MTMP_evidence]);    
scripts/misc/create_MTMP_tables.pl:    $dbh->do( qq[ create table MTMP_evidence (
scripts/misc/create_MTMP_tables.pl:    my $ev_ext_sth  = $dbh->prepare(qq[ select variation_id, evidence_attribs from variation ]);
scripts/misc/create_MTMP_tables.pl:    my $ev_ins_sth  = $dbh->prepare(qq[ insert into  MTMP_evidence variation_id ,evidence
scripts/misc/create_MTMP_tables.pl:    $ev_ext_sth->{mysql_use_result} = 1;
scripts/misc/create_MTMP_tables.pl:    $ev_ext_sth->execute()||die ;
scripts/misc/create_MTMP_tables.pl:    while ( my $aref = $ev_ext_sth->fetchrow_arrayref() ) {
scripts/misc/create_MTMP_tables.pl:        unless(defined $aref->[1]){
scripts/misc/create_MTMP_tables.pl:            print $out "$aref->[0]\t\\N\n";
scripts/misc/create_MTMP_tables.pl:        my @ev_old = split/\,/, $aref->[1];
scripts/misc/create_MTMP_tables.pl:            die "No id for $old\n" unless defined  $evidence_id->{$old}; 
scripts/misc/create_MTMP_tables.pl:            push @ev_new, $evidence_id->{$old};             
scripts/misc/create_MTMP_tables.pl:        print $out "$aref->[0]\t$new\n";
scripts/misc/create_MTMP_tables.pl:    $dbh->do( qq[ LOAD DATA LOCAL INFILE "$tmpdir/$filename" INTO TABLE  MTMP_evidence]) || die "Error loading $filename data \n";
scripts/misc/create_MTMP_tables.pl:  my $att_ext_sth  = $dbh->prepare(qq[ select attrib.attrib_id, attrib.value
scripts/misc/create_MTMP_tables.pl:  $att_ext_sth->execute()||die "Failed to get evidence attribs\n";
scripts/misc/create_MTMP_tables.pl:  my $attdata = $att_ext_sth->fetchall_arrayref();
scripts/misc/create_MTMP_tables.pl:    $ids{$l->[0]} = $l->[1];
scripts/misc/create_MTMP_tables.pl:    $type_string .= "'". $l->[1] . "'," 
scripts/misc/create_MTMP_tables.pl:    my $dbh = DBI->connect( "dbi:mysql:$db_name\:$host\:$port", $user, $pass, undef) ||die "Failed to connect to $db_name\n";
scripts/misc/create_MTMP_tables.pl:    ## no need to re-create if the table is already present for a new import
scripts/misc/create_MTMP_tables.pl:    my $check_present_sth = $dbh->prepare(qq[show tables like 'MTMP_population_genotype']);
scripts/misc/create_MTMP_tables.pl:    $check_present_sth->execute()||die "Failed to check for existing tables \n";
scripts/misc/create_MTMP_tables.pl:    my $dat = $check_present_sth->fetchall_arrayref();
scripts/misc/create_MTMP_tables.pl:    next if $dat->[0]->[0] eq 'MTMP_population_genotype';
scripts/misc/create_MTMP_tables.pl:    $dbh->do(qq[CREATE TABLE `MTMP_population_genotype` (
scripts/misc/create_MTMP_tables.pl:    $dbh->do(qq[INSERT IGNORE INTO MTMP_population_genotype
scripts/misc/create_MTMP_tables.pl:    my $dbh = DBI->connect( "dbi:mysql:$db_name\:$host\:$port", $user, $pass, undef) || die "Failed to connect to $db_name\n";
scripts/misc/create_MTMP_tables.pl:    $dbh->do(qq[ drop table if exists $mtmp_table_name ]);   
scripts/misc/create_MTMP_tables.pl:    $dbh->do(qq[ create table $mtmp_table_name like $table ])|| die "Failed to create MTMP_$table" ;
scripts/misc/create_MTMP_tables.pl:    ## copy direct variant <-> set relationships
scripts/misc/create_MTMP_tables.pl:    $dbh->do(qq[ insert into $mtmp_table_name select * from $table ])
scripts/misc/create_MTMP_tables.pl:    ## add variant <-> parent set relationships
scripts/misc/create_MTMP_tables.pl:    $dbh->do(qq[ insert ignore into $mtmp_table_name ( $object_id, variation_set_id )
scripts/misc/create_MTMP_tables.pl:    ## add variant <-> parent of parent set relationships
scripts/misc/create_MTMP_tables.pl:    $dbh->do(qq[ insert ignore into $mtmp_table_name ($object_id, variation_set_id )
scripts/misc/create_MTMP_tables.pl:    die "\n\tUsage: create_MTMP_tables.pl -host [host] 
scripts/misc/create_MTMP_tables.pl:                                     -user [write-user name] 
scripts/misc/create_MTMP_tables.pl:                                     -pass [write-user password] 
scripts/misc/create_MTMP_tables.pl:                                     -mode [evidence|population_genotype|variation_set_variation|variation_set_structural_variation]\n
scripts/misc/create_MTMP_tables.pl:\t\tOptions: -db [database name]    default: all* variation databases on the host
scripts/misc/create_MTMP_tables.pl:\t\t         -tmpdir [directory for temp files]
scripts/misc/create_MTMP_tables.pl:\t\t         -tmpfile [ name for temp files]
scripts/misc/create_MTMP_tables.pl:    my $dbh = DBI->connect("dbi:mysql:information_schema:$host:$port", $user, $pass, undef) || die "Failed to look up available databases\n";
scripts/misc/create_MTMP_tables.pl:    my $db_ext_sth = $dbh->prepare(qq[ show databases like '%variation%']);
scripts/misc/create_MTMP_tables.pl:    $db_ext_sth->execute()||die "Failed to extract database list\n";
scripts/misc/create_MTMP_tables.pl:    my $db_list = $db_ext_sth->fetchall_arrayref();
scripts/misc/create_MTMP_tables.pl:        next if $l->[0] =~/master/;
scripts/misc/create_MTMP_tables.pl:        print "Doing $l->[0] on $host\n";
scripts/misc/create_MTMP_tables.pl:        push @databases, $l->[0] ;
scripts/misc/add_attrib_entries.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/add_attrib_entries.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/add_attrib_entries.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/add_attrib_entries.pl:    print "Usage: $0 --host <host> --port <port> --user <user> --pass <pass> --pattern <pattern> --attrib_file <attrib_sql_file> --dry_run --help\n";
scripts/misc/add_attrib_entries.pl:unless (-e $attrib_file) {
scripts/misc/add_attrib_entries.pl:my $dbh = DBI->connect(
scripts/misc/add_attrib_entries.pl:my $sth = $dbh->prepare("SHOW DATABASES LIKE '$pattern'");
scripts/misc/add_attrib_entries.pl:$sth->execute;
scripts/misc/add_attrib_entries.pl:while (my ($db) = $sth->fetchrow_array) {
scripts/misc/add_attrib_entries.pl:    my $cmd = "mysql --host=$host --port=$port --user=$user --pass=$pass --database=$db < $attrib_file";
scripts/misc/patch_var_class.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/patch_var_class.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/patch_var_class.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/patch_var_class.pl:    print "Usage: $0 --species <species> --registry <file> --variations <file> --help --verbose\n";
scripts/misc/patch_var_class.pl:$reg->load_all($reg_file);
scripts/misc/patch_var_class.pl:my $vdba = $reg->get_DBAdaptor($species, 'variation') or die "Failed to get variation DBA\n";
scripts/misc/patch_var_class.pl:my $va  = $reg->get_adaptor($species, 'variation', 'variation');
scripts/misc/patch_var_class.pl:    my $v = $va->fetch_by_name($_);
scripts/misc/patch_var_class.pl:    my $svc = Bio::EnsEMBL::Variation::Pipeline::SetVariationClass->new;
scripts/misc/patch_var_class.pl:    $svc->param('species', $species);
scripts/misc/patch_var_class.pl:    $svc->param('ensembl_registry', $reg_file);
scripts/misc/patch_var_class.pl:    $svc->param('variation_id_start', $v->dbID);
scripts/misc/patch_var_class.pl:    $svc->param('variation_id_stop', $v->dbID);
scripts/misc/patch_var_class.pl:    $svc->run;
scripts/misc/index_fasta_for_vep.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/index_fasta_for_vep.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/index_fasta_for_vep.pl:     http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/index_fasta_for_vep.pl:) or die "ERROR: Failed to parse command-line flags\n";
scripts/misc/index_fasta_for_vep.pl:do { usage(); exit(0); } if $config->{help};
scripts/misc/index_fasta_for_vep.pl:$config->{dir}     ||= $ENV{HOME}.'/.vep/';
scripts/misc/index_fasta_for_vep.pl:$config->{tmpdir}  ||= '/tmp';
scripts/misc/index_fasta_for_vep.pl:die("ERROR: no FASTA directory specified (--fasta)\n") unless defined($config->{fasta});
scripts/misc/index_fasta_for_vep.pl:if($config->{species} ne 'all') {
scripts/misc/index_fasta_for_vep.pl:  $match_species{lc($_)} = 1 for split(/\,/, $config->{species});
scripts/misc/index_fasta_for_vep.pl:opendir DIR, $config->{dir};
scripts/misc/index_fasta_for_vep.pl:  -d $config->{dir}.'/'.$_
scripts/misc/index_fasta_for_vep.pl:  my ($fastadir, $tmpdir) = ($config->{fasta}, $config->{tmpdir});
scripts/misc/index_fasta_for_vep.pl:  # remove repeat/soft-masked files
scripts/misc/index_fasta_for_vep.pl:  Bio::DB::Fasta->new("$tmpdir/$unz");
scripts/misc/index_fasta_for_vep.pl:  if(!-e "$tmpdir/$unz\.index") {
scripts/misc/index_fasta_for_vep.pl:  if(!defined($config->{target})) {
scripts/misc/index_fasta_for_vep.pl:    my $cdir = $config->{dir};
scripts/misc/index_fasta_for_vep.pl:      !/^\./ && -d $cdir.'/'.$cache.'/'.$_
scripts/misc/index_fasta_for_vep.pl:    $tdir = $vs{(sort {$a <=> $b} keys %vs)[-1]};
scripts/misc/index_fasta_for_vep.pl:    if(defined($config->{version})) {
scripts/misc/index_fasta_for_vep.pl:      $tdir = $vs{$config->{version}};
scripts/misc/index_fasta_for_vep.pl:      warn "WARNING: No matching cache directory (version ".($config->{version} || '?').") found in $cache";
scripts/misc/index_fasta_for_vep.pl:    $tdir = $config->{target};
scripts/misc/index_fasta_for_vep.pl:--dir | -d        Root directory of VEP caches (\$HOME/.vep/)
scripts/misc/index_fasta_for_vep.pl:--fasta | -f      Directory containing FASTA file dirs
scripts/misc/index_fasta_for_vep.pl:--tmpdir | -t     Temporary dir - used to unpack FASTA gzip files (/tmp)
scripts/misc/index_fasta_for_vep.pl:--target | -g     Target dir for index files (per-species cache dir)
scripts/misc/index_fasta_for_vep.pl:--species | -s    Species (all species found)
scripts/misc/index_fasta_for_vep.pl:--version | -v    Version (latest)
scripts/misc/process_dbNSFP_data.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/process_dbNSFP_data.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/process_dbNSFP_data.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/process_dbNSFP_data.pl:=item B<--help>
scripts/misc/process_dbNSFP_data.pl:=item B<--dbNSFP_dir DIR>
scripts/misc/process_dbNSFP_data.pl:=item B<--dbNSFP_version>
scripts/misc/process_dbNSFP_data.pl:=item B<--tmp_dir DIR >
scripts/misc/process_dbNSFP_data.pl:pod2usage(1) if ($config->{'help'} || !$args);
scripts/misc/process_dbNSFP_data.pl:  if (!$config->{$arg}) {
scripts/misc/process_dbNSFP_data.pl:    die("Argument --$arg is required.");
scripts/misc/process_dbNSFP_data.pl:my $tmp_dir = $config->{tmp_dir};
scripts/misc/process_dbNSFP_data.pl:my $dir = $config->{dbNSFP_dir};
scripts/misc/process_dbNSFP_data.pl:my $version = $config->{dbNSFP_version};
scripts/misc/process_dbNSFP_data.pl:if (!-e "$dir/dbNSFP$version\_variant.chr1.gz") {
scripts/misc/process_dbNSFP_data.pl:run_system_cmd("zcat $dir/dbNSFP$version\_variant.chr1.gz | head -n1 > $dir/h");
scripts/misc/process_dbNSFP_data.pl:    'grch37' => '-k8,8 -k9,9n',
scripts/misc/process_dbNSFP_data.pl:    'grch38' => '-k1,1 -k2,2n',
scripts/misc/process_dbNSFP_data.pl:    'grch37' => '-s 8 -b 9 -e 9',
scripts/misc/process_dbNSFP_data.pl:    'grch38' => '-s 1 -b 2 -e 2',
scripts/misc/process_dbNSFP_data.pl:  my $tabix_arg = $cmd_args->{tabix}->{$assembly};
scripts/misc/process_dbNSFP_data.pl:  my $sort_arg = $cmd_args->{sort}->{$assembly};
scripts/misc/process_dbNSFP_data.pl:  my $extra_arg = $cmd_args->{extra}->{$assembly};
scripts/misc/process_dbNSFP_data.pl:  run_system_cmd("zgrep -h -v ^#chr $dir/dbNSFP$version\_variant.chr* $extra_arg | sort -T $tmp_dir $sort_arg - | cat $dir/h - | bgzip -c > $dir/dbNSFP$version\_$assembly.gz");
scripts/misc/generate_variation_set_table.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/generate_variation_set_table.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/generate_variation_set_table.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/generate_variation_set_table.pl:  usage("> Error! Please give an Ensembl version, using the option '-v' \n");
scripts/misc/generate_variation_set_table.pl:  usage("> Error! Please give an output file using the option '-o'\n");
scripts/misc/generate_variation_set_table.pl:  usage("> Error! Please give the list of host names where the new databases are stored using the option '-hlist'\n");
scripts/misc/generate_variation_set_table.pl:  usage("> Error! Please give user name using the option '-user'\n");
scripts/misc/generate_variation_set_table.pl:my $img_class = "badge-48";
scripts/misc/generate_variation_set_table.pl:my $example_track_url = qq{<a href="/####SPECIES####/Location/View?contigviewbottom=variation_set_####SET####=normal;r=####LOCATION####;v=####VARIANT####" target="_blank" title="See a track example"><img src="$internal_link" style="vertical-align:middle" alt="Link"/> track</a>};
scripts/misc/generate_variation_set_table.pl:my $example_var_url = qq{<a href="/####SPECIES####/Variation/Explore?v=####VARIANT####" target="_blank" title="See a variant example"><img src="$internal_link" style="vertical-align:middle" alt="Link"/> variant</a>};
scripts/misc/generate_variation_set_table.pl:  $registry->load_registry_from_db(
scripts/misc/generate_variation_set_table.pl:        -host => $host,
scripts/misc/generate_variation_set_table.pl:        -port => $port,
scripts/misc/generate_variation_set_table.pl:        -user => $user,
scripts/misc/generate_variation_set_table.pl:        -db_version => $db_version
scripts/misc/generate_variation_set_table.pl:  while (my ($dbname) = $sth->fetchrow_array) {
scripts/misc/generate_variation_set_table.pl:    next if ($dbname !~ /^[a-z][a-z_]*_[a-z]+_$db_type\_$db_version\_\d+$/i);    
scripts/misc/generate_variation_set_table.pl:    my $display_name = $sth_core->fetchrow_array;  
scripts/misc/generate_variation_set_table.pl:    my $vs_adaptor = $registry->get_adaptor($s_name,'variation','variationset');
scripts/misc/generate_variation_set_table.pl:    # Get all top-level variation sets
scripts/misc/generate_variation_set_table.pl:    my $top_vss = $vs_adaptor->fetch_all_top_VariationSets();
scripts/misc/generate_variation_set_table.pl:        if ($top_vs->short_name =~ /^$com_filter/) {
scripts/misc/generate_variation_set_table.pl:          $com_sets->{$top_vs->short_name} = $top_vs;
scripts/misc/generate_variation_set_table.pl:        $sets->{$s_name}{$top_vs->short_name} = $top_vs;
scripts/misc/generate_variation_set_table.pl:foreach my $com_set_name (sort {lc $sets->{$a}->name cmp lc $sets->{$b}->name} keys(%$com_sets)) {
scripts/misc/generate_variation_set_table.pl:  $html .= print_set($com_sets->{$com_set_name},'',\$com_rowcount);
scripts/misc/generate_variation_set_table.pl:    <div style="padding-left:0px;padding-bottom:3px">
scripts/misc/generate_variation_set_table.pl:      <a href="/$id_species/Info/Index" title="$display_name Ensembl Home page" style="vertical-align:middle" target="_blank"><img src="/i/species/$id_species.png" alt="$display_name" class="$img_class" style="float:none;margin-right:4px;vertical-align:middle" /></a>
scripts/misc/generate_variation_set_table.pl:  foreach my $set_name (sort {lc $sets->{$species}->{$a}->name cmp lc $sets->{$species}->{$b}->name } keys(%{$sets->{$species}})) {
scripts/misc/generate_variation_set_table.pl:    $html .= print_set($sets->{$species}->{$set_name},$species,\$rowcount);
scripts/misc/generate_variation_set_table.pl:    <div style="background-color:#F0F0F0;margin:75px 0px 35px;padding:5px;border-top:2px solid #336;border-bottom:1px solid #336">
scripts/misc/generate_variation_set_table.pl:      <h2 style="display:inline;color:#000">Variant sets for the non-$top_species species</h2>
scripts/misc/generate_variation_set_table.pl:  # Put a bullet next to subsets (will only be correct for one level of nesting - needs to be modified if we're having multiple levels in the future)
scripts/misc/generate_variation_set_table.pl:  my $label = $set->name();
scripts/misc/generate_variation_set_table.pl:  my $short_name = ($set->short_name())  ? $set->short_name()  : '-';
scripts/misc/generate_variation_set_table.pl:  my $set_desc   = ($set->description()) ? $set->description() : '-';
scripts/misc/generate_variation_set_table.pl:  my $set_url_examples = '-</td><td>-';
scripts/misc/generate_variation_set_table.pl:  if ($short_name ne '-' && $species ne '') {
scripts/misc/generate_variation_set_table.pl:  my $subsets = $set->get_all_sub_VariationSets(1);
scripts/misc/generate_variation_set_table.pl:  foreach my $sub_vs ( sort {$a->name cmp $b->name} @{$subsets}) {
scripts/misc/generate_variation_set_table.pl:    $ssets->{$sub_vs->name} = $sub_vs;
scripts/misc/generate_variation_set_table.pl:    $html_set .= print_set($ssets->{$sset_name},$species,$rowcount,$indent+1);
scripts/misc/generate_variation_set_table.pl:  my ($var_id,$chr,$start,$end) = $sth_ex->fetchrow_array;
scripts/misc/generate_variation_set_table.pl:  $sth_ex->finish();
scripts/misc/generate_variation_set_table.pl:  $start -= $expand;
scripts/misc/generate_variation_set_table.pl:     $ex_track_url =~ s/####LOCATION####/$chr:$start-$end/;
scripts/misc/generate_variation_set_table.pl:  my $dbh = DBI->connect($dsn, $user, $pswd) or die "Connection failed";
scripts/misc/generate_variation_set_table.pl:  my $sth = $dbh->prepare($sql);
scripts/misc/generate_variation_set_table.pl:    $sth->execute(join(',',@$params));
scripts/misc/generate_variation_set_table.pl:    $sth->execute;
scripts/misc/generate_variation_set_table.pl:  Update the variation set tables in "data_description.html" (under public-plugins/ensembl/htdocs/info/genome/variation/).
scripts/misc/generate_variation_set_table.pl:    -help       Print this message
scripts/misc/generate_variation_set_table.pl:    -v          Ensembl version, e.g. 65 (Required)
scripts/misc/generate_variation_set_table.pl:    -o          An HTML output file name (Required)
scripts/misc/generate_variation_set_table.pl:    -hlist      The list of host names (with port) where the new databases are stored, separated by a coma,
scripts/misc/generate_variation_set_table.pl:    -user       MySQL user name (Required)
scripts/misc/generate_reg_file.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/generate_reg_file.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/generate_reg_file.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/generate_reg_file.pl:usage() if ($config->{help});
scripts/misc/generate_reg_file.pl:$config->{server_file} ||= '/nfs/production/flicek/ensembl/variation/servers.txt';
scripts/misc/generate_reg_file.pl:die "Error: server file not found\n" unless -e $config->{server_file};
scripts/misc/generate_reg_file.pl:die "Error: --release version is required\n" unless ($config->{release});
scripts/misc/generate_reg_file.pl:my $release = $config->{release};
scripts/misc/generate_reg_file.pl:  "Macaca_fascicularis"          => "crab-eating_macaque",
scripts/misc/generate_reg_file.pl:  "Sander_lucioperca"            => "pike-perch",
scripts/misc/generate_reg_file.pl:  %s->new(
scripts/misc/generate_reg_file.pl:    '-species' => '%s',
scripts/misc/generate_reg_file.pl:    '-group'   => '%s',
scripts/misc/generate_reg_file.pl:    '-port'    => %d,
scripts/misc/generate_reg_file.pl:    '-host'    => '%s',
scripts/misc/generate_reg_file.pl:    '-user'    => '%s',
scripts/misc/generate_reg_file.pl:    '-pass'    => '%s',
scripts/misc/generate_reg_file.pl:    '-dbname'  => '%s',
scripts/misc/generate_reg_file.pl:Bio::EnsEMBL::Registry->add_alias('%s', '%s'); };
scripts/misc/generate_reg_file.pl:print "use " . $adaptors->{$_}->{adaptor} . ";\n" for sort keys %$adaptors;
scripts/misc/generate_reg_file.pl:  my $fh = FileHandle->new($server_file, 'r');
scripts/misc/generate_reg_file.pl:    $servers->{$alias}->{host} = $host;
scripts/misc/generate_reg_file.pl:    $servers->{$alias}->{port} = $port;
scripts/misc/generate_reg_file.pl:    $servers->{$alias}->{user} = $user;
scripts/misc/generate_reg_file.pl:    $servers->{$alias}->{password} = $password || '';
scripts/misc/generate_reg_file.pl:my $servers = readServerConfig $config->{server_file};
scripts/misc/generate_reg_file.pl:my @variation     = getServers $config->{variation},     ('v1-w', 'v3-w');
scripts/misc/generate_reg_file.pl:my @core          = getServers $config->{core},          ('v1',   'v3');
scripts/misc/generate_reg_file.pl:my @otherfeatures = getServers $config->{otherfeatures}, ('v1',   'v3');
scripts/misc/generate_reg_file.pl:my @funcgen       = getServers $config->{funcgen},       ('v1',   'v3');
scripts/misc/generate_reg_file.pl:  my $db_config = $servers->{$server};
scripts/misc/generate_reg_file.pl:  my $host = $db_config->{host};
scripts/misc/generate_reg_file.pl:  my $password = $db_config->{password} || '';
scripts/misc/generate_reg_file.pl:  my $user = $db_config->{user};
scripts/misc/generate_reg_file.pl:  my $port = $db_config->{port};
scripts/misc/generate_reg_file.pl:  my $dbh = DBI->connect("DBI:mysql:host=$host;port=$port", $user, $password, );
scripts/misc/generate_reg_file.pl:    my $sth = $dbh->prepare(qq{SHOW DATABASES like '$pattern'});
scripts/misc/generate_reg_file.pl:    $sth->execute;
scripts/misc/generate_reg_file.pl:    if ($config->{dbname_var} and $group eq 'variation') {
scripts/misc/generate_reg_file.pl:      $dbname_var = $config->{dbname_var};
scripts/misc/generate_reg_file.pl:      my $sth2 = $dbh->prepare(qq{SHOW DATABASES like '$dbname_var'});
scripts/misc/generate_reg_file.pl:      $sth2->execute;
scripts/misc/generate_reg_file.pl:      $sth2->fetchrow_array and $custom_db_exists = 1;
scripts/misc/generate_reg_file.pl:    while (my ($db) = $sth->fetchrow_array) {
scripts/misc/generate_reg_file.pl:      $dbs->{$species}->{$group}->{db} = $dbname_var || $db;
scripts/misc/generate_reg_file.pl:      $dbs->{$species}->{$group}->{host} = $host;
scripts/misc/generate_reg_file.pl:      $dbs->{$species}->{$group}->{user} = $user;
scripts/misc/generate_reg_file.pl:      $dbs->{$species}->{$group}->{pass} = $password;
scripts/misc/generate_reg_file.pl:      $dbs->{$species}->{$group}->{port} = $port;
scripts/misc/generate_reg_file.pl:if ($config->{dbname_var} and !$custom_db_exists) {
scripts/misc/generate_reg_file.pl:  die "Database $config->{dbname_var} was not found in ",
scripts/misc/generate_reg_file.pl:if ($config->{species}) {
scripts/misc/generate_reg_file.pl:  @all_species = split ',', $config->{species};
scripts/misc/generate_reg_file.pl:  # if no species is user-defined, default to all species in aliases
scripts/misc/generate_reg_file.pl:    $species = $_ if lc($species) eq $aliases->{$_};
scripts/misc/generate_reg_file.pl:  next unless $dbs->{$species}->{variation};
scripts/misc/generate_reg_file.pl:  for my $group (keys %{ $dbs->{$species} }) {
scripts/misc/generate_reg_file.pl:           $adaptors->{$group}->{adaptor},
scripts/misc/generate_reg_file.pl:           $dbs->{$species}->{$group}->{port},
scripts/misc/generate_reg_file.pl:           $dbs->{$species}->{$group}->{host},
scripts/misc/generate_reg_file.pl:           $dbs->{$species}->{$group}->{user},
scripts/misc/generate_reg_file.pl:           $dbs->{$species}->{$group}->{pass} || '',
scripts/misc/generate_reg_file.pl:           $dbs->{$species}->{$group}->{db};
scripts/misc/generate_reg_file.pl:  if (my $alias = $aliases->{$species}) {
scripts/misc/generate_reg_file.pl:    perl generate_reg_file.pl --species mouse,human --release 108
scripts/misc/generate_reg_file.pl:    perl generate_reg_file.pl --species mouse --release 108 --dbname_var user_mus_musculus_variation_108_3_test
scripts/misc/generate_reg_file.pl:    # registry with read-only access to databases in v1 and v3
scripts/misc/generate_reg_file.pl:    perl generate_reg_file.pl --species mouse,human --release 108 -v v1,v3
scripts/misc/generate_reg_file.pl:    perl generate_reg_file.pl --species mouse,human --release 108 -c st1,st2,st3
scripts/misc/generate_reg_file.pl:    --release       Release version (required)
scripts/misc/generate_reg_file.pl:    --species       Comma-separated list of species (supports scientific and
scripts/misc/generate_reg_file.pl:    --variation     Servers for vatiation databases. Default: v1-w,v3-w
scripts/misc/generate_reg_file.pl:    --core          Servers for core databases. Default: v1,v3
scripts/misc/generate_reg_file.pl:    --funcgen       Servers for funcgen databases. Default: v1,v3
scripts/misc/generate_reg_file.pl:    --otherfeatures Servers for otherfeatures databases. Default: v1,v3
scripts/misc/generate_reg_file.pl:    --dbname_var    Custom database name for variation. Default:
scripts/misc/generate_reg_file.pl:    --server_file   File with server details. Default:
scripts/misc/generate_reg_file.pl:    --help          Print this message
scripts/misc/update_predicted_data.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/update_predicted_data.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/update_predicted_data.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/update_predicted_data.pl:#`perl generate_consequence_table.pl -o $tmp_section -colour_file $web_colour_file -mapping_file $web_mapping_colour`;
scripts/misc/update_predicted_data.pl:#`rm -f $tmp_section`;
scripts/misc/update_predicted_data.pl:  while (my ($dbname) = $sth->fetchrow_array) {
scripts/misc/update_predicted_data.pl:      while (my ($key,$value) = $sth2->fetchrow_array) {
scripts/misc/update_predicted_data.pl:      $sth2->finish();
scripts/misc/update_predicted_data.pl:    if ($sth_sift->fetchrow_array) {
scripts/misc/update_predicted_data.pl:    $sth_sift->finish();
scripts/misc/update_predicted_data.pl:    if ($sth_polyphen->fetchrow_array) {
scripts/misc/update_predicted_data.pl:    $sth_polyphen->finish();
scripts/misc/update_predicted_data.pl:`rm -f $tmp_file`;
scripts/misc/update_predicted_data.pl:  my $anchor = "<!-- $section - $type -->";
scripts/misc/update_predicted_data.pl:  my $line = `grep -m1 -n '$anchor' $tmp_file`;
scripts/misc/update_predicted_data.pl:    $content = `head -n$line_number $tmp_file`;
scripts/misc/update_predicted_data.pl:    my $lines_count = (split(' ',`wc -l $tmp_file`))[0];
scripts/misc/update_predicted_data.pl:    $line_number = $lines_count - $line_number + 1;
scripts/misc/update_predicted_data.pl:    $content = `tail -n$line_number $tmp_file`;
scripts/misc/update_predicted_data.pl:<div style="float:left;font-style:italic">
scripts/misc/update_predicted_data.pl:  <ul style="margin-bottom:0px">};
scripts/misc/update_predicted_data.pl:    $html .= ($count_row == 1) ? qq{    <li style="margin-top:0px">} : '    <li>';
scripts/misc/update_predicted_data.pl:  my $dbh = DBI->connect($dsn, $user, $pswd) or die "Connection failed";
scripts/misc/update_predicted_data.pl:  my $sth = $dbh->prepare($sql);
scripts/misc/update_predicted_data.pl:    $sth->execute(join(',',@$params));
scripts/misc/update_predicted_data.pl:    $sth->execute;
scripts/misc/update_predicted_data.pl:  Update the page "data_description.html" (under public-plugins/ensembl/htdocs/info/genome/variation/).
scripts/misc/update_predicted_data.pl:    -help           Print this message
scripts/misc/update_predicted_data.pl:    -v              Ensembl version, e.g. 65 (Required)
scripts/misc/update_predicted_data.pl:    -i              Path to the data_description.html file (Required)
scripts/misc/update_predicted_data.pl:    -o              An HTML output file name (Required)
scripts/misc/update_predicted_data.pl:    -species        Species name. 'Homo_sapiens' by default (optional)
scripts/misc/update_predicted_data.pl:    -hlist          The list of host names where the new databases are stored, separated by a coma,
scripts/misc/update_predicted_data.pl:    -user           MySQL user name (Required)
scripts/misc/update_predicted_data.pl:    -port           MySQL port. 3306 by default (optional)
scripts/misc/update_predicted_data.pl:#    -colour_file    If you want to use directly the colours from the web colours configuration file
scripts/misc/update_predicted_data.pl:#                    instead of the almost-up-to-date-colour-hash \%colour hash. (optional)
scripts/misc/update_predicted_data.pl:#                    ensembl-webcode/conf/ini-files/COLOUR.ini 
scripts/misc/update_predicted_data.pl:#    -mapping_file   Web module to map the colour names to the corresponding hexadecimal code. (optional)
scripts/misc/update_predicted_data.pl:#                    ensembl-webcode/modules/Sanger/Graphics/ColourMap.pm
scripts/misc/mart_so.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/mart_so.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/mart_so.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/mart_so.pl:$config->{host} ||= 'ens-staging';
scripts/misc/mart_so.pl:$config->{user} ||= 'ensro';
scripts/misc/mart_so.pl:$config->{port} ||= 3306;
scripts/misc/mart_so.pl:$reg->load_registry_from_db(-host => $config->{host}, -user => $config->{user}, -port => $config->{port}, -db_version => $config->{version});
scripts/misc/mart_so.pl:my $oa = $reg->get_adaptor( 'Multi', 'Ontology', 'OntologyTerm' );
scripts/misc/mart_so.pl:	my $obj = $oa->fetch_by_accession($con->SO_accession);
scripts/misc/mart_so.pl:    die("ERROR: Failed to fetch DB object for ".$con->SO_term." (".$con->SO_accession.")\n") unless defined($obj);
scripts/misc/mart_so.pl:	get_parents($_, $term_list) for @{$obj->parents};
scripts/misc/mart_so.pl:	$term_list->{$obj->name} = 1;
scripts/misc/species_list.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/species_list.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/species_list.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/species_list.pl:  print "> Error! Please give an Ensembl version, using the option '-v' \n";
scripts/misc/species_list.pl:  print "> Error! Please give an output file using the option '-o'\n";
scripts/misc/species_list.pl:  print "> Error! Please give the list of host names where the new databases are stored using the option '-hlist'\n";
scripts/misc/species_list.pl:  print "> Error! Please give user name using the option '-user'\n";
scripts/misc/species_list.pl:my $p_version = $e_version-1;
scripts/misc/species_list.pl:  while (my ($dbname) = $sth->fetchrow_array) {
scripts/misc/species_list.pl:    next if ($dbname !~ /^[a-z][a-z_]*_[a-z0-9]+_$db_type\_$e_version\_\d+$/i);
scripts/misc/species_list.pl:    if ($etype) { # EG site - need to filter out species
scripts/misc/species_list.pl:      my $img_thumb = sprintf qq{eg-plugins/%s/htdocs/img/species/thumb_%s.png}, $etype, ucfirst($s_name);
scripts/misc/species_list.pl:      #  print "- checking for $img_thumb ... ";
scripts/misc/species_list.pl:      if (! -e $img_thumb) {
scripts/misc/species_list.pl:    my $count_var = $sth2->fetchrow_array;
scripts/misc/species_list.pl:    $sth2->finish;
scripts/misc/species_list.pl:       $label_name =~ s/_gca[0-9]{9}[v0-9]*+$//g;	# remove any gca from name 
scripts/misc/species_list.pl:    my $display_name = $sth_core->fetchrow_array;  
scripts/misc/species_list.pl:    while(my $src = ($sth2a->fetchrow_array)[0]) {
scripts/misc/species_list.pl:    $sth2a->finish;
scripts/misc/species_list.pl:    my $p_dbname = $sth3->fetchrow_array;
scripts/misc/species_list.pl:      my $count_p_var = $sth4->fetchrow_array;
scripts/misc/species_list.pl:      $sth4->finish;
scripts/misc/species_list.pl:      $species_list{$s_name}{'p_count'} = round_count_diff($count_var-$count_p_var);
scripts/misc/species_list.pl:my $th_bg = qq{background-color:#BBB};
scripts/misc/species_list.pl:my $th_border_left = qq{border-left:1px solid #DDD};
scripts/misc/species_list.pl:my $th_border_left_top = qq{style="$th_border_left;text-align:center"};
scripts/misc/species_list.pl:my $header_link = qq{<a class="_ht" style="text-decoration:none" title="See detailed counts" href="};
scripts/misc/species_list.pl:      <th style="$th_bg;padding-left:0px">
scripts/misc/species_list.pl:  my $img_class = "badge-32";
scripts/misc/species_list.pl:  <tr$bg style="vertical-align:middle">
scripts/misc/species_list.pl:          <a href="/$uc_sp/Info/Index" title="$label Ensembl Home page" style="vertical-align:middle" target="_blank">
scripts/misc/species_list.pl:            <img src="$img_src" alt="$label" class="$img_class" style="vertical-align:middle" />
scripts/misc/species_list.pl:         <div style="float:left;margin-left:6px;padding-top:2px">
scripts/misc/species_list.pl:           <div class="small" style="font-style:italic">$label</div>
scripts/misc/species_list.pl:    <td style="text-align:right">$var_count</td>
scripts/misc/species_list.pl:    <td style="text-align:right">$var_p_count</td>
scripts/misc/species_list.pl:    <td style="text-align:right">
scripts/misc/species_list.pl:      <a href="sources_documentation.html#$sp" class="ht _ht" style="text-decoration:none" title="$var_src_title">$var_src_count</a>
scripts/misc/species_list.pl:    my $has_data = ($species_data_tables->{$sp}{$type}) ? qq{<img src="/i/16/check.png" title="Data available" />} : '-';
scripts/misc/species_list.pl:    $html_content .= qq{    <td style="text-align:center">$has_data</td>\n};
scripts/misc/species_list.pl:    my $has_data = ($species_data_columns->{$sp}{$type}) ?  qq{<img src="/i/16/check.png" title="Data available" />} : '-';
scripts/misc/species_list.pl:    $html_content .= qq{    <td style="text-align:center">$has_data</td>\n};
scripts/misc/species_list.pl:    <span style="margin-right:5px;font-weight:bold">Colour legend: </span>
scripts/misc/species_list.pl:    <span style="margin-left:20px">
scripts/misc/species_list.pl:      <span class="vdoc_count_legend $class" style="margin-right:5px"></span>
scripts/misc/species_list.pl:print HTML qq{<p style="padding-top:0px;margin-top:0px">We currently have <span style="font-weight:bold;font-size:1.1em;color:#000">$count_species</span> vertebrate species with variation databases. A range of different information is available:</p>\n};
scripts/misc/species_list.pl:  my $dbh = DBI->connect($dsn, $user, $pswd) or die "Connection failed";
scripts/misc/species_list.pl:  my $sth = $dbh->prepare($sql);
scripts/misc/species_list.pl:  $sth->execute;
scripts/misc/species_list.pl:    return '-';
scripts/misc/species_list.pl:    $symbol = '-';
scripts/misc/species_list.pl:      while (my ($dbname) = $sth->fetchrow_array) {
scripts/misc/species_list.pl:        next if ($dbname !~ /^[a-z][a-z_]*_[a-z0-9]+_$db_type\_$e_version\_\d+$/i);
scripts/misc/species_list.pl:      $sth->finish();
scripts/misc/species_list.pl:      while (my ($dbname) = $sth->fetchrow_array) {
scripts/misc/species_list.pl:        my $col_count = ($sth_col->fetchrow_array)[0];
scripts/misc/species_list.pl:        $sth_col->finish();
scripts/misc/species_list.pl:      $sth->finish();
scripts/misc/species_list.pl:    -help           Print this message
scripts/misc/species_list.pl:    -v              Ensembl version, e.g. 65 (Required)
scripts/misc/species_list.pl:    -o              An HTML output file name (Required)      
scripts/misc/species_list.pl:    -hlist          The list of host names (with port) where the new databases are stored, separated by a coma,
scripts/misc/species_list.pl:    -phost          Host name (with port) where the previous databases are stored, e.g. ensembldb.ensembl.org:3306  (Required)
scripts/misc/species_list.pl:    -user           MySQL user name (Required)
scripts/misc/species_list.pl:    -site           The URL of the website (optional)
scripts/misc/species_list.pl:    -etype          The type of Ensembl, e.g. Plant (optional)
scripts/misc/generate_classes_table.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/generate_classes_table.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/generate_classes_table.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/generate_classes_table.pl:$registry->load_registry_from_db(
scripts/misc/generate_classes_table.pl:    -host => $host,
scripts/misc/generate_classes_table.pl:    -port => $port,
scripts/misc/generate_classes_table.pl:    -user => 'ensro',
scripts/misc/generate_classes_table.pl:    -db_version => $db_version
scripts/misc/generate_classes_table.pl:my $vdb = $registry->get_DBAdaptor($species,'variation');
scripts/misc/generate_classes_table.pl:my $dbVar = $vdb->dbc->db_handle;
scripts/misc/generate_classes_table.pl:$onto_registy->load_registry_from_db(
scripts/misc/generate_classes_table.pl:    -host => $onto_host,
scripts/misc/generate_classes_table.pl:    -port => $onto_port,
scripts/misc/generate_classes_table.pl:    -user => 'ensro',
scripts/misc/generate_classes_table.pl:    -db_version => $db_version
scripts/misc/generate_classes_table.pl:my $odb = $onto_registy->get_adaptor( 'Multi', 'Ontology', 'OntologyTerm' );
scripts/misc/generate_classes_table.pl:my $sth1  = $dbVar->prepare($stmt1);
scripts/misc/generate_classes_table.pl:my $sth1a = $dbVar->prepare($stmt1a);
scripts/misc/generate_classes_table.pl:my $sth1b = $dbVar->prepare($stmt1b);
scripts/misc/generate_classes_table.pl:$sth1->execute;
scripts/misc/generate_classes_table.pl:while(my $v_class = ($sth1->fetchrow_array)[0]) {
scripts/misc/generate_classes_table.pl:  $sth1a->execute($v_class);
scripts/misc/generate_classes_table.pl:  my $v_name = ($sth1a->fetchrow_array)[0];
scripts/misc/generate_classes_table.pl:    $sth1b->execute($v_class);
scripts/misc/generate_classes_table.pl:    $v_name = ($sth1b->fetchrow_array)[0];
scripts/misc/generate_classes_table.pl:$sth1->finish; 
scripts/misc/generate_classes_table.pl:$sth1a->finish;
scripts/misc/generate_classes_table.pl:my $sth2  = $dbVar->prepare($stmt2);
scripts/misc/generate_classes_table.pl:my $sth2a = $dbVar->prepare($stmt2a);
scripts/misc/generate_classes_table.pl:my $sth2b = $dbVar->prepare($stmt2b);
scripts/misc/generate_classes_table.pl:$sth2->execute;
scripts/misc/generate_classes_table.pl:while(my $sv_class = ($sth2->fetchrow_array)[0]) {
scripts/misc/generate_classes_table.pl:  $sth2a->execute($sv_class);
scripts/misc/generate_classes_table.pl:  my $sv_name = ($sth2a->fetchrow_array)[0];
scripts/misc/generate_classes_table.pl:    $sth2b->execute($sv_class);
scripts/misc/generate_classes_table.pl:    $sv_name = ($sth2b->fetchrow_array)[0];
scripts/misc/generate_classes_table.pl:$sth2->finish;
scripts/misc/generate_classes_table.pl:$sth2a->finish;
scripts/misc/generate_classes_table.pl:$sth2b->finish;
scripts/misc/generate_classes_table.pl:    <th style="width:8px;padding-left:0px;padding-right:0px;text-align:center">*</th>
scripts/misc/generate_classes_table.pl:  my $so_acc   = $data->{'class'}{SO_accession};
scripts/misc/generate_classes_table.pl:  my $som_term = $data->{'class'}{somatic_display_term};
scripts/misc/generate_classes_table.pl:  my $oterm = $odb->fetch_by_accession($so_acc);
scripts/misc/generate_classes_table.pl:    my $desc = $oterm->definition;
scripts/misc/generate_classes_table.pl:    $class_col = qq{;background-color:$class_col};
scripts/misc/generate_classes_table.pl:    $class_col = qq{;background-color:$default_colour};
scripts/misc/generate_classes_table.pl:  my $border = ($class_col eq '') ? '' : ';border-top:1px solid #FFF';
scripts/misc/generate_classes_table.pl:    <td style="font-weight:bold">$so_term</td>
scripts/misc/generate_classes_table.pl:      <ul style="margin:0px;padding-left:1em">
scripts/misc/generate_classes_table.pl:    <td style="padding-left:0px;width:16px">$examples</td>
scripts/misc/generate_classes_table.pl:    if ($data->{'v_example'}) {
scripts/misc/generate_classes_table.pl:      my $v_name = $data->{'v_example'};
scripts/misc/generate_classes_table.pl:    if ($data->{'sv_example'}) {
scripts/misc/generate_classes_table.pl:      my $sv_name = $data->{'sv_example'};
scripts/misc/generate_classes_table.pl:    $html .= qq{<div style="padding-top:1px">$sv_url</div>};
scripts/misc/generate_classes_table.pl:    if ($data->{'example'}) {
scripts/misc/generate_classes_table.pl:      my $v_name = $data->{'example'};
scripts/misc/generate_classes_table.pl:    if ($data->{'example'}) {
scripts/misc/generate_classes_table.pl:      my $sv_name = $data->{'example'};
scripts/misc/generate_classes_table.pl:  my $sth = $dbVar->prepare($stmt);
scripts/misc/generate_classes_table.pl:  $sth->execute;
scripts/misc/generate_classes_table.pl:  while(my ($class,$count) = $sth->fetchrow_array) {
scripts/misc/generate_classes_table.pl:  $sth->finish;
scripts/misc/generate_classes_table.pl:<div class="js_panel" id="pie_chart_panel" style="margin-top:15px;margin-bottom:20px">
scripts/misc/generate_classes_table.pl:  <div class="pie_chart_classes" title="classes" style="width:400px;height:220px;border:1px solid #CCC;border-radius:8px;box-shadow:0 1px 3px #666">
scripts/misc/generate_classes_table.pl:     <h3 style="padding:10px 10px 5px">%s variant class distribution - Ensembl %s</h4>
scripts/misc/generate_classes_table.pl:  Update the classes table in "data_description.html" (under public-plugins/ensembl/htdocs/info/genome/variation/).
scripts/misc/generate_classes_table.pl:    -help           Print this message
scripts/misc/generate_classes_table.pl:    -v              Ensembl version, e.g. 65 (Required)
scripts/misc/generate_classes_table.pl:    -o              An HTML output file name (Required)
scripts/misc/generate_classes_table.pl:    -host           Host of the human database (Required)
scripts/misc/generate_classes_table.pl:    -port           Human database port (Required)
scripts/misc/generate_classes_table.pl:    -ohost          Host name where the ontology database is stored, with the port, e.g. ensembldb.ensembl.org:1234 (Required)
scripts/misc/generate_classes_table.pl:    -species        Species name (Required)
scripts/misc/copy_mtmp_tables.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/copy_mtmp_tables.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/copy_mtmp_tables.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/copy_mtmp_tables.pl:#die "ERROR: You must run this script on the database server machine on which the MTMP table database resides\n" unless $ENV{HOST} eq 'ens-variation2';
scripts/misc/copy_mtmp_tables.pl:$config->{tables} ||= 'MTMP_population_genotype,subsnp_map,tmp_sample_genotype_single_bp';
scripts/misc/copy_mtmp_tables.pl:my %t = map {$_ => 1} split /\,/, $config->{tables};
scripts/misc/copy_mtmp_tables.pl:$config->{tables} = \%t;
scripts/misc/copy_mtmp_tables.pl:$config->{user} = 'ensro';
scripts/misc/copy_mtmp_tables.pl:$config->{password} = '';
scripts/misc/copy_mtmp_tables.pl:$config->{port} = 3306;
scripts/misc/copy_mtmp_tables.pl:$config->{dir} ||= '/mysql/data_3306/databases/production_archive/';
scripts/misc/copy_mtmp_tables.pl:die "ERROR: Directory ".$config->{dir}." not found, perhaps you need to specify with --dir?\n" unless -e $config->{dir};
scripts/misc/copy_mtmp_tables.pl:opendir DIR, $config->{dir};
scripts/misc/copy_mtmp_tables.pl:foreach my $host(qw(ens-staging ens-staging2)) {
scripts/misc/copy_mtmp_tables.pl:		$species =~ s/^([a-z]+\_[a-z]+)(.+)/$1/;
scripts/misc/copy_mtmp_tables.pl:		my $dbc = DBI->connect(
scripts/misc/copy_mtmp_tables.pl:				$config->{port},
scripts/misc/copy_mtmp_tables.pl:			), $config->{user}, $config->{password}
scripts/misc/copy_mtmp_tables.pl:		my $sth = $dbc->prepare(qq{
scripts/misc/copy_mtmp_tables.pl:		$sth->execute();
scripts/misc/copy_mtmp_tables.pl:		$sth->bind_columns(\$table);
scripts/misc/copy_mtmp_tables.pl:		push @tables, $table while $sth->fetch;
scripts/misc/copy_mtmp_tables.pl:		$sth->finish;
scripts/misc/copy_mtmp_tables.pl:		$sth = $dbc->prepare(qq{
scripts/misc/copy_mtmp_tables.pl:		$sth->execute();
scripts/misc/copy_mtmp_tables.pl:		$sth->bind_columns(\$table);
scripts/misc/copy_mtmp_tables.pl:		push @tables, $table while $sth->fetch;
scripts/misc/copy_mtmp_tables.pl:		$sth->finish;
scripts/misc/copy_mtmp_tables.pl:		$sth = $dbc->prepare(qq{
scripts/misc/copy_mtmp_tables.pl:		$sth->execute();
scripts/misc/copy_mtmp_tables.pl:		$sth->bind_columns(\$table);
scripts/misc/copy_mtmp_tables.pl:		push @tables, $table while $sth->fetch;
scripts/misc/copy_mtmp_tables.pl:		$sth->finish;
scripts/misc/copy_mtmp_tables.pl:		my %table_hash = map {$_ => 1} grep {$config->{tables}->{$_}} @tables;
scripts/misc/copy_mtmp_tables.pl:			# special case for tmp_gt, filename is too long for MySQL 64-char table name limit
scripts/misc/copy_mtmp_tables.pl:			foreach my $t(keys %{$config->{tables}}) {
scripts/misc/copy_mtmp_tables.pl:				system "scp ".$config->{dir}."/$map{$t}{$latest_version}\.$ext $host:/mysql/data_3306/databases/$db/$t\.$ext";
scripts/misc/copy_mtmp_tables.pl:#				print "scp ".$config->{dir}."/$map{$t}{$latest_version}\.$ext $host:/mysql/data_3306/databases/$db/$t\.$ext\n";
scripts/misc/copy_mtmp_tables.pl:	my $dbc = DBI->connect(
scripts/misc/copy_mtmp_tables.pl:			$config->{port}
scripts/misc/copy_mtmp_tables.pl:		), $config->{user}, $config->{password}
scripts/misc/copy_mtmp_tables.pl:	my $version = $config->{version};
scripts/misc/copy_mtmp_tables.pl:	my $sth = $dbc->prepare(qq{
scripts/misc/copy_mtmp_tables.pl:	$sth->execute();
scripts/misc/copy_mtmp_tables.pl:	$sth->bind_columns(\$db);
scripts/misc/copy_mtmp_tables.pl:	push @dbs, $db while $sth->fetch;
scripts/misc/copy_mtmp_tables.pl:	$sth->finish;
scripts/misc/copy_mtmp_tables.pl:	my $pattern = $config->{pattern};
scripts/misc/copy_mtmp_tables.pl:	#$_ =~ s/^([a-z]+\_[a-z]+)(.+)/$1/ for @dbs;
scripts/misc/generate_vep_docs.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/generate_vep_docs.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/generate_vep_docs.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/generate_vep_docs.pl:      $in_body = 1 - $in_body;
scripts/misc/generate_vep_docs.pl:  print '<div style="clear:both"><h1 style="page-break-after: always">&nbsp</h1></div>';
scripts/misc/patch_transcript_variation.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/patch_transcript_variation.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/patch_transcript_variation.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/patch_transcript_variation.pl:    print "Usage: $0 --species <species> --registry <file> --transcripts <file> --variations <file> --disamb --help --verbose\n";
scripts/misc/patch_transcript_variation.pl:$reg->load_all($reg_file);
scripts/misc/patch_transcript_variation.pl:my $vdba = $reg->get_DBAdaptor($species, 'variation') or die "Failed to get variation DBA\n";
scripts/misc/patch_transcript_variation.pl:my $dbh = $vdba->dbc->db_handle;
scripts/misc/patch_transcript_variation.pl:my $remove_existing_by_tran_sth = $dbh->prepare(qq{
scripts/misc/patch_transcript_variation.pl:my $get_affected_vfs_sth = $dbh->prepare(qq{
scripts/misc/patch_transcript_variation.pl:my $update_vfs_sth = $dbh->prepare(qq{
scripts/misc/patch_transcript_variation.pl:        $transcript_stable_ids->{$_} = 1;
scripts/misc/patch_transcript_variation.pl:    my $va  = $reg->get_adaptor($species, 'variation', 'variation');
scripts/misc/patch_transcript_variation.pl:    my $vfa = $reg->get_adaptor($species, 'variation', 'variationfeature');
scripts/misc/patch_transcript_variation.pl:    my $ta  = $reg->get_adaptor($species, 'core', 'transcript');
scripts/misc/patch_transcript_variation.pl:        my $v = $va->fetch_by_name($_);
scripts/misc/patch_transcript_variation.pl:        for my $vf (@{ $vfa->fetch_all_by_Variation($v) }) {
scripts/misc/patch_transcript_variation.pl:            my $chr_slice = $vf->feature_Slice->expand(MAX_DISTANCE_FROM_TRANSCRIPT, MAX_DISTANCE_FROM_TRANSCRIPT);
scripts/misc/patch_transcript_variation.pl:            my @transcripts = @{ $ta->fetch_all_by_Slice($chr_slice) };
scripts/misc/patch_transcript_variation.pl:            for my $seg (@{ $chr_slice->project('lrg') }){
scripts/misc/patch_transcript_variation.pl:                push @transcripts, @{ $ta->fetch_all_by_Slice($seg->to_Slice) };
scripts/misc/patch_transcript_variation.pl:                    next unless $transcript_stable_ids->{$t->stable_id};
scripts/misc/patch_transcript_variation.pl:                    $transcript_stable_ids->{$t->stable_id} = 1;
scripts/misc/patch_transcript_variation.pl:                push @{ $variations_by_transcript->{$t->stable_id} ||= [] }, $vf;
scripts/misc/patch_transcript_variation.pl:    my $te = Bio::EnsEMBL::Variation::Pipeline::TranscriptEffect->new();
scripts/misc/patch_transcript_variation.pl:    $te->param('species', $species);
scripts/misc/patch_transcript_variation.pl:    $te->param('ensembl_registry', $reg_file);
scripts/misc/patch_transcript_variation.pl:    $te->param('disambiguate_single_nucleotide_alleles', $disamb);
scripts/misc/patch_transcript_variation.pl:    $te->param('transcript_stable_id', $transcript_stable_id);
scripts/misc/patch_transcript_variation.pl:    my $vars = $variations_by_transcript->{$transcript_stable_id};
scripts/misc/patch_transcript_variation.pl:        my $vf_id_str = join ',', map { $_->dbID } @$vars;
scripts/misc/patch_transcript_variation.pl:        $dbh->do(qq{
scripts/misc/patch_transcript_variation.pl:        my $vars_to_include = [ map {  $_->variation_name } @$vars ];
scripts/misc/patch_transcript_variation.pl:        $te->param('variations_to_include', $vars_to_include);
scripts/misc/patch_transcript_variation.pl:        $remove_existing_by_tran_sth->execute($transcript_stable_id);
scripts/misc/patch_transcript_variation.pl:    $te->run;
scripts/misc/patch_transcript_variation.pl:        map { $affected_vf_ids->{$_->dbID} = 1 } @$vars;
scripts/misc/patch_transcript_variation.pl:        $get_affected_vfs_sth->execute($transcript_stable_id);
scripts/misc/patch_transcript_variation.pl:        while (my ($vf_id) = $get_affected_vfs_sth->fetchrow_array) {
scripts/misc/patch_transcript_variation.pl:            $affected_vf_ids->{$vf_id} = 1;
scripts/misc/patch_transcript_variation.pl:    $update_vfs_sth->execute($vf_id);
scripts/misc/mart_phenotypes.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/mart_phenotypes.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/mart_phenotypes.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/mart_phenotypes.pl:	die("ERROR: $_ not defined, use --$_\n") unless defined $config->{$_};
scripts/misc/mart_phenotypes.pl:if(!defined($config->{db})) {
scripts/misc/mart_phenotypes.pl:  @db_list = @{get_species_list($config, $config->{host})};
scripts/misc/mart_phenotypes.pl:  push @db_list, $config->{db};
scripts/misc/mart_phenotypes.pl:die "ERROR: no suitable databases found on host ".$config->{host}."\n" unless scalar @db_list;
scripts/misc/mart_phenotypes.pl:my $TMP_DIR = $config->{tmpdir};
scripts/misc/mart_phenotypes.pl:my $TMP_FILE = $config->{tmpfile};
scripts/misc/mart_phenotypes.pl:  my $dbc = Bio::EnsEMBL::DBSQL::DBConnection->new(
scripts/misc/mart_phenotypes.pl:    -user   => $config->{user},
scripts/misc/mart_phenotypes.pl:    -dbname => $db,
scripts/misc/mart_phenotypes.pl:    -host   => $config->{host},
scripts/misc/mart_phenotypes.pl:    -pass => $config->{password},
scripts/misc/mart_phenotypes.pl:    -driver => 'mysql',
scripts/misc/mart_phenotypes.pl:    -port => $config->{port},
scripts/misc/mart_phenotypes.pl:	$dbc->do(qq{DROP TABLE IF EXISTS MTMP_phenotype;});
scripts/misc/mart_phenotypes.pl:	$dbc->do(qq{
scripts/misc/mart_phenotypes.pl:	my $sth = $dbc->prepare(qq{
scripts/misc/mart_phenotypes.pl:	$sth->execute();
scripts/misc/mart_phenotypes.pl:	while (my $row = $sth->fetchrow_arrayref) {
scripts/misc/mart_phenotypes.pl:		$strains->{$individual_id}->{name} = $name;
scripts/misc/mart_phenotypes.pl:		$strains->{$individual_id}->{gender} = $gender;
scripts/misc/mart_phenotypes.pl:	$sth->finish();	
scripts/misc/mart_phenotypes.pl:	my $sth = $dbc->prepare(qq{
scripts/misc/mart_phenotypes.pl:	$sth->execute();
scripts/misc/mart_phenotypes.pl:	$sth->bind_columns(\($pf_id, $gene_id, $desc, $code, $value, $source));	    
scripts/misc/mart_phenotypes.pl:	while ($sth->fetch) {
scripts/misc/mart_phenotypes.pl:		$row->{pf_id}          = $pf_id;
scripts/misc/mart_phenotypes.pl:		$row->{gene_stable_id} = $gene_id;
scripts/misc/mart_phenotypes.pl:		$row->{description}    = $desc;
scripts/misc/mart_phenotypes.pl:		$row->{source}         = $source;
scripts/misc/mart_phenotypes.pl:			$row->{strain_name}   = $strains->{$value}->{name};
scripts/misc/mart_phenotypes.pl:			$row->{strain_gender} = $strains->{$value}->{gender}; 
scripts/misc/mart_phenotypes.pl:			$row->{p_value} = $value;
scripts/misc/mart_phenotypes.pl:			$row->{external_id} = $value;
scripts/misc/mart_phenotypes.pl:    $sth->finish;
scripts/misc/mart_phenotypes.pl:	$row->{strain_name} ||= '\N';		
scripts/misc/mart_phenotypes.pl:	$row->{strain_gender} ||= '\N';		
scripts/misc/mart_phenotypes.pl:	$row->{p_value} ||= '\N';
scripts/misc/mart_phenotypes.pl:	$row->{external_id} ||= '\N';
scripts/misc/mart_phenotypes.pl:		$row->{pf_id}, 
scripts/misc/mart_phenotypes.pl:		$row->{gene_stable_id}, 
scripts/misc/mart_phenotypes.pl:		$row->{description}, 
scripts/misc/mart_phenotypes.pl:		$row->{source}, 
scripts/misc/mart_phenotypes.pl:		$row->{p_value}, 
scripts/misc/mart_phenotypes.pl:		$row->{strain_name}, 
scripts/misc/mart_phenotypes.pl:		$row->{strain_gender},
scripts/misc/mart_phenotypes.pl:		$row->{external_id},);
scripts/misc/mart_phenotypes.pl:	my $dbc = DBI->connect(
scripts/misc/mart_phenotypes.pl:			$config->{port}
scripts/misc/mart_phenotypes.pl:		), $config->{user}, $config->{password}
scripts/misc/mart_phenotypes.pl:	my $version = $config->{version};
scripts/misc/mart_phenotypes.pl:	my $sth = $dbc->prepare(qq{
scripts/misc/mart_phenotypes.pl:	$sth->execute();
scripts/misc/mart_phenotypes.pl:	$sth->bind_columns(\$db);
scripts/misc/mart_phenotypes.pl:	push @dbs, $db while $sth->fetch;
scripts/misc/mart_phenotypes.pl:	$sth->finish;
scripts/misc/mart_phenotypes.pl:	my $pattern = $config->{pattern};
scripts/misc/mart_phenotypes.pl:	#$_ =~ s/^([a-z]+\_[a-z]+)(.+)/$1/ for @dbs;
scripts/misc/generate_hgvs_table.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/generate_hgvs_table.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/generate_hgvs_table.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/generate_hgvs_table.pl:    run_all_by_host('ens-staging', $pass);
scripts/misc/generate_hgvs_table.pl:    run_all_by_host('ens-staging2', $pass);
scripts/misc/generate_hgvs_table.pl:    my $dbh = DBI->connect("dbi:mysql:information_schema:$host:3306", 'ensro', undef, undef);
scripts/misc/generate_hgvs_table.pl:    my $db_ext_sth = $dbh->prepare(qq[ show databases like '%var%']);
scripts/misc/generate_hgvs_table.pl:    $db_ext_sth->execute()||die;
scripts/misc/generate_hgvs_table.pl:    my $db_list = $db_ext_sth->fetchall_arrayref();
scripts/misc/generate_hgvs_table.pl:	print "Doing $l->[0] on $host\n";
scripts/misc/generate_hgvs_table.pl:	create_table($l->[0], $host, $pass);
scripts/misc/generate_hgvs_table.pl:    my $dbh = DBI->connect("dbi:mysql:$db:$host:3306", 'ensadmin', $pass, undef);
scripts/misc/generate_hgvs_table.pl:    $dbh->do(qq[ CREATE TABLE variation_hgvs (
scripts/misc/generate_hgvs_table.pl:    my $trans_ins_sth = $dbh->prepare(qq[ insert ignore into variation_hgvs(
scripts/misc/generate_hgvs_table.pl:    my $prot_ins_sth  = $dbh->prepare(qq[ insert ignore into variation_hgvs(
scripts/misc/generate_hgvs_table.pl:    $trans_ins_sth->execute()||die;
scripts/misc/generate_hgvs_table.pl:    $prot_ins_sth->execute()||die;
scripts/misc/generate_hgvs_table.pl:    my $tran_ext_sth = $dbh->prepare(qq[select feature_stable_id from transcript_variation limit 1]);
scripts/misc/generate_hgvs_table.pl:    $tran_ext_sth->execute()||die;
scripts/misc/generate_hgvs_table.pl:    my $trans = $tran_ext_sth->fetchall_arrayref();
scripts/misc/generate_hgvs_table.pl:die "\n\tUsage generate_hgvs_table.pl -pass [admin password]
scripts/misc/generate_hgvs_table.pl:\toptions:   -host [host name]
scripts/misc/generate_hgvs_table.pl:\t           -db   [ database name]
scripts/misc/generate_pheno_class_table.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/generate_pheno_class_table.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/generate_pheno_class_table.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/generate_pheno_class_table.pl:$registry->load_registry_from_db(
scripts/misc/generate_pheno_class_table.pl:    -host => $host,
scripts/misc/generate_pheno_class_table.pl:    -port => $port,
scripts/misc/generate_pheno_class_table.pl:    -user => 'ensro',
scripts/misc/generate_pheno_class_table.pl:    -db_version => $db_version,
scripts/misc/generate_pheno_class_table.pl:my $vdb = $registry->get_DBAdaptor($species,'variation');
scripts/misc/generate_pheno_class_table.pl:my $dbVar = $vdb->dbc->db_handle;
scripts/misc/generate_pheno_class_table.pl:my $border_left = qq{ style="border-left:1px solid #BBB"};
scripts/misc/generate_pheno_class_table.pl:  my $class_example = $class_example_data->{html};
scripts/misc/generate_pheno_class_table.pl:  my $sth = $dbVar->prepare($stmt);
scripts/misc/generate_pheno_class_table.pl:  $sth->bind_param(1, $value);
scripts/misc/generate_pheno_class_table.pl:  $sth->bind_param(2, $source);
scripts/misc/generate_pheno_class_table.pl:  $sth->execute();
scripts/misc/generate_pheno_class_table.pl:  return $sth->fetchrow_array;
scripts/misc/generate_pheno_class_table.pl:  my @var = (execute_stmt_one_result($data->{'query'},$value, $source));
scripts/misc/generate_pheno_class_table.pl:  my $example = (defined($var[0])) ? sprintf (qq{<a href="%s%s">%s</a>},$data->{'link'},$var[0],$var[0]) : '-';
scripts/misc/generate_pheno_class_table.pl:  my $pheno = $class_example->{var}[1];
scripts/misc/generate_pheno_class_table.pl:  my $source = $data->{class}{$class}{source};
scripts/misc/generate_pheno_class_table.pl:  my $desc_ex = (defined($class)) ? sprintf (qq{'$pheno' from <a href="%s">%s</a>},$source_url{$source}, $source) : '-';
scripts/misc/generate_pheno_class_table.pl:  Update the clinical significance tables in "data_description.html" (under public-plugins/ensembl/htdocs/info/genome/variation/).
scripts/misc/generate_pheno_class_table.pl:    -help           Print this message
scripts/misc/generate_pheno_class_table.pl:    -v              Ensembl version, e.g. 65 (Required)
scripts/misc/generate_pheno_class_table.pl:    -o              An HTML output file name (Required)
scripts/misc/generate_pheno_class_table.pl:    -host           Host of the human database (Required)
scripts/misc/generate_pheno_class_table.pl:    -port           Human database port (Required)
scripts/misc/generate_pheno_class_table.pl:    -species        Species name (Required)
scripts/misc/species_list_detailed_counts.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/species_list_detailed_counts.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/species_list_detailed_counts.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/species_list_detailed_counts.pl:  print "> Error! Please give an Ensembl version, using the option '-v' \n";
scripts/misc/species_list_detailed_counts.pl:  print "> Error! Please give an output file using the option '-o'\n";
scripts/misc/species_list_detailed_counts.pl:  print "> Error! Please give the list of host names where the new databases are stored using the option '-hlist'\n";
scripts/misc/species_list_detailed_counts.pl:  print "> Error! Please give user name using the option '-user'\n";
scripts/misc/species_list_detailed_counts.pl:my $p_version = $e_version-1;
scripts/misc/species_list_detailed_counts.pl:    <h1 style="margin-top:15px">Ensembl Variation - Detailed species data count</h1>
scripts/misc/species_list_detailed_counts.pl:    <h2>List of data counts by category and species - $ecaption $e_version</h2>
scripts/misc/species_list_detailed_counts.pl:  <!-- Right hand side legend -->
scripts/misc/species_list_detailed_counts.pl:  <div style="float:right;max-width:220px;top:20px">
scripts/misc/species_list_detailed_counts.pl:        <img src="/i/16/info.png" style="vertical-align:top" alt="info" /> 
scripts/misc/species_list_detailed_counts.pl:my $th_bg = qq{background-color:#BBB};
scripts/misc/species_list_detailed_counts.pl:my $th_border_left = qq{border-left:1px solid #DDD};
scripts/misc/species_list_detailed_counts.pl:my $th_border_left_top = qq{style="$th_border_left;text-align:center"};
scripts/misc/species_list_detailed_counts.pl:    while (my ($dbname) = $sth->fetchrow_array) {
scripts/misc/species_list_detailed_counts.pl:      next if ($dbname !~ /^[a-z][a-z_]*_[a-z]+_variation_\d+_\d+$/i);
scripts/misc/species_list_detailed_counts.pl:      if ($etype) { # EG site - need to filter out species
scripts/misc/species_list_detailed_counts.pl:        my $img_thumb = sprintf qq{eg-plugins/%s/htdocs/img/species/thumb_%s.png}, $etype, ucfirst($s_name);
scripts/misc/species_list_detailed_counts.pl:        #  print "- checking for $img_thumb ... ";
scripts/misc/species_list_detailed_counts.pl:        if (! -e $img_thumb) {
scripts/misc/species_list_detailed_counts.pl:      my $display_name = $sth_core->fetchrow_array;  
scripts/misc/species_list_detailed_counts.pl:      # Count the number of variations - column A
scripts/misc/species_list_detailed_counts.pl:      my $res_a = $sth_a->fetchrow_array;
scripts/misc/species_list_detailed_counts.pl:      $sth_a->finish;
scripts/misc/species_list_detailed_counts.pl:      # Count the number of variations - column B
scripts/misc/species_list_detailed_counts.pl:      my $res_b = $sth_b->fetchrow_array;
scripts/misc/species_list_detailed_counts.pl:      $sth_b->finish;
scripts/misc/species_list_detailed_counts.pl:      my $p_dbname = $sth3->fetchrow_array;
scripts/misc/species_list_detailed_counts.pl:        # Previous variants - column A
scripts/misc/species_list_detailed_counts.pl:        my $p_res_a = $sth4a->fetchrow_array;
scripts/misc/species_list_detailed_counts.pl:        $sth4a->finish;
scripts/misc/species_list_detailed_counts.pl:        $species_list{$s_name}{'p_a'} = $res_a-$p_res_a;
scripts/misc/species_list_detailed_counts.pl:        # Previous variants - column B
scripts/misc/species_list_detailed_counts.pl:          $p_res_b = $sth4b->fetchrow_array;
scripts/misc/species_list_detailed_counts.pl:          $sth4b->finish;
scripts/misc/species_list_detailed_counts.pl:          $species_list{$s_name}{'p_b'} = $res_b-$p_res_b;
scripts/misc/species_list_detailed_counts.pl:        <th style="$th_bg;padding-left:0px">
scripts/misc/species_list_detailed_counts.pl:        <th style="$th_bg;padding-left:0px">
scripts/misc/species_list_detailed_counts.pl:    my $img_class = "badge-32";
scripts/misc/species_list_detailed_counts.pl:    $b_count = ($b_type eq 'num') ? round_count($b_count,$lc_label_b) : qq{<ul style="margin-bottom:0px"><li style="margin-top:0px">}.join("</li><li>", split(',',$b_count))."</li></ul>";
scripts/misc/species_list_detailed_counts.pl:    <tr$bg style="vertical-align:middle">
scripts/misc/species_list_detailed_counts.pl:            <a href="/$uc_sp/Info/Index" title="$label Ensembl Home page" style="vertical-align:middle" target="_blank">
scripts/misc/species_list_detailed_counts.pl:              <img src="$img_src" alt="$label" class="$img_class" style="vertical-align:middle" />
scripts/misc/species_list_detailed_counts.pl:           <div style="float:left;margin-left:6px;padding-top:2px">
scripts/misc/species_list_detailed_counts.pl:             <div class="small" style="font-style:italic">$label</div>
scripts/misc/species_list_detailed_counts.pl:      <td style="text-align:right">$a_count</td>
scripts/misc/species_list_detailed_counts.pl:      <td style="text-align:right">$a_p_count</td>
scripts/misc/species_list_detailed_counts.pl:      <td style="text-align:$b_align">$b_count</td>\n};
scripts/misc/species_list_detailed_counts.pl:    $html_content .= qq{      <td style="text-align:right">$b_p_count</td>\n} if ($b_type eq 'num');
scripts/misc/species_list_detailed_counts.pl:  $html .= qq{\n  <h2 id="$anchor" style="margin-top:40px">$type data</h2>};
scripts/misc/species_list_detailed_counts.pl:  $html .= qq{<p style="padding-top:0px;margin-top:0px">There are currently <span style="font-weight:bold;font-size:1.1em;color:#000">$count_species</span> species with $lc_type data in the Ensembl Variation databases:</p>\n};
scripts/misc/species_list_detailed_counts.pl:        <td style="padding-top:4px;text-align:center">
scripts/misc/species_list_detailed_counts.pl:        <td style="padding-top:4px">$desc</td>
scripts/misc/species_list_detailed_counts.pl:print HTML qq{<p style="padding-top:15px">The <b>full list of species</b> with their assembly versions in Ensembl is available <a href="/info/about/species.html">here</a>.</p>\n};
scripts/misc/species_list_detailed_counts.pl:  my $dbh = DBI->connect($dsn, $user, $pswd) or die "Connection failed";
scripts/misc/species_list_detailed_counts.pl:  my $sth = $dbh->prepare($sql);
scripts/misc/species_list_detailed_counts.pl:  $sth->execute;
scripts/misc/species_list_detailed_counts.pl:    return '-';
scripts/misc/species_list_detailed_counts.pl:    $symbol = '-';
scripts/misc/species_list_detailed_counts.pl:    -help           Print this message
scripts/misc/species_list_detailed_counts.pl:    -v              Ensembl version, e.g. 65 (Required)
scripts/misc/species_list_detailed_counts.pl:    -o              An HTML output file name (Required)      
scripts/misc/species_list_detailed_counts.pl:    -hlist          The list of host names where the new databases are stored, separated by a coma,
scripts/misc/species_list_detailed_counts.pl:    -phost          Host name where the previous databases are stored, e.g. ensembldb.ensembl.org  (Required)
scripts/misc/species_list_detailed_counts.pl:    -user           MySQL user name (Required)
scripts/misc/species_list_detailed_counts.pl:    -port           MySQL port. 3306 by default (optional)
scripts/misc/species_list_detailed_counts.pl:    -site           The URL of the website (optional)
scripts/misc/species_list_detailed_counts.pl:    -etype          The type of Ensembl, e.g. Plant (optional)
scripts/misc/update_seq_region_coord.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/update_seq_region_coord.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/update_seq_region_coord.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/update_seq_region_coord.pl:my $cli_helper = Bio::EnsEMBL::Utils::CliHelper->new();
scripts/misc/update_seq_region_coord.pl:my $opts = $cli_helper->process_args( $optsd, \&usage );
scripts/misc/update_seq_region_coord.pl:if (defined $opts->{dbname}) {
scripts/misc/update_seq_region_coord.pl:  die "Variation database required" unless ($opts->{dbname} =~ m/variation/);
scripts/misc/update_seq_region_coord.pl:  my $version = $opts->{version};
scripts/misc/update_seq_region_coord.pl:  $opts->{pattern} = 'variation_'.$version.'_\d+$';
scripts/misc/update_seq_region_coord.pl:  my $vdba = $variation_dbas->{$variation_dbname};
scripts/misc/update_seq_region_coord.pl:  if ($opts->{truncate}) {
scripts/misc/update_seq_region_coord.pl:    my $trunc = $vdba->dbc()->sql_helper()->execute(
scripts/misc/update_seq_region_coord.pl:                                         -SQL => $sql_truncate);
scripts/misc/update_seq_region_coord.pl:  if ($opts->{dry_run}) {
scripts/misc/update_seq_region_coord.pl:    my $num_update = $vdba->dbc()->sql_helper()->execute_update(
scripts/misc/update_seq_region_coord.pl:                                         -SQL => $sql_update);
scripts/misc/update_seq_region_coord.pl:  if ($opts->{dry_run}) {
scripts/misc/update_seq_region_coord.pl:    my $num_update = $vdba->dbc()->sql_helper()->execute_update(
scripts/misc/update_seq_region_coord.pl:                                         -SQL => $sql_update);
scripts/misc/update_seq_region_coord.pl:  for my $db_args ( @{ $cli_helper->get_dba_args_for_opts( $opts, 0 ) } ) {
scripts/misc/update_seq_region_coord.pl:    my $dbname = $dba->dbc()->dbname();
scripts/misc/update_seq_region_coord.pl:    $dbas->{$dbname} = $dba;
scripts/misc/update_seq_region_coord.pl:    my $opt = join '|', @{$_->{args}};
scripts/misc/update_seq_region_coord.pl:    $opt . $_->{type};
scripts/misc/update_seq_region_coord.pl:  $0 --dbhost=XhostX [--dbport=3306] \\
scripts/misc/update_seq_region_coord.pl:  \t--dbuser=XuserX --dbpass=XXX \\
scripts/misc/update_seq_region_coord.pl:  $0 \$(XserverX details script_db) --dbname XdbnameX
scripts/misc/update_seq_region_coord.pl:  $0 \$(XserverX details script_db) --dbname XdbnameX --dry_run
scripts/misc/update_seq_region_coord.pl:  $0 \$(XserverX details script_db) --version Xrelease-versionX
scripts/misc/update_seq_region_coord.pl:  $0 --help
scripts/misc/update_seq_region_coord.pl:  --dry_run     Print update statements
scripts/misc/update_seq_region_coord.pl:  --help        Displays this help text.
scripts/misc/update_seq_region_coord.pl:- the variation seq_region.coord_system_id with core seq_region.coord_system_id
scripts/misc/update_seq_region_coord.pl:- the variation coord_system table with coord_system records
scripts/misc/update_seq_region_coord.pl:  my $helper = $vdba->dbc()->sql_helper();
scripts/misc/update_seq_region_coord.pl:   my $count = $helper->execute_single_result(-SQL => $sql);
scripts/misc/update_web_documentation.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/update_web_documentation.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/update_web_documentation.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/update_web_documentation.pl:die "Could not find output dir $output_dir - please create it first\n" unless -d $output_dir;
scripts/misc/update_web_documentation.pl:`perl $dirname/species_list.pl -v $version -o $tmp_section -hlist $hlist -user $user -phost $phost`;
scripts/misc/update_web_documentation.pl:`rm -f $tmp_section`;
scripts/misc/update_web_documentation.pl:print STDOUT localtime() . "\t\t> Species list - finished\n";
scripts/misc/update_web_documentation.pl:`perl $dirname/generate_classes_table.pl -v $version -o $tmp_section -host $host -port $port -ohost $ohost -species $species`;
scripts/misc/update_web_documentation.pl:`rm -f $tmp_section`;
scripts/misc/update_web_documentation.pl:print STDOUT localtime() . "\t\t> Variant classes - finished\n";
scripts/misc/update_web_documentation.pl:`perl $dirname/generate_population_table.pl -v $version -o $tmp_section -hlist $hlist -user $user`;
scripts/misc/update_web_documentation.pl:`rm -f $tmp_section`;
scripts/misc/update_web_documentation.pl:print STDOUT localtime() . "\t\t> Populations - finished\n";
scripts/misc/update_web_documentation.pl:`perl $dirname/generate_variation_set_table.pl -v $version -o $tmp_section -hlist $hlist -user $user`;
scripts/misc/update_web_documentation.pl:`rm -f $tmp_section`;
scripts/misc/update_web_documentation.pl:print STDOUT localtime() . "\t\t> Variant sets - finished\n";
scripts/misc/update_web_documentation.pl:`perl $dirname/generate_clin_significance_tables.pl -v $version -o $tmp_section -host $host -port $port -species $species`;
scripts/misc/update_web_documentation.pl:`rm -f $tmp_section`;
scripts/misc/update_web_documentation.pl:print STDOUT localtime() . "\t\t> Clinical significance - finished\n";
scripts/misc/update_web_documentation.pl:`perl $dirname/generate_pheno_class_table.pl -v $version -o $tmp_section -host $host -port $port -species $species`;
scripts/misc/update_web_documentation.pl:`rm -f $tmp_section`;
scripts/misc/update_web_documentation.pl:print STDOUT localtime() . "\t\t> Phenotype class - finished\n";
scripts/misc/update_web_documentation.pl:if (-d "$output_dir/$subdir") {
scripts/misc/update_web_documentation.pl:  my $o_version = ($sth->fetchrow_array)[0];
scripts/misc/update_web_documentation.pl:  $tmp_file_content =~ s/<span id="$onto\_version">(\d+(-|\.)?)+<\/span>/<span id="$onto\_version">$o_version<\/span>/i;  
scripts/misc/update_web_documentation.pl:print STDOUT localtime() . "\t\t> Phenotype ontology - finished\n";
scripts/misc/update_web_documentation.pl:`perl $dirname/sources2html.pl -v $version -o $tmp_file -hlist $hlist -phost $phost`;
scripts/misc/update_web_documentation.pl:print STDOUT localtime() . "\t\t> Sources list - finished\n";
scripts/misc/update_web_documentation.pl:`perl $dirname/phensources2html.pl -v $version -o $tmp_file -hlist $hlist -phost $phost`;
scripts/misc/update_web_documentation.pl:print STDOUT localtime() . "\t\t> Phenotype sources list - finished\n";
scripts/misc/update_web_documentation.pl:#### Create the detailed species data count documentation (including SIFT and PolyPhen-2)
scripts/misc/update_web_documentation.pl:`perl $dirname/species_list_detailed_counts.pl -v $version -o $tmp_file -hlist $hlist -phost $phost --user ensro`;
scripts/misc/update_web_documentation.pl:print STDOUT localtime() . "\t\t> Detailed species data count - finished\n";
scripts/misc/update_web_documentation.pl:#---------#
scripts/misc/update_web_documentation.pl:#---------#
scripts/misc/update_web_documentation.pl:  my $anchor = "<!-- Data $section - $type -->";
scripts/misc/update_web_documentation.pl:  my $line = `grep -m1 -n '$anchor' $tmp_file`;
scripts/misc/update_web_documentation.pl:    $content = `head -n$line_number $tmp_file`;
scripts/misc/update_web_documentation.pl:    my $lines_count = (split(' ',`wc -l $tmp_file`))[0];
scripts/misc/update_web_documentation.pl:    $line_number = $lines_count - $line_number + 1;
scripts/misc/update_web_documentation.pl:    $content = `tail -n$line_number $tmp_file`;
scripts/misc/update_web_documentation.pl:  my $dbh = DBI->connect($dsn, $user, '') or die "Connection failed";
scripts/misc/update_web_documentation.pl:  my $sth = $dbh->prepare($sql);
scripts/misc/update_web_documentation.pl:    $sth->execute(join(',',@$params));
scripts/misc/update_web_documentation.pl:    $sth->execute;
scripts/misc/update_web_documentation.pl:  my $file_path = (-d "$output_dir/$sdir") ? "$output_dir/$sdir/$fname" : "$output_dir/$fname";
scripts/misc/update_web_documentation.pl:  Update the Variation web documentation pages (under public-plugins/ensembl/htdocs/info/genome/variation/).
scripts/misc/update_web_documentation.pl:    -help           Print this message
scripts/misc/update_web_documentation.pl:    -v              Ensembl version, e.g. 65 (Required)
scripts/misc/update_web_documentation.pl:    -i              Path to the input directory (Required)
scripts/misc/update_web_documentation.pl:    -o              Path to the output directory (Required)
scripts/misc/update_web_documentation.pl:    -host           Host of the human database (Required)
scripts/misc/update_web_documentation.pl:    -port           MySQL port of the human database (Required)
scripts/misc/update_web_documentation.pl:    -species        Species name. 'Homo_sapiens' by default (optional)
scripts/misc/update_web_documentation.pl:    -hlist          The list of host names where the new databases are stored, separated by a coma,
scripts/misc/update_web_documentation.pl:    -phost          Host name where the previous databases are stored, e.g. ensembldb.ensembl.org  (Required)
scripts/misc/update_web_documentation.pl:    -ohost          Host name where the ontology database is stored, with the port, e.g. ensembldb.ensembl.org:1234 (Required)
scripts/misc/update_web_documentation.pl:    -user           MySQL user name (Required)
scripts/misc/update_web_documentation.pl:    -no_subdir      Doesn't copy the files onto their subdirectories
scripts/misc/merge_vep_caches.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/merge_vep_caches.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/merge_vep_caches.pl:     http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/merge_vep_caches.pl:) or die "ERROR: Failed to parse command-line flags\n";
scripts/misc/merge_vep_caches.pl:do { usage(); exit(0); } if $config->{help};
scripts/misc/merge_vep_caches.pl:$config->{dir}     ||= $ENV{HOME}.'/.vep/';
scripts/misc/merge_vep_caches.pl:$config->{version} ||= Bio::EnsEMBL::Registry->software_version;
scripts/misc/merge_vep_caches.pl:$config->{species} ||= 'all';
scripts/misc/merge_vep_caches.pl:$config->{compress}||= 'zcat';
scripts/misc/merge_vep_caches.pl:$config->{cache_region_size} = 1e6;
scripts/misc/merge_vep_caches.pl:if($config->{species} ne 'all') {
scripts/misc/merge_vep_caches.pl:  $match_species{$_} = 1 for split(/\,/, $config->{species});
scripts/misc/merge_vep_caches.pl:opendir DIR, $config->{dir};
scripts/misc/merge_vep_caches.pl:  -d $config->{dir}.'/'.$_ &&
scripts/misc/merge_vep_caches.pl:#  -d $config->{dir}.'/'.$_.'/'.$config->{version} &&
scripts/misc/merge_vep_caches.pl:  -d $config->{dir}.'/'.$_.'_refseq' # &&
scripts/misc/merge_vep_caches.pl:#  -d $config->{dir}.'/'.$_.'_refseq/'.$config->{version}
scripts/misc/merge_vep_caches.pl:  opendir ENS, $config->{dir}.'/'.$species;
scripts/misc/merge_vep_caches.pl:  opendir REF, $config->{dir}.'/'.$species.'_refseq';
scripts/misc/merge_vep_caches.pl:  my $v = $config->{version};
scripts/misc/merge_vep_caches.pl:  next unless $config->{species} eq 'all' || defined($match_species{$species});
scripts/misc/merge_vep_caches.pl:    my $ens_root = join("/", $config->{dir}, $species, $config->{version}.($ass ? '_'.$ass : ''));
scripts/misc/merge_vep_caches.pl:    my $ref_root = join("/", $config->{dir}, $species.'_refseq', $config->{version}.($ass ? '_'.$ass : ''));
scripts/misc/merge_vep_caches.pl:    my $mrg_root = join("/", $config->{dir}, $species.'_merged', $config->{version}.($ass ? '_'.$ass : ''));
scripts/misc/merge_vep_caches.pl:    mkdir($config->{dir}.'/'.$species.'_merged/');
scripts/misc/merge_vep_caches.pl:    my %ens_chrs = map {$_ => 1} grep {-d $ens_root.'/'.$_ && !/^\./} readdir ENSROOT;
scripts/misc/merge_vep_caches.pl:    my %ref_chrs = map {$_ => 1} grep {-d $ref_root.'/'.$_ && !/^\./} readdir REFROOT;
scripts/misc/merge_vep_caches.pl:      if(-d $ens_root.'/'.$chr && -d $ref_root.'/'.$chr) {
scripts/misc/merge_vep_caches.pl:          if(-e $ens_root.'/'.$chr.'/'.$file && -e $ref_root.'/'.$chr.'/'.$file) {
scripts/misc/merge_vep_caches.pl:            open my $ens_fh, $config->{compress}." ".$ens_root.'/'.$chr.'/'.$file." |";
scripts/misc/merge_vep_caches.pl:            $_->{_source_cache} = 'Ensembl' for @{$ens_cache->{$chr}};
scripts/misc/merge_vep_caches.pl:            open my $ref_fh, $config->{compress}." ".$ref_root.'/'.$chr.'/'.$file." |";
scripts/misc/merge_vep_caches.pl:            $_->{_source_cache} = 'RefSeq' for @{$ref_cache->{$chr}};
scripts/misc/merge_vep_caches.pl:            @{$mrg_cache->{$chr}} = sort {$a->{start} <=> $b->{start}} (@{$ens_cache->{$chr}}, @{$ref_cache->{$chr}});
scripts/misc/merge_vep_caches.pl:            open my $mrg_fh, "| gzip -9 -c > ".$mrg_root.'/'.$chr.'/'.$file or die "ERROR: Could not write to dump file";
scripts/misc/merge_vep_caches.pl:            my $root = -e $ens_root.'/'.$chr.'/'.$file ? $ens_root : $ref_root;
scripts/misc/merge_vep_caches.pl:        my $root = -d $ens_root.'/'.$chr ? $ens_root : $ref_root;
scripts/misc/merge_vep_caches.pl:Merge Ensembl- and RefSeq-based VEP caches
scripts/misc/merge_vep_caches.pl:--dir | -d        Root directory of VEP caches (\$HOME/.vep/)
scripts/misc/merge_vep_caches.pl:--version | -v    Cache version (current API version)
scripts/misc/merge_vep_caches.pl:--species | -s    Species (all species found with both cache types)
scripts/misc/generate_population_table.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/generate_population_table.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/generate_population_table.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/generate_population_table.pl:  print "> Error! Please give an Ensembl version, using the option '-v' \n";
scripts/misc/generate_population_table.pl:  print "> Error! Please give an output file using the option '-o'\n";
scripts/misc/generate_population_table.pl:  print "> Error! Please give the list of host names where the new databases are stored using the option '-hlist'\n";
scripts/misc/generate_population_table.pl:  print "> Error! Please give user name using the option '-user'\n";
scripts/misc/generate_population_table.pl:my $vcf_config = JSON->new->decode($json_string) or throw("ERROR: Failed to parse config file $vcf_config_file");
scripts/misc/generate_population_table.pl:  'TOPMed'          => 'https://www.nhlbi.nih.gov/research/resources/nhlbi-precision-medicine-initiative/topmed',
scripts/misc/generate_population_table.pl:  'EVA'             => 'https://www.ebi.ac.uk/eva/?eva-study=###ID###',
scripts/misc/generate_population_table.pl:  'Gambian Genome Variation Project' => 'https://www.internationalgenome.org/data-portal/data-collection/ggvp-grch38',
scripts/misc/generate_population_table.pl:  'GEM-J'           => 'https://togovar.biosciencedbc.jp/doc/datasets/gem_j_wga',
scripts/misc/generate_population_table.pl:my $img_class = "badge-48";
scripts/misc/generate_population_table.pl:  while (my ($dbname) = $sth->fetchrow_array) {
scripts/misc/generate_population_table.pl:    next if ($dbname !~ /^[a-z][a-z_]*_[a-z]+_$db_type\_$e_version\_\d+$/i);
scripts/misc/generate_population_table.pl:  $sth->finish;
scripts/misc/generate_population_table.pl:    <div style="padding-left:0px;padding-bottom:3px;margin-top:$margin_top;margin-bottom:20px">
scripts/misc/generate_population_table.pl:      <a href="/$id_species/Info/Index" title="$species Ensembl Home page" style="vertical-align:middle" target="_blank"><img src="/i/species/$id_species.png" alt="$id_species" class="$img_class" style="float:none;margin-right:4px;vertical-align:middle" /></a>
scripts/misc/generate_population_table.pl:    <div style="margin-left:10px">
scripts/misc/generate_population_table.pl:    my $html_current_pop = qq{<table id="$project_id" class="ss" style="margin-bottom:5px">\n  $pop_table_header\n};
scripts/misc/generate_population_table.pl:        $html_current_pop .= qq{  <tr$new_bg>\n    <td>$p_name</td>\n    <td style="text-align:right">$size</td>\n    <td>$desc</td>\n  </tr>\n};
scripts/misc/generate_population_table.pl:    my $project_title = ($url) ? qq{<a href="$url" target="_blank" style="text-decoration:none">$project_label</a>} : $project_label;
scripts/misc/generate_population_table.pl:      <p style="margin-bottom:$margin_bottom_max">
scripts/misc/generate_population_table.pl:      On the website this corresponds to the icon <a href="$evidence_doc_url"><img class="_ht" src="$evidence_img" title="$evidence" style="vertical-align:bottom"/></a>.
scripts/misc/generate_population_table.pl:      $html_pop .= qq{\n  <div style="margin-bottom:$margin_bottom_max"></div>\n};
scripts/misc/generate_population_table.pl:      if (!$pop_tree->{$pop_id} && !$sub_pops->{$pop_id}) {
scripts/misc/generate_population_table.pl:      elsif ($pop_tree->{$pop_id}) {
scripts/misc/generate_population_table.pl:# Add the sub-populations after the super-population in the "pop_list" array
scripts/misc/generate_population_table.pl:  foreach my $sub_pop_id (sort {$a cmp $b} keys(%{$pop_tree->{$pop_id}})) {
scripts/misc/generate_population_table.pl:    if ($pop_tree->{$sub_pop_id}) {
scripts/misc/generate_population_table.pl:  while(my @data = $sth->fetchrow_array) {
scripts/misc/generate_population_table.pl:  $sth->finish;
scripts/misc/generate_population_table.pl:  my $size = ($sth->fetchrow_array)[0];
scripts/misc/generate_population_table.pl:  $sth->finish;
scripts/misc/generate_population_table.pl:  return ($size == 0) ? '-' : $size;
scripts/misc/generate_population_table.pl:  $content = '-' if (!$content);
scripts/misc/generate_population_table.pl:  while(my @data = $pop_sth->fetchrow_array) {
scripts/misc/generate_population_table.pl:  $pop_sth->finish;
scripts/misc/generate_population_table.pl:  foreach my $project (@{$vcf_config->{'collections'}}) {
scripts/misc/generate_population_table.pl:    my $project_id = $project->{'id'};
scripts/misc/generate_population_table.pl:    next if ($project->{'assembly'} =~ /GRCh37/i || $project->{'annotation_type'});
scripts/misc/generate_population_table.pl:    my $species = ucfirst($project->{'species'});
scripts/misc/generate_population_table.pl:      $species_usual_name{$species} = ($spe_sth->fetchrow_array)[0];
scripts/misc/generate_population_table.pl:      $spe_sth->finish;
scripts/misc/generate_population_table.pl:    if ($project->{'population_prefix'}) {
scripts/misc/generate_population_table.pl:      $population_prefix = $project->{'population_prefix'};
scripts/misc/generate_population_table.pl:    elsif ($project->{'sample_prefix'}) {
scripts/misc/generate_population_table.pl:      $population_prefix = $project->{'sample_prefix'};
scripts/misc/generate_population_table.pl:    if ($project->{'populations'}) {
scripts/misc/generate_population_table.pl:      foreach my $pop (keys(%{$project->{'populations'}})) {
scripts/misc/generate_population_table.pl:        my $pop_name = $project->{'populations'}{$pop}{'name'};
scripts/misc/generate_population_table.pl:        my $pop_desc = $project->{'populations'}{$pop}{'description'};
scripts/misc/generate_population_table.pl:                                'size'  => '-'
scripts/misc/generate_population_table.pl:      while(my @data = $sth->fetchrow_array) {
scripts/misc/generate_population_table.pl:        $data[2] = '-' if (!$data[2]);
scripts/misc/generate_population_table.pl:        my $size = ($data[2] && $data[2] ne '-' ) ? $data[2] : get_size($data[0], $dbname, $host);
scripts/misc/generate_population_table.pl:      $sth->finish;
scripts/misc/generate_population_table.pl:  my $label =  $project->{'id'};
scripts/misc/generate_population_table.pl:  if ($project->{'population_display_group'} && $project->{'population_display_group'}{'display_group_name'}) {
scripts/misc/generate_population_table.pl:    $label = $project->{'population_display_group'}{'display_group_name'};
scripts/misc/generate_population_table.pl:  elsif ($project->{'source_name'}) {
scripts/misc/generate_population_table.pl:    $label = $project->{'source_name'};
scripts/misc/generate_population_table.pl:  my $dbh = DBI->connect($dsn, $user, $pswd) or die "Connection failed";
scripts/misc/generate_population_table.pl:  my $sth = $dbh->prepare($sql);
scripts/misc/generate_population_table.pl:    $sth->execute(@$params);
scripts/misc/generate_population_table.pl:    $sth->execute;
scripts/misc/generate_population_table.pl:    -help           Print this message
scripts/misc/generate_population_table.pl:    -v              Ensembl version, e.g. 65 (Required)
scripts/misc/generate_population_table.pl:    -o              An HTML output file name (Required)      
scripts/misc/generate_population_table.pl:    -hlist          The list of host names (with port) where the new databases are stored, separated by a coma,
scripts/misc/generate_population_table.pl:    -user           MySQL user name (Required)
scripts/misc/copy_vep_dbs.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/copy_vep_dbs.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/copy_vep_dbs.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/copy_vep_dbs.pl:if(defined($config->{help}) || !@ARGV) {
scripts/misc/copy_vep_dbs.pl:--version | -v          Database version to copy
scripts/misc/copy_vep_dbs.pl:--target_host | -h     Target DB host
scripts/misc/copy_vep_dbs.pl:--target_port | -P     Target DB port
scripts/misc/copy_vep_dbs.pl:--target_pass | -p     Target DB password
scripts/misc/copy_vep_dbs.pl:NB target DB user is hard-coded to ensadmin in CopyDBoverServer.pl
scripts/misc/copy_vep_dbs.pl:--source_host | -sh      Source DB host(s) (default: ens-staging1,ens-staging2)
scripts/misc/copy_vep_dbs.pl:--source_user | -su      Source DB user (default: ensro)
scripts/misc/copy_vep_dbs.pl:--source_port | -sP      Source DB port (default: 3306)
scripts/misc/copy_vep_dbs.pl:--source_pass | -sp      Source DB password
scripts/misc/copy_vep_dbs.pl:--copy_script | -c      Path to CopyDBoverServer.pl
scripts/misc/copy_vep_dbs.pl:--tables | -t           Comma-separated list of tables to copy
scripts/misc/copy_vep_dbs.pl:--pattern | -p          Select only databases that match '%pattern%'
scripts/misc/copy_vep_dbs.pl:$config->{source_hosts}    ||= 'ens-staging,ens-staging2';
scripts/misc/copy_vep_dbs.pl:$config->{source_user}     ||= 'ensro';
scripts/misc/copy_vep_dbs.pl:$config->{source_port}     ||= 3306;
scripts/misc/copy_vep_dbs.pl:$config->{target_port}     ||= 3306;
scripts/misc/copy_vep_dbs.pl:$config->{copy_script}     ||= '../../../ensembl/misc-scripts/CopyDBoverServer.pl';
scripts/misc/copy_vep_dbs.pl:$config->{tables}          ||= join(',', qw(
scripts/misc/copy_vep_dbs.pl:die("ERROR: Could not find DB copy script ".$config->{copy_script}."\n") unless defined($config->{copy_script}) && -e $config->{copy_script};
scripts/misc/copy_vep_dbs.pl:  die("ERROR: No target $_ given - use --target_$_ [$_]") unless defined($config->{'target_'.$_});
scripts/misc/copy_vep_dbs.pl:die "ERROR: No Ensembl DB version defined - use --version [version]\n" unless defined($config->{version});
scripts/misc/copy_vep_dbs.pl:$config->{source_hosts} = [split /\,/, $config->{source_hosts}];
scripts/misc/copy_vep_dbs.pl:foreach my $host(@{$config->{source_hosts}}) {
scripts/misc/copy_vep_dbs.pl:  my $dbc = connect_to_host($host, $config->{source_port}, $config->{source_user}, $config->{source_password});
scripts/misc/copy_vep_dbs.pl:	my $version = $config->{version};
scripts/misc/copy_vep_dbs.pl:	my $sth = $dbc->prepare(qq{
scripts/misc/copy_vep_dbs.pl:	$sth->execute();
scripts/misc/copy_vep_dbs.pl:	$sth->bind_columns(\$db);
scripts/misc/copy_vep_dbs.pl:	push @dbs, $db while $sth->fetch;
scripts/misc/copy_vep_dbs.pl:	$sth->finish;
scripts/misc/copy_vep_dbs.pl:  my $pattern = $config->{pattern};
scripts/misc/copy_vep_dbs.pl:	my $dbc = DBI->connect(
scripts/misc/copy_vep_dbs.pl:    'perl %s --source %s@%s:%i --target %s@%s:%i --pass %s --only_tables %s%s',
scripts/misc/copy_vep_dbs.pl:    $config->{copy_script},
scripts/misc/copy_vep_dbs.pl:    $db, $host, $config->{source_port},
scripts/misc/copy_vep_dbs.pl:    $db, $config->{target_host}, $config->{target_port},
scripts/misc/copy_vep_dbs.pl:    $config->{target_password},
scripts/misc/copy_vep_dbs.pl:    $config->{tables},
scripts/misc/copy_vep_dbs.pl:    $config->{force} ? ' --force' : ''
scripts/misc/copy_vep_dbs.pl:    ($time[5] + 1900)."-".
scripts/misc/copy_vep_dbs.pl:    $time[4]."-".
scripts/misc/copy_vep_dbs.pl:  print $time." - ".$text.($text =~ /\n$/ ? "" : "\n");
scripts/misc/convert_ensembl_to_SO_consequences.pl:# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
scripts/misc/convert_ensembl_to_SO_consequences.pl:# Copyright [2016-2022] EMBL-European Bioinformatics Institute
scripts/misc/convert_ensembl_to_SO_consequences.pl:#      http://www.apache.org/licenses/LICENSE-2.0
scripts/misc/convert_ensembl_to_SO_consequences.pl:if(@ARGV and ($ARGV[0] =~ /^(-)+h/)) {
scripts/misc/convert_ensembl_to_SO_consequences.pl:my @cons = grep {$_->{display_term} =~ /\w+/} sort {$b->rank <=> $a->rank} values %OVERLAP_CONSEQUENCES;
scripts/misc/convert_ensembl_to_SO_consequences.pl:        my $ens = $con->{display_term};
scripts/misc/convert_ensembl_to_SO_consequences.pl:        my $so  = $con->{SO_term};
nextflow/ProteinFunction/nf_modules/translations.nf:  -------
nextflow/ProteinFunction/nf_modules/translations.nf:  container "quay.io/biocontainers/agat:0.9.0--pl5321hdfd78af_0"
nextflow/ProteinFunction/nf_modules/translations.nf:  agat_sp_extract_sequences.pl -g \${annot} -f \${seq} --protein \
nextflow/ProteinFunction/nf_modules/translations.nf:                               -o ${gtf.baseName}_translated.fa
nextflow/ProteinFunction/nf_modules/translations.nf:    all_md5s = current_md5s.flatten().map{it -> [md5: it]}.concat(translated)
nextflow/ProteinFunction/nf_modules/utils.nf:  container "quay.io/biocontainers/agat:0.9.0--pl5321hdfd78af_0"
nextflow/ProteinFunction/nf_modules/database_utils.nf:  mysql --host=${params.host} --port=${params.port} \
nextflow/ProteinFunction/nf_modules/database_utils.nf:        --user=${params.user} --password=${params.pass} \
nextflow/ProteinFunction/nf_modules/database_utils.nf:        ${params.database} --local-infile=1 <<'EOF'
nextflow/ProteinFunction/nf_modules/database_utils.nf:  mysql --host=${params.host} --port=${params.port} \
nextflow/ProteinFunction/nf_modules/database_utils.nf:        --user=${params.user} --password=${params.pass} \
nextflow/ProteinFunction/nf_modules/database_utils.nf:  mysql --host=${params.host} --port=${params.port} \
nextflow/ProteinFunction/nf_modules/database_utils.nf:        --user=${params.user} --password=${params.pass} \
nextflow/ProteinFunction/nf_modules/database_utils.nf:  # --batch prints output in nontabular format
nextflow/ProteinFunction/nf_modules/database_utils.nf:  mysql --host=${params.host} --port=${params.port} \
nextflow/ProteinFunction/nf_modules/database_utils.nf:        --user=${params.user} --password=${params.pass} \
nextflow/ProteinFunction/nf_modules/database_utils.nf:        ${params.database} --batch --skip-column-names <<'EOF'   
nextflow/ProteinFunction/nf_modules/sift.nf:  grep -Po "VERSION \\d+\\.\\d+\\.\\d+" /opt/sift/VERSION_UPDATE | tail -n 1 | tr -d '\n'
nextflow/ProteinFunction/nf_modules/sift.nf:  echo -n ${db.baseName} \\(`date -r ${db} -u +"%Y_%m"`\\)
nextflow/ProteinFunction/nf_modules/sift.nf:  afterScript 'rm -rf *.fa *.fa.query.out'
nextflow/ProteinFunction/nf_modules/sift.nf:  -------
nextflow/ProteinFunction/nf_modules/sift.nf:  afterScript 'rm -rf *.subs'
nextflow/ProteinFunction/nf_modules/sift.nf:  container "ensemblorg/ensembl-vep:latest"
nextflow/ProteinFunction/nf_modules/polyphen2.nf:params.pph_data = "/hps/nobackup/flicek/ensembl/variation/nuno/sift-polyphen2-nextflow-4667/input/polyphen2"
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  container "ensemblorg/polyphen-2:2.2.3"
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  cat /opt/pph2/VERSION | tr -d '\n'                                           
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  Run PolyPhen-2 on a protein sequence with a substitions file
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  -------
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  container "ensemblorg/polyphen-2:2.2.3"
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  containerOptions "--bind ${params.pph_data}:/opt/pph2/data"
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  afterScript 'rm -rf *.fa *.subs tmp/'
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  mkdir -p tmp/lock
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  /opt/pph2/bin/run_pph.pl -A -d tmp -s ${fasta} ${subs} > $out
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  if [ "$( wc -l <$out )" -eq 1 ]; then rm $out; fi
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  -------
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  container "ensemblorg/polyphen-2:2.2.3"
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  run_weka.pl -l /opt/pph2/models/${model} ${pph2_out} \
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  container "ensemblorg/ensembl-vep:latest"
nextflow/ProteinFunction/nf_modules/polyphen2.nf:  // Run PolyPhen-2 and Weka
nextflow/ProteinFunction/README.md:# Predict protein function using SIFT and PolyPhen-2
nextflow/ProteinFunction/README.md:acid substitutions (SAAS) using SIFT (for multiple species) and PolyPhen-2
nextflow/ProteinFunction/README.md:There are three modes of actions for SIFT (`sift_run_type`) and PolyPhen-2
nextflow/ProteinFunction/README.md:- `NONE` where no translations are computed for the selected program.
nextflow/ProteinFunction/README.md:- `UPDATE` where translations in the database are skipped and thus we only
nextflow/ProteinFunction/README.md:- `FULL` where the translations in the database are removed and all translations
nextflow/ProteinFunction/README.md:space-efficient serialised matrices in the database, one matrix per protein. For
nextflow/ProteinFunction/README.md:[eHIVE]: https://github.com/Ensembl/ensembl-variation/tree/release/107/modules/Bio/EnsEMBL/Variation/Pipeline/ProteinFunction
nextflow/ProteinFunction/README.md:- [Nextflow 22.04.3](https://nextflow.io)
nextflow/ProteinFunction/README.md:- Docker images:
nextflow/ProteinFunction/README.md:  - SIFT
nextflow/ProteinFunction/README.md:  - PolyPhen-2
nextflow/ProteinFunction/README.md:  - [Ensembl VEP](https://hub.docker.com/r/ensemblorg/ensembl-vep)
nextflow/ProteinFunction/README.md:  - [AGAT](https://quay.io/repository/biocontainers/agat)
nextflow/ProteinFunction/README.md:Check [nextflow.config](nextflow.config) for available pre-configured profiles.
nextflow/ProteinFunction/README.md:nextflow run main.nf -profile lsf -resume \
nextflow/ProteinFunction/README.md:         --species canis_lupus_familiaris \
nextflow/ProteinFunction/README.md:         --gtf basenji.gtf,boxer.gtf --fasta basenji.fa,boxer.fa \
nextflow/ProteinFunction/README.md:         --pph_run_type UPDATE --pph_data [path/to/pph_data] \
nextflow/ProteinFunction/README.md:         --sift_run_type UPDATE --blastdb [path/to/blastdb] \
nextflow/ProteinFunction/README.md:         --host [h] --port [p] --user [u] --pass [p] --database [db]
nextflow/ProteinFunction/README.md:| ----------------- | ----------------------------------------------- |
nextflow/ProteinFunction/README.md:| `--gtf`           | Comma-separated list of annotation GTF files (requires `--fasta`) |
nextflow/ProteinFunction/README.md:| `--fasta`         | Comma-separated list of genomic sequence FASTA files (requires `--gtf`) |
nextflow/ProteinFunction/README.md:| `--translated`    | Comma-separated list of peptide sequence FASTA files; skips sequence translation based on GTF and FASTA files |
nextflow/ProteinFunction/README.md:| `--outdir`        | Name of output dir (default: `outdir`)    |
nextflow/ProteinFunction/README.md:| `--species`       | Latin species name (default: `homo_sapiens`); PolyPhen-2 only works for human |
nextflow/ProteinFunction/README.md:| ------------ | ------------------------ |
nextflow/ProteinFunction/README.md:| `--host`     | Database server host     |
nextflow/ProteinFunction/README.md:| `--port`     | Database server port     |
nextflow/ProteinFunction/README.md:| `--user`     | Database server user     |
nextflow/ProteinFunction/README.md:| `--pass`     | Database server password |
nextflow/ProteinFunction/README.md:| `--database` | Database name            |
nextflow/ProteinFunction/README.md:| -------- | ----------- |
nextflow/ProteinFunction/README.md:| `--sift_run_type` | SIFT run type:<br/>- `FULL` to run for all translations<br/>- `UPDATE` to only run for new/changed translations<br/>- `NONE` to skip this step (default) |
nextflow/ProteinFunction/README.md:| `--blastdb`       | SIFT-formatted BLAST database directory (e.g., `uniref100`; required if running SIFT) |
nextflow/ProteinFunction/README.md:| `--median_cutoff` | Protein alignment's median cutoff (default: 2.75)           |
nextflow/ProteinFunction/README.md:**PolyPhen-2 options:**
nextflow/ProteinFunction/README.md:| -------- | ----------- |
nextflow/ProteinFunction/README.md:| `--pph_run_type` | PolyPhen-2 run type:<br/>- `FULL` to run for all translations<br/>- `UPDATE` to only run for new/changed translations<br/>- `NONE` to skip this step (default) |
nextflow/ProteinFunction/README.md:| `--pph_data`     | Path to PolyPhen-2 data (required if running PolyPhen-2); available from http://genetics.bwh.harvard.edu/pph2/dokuwiki/downloads |
nextflow/ProteinFunction/main.nf: * Nextflow pipeline to predict protein function using SIFT and PolyPhen-2
nextflow/ProteinFunction/main.nf:// PolyPhen-2 params
nextflow/ProteinFunction/main.nf:  Predict protein function using SIFT and PolyPhen-2
nextflow/ProteinFunction/main.nf:  --------------------------------------------------
nextflow/ProteinFunction/main.nf:    nextflow run main.nf -profile lsf -resume \\
nextflow/ProteinFunction/main.nf:             --species canis_lupus_familiaris \\
nextflow/ProteinFunction/main.nf:             --gtf basenji.gtf,boxer.gtf --fasta basenji.fa,boxer.fa \\
nextflow/ProteinFunction/main.nf:             --pph_run_type  UPDATE --pph_data [path/to/pph_data] \\
nextflow/ProteinFunction/main.nf:             --sift_run_type UPDATE --blastdb  [path/to/blastdb] \\
nextflow/ProteinFunction/main.nf:             --host [h] --port [p] --user [u] --pass [p] --database [db]
nextflow/ProteinFunction/main.nf:    --gtf FILE           Comma-separated list of annotation GTF files; requires
nextflow/ProteinFunction/main.nf:    --fasta FILE         Comma-separated list of FASTA files with genomic
nextflow/ProteinFunction/main.nf:    --translated FILE    Comma-separated list of FASTA files with peptide
nextflow/ProteinFunction/main.nf:    --outdir VAL         Name of output dir (default: outdir)
nextflow/ProteinFunction/main.nf:    --species VAL        Latin species name (default: homo_sapiens);
nextflow/ProteinFunction/main.nf:                         PolyPhen-2 only works for human
nextflow/ProteinFunction/main.nf:    --host VAL           Server host
nextflow/ProteinFunction/main.nf:    --port VAL           Server port
nextflow/ProteinFunction/main.nf:    --user VAL           Server user
nextflow/ProteinFunction/main.nf:    --pass VAL           Server password
nextflow/ProteinFunction/main.nf:    --database VAL       Name of database
nextflow/ProteinFunction/main.nf:    --sift_run_type VAL  SIFT run type:
nextflow/ProteinFunction/main.nf:                           - FULL   to run for all translations
nextflow/ProteinFunction/main.nf:                           - UPDATE to only run for new/changed translations
nextflow/ProteinFunction/main.nf:                           - NONE   to skip this step (default)
nextflow/ProteinFunction/main.nf:    --blastdb DIR        Path to SIFT-formatted BLAST database
nextflow/ProteinFunction/main.nf:    --median_cutoff VAL  Protein alignment's median cutoff (default: 2.75)
nextflow/ProteinFunction/main.nf:  PolyPhen-2 options:
nextflow/ProteinFunction/main.nf:    --pph_run_type VAL   PolyPhen-2 run type:
nextflow/ProteinFunction/main.nf:                           - FULL   to run for all translations
nextflow/ProteinFunction/main.nf:                           - UPDATE to only run for new/changed translations
nextflow/ProteinFunction/main.nf:                           - NONE   to skip this step (default)
nextflow/ProteinFunction/main.nf:    --pph_data DIR       Path to PolyPhen-2 databases (required if running
nextflow/ProteinFunction/main.nf:                         PolyPhen-2); available from
nextflow/ProteinFunction/main.nf:    exit 1, "ERROR: arguments --fasta/--gtf or --translated are mandatory"
nextflow/ProteinFunction/main.nf:    exit 1, "ERROR: both --fasta and --gtf need to be defined"
nextflow/ProteinFunction/main.nf:// PolyPhen-2: check if providing databases and if species is human
nextflow/ProteinFunction/main.nf:    exit 1, "ERROR: PolyPhen-2 only works with human data"
nextflow/ProteinFunction/main.nf:    exit 1, "ERROR: --pph_data must be provided when running PolyPhen-2"
nextflow/ProteinFunction/main.nf:  exit 1, "ERROR: --blastdb must be supplied when running SIFT"
nextflow/ProteinFunction/main.nf:  Predict protein function using SIFT and PolyPhen-2
nextflow/ProteinFunction/main.nf:  --------------------------------------------------
nextflow/ProteinFunction/main.nf:                 .map{ it -> [id: it.id,
nextflow/ProteinFunction/main.nf:        ----------------
Binary file nextflow/ProteinFunction/diagram.png matches
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:  die "ERROR: PolyPhen-2 data model not recognised based on filename $model\n";
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:my $pred_matrix = Bio::EnsEMBL::Variation::ProteinFunctionPredictionMatrix->new(
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:    -analysis           => 'polyphen',
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:    -sub_analysis       => $model_name,
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:    -peptide_length     => length($peptide),
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:    -translation_md5    => md5_hex($peptide),
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:  my %results = map { $fields[$_] => $values[$_] } (0 .. @fields-1);
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:  $pred_matrix->add_prediction(
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:  my $var_dba = Bio::EnsEMBL::Variation::DBSQL::DBAdaptor->new(
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:      '-species' => $species,
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:      '-port'    => $port,
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:      '-host'    => $host,
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:      '-user'    => $user,
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:      '-pass'    => $pass,
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:      '-dbname'  => $dbname
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:  my $pfpma = $var_dba->get_ProteinFunctionPredictionMatrixAdaptor
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:  $pfpma->store($pred_matrix);
nextflow/ProteinFunction/bin/store_polyphen_scores.pl:  $var_dba->dbc and $var_dba->dbc->disconnect_if_idle();
nextflow/ProteinFunction/bin/store_sift_scores.pl:my $pred_matrix = Bio::EnsEMBL::Variation::ProteinFunctionPredictionMatrix->new(
nextflow/ProteinFunction/bin/store_sift_scores.pl:    -analysis           => 'sift',
nextflow/ProteinFunction/bin/store_sift_scores.pl:    -peptide_length     => length($peptide),
nextflow/ProteinFunction/bin/store_sift_scores.pl:    -translation_md5    => md5_hex($peptide),
nextflow/ProteinFunction/bin/store_sift_scores.pl:  my ($ref_aa, $position, $alt_aa) = $subst =~ /([A-Z])(\d+)([A-Z])/;
nextflow/ProteinFunction/bin/store_sift_scores.pl:  $pred_matrix->add_prediction(
nextflow/ProteinFunction/bin/store_sift_scores.pl:    $pred_matrix->add_evidence( 'sequence_number',  $position, $num_seqs );
nextflow/ProteinFunction/bin/store_sift_scores.pl:    $pred_matrix->add_evidence( 'conservation_score', $position, $median_cons );
nextflow/ProteinFunction/bin/store_sift_scores.pl:  my $var_dba = Bio::EnsEMBL::Variation::DBSQL::DBAdaptor->new(                 
nextflow/ProteinFunction/bin/store_sift_scores.pl:      '-species' => $species,                                                   
nextflow/ProteinFunction/bin/store_sift_scores.pl:      '-port'    => $port,                                                      
nextflow/ProteinFunction/bin/store_sift_scores.pl:      '-host'    => $host,                                                      
nextflow/ProteinFunction/bin/store_sift_scores.pl:      '-user'    => $user,                                                      
nextflow/ProteinFunction/bin/store_sift_scores.pl:      '-pass'    => $pass,                                                      
nextflow/ProteinFunction/bin/store_sift_scores.pl:      '-dbname'  => $dbname                                                     
nextflow/ProteinFunction/bin/store_sift_scores.pl:  my $pfpma = $var_dba->get_ProteinFunctionPredictionMatrixAdaptor
nextflow/ProteinFunction/bin/store_sift_scores.pl:  $pfpma->store($pred_matrix);
nextflow/ProteinFunction/bin/store_sift_scores.pl:  $var_dba->dbc and $var_dba->dbc->disconnect_if_idle();
nextflow/ProteinFunction/bin/create_aa_substitutions.sh:for ref in `grep -o . <<< $peptide`; do
nextflow/ProteinFunction/bin/create_aa_substitutions.sh:  # ignore non-standard amino acids (e.g. X) when using PolyPhen-2
nextflow/ProteinFunction/bin/create_aa_substitutions.sh:    echo -e "$output"
nextflow/ProteinFunction/nextflow.config:      //   clusterOptions = '-R"select[mem>2000] rusage[mem=2000]" -M2000'
nextflow/ProteinFunction/nextflow.config:      //   clusterOptions = '-R"select[mem>8000] rusage[mem=8000]" -M8000'
nextflow/ProteinFunction/nextflow.config:      //  clusterOptions = '-R"select[mem>2000] rusage[mem=2000]" -M2000'
nextflow/ProteinFunction/nextflow.config:      //   clusterOptions = '-R"select[mem>16000] rusage[mem=16000]" -M16000'
nextflow/ProteinFunction/nextflow.config:      //   clusterOptions = '-R"select[mem>2000] rusage[mem=2000]" -M2000'
.git/packed-refs:# pack-refs with: peeled fully-peeled sorted 
.git/packed-refs:43f230f5271877efbc193c82b8ff2c828a77163a refs/remotes/origin/bugfix/vcf-file-push-error
.git/packed-refs:6cee10862f90eaec419bf2aea72ce4146164474f refs/remotes/origin/feature/transcript-haplotypes
.git/packed-refs:f2e252dd66efc87efd3865143a6632dfb66265c5 refs/remotes/origin/feature/vcf-backend
.git/packed-refs:76e007fb0200fde08ec69acf3fcd21f878f88153 refs/remotes/origin/revert-699-vr_var_synonyms_104
.git/packed-refs:1ac27550b5cadd185975a5098f3a1621a4eb680e refs/tags/cvs/attic/branch-1000genomes-13-69
.git/packed-refs:f3e383abe78a7c97ae6904566d43409bc68cf452 refs/tags/cvs/attic/branch-ensembl-50-dev
.git/packed-refs:858ffdafc1d3d127f31ebc2acae9a3a1359804a3 refs/tags/cvs/attic/branch-ensembl-dec09
.git/packed-refs:bbb192a3d058ceae506c3314e8b2f94308ebd965 refs/tags/cvs/attic/branch-ensembl-magic
.git/packed-refs:48a7c0e850b076ecc89d65c8c7c8a917ff3562bd refs/tags/cvs/attic/branch-ensemblgenomes-56
.git/packed-refs:54c1917f2058e1f0790b8b27cea0ccc99410511c refs/tags/cvs/attic/branch-normalized-alleles
.git/packed-refs:55c92cfb353eb757a57d33722116b3ded924d1fb refs/tags/cvs/attic/branch-vega-26-dev
.git/packed-refs:bbb192a3d058ceae506c3314e8b2f94308ebd965 refs/tags/cvs/attic/ensembl-47-mergepoint-1
.git/packed-refs:ddb7b12705f4a0aa15f1930a1ceed7226687a205 refs/tags/cvs/attic/ensembl-47-mp-1
.git/packed-refs:e1e22ae07bdb819770262939e1ede9d1997fe51a refs/tags/cvs/mergepoint/ensembl/dec09-head
.git/packed-refs:721f00083cd13928349fe11480417e2b73aadbef refs/tags/cvs/mergepoint/vega/38-dev-1
.git/packed-refs:bb2387d3520d5dfe84542391fcde6169730389c8 refs/tags/cvs/mergepoint/vega/38-dev-head-1
.git/packed-refs:44017021e19a33c0d5f29863999a10729b723676 refs/tags/cvs/mergepoint/vega/44-dev-head-1
.git/packed-refs:7321de0b11394dfea0c514a217ce60dde95c691d refs/tags/cvs/mergepoint/vega/46-dev-e48
.git/packed-refs:7321de0b11394dfea0c514a217ce60dde95c691d refs/tags/cvs/mergepoint/vega/46-dev-head-1
.git/packed-refs:a31c7bde50c50bac8dc4a33f9572d80703616334 refs/tags/cvs/mergepoint/vega/49-dev-head
.git/packed-refs:d656112d0ef9db224a78287c29b7421c66572251 refs/tags/cvs/release/ensemblgenomes/10-63
.git/packed-refs:1c403621253a556ab3778d57dc214cc296777ee8 refs/tags/cvs/release/ensemblgenomes/11-64
.git/packed-refs:1c403621253a556ab3778d57dc214cc296777ee8 refs/tags/cvs/release/ensemblgenomes/12-65
.git/packed-refs:b686a0f5dd64fedb76af6de8f20ec94b2de7b808 refs/tags/cvs/release/ensemblgenomes/13-66
.git/packed-refs:f829252bb0b1e898ec45801b3e3e615cb04ac5e5 refs/tags/cvs/release/ensemblgenomes/14-67
.git/packed-refs:82740ed0993faad209d2797218f6021f37fa50a8 refs/tags/cvs/release/ensemblgenomes/15-68
.git/packed-refs:60e0ea2c4ed7a1a8f1ac01b1f1d394dd5e1d8a98 refs/tags/cvs/release/ensemblgenomes/16-69
.git/packed-refs:0fbe3bffc7b073b17061a9d2993842359f326b0b refs/tags/cvs/release/ensemblgenomes/17-70
.git/packed-refs:a2b03d84afa545ef148df75d4f183e3387237743 refs/tags/cvs/release/ensemblgenomes/18-71
.git/packed-refs:90c87b94bae0908f73c70d958cb966cda78926d7 refs/tags/cvs/release/ensemblgenomes/19-72
.git/packed-refs:879224692068e3c53f75820d9f5df885808b6d28 refs/tags/cvs/release/ensemblgenomes/20-73
.git/packed-refs:48a7c0e850b076ecc89d65c8c7c8a917ff3562bd refs/tags/cvs/release/ensemblgenomes/4-56
.git/packed-refs:2dac3571204100ae2feaeb81c0a7b73b0d5c9293 refs/tags/cvs/release/ensemblgenomes/5-58
.git/packed-refs:9e797435535e38c1149151b689ee7f5cd74e77ca refs/tags/cvs/release/ensemblgenomes/6-59
.git/packed-refs:f1d671215610aa222632aeb585e8fecd8857203c refs/tags/cvs/release/ensemblgenomes/7-60
.git/packed-refs:218b547420d52fb81c2e5e9eef31013492678608 refs/tags/cvs/release/ensemblgenomes/8-61
.git/packed-refs:57bb048b609a7589dcf2f6a9700ec293424a84f3 refs/tags/cvs/release/ensemblgenomes/9-62
.git/packed-refs:55c92cfb353eb757a57d33722116b3ded924d1fb refs/tags/cvs/release/vega/26-2
.git/packed-refs:456e7bf5fbe62655f9798560abba9e6f2bca7bf5 refs/tags/cvs/release/vega/28-1
.git/packed-refs:a84fac28f05eb17aada045e70f6bad6975335ce8 refs/tags/cvs/release/vega/30-1
.git/packed-refs:a84fac28f05eb17aada045e70f6bad6975335ce8 refs/tags/cvs/release/vega/30-2
.git/packed-refs:a84fac28f05eb17aada045e70f6bad6975335ce8 refs/tags/cvs/release/vega/30-3
.git/packed-refs:23129f20578e135b44e6a8d0b03dd2bcb8d598d2 refs/tags/cvs/release/vega/31-1
.git/packed-refs:70087a61ec4eb165b583cd43b6aa7431e26a9553 refs/tags/cvs/release/vega/35-1
.git/packed-refs:721f00083cd13928349fe11480417e2b73aadbef refs/tags/cvs/release/vega/37-1
.git/packed-refs:721f00083cd13928349fe11480417e2b73aadbef refs/tags/cvs/release/vega/37-2
.git/packed-refs:bb2387d3520d5dfe84542391fcde6169730389c8 refs/tags/cvs/release/vega/38-1
.git/packed-refs:d5d2531641f01867702806027c371d7d56fa0e54 refs/tags/cvs/release/vega/40-1
.git/packed-refs:aef91d8e8e7a8727b95ce084e96b5a78fac39c06 refs/tags/cvs/release/vega/41-1
.git/packed-refs:473ea1fd1d980e906fbf46506c821dd38f5797e7 refs/tags/cvs/release/vega/44-2
.git/packed-refs:473ea1fd1d980e906fbf46506c821dd38f5797e7 refs/tags/cvs/release/vega/44-3
.git/packed-refs:44017021e19a33c0d5f29863999a10729b723676 refs/tags/cvs/release/vega/46-1
.git/packed-refs:44017021e19a33c0d5f29863999a10729b723676 refs/tags/cvs/release/vega/46-3
.git/packed-refs:44017021e19a33c0d5f29863999a10729b723676 refs/tags/cvs/release/vega/46-4
.git/packed-refs:aa40aa4a9f53fc78539d7afbdf2d48d9d6b56ef1 refs/tags/cvs/release/vega/49-1
.git/packed-refs:aa40aa4a9f53fc78539d7afbdf2d48d9d6b56ef1 refs/tags/cvs/release/vega/49-2
.git/packed-refs:aa40aa4a9f53fc78539d7afbdf2d48d9d6b56ef1 refs/tags/cvs/release/vega/49-3
.git/packed-refs:aa40aa4a9f53fc78539d7afbdf2d48d9d6b56ef1 refs/tags/cvs/release/vega/49-5
.git/packed-refs:7558242e2f537c6e8309a20f583f45c534bab703 refs/tags/cvs/release/vega/55-1
.git/packed-refs:80c2bbb8c55e7b204c5a2be7752cb4bba6524a7e refs/tags/cvs/release/vega/59-1
.git/packed-refs:b57f9b8613adbd4847f71d25b3a3a68878d8f700 refs/tags/cvs/release/vega/61-1
.git/info/exclude:# git ls-files --others --exclude-from=.git/info/exclude
.git/FETCH_HEAD:0eb2deb4aec4581e512965933b23defe517c963c		branch 'release/109' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:8d217f6a8592ded52c82a626c11ceec86e46bd47	not-for-merge	branch 'bugfix/gerp_annotation_test' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:3d18f606af530cf90fd4697a3d816534626fa5db	not-for-merge	branch 'bugfix/ld_vcf_missing_variant' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:43f230f5271877efbc193c82b8ff2c828a77163a	not-for-merge	branch 'bugfix/vcf-file-push-error' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:b0eedf1c768552966326cfeb405b7dc4e9064e80	not-for-merge	branch 'display_sv_freq_exp' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:94280b081171c1b391f95b946d38e4398a8eb269	not-for-merge	branch 'feature/backup_db' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:b3be0d959ad2460b7e2959ce15d541a1e09d73f8	not-for-merge	branch 'feature/sample' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:71946b07098829e15b54d6c2d3ebb2e4953c8df2	not-for-merge	branch 'feature/source' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:e25578640f8d12643a2af794607b877eae5d6d8d	not-for-merge	branch 'feature/sv_freq' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:6cee10862f90eaec419bf2aea72ce4146164474f	not-for-merge	branch 'feature/transcript-haplotypes' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:f2e252dd66efc87efd3865143a6632dfb66265c5	not-for-merge	branch 'feature/vcf-backend' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:29db0f21be6ffdefff89c5bb16f85f6379730997	not-for-merge	branch 'feature84/rest_overlap_region' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:3663b06d41dca00bbd5be415b2ea6a64b6456aac	not-for-merge	branch 'fix/errored_rest_test' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:f5523622ec2fc5271bf993c35598507ca2f6bf8a	not-for-merge	branch 'fix_phenotype_assembly_rgd' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:0fc10caeb225d3523e5c3f956e973086a525affb	not-for-merge	branch 'fix_phenotype_warning_106' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:140adf1dd406d99519c1c9f9d542daa81efe6e76	not-for-merge	branch 'main' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:2bb2075e0311092e357295580e0be38266fe0638	not-for-merge	branch 'olaaustine-patch-1' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:c9a2c9591bf6838be47a2f46b070a0e47f240fb3	not-for-merge	branch 'postreleasefix/100' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:94dfdb8c1ed14287a38e399124a527458941940a	not-for-merge	branch 'postreleasefix/101' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:2d027f6a6a893b2cbd1031c6b122209a09814de4	not-for-merge	branch 'postreleasefix/102' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:05bcd50c330cd880770305639a8c7cdfc2f1fb8a	not-for-merge	branch 'postreleasefix/103' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:e958a3b384b75fef15e97128999bb7aef70f7d31	not-for-merge	branch 'postreleasefix/104' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:65d46507c9dec495caecda04485f973d31045ae1	not-for-merge	branch 'postreleasefix/105' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:80ec74359c6c6559883c22cd42686b590865d8b2	not-for-merge	branch 'postreleasefix/106' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:d6ee26a71449999860d27070d5d05b45b11b1992	not-for-merge	branch 'postreleasefix/107' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:9bd068f9f0d7d2900d654417c2ea761617adbc72	not-for-merge	branch 'postreleasefix/108' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:033dc53d481cfcc7b6bf70fe6208d74a7c6a7f57	not-for-merge	branch 'postreleasefix/109' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:a55cd5a49c87d03cff0210c8f5582d4f919173eb	not-for-merge	branch 'postreleasefix/78' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:24c1e8d76c4f1a8176018e98177c47f0c5aa3908	not-for-merge	branch 'postreleasefix/79' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:a4480546bb02ccc7a5a104ba6bf5d8f8daeea211	not-for-merge	branch 'postreleasefix/80' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:3e35a6f3be08d3ec9a9e441634bf4802619e7455	not-for-merge	branch 'postreleasefix/81' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:676e82f9bb76187967d828aa79fb80b7999f35ca	not-for-merge	branch 'postreleasefix/82' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:f5f2af4af94296c4c14a82b9722ae6d5d44ab749	not-for-merge	branch 'postreleasefix/83' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:dc810bcc10e73173090036844373788cdcc2fde4	not-for-merge	branch 'postreleasefix/84' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:7914df18a676b90259c92d2f69ad1a1bc0fa9978	not-for-merge	branch 'postreleasefix/85' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:d6aed67c9408303d06f34ea9f847995cec10a960	not-for-merge	branch 'postreleasefix/86' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:3b3ae6487de361a27113668fc41a78bdcff186a7	not-for-merge	branch 'postreleasefix/87' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:ec1fc11713d6cab5d9e6afa8bd38920c709a5f1b	not-for-merge	branch 'postreleasefix/88' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:5f990a2e74318edf993aef98076766ffa9704bd0	not-for-merge	branch 'postreleasefix/89' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:b8fdd164db0e0c9a5ecb2386e0e7e554c2eb842d	not-for-merge	branch 'postreleasefix/90' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:c78d8b45aad15a830057c4f15d5b0ead6b3b2cfb	not-for-merge	branch 'postreleasefix/91' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:d4ec639bdf0244bf3c15af3142bacc7ff1ea4147	not-for-merge	branch 'postreleasefix/92' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:adeaffa2461f12784ff60057587f2307d59c8e77	not-for-merge	branch 'postreleasefix/93' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:55ef497e6f12c6cba65f6d1d11e5b5031100413c	not-for-merge	branch 'postreleasefix/94' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:01dab32fbaca339d9441e476c8a881a1e60270fe	not-for-merge	branch 'postreleasefix/95' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:7aa3a75fc002eac1cfad6ee5db6ee6a0c9b8730b	not-for-merge	branch 'postreleasefix/96' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:05c37eff8c99ac598a74d60bad787c1212a7e2cb	not-for-merge	branch 'postreleasefix/97' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:d0571a5ab826453e00ba048949e9b8ee66fe6fb4	not-for-merge	branch 'postreleasefix/98' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:40f0ca00c8bb5cb76d5ab5b882c6ad72f387af3b	not-for-merge	branch 'postreleasefix/99' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:dd0b3c749a87446a4a8b08e977776d8dce870771	not-for-merge	branch 'release/100' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:819eef27499d2de430792e552bf9e6060ca4b472	not-for-merge	branch 'release/101' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:2716d2e86f168de1d64cc4e70b0bd5d09342c1c1	not-for-merge	branch 'release/102' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:06320c480e6b731c18126b8652ef24ef6e5938ce	not-for-merge	branch 'release/103' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:6154f8ba2a8499bbedde5211fb264c9c849a93d0	not-for-merge	branch 'release/104' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:ac8178e987511a0bd2357334150c4271e6698896	not-for-merge	branch 'release/105' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:2aa7a5dd99bd3334dcce19c6476c26f1710b74a1	not-for-merge	branch 'release/106' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:ab78711df6429b0fe98514b29e59b9ff4561cb9c	not-for-merge	branch 'release/107' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:a885ada3058bcd8f284c09396e7d911341f8aec2	not-for-merge	branch 'release/108' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:55c92cfb353eb757a57d33722116b3ded924d1fb	not-for-merge	branch 'release/27' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:8e52b64a4e617bbfd55b245307dbf4d1641fb4b7	not-for-merge	branch 'release/28' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:dbc5a853a4d3ea6e74bceefa81380ecd40c3c698	not-for-merge	branch 'release/29' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:a84fac28f05eb17aada045e70f6bad6975335ce8	not-for-merge	branch 'release/30' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:98e6c0ee19c5b5c4febc37fd578bbf9ad0f3c1cf	not-for-merge	branch 'release/31' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:63af287a53503cecc4b0187f75e3afc9a9fa3069	not-for-merge	branch 'release/32' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:88886eeda3d51c0fb634295db026374a6d6c1436	not-for-merge	branch 'release/33' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:5a20a31bc6358d3f0524e0454eda787b81592697	not-for-merge	branch 'release/34' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:6410afdfc4a428a2673ae5f070ebd712f74ed2c1	not-for-merge	branch 'release/35' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:6d872c3e67fefddd25003884311d700f4d493023	not-for-merge	branch 'release/36' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:22e339ba87af550c3668a832b4698034ba711348	not-for-merge	branch 'release/37' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:88caf20bf9ffad413fc83c413ca8ae69e10ab72d	not-for-merge	branch 'release/38' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:ce9acc990832bbd82301dbbbeabe92c4e83d2789	not-for-merge	branch 'release/39' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:729eaa2ab19d2fd40efd4882acc75cb6514472c4	not-for-merge	branch 'release/40' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:785628b2e38220fda176316f0622b74cf1564e9c	not-for-merge	branch 'release/41' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:84e7ee964b0ea478063d14d517cb28aeebc1daa9	not-for-merge	branch 'release/42' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:9ed8085f052ea972bd484c2272086a1732052ee4	not-for-merge	branch 'release/43' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:473ea1fd1d980e906fbf46506c821dd38f5797e7	not-for-merge	branch 'release/44' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:80acf2c2097eac156ea5a5175245b3c83491fabf	not-for-merge	branch 'release/45' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:44017021e19a33c0d5f29863999a10729b723676	not-for-merge	branch 'release/46' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:94e079610d24da9c82e92cce9685d9ccb1923b2a	not-for-merge	branch 'release/47' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:b7dc5576e528d709b1a84c3707f3ae0c2c72b516	not-for-merge	branch 'release/48' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:49c51605fea3351809afe5bbf329d3e1ccfe2b8b	not-for-merge	branch 'release/49' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:49c51605fea3351809afe5bbf329d3e1ccfe2b8b	not-for-merge	branch 'release/50' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:cda4f74ac1fad0909f4b36e710ef13791ee6e0c2	not-for-merge	branch 'release/51' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:145ad143060a6cf8372266ba9544f25c75bceb06	not-for-merge	branch 'release/52' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:ece456e6e19125755da1a7719edea857be8fa6db	not-for-merge	branch 'release/53' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:e88f6eaab80a836bcc67ae6fc3a1e8d7368fed72	not-for-merge	branch 'release/54' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:7e1c0690421a9750cc9f3b5a58739b75007825fb	not-for-merge	branch 'release/55' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:3e05ced4d68aecf03c109c1d4dbe95d49c509992	not-for-merge	branch 'release/56' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:c3865546732d6cd44999a13c0b95ff71ee31d11c	not-for-merge	branch 'release/57' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:bdfad258f523cd2d286eb54205af6bf1363328af	not-for-merge	branch 'release/58' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:80c2bbb8c55e7b204c5a2be7752cb4bba6524a7e	not-for-merge	branch 'release/59' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:f1d671215610aa222632aeb585e8fecd8857203c	not-for-merge	branch 'release/60' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:1dff0ae4d988279d0125b96837f27b33f94685d2	not-for-merge	branch 'release/61' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:8264d32f77e60c566902250b9bbdbd519c1e4753	not-for-merge	branch 'release/62' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:2d6eadeee724a36a5dfc5b16224a0c894207b8de	not-for-merge	branch 'release/63' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:d5bcb5d5a67f715ce6d978631059c0793b89caf6	not-for-merge	branch 'release/64' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:b40b3abe29db7d6ce4eeab6fda3946f6e5f3a1d0	not-for-merge	branch 'release/65' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:a01c0f0c7b574d34373ec1aa7c100df7c303a855	not-for-merge	branch 'release/66' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:07c269e072b6635820f0f4f6fccac5c124105eab	not-for-merge	branch 'release/67' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:d8feea2454e7fe54406f3805e94298b6350b42cd	not-for-merge	branch 'release/68' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:26cd4b60317a3001c1370f1140820a1ed82f101d	not-for-merge	branch 'release/69' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:6ab6f296f7ae81d74b25f1b8661625ef8cf82235	not-for-merge	branch 'release/70' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:b5f1a03c9e630dc288e8ed0fd917a80ce95a3c3e	not-for-merge	branch 'release/71' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:b1248e9f7255e0c7a4b583e546a2e156d6be0c58	not-for-merge	branch 'release/72' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:33db34696e5ee216a0af27b71e7858c62f56a0af	not-for-merge	branch 'release/73' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:4a3d8417c85eb3e5df2e71c0c81f9935d36627b5	not-for-merge	branch 'release/74' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:e395d4db93d2e57759be22d546bc10363ab07655	not-for-merge	branch 'release/75' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:b6e1d606a27d0d8da33c238caef7e6203140a041	not-for-merge	branch 'release/76' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:5afc212d89b7b9a64124672a76206f5e9537d5e6	not-for-merge	branch 'release/77' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:f230332acb4e95b29618eec262956670f3f98676	not-for-merge	branch 'release/78' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:a4942752489ad1f8f1751bae4eb4b68b2947d740	not-for-merge	branch 'release/79' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:f20ac41b9ce02289f5b71e12593e4760310b9970	not-for-merge	branch 'release/80' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:f421fb686d79ede1db5ef8e22d566cdf37ec8765	not-for-merge	branch 'release/81' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:f35c52194a9c20bb43966a1e3a2f5e36fcd3d3bf	not-for-merge	branch 'release/82' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:ff110c850b54536322b60230cad0c34e163aae1b	not-for-merge	branch 'release/83' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:0b4e91a94dabf9f2644f6d4e94d027349d5e1ab8	not-for-merge	branch 'release/84' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:5ac54a6a43cfd09c48f686330d02e3e58af77943	not-for-merge	branch 'release/85' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:a5089a0d302eacc696e0f0df14add2cdeb3f505e	not-for-merge	branch 'release/86' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:314c4e3f5708d9060605b7822b5cb8d4d867278c	not-for-merge	branch 'release/87' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:e22c7a8c3d9b568258082d05cd99cbd5e1dedf45	not-for-merge	branch 'release/88' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:0e12f4e5faa636286aa14f39d49e1034d5d7337c	not-for-merge	branch 'release/89' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:00c29b749cf582a89e534f68e48185a791239dfe	not-for-merge	branch 'release/90' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:c78d8b45aad15a830057c4f15d5b0ead6b3b2cfb	not-for-merge	branch 'release/91' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:77a06cfe0cc0125fe01a8eedaa20a93691300916	not-for-merge	branch 'release/92' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:b5c76478ba7566481afabd2a71fbc3188e29bbbe	not-for-merge	branch 'release/93' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:066b102ed9c4f99dacd1998ada9438aa867da117	not-for-merge	branch 'release/94' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:858de3ee083fd066bc0b8a78e8a449176dd51bce	not-for-merge	branch 'release/95' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:617872b92b3e4b42425286fb0c17ca3f3b961078	not-for-merge	branch 'release/96' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:26a059c2c03bbc373621daf3ac87e20fd888e9df	not-for-merge	branch 'release/97' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:7a544e703a0370cbda0ed05fedf97fbea0d4f5ba	not-for-merge	branch 'release/98' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:a7f8736d7400d18fc0c2988ee0b5d45fdf6b1ca2	not-for-merge	branch 'release/99' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:642e1cd05f4cd91e9b22d98357e85fedcf85f776	not-for-merge	branch 'release1' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:76e007fb0200fde08ec69acf3fcd21f878f88153	not-for-merge	branch 'revert-699-vr_var_synonyms_104' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:bd93413424aefecc84fac7a6d4e6bd5ebaa48d4b	not-for-merge	branch 'update_protein_function_polyphen' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:ed8771b7f31460b46642c06b816146d65f7b03df	not-for-merge	branch 'update_regulation_pipeline' of https://github.com/Ensembl/ensembl-variation
.git/FETCH_HEAD:470f8d86675c5f4802458281e000901b1ca844fa	not-for-merge	branch 'update_travis_yml' of https://github.com/Ensembl/ensembl-variation
Binary file .git/index matches
.git/logs/HEAD:0000000000000000000000000000000000000000 ac8178e987511a0bd2357334150c4271e6698896 jamie-m-a <jma@ebi.ac.uk> 1669825272 +0000	clone: from https://github.com/jamie-m-a/ensembl-variation
.git/logs/HEAD:ac8178e987511a0bd2357334150c4271e6698896 c93675b3fb8b684246342a8f07bbe0e8faf2dac4 jamie-m-a <jma@ebi.ac.uk> 1669825469 +0000	checkout: moving from release/105 to postreleasefix/109
.git/logs/HEAD:c93675b3fb8b684246342a8f07bbe0e8faf2dac4 b9473b2c6e52fb93813d2799349de914847eef67 jamie-m-a <jma@ebi.ac.uk> 1669825548 +0000	checkout: moving from postreleasefix/109 to main
.git/logs/HEAD:b9473b2c6e52fb93813d2799349de914847eef67 c93675b3fb8b684246342a8f07bbe0e8faf2dac4 jamie-m-a <jma@ebi.ac.uk> 1669826016 +0000	checkout: moving from main to postreleasefix/109
.git/logs/HEAD:c93675b3fb8b684246342a8f07bbe0e8faf2dac4 c93675b3fb8b684246342a8f07bbe0e8faf2dac4 jamie-m-a <jma@ebi.ac.uk> 1669826033 +0000	checkout: moving from postreleasefix/109 to fixing_vc_update-mode
.git/logs/HEAD:c93675b3fb8b684246342a8f07bbe0e8faf2dac4 147fefe839b37dbb15237e514dc47c57e968b5f8 jamie-m-a <jma@ebi.ac.uk> 1669826179 +0000	commit: Adding Jose's GFF compare script to our repo
.git/logs/HEAD:147fefe839b37dbb15237e514dc47c57e968b5f8 f82afd5331427b16b2a26112dfdabbf1eb4cf34f jamie-m-a <jma@ebi.ac.uk> 1669826559 +0000	commit: Ensure LRG genes not run when update mode active
.git/logs/HEAD:f82afd5331427b16b2a26112dfdabbf1eb4cf34f 5d36ecda595b613cc072b414aa32a3b7eaa62194 jamie-m-a <jma@ebi.ac.uk> 1669829580 +0000	commit: Adding file dump for deleted TVs
.git/logs/HEAD:5d36ecda595b613cc072b414aa32a3b7eaa62194 7b9068e24aa91af433fe4323cf0ab476af213c3e jamie-m-a <jma@ebi.ac.uk> 1669914173 +0000	commit: Update variation feature handles VFs where TVs were deleted
.git/logs/HEAD:7b9068e24aa91af433fe4323cf0ab476af213c3e f4f91feed48525f79ba4bb8903a10a000c9d49ea jamie-m-a <jma@ebi.ac.uk> 1669931000 +0000	commit: tweak to update
.git/logs/HEAD:f4f91feed48525f79ba4bb8903a10a000c9d49ea a95424e61843bd39de43337e8a7f2ce6ad2ddc93 jamie-m-a <jma@ebi.ac.uk> 1670260140 +0000	commit: bug fixing
.git/logs/HEAD:a95424e61843bd39de43337e8a7f2ce6ad2ddc93 f039ce5ec92a14f486e0c05d7db2b99d20398f6d jamie-m-a <jma@ebi.ac.uk> 1670591924 +0000	commit: fxixing
.git/logs/HEAD:f039ce5ec92a14f486e0c05d7db2b99d20398f6d b225ed687933ab61f0f2f7981cc7917e0eddd9e8 jamie-m-a <jma@ebi.ac.uk> 1670591930 +0000	checkout: moving from fixing_vc_update-mode to release/109
.git/logs/HEAD:b225ed687933ab61f0f2f7981cc7917e0eddd9e8 0eb2deb4aec4581e512965933b23defe517c963c jamie-m-a <jma@ebi.ac.uk> 1670591938 +0000	pull: Fast-forward
.git/logs/HEAD:0eb2deb4aec4581e512965933b23defe517c963c 0eb2deb4aec4581e512965933b23defe517c963c jamie-m-a <jma@ebi.ac.uk> 1670605982 +0000	reset: moving to HEAD
.git/logs/HEAD:0eb2deb4aec4581e512965933b23defe517c963c 0eb2deb4aec4581e512965933b23defe517c963c jamie-m-a <jma@ebi.ac.uk> 1670606021 +0000	checkout: moving from release/109 to update_vc_fixes
.git/logs/HEAD:0eb2deb4aec4581e512965933b23defe517c963c d48c677c7a23064ac7ae52856cba890804940a19 jamie-m-a <jma@ebi.ac.uk> 1670606236 +0000	commit: genefactory and updatevar changes
.git/logs/HEAD:d48c677c7a23064ac7ae52856cba890804940a19 3c22f3e7a46b54c21230f458e97ba58ca9ca7dab jamie-m-a <jma@ebi.ac.uk> 1670628001 +0000	commit: adding deleting back in
.git/logs/HEAD:3c22f3e7a46b54c21230f458e97ba58ca9ca7dab 3b25ef4a1a2eac107ea8db2bd616eb6112f2b26c jamie-m-a <jma@ebi.ac.uk> 1671032388 +0000	commit: more fixes
.git/logs/HEAD:3b25ef4a1a2eac107ea8db2bd616eb6112f2b26c f039ce5ec92a14f486e0c05d7db2b99d20398f6d jamie-m-a <jma@ebi.ac.uk> 1671032393 +0000	checkout: moving from update_vc_fixes to fixing_vc_update-mode
.git/logs/HEAD:f039ce5ec92a14f486e0c05d7db2b99d20398f6d 3b25ef4a1a2eac107ea8db2bd616eb6112f2b26c jamie-m-a <jma@ebi.ac.uk> 1671032551 +0000	checkout: moving from fixing_vc_update-mode to update_vc_fixes
.git/logs/HEAD:3b25ef4a1a2eac107ea8db2bd616eb6112f2b26c 3cf65d74b92c951c0b91610902381b9b7ed021b5 jamie-m-a <jma@ebi.ac.uk> 1671035438 +0000	commit: more changes getting files back
.git/logs/HEAD:3cf65d74b92c951c0b91610902381b9b7ed021b5 f039ce5ec92a14f486e0c05d7db2b99d20398f6d jamie-m-a <jma@ebi.ac.uk> 1671035462 +0000	checkout: moving from update_vc_fixes to fixing_vc_update-mode
.git/logs/HEAD:f039ce5ec92a14f486e0c05d7db2b99d20398f6d 3cf65d74b92c951c0b91610902381b9b7ed021b5 jamie-m-a <jma@ebi.ac.uk> 1671035574 +0000	checkout: moving from fixing_vc_update-mode to update_vc_fixes
.git/logs/refs/heads/postreleasefix/109:0000000000000000000000000000000000000000 c93675b3fb8b684246342a8f07bbe0e8faf2dac4 jamie-m-a <jma@ebi.ac.uk> 1669825469 +0000	branch: Created from refs/remotes/upstream/postreleasefix/109
.git/logs/refs/heads/main:0000000000000000000000000000000000000000 b9473b2c6e52fb93813d2799349de914847eef67 jamie-m-a <jma@ebi.ac.uk> 1669825548 +0000	branch: Created from refs/remotes/upstream/main
.git/logs/refs/heads/release/109:0000000000000000000000000000000000000000 b225ed687933ab61f0f2f7981cc7917e0eddd9e8 jamie-m-a <jma@ebi.ac.uk> 1670591930 +0000	branch: Created from refs/remotes/upstream/release/109
.git/logs/refs/heads/release/109:b225ed687933ab61f0f2f7981cc7917e0eddd9e8 0eb2deb4aec4581e512965933b23defe517c963c jamie-m-a <jma@ebi.ac.uk> 1670591938 +0000	pull: Fast-forward
.git/logs/refs/heads/release/105:0000000000000000000000000000000000000000 ac8178e987511a0bd2357334150c4271e6698896 jamie-m-a <jma@ebi.ac.uk> 1669825272 +0000	clone: from https://github.com/jamie-m-a/ensembl-variation
.git/logs/refs/heads/update_vc_fixes:0000000000000000000000000000000000000000 0eb2deb4aec4581e512965933b23defe517c963c jamie-m-a <jma@ebi.ac.uk> 1670606021 +0000	branch: Created from HEAD
.git/logs/refs/heads/update_vc_fixes:0eb2deb4aec4581e512965933b23defe517c963c d48c677c7a23064ac7ae52856cba890804940a19 jamie-m-a <jma@ebi.ac.uk> 1670606236 +0000	commit: genefactory and updatevar changes
.git/logs/refs/heads/update_vc_fixes:d48c677c7a23064ac7ae52856cba890804940a19 3c22f3e7a46b54c21230f458e97ba58ca9ca7dab jamie-m-a <jma@ebi.ac.uk> 1670628001 +0000	commit: adding deleting back in
.git/logs/refs/heads/update_vc_fixes:3c22f3e7a46b54c21230f458e97ba58ca9ca7dab 3b25ef4a1a2eac107ea8db2bd616eb6112f2b26c jamie-m-a <jma@ebi.ac.uk> 1671032388 +0000	commit: more fixes
.git/logs/refs/heads/update_vc_fixes:3b25ef4a1a2eac107ea8db2bd616eb6112f2b26c 3cf65d74b92c951c0b91610902381b9b7ed021b5 jamie-m-a <jma@ebi.ac.uk> 1671035438 +0000	commit: more changes getting files back
.git/logs/refs/heads/fixing_vc_update-mode:0000000000000000000000000000000000000000 c93675b3fb8b684246342a8f07bbe0e8faf2dac4 jamie-m-a <jma@ebi.ac.uk> 1669826033 +0000	branch: Created from HEAD
.git/logs/refs/heads/fixing_vc_update-mode:c93675b3fb8b684246342a8f07bbe0e8faf2dac4 147fefe839b37dbb15237e514dc47c57e968b5f8 jamie-m-a <jma@ebi.ac.uk> 1669826179 +0000	commit: Adding Jose's GFF compare script to our repo
.git/logs/refs/heads/fixing_vc_update-mode:147fefe839b37dbb15237e514dc47c57e968b5f8 f82afd5331427b16b2a26112dfdabbf1eb4cf34f jamie-m-a <jma@ebi.ac.uk> 1669826559 +0000	commit: Ensure LRG genes not run when update mode active
.git/logs/refs/heads/fixing_vc_update-mode:f82afd5331427b16b2a26112dfdabbf1eb4cf34f 5d36ecda595b613cc072b414aa32a3b7eaa62194 jamie-m-a <jma@ebi.ac.uk> 1669829580 +0000	commit: Adding file dump for deleted TVs
.git/logs/refs/heads/fixing_vc_update-mode:5d36ecda595b613cc072b414aa32a3b7eaa62194 7b9068e24aa91af433fe4323cf0ab476af213c3e jamie-m-a <jma@ebi.ac.uk> 1669914173 +0000	commit: Update variation feature handles VFs where TVs were deleted
.git/logs/refs/heads/fixing_vc_update-mode:7b9068e24aa91af433fe4323cf0ab476af213c3e f4f91feed48525f79ba4bb8903a10a000c9d49ea jamie-m-a <jma@ebi.ac.uk> 1669931000 +0000	commit: tweak to update
.git/logs/refs/heads/fixing_vc_update-mode:f4f91feed48525f79ba4bb8903a10a000c9d49ea a95424e61843bd39de43337e8a7f2ce6ad2ddc93 jamie-m-a <jma@ebi.ac.uk> 1670260140 +0000	commit: bug fixing
.git/logs/refs/heads/fixing_vc_update-mode:a95424e61843bd39de43337e8a7f2ce6ad2ddc93 f039ce5ec92a14f486e0c05d7db2b99d20398f6d jamie-m-a <jma@ebi.ac.uk> 1670591924 +0000	commit: fxixing
.git/logs/refs/remotes/upstream/postreleasefix/84:0000000000000000000000000000000000000000 dc810bcc10e73173090036844373788cdcc2fde4 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/103:0000000000000000000000000000000000000000 05bcd50c330cd880770305639a8c7cdfc2f1fb8a jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/90:0000000000000000000000000000000000000000 b8fdd164db0e0c9a5ecb2386e0e7e554c2eb842d jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/102:0000000000000000000000000000000000000000 2d027f6a6a893b2cbd1031c6b122209a09814de4 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/82:0000000000000000000000000000000000000000 676e82f9bb76187967d828aa79fb80b7999f35ca jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/101:0000000000000000000000000000000000000000 94dfdb8c1ed14287a38e399124a527458941940a jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/85:0000000000000000000000000000000000000000 7914df18a676b90259c92d2f69ad1a1bc0fa9978 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/91:0000000000000000000000000000000000000000 c78d8b45aad15a830057c4f15d5b0ead6b3b2cfb jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/100:0000000000000000000000000000000000000000 c9a2c9591bf6838be47a2f46b070a0e47f240fb3 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/81:0000000000000000000000000000000000000000 3e35a6f3be08d3ec9a9e441634bf4802619e7455 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/93:0000000000000000000000000000000000000000 adeaffa2461f12784ff60057587f2307d59c8e77 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/104:0000000000000000000000000000000000000000 e958a3b384b75fef15e97128999bb7aef70f7d31 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/78:0000000000000000000000000000000000000000 a55cd5a49c87d03cff0210c8f5582d4f919173eb jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/87:0000000000000000000000000000000000000000 3b3ae6487de361a27113668fc41a78bdcff186a7 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/79:0000000000000000000000000000000000000000 24c1e8d76c4f1a8176018e98177c47f0c5aa3908 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/88:0000000000000000000000000000000000000000 ec1fc11713d6cab5d9e6afa8bd38920c709a5f1b jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/95:0000000000000000000000000000000000000000 01dab32fbaca339d9441e476c8a881a1e60270fe jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/92:0000000000000000000000000000000000000000 d4ec639bdf0244bf3c15af3142bacc7ff1ea4147 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/80:0000000000000000000000000000000000000000 a4480546bb02ccc7a5a104ba6bf5d8f8daeea211 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/86:0000000000000000000000000000000000000000 d6aed67c9408303d06f34ea9f847995cec10a960 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/97:0000000000000000000000000000000000000000 05c37eff8c99ac598a74d60bad787c1212a7e2cb jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/107:0000000000000000000000000000000000000000 d6ee26a71449999860d27070d5d05b45b11b1992 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/108:0000000000000000000000000000000000000000 9bd068f9f0d7d2900d654417c2ea761617adbc72 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/109:0000000000000000000000000000000000000000 c93675b3fb8b684246342a8f07bbe0e8faf2dac4 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/109:c93675b3fb8b684246342a8f07bbe0e8faf2dac4 033dc53d481cfcc7b6bf70fe6208d74a7c6a7f57 jamie-m-a <jma@ebi.ac.uk> 1670591937 +0000	pull: fast-forward
.git/logs/refs/remotes/upstream/postreleasefix/98:0000000000000000000000000000000000000000 d0571a5ab826453e00ba048949e9b8ee66fe6fb4 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/99:0000000000000000000000000000000000000000 40f0ca00c8bb5cb76d5ab5b882c6ad72f387af3b jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/105:0000000000000000000000000000000000000000 65d46507c9dec495caecda04485f973d31045ae1 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/96:0000000000000000000000000000000000000000 7aa3a75fc002eac1cfad6ee5db6ee6a0c9b8730b jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/89:0000000000000000000000000000000000000000 5f990a2e74318edf993aef98076766ffa9704bd0 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/106:0000000000000000000000000000000000000000 80ec74359c6c6559883c22cd42686b590865d8b2 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/83:0000000000000000000000000000000000000000 f5f2af4af94296c4c14a82b9722ae6d5d44ab749 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/postreleasefix/94:0000000000000000000000000000000000000000 55ef497e6f12c6cba65f6d1d11e5b5031100413c jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/bugfix/ld_vcf_missing_variant:0000000000000000000000000000000000000000 3d18f606af530cf90fd4697a3d816534626fa5db jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/bugfix/gerp_annotation_test:0000000000000000000000000000000000000000 8d217f6a8592ded52c82a626c11ceec86e46bd47 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/bugfix/vcf-file-push-error:0000000000000000000000000000000000000000 43f230f5271877efbc193c82b8ff2c828a77163a jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/fix/errored_rest_test:0000000000000000000000000000000000000000 3663b06d41dca00bbd5be415b2ea6a64b6456aac jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/fix_phenotype_assembly_rgd:0000000000000000000000000000000000000000 f5523622ec2fc5271bf993c35598507ca2f6bf8a jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/update_protein_function_polyphen:0000000000000000000000000000000000000000 bd93413424aefecc84fac7a6d4e6bd5ebaa48d4b jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/main:0000000000000000000000000000000000000000 b9473b2c6e52fb93813d2799349de914847eef67 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/main:b9473b2c6e52fb93813d2799349de914847eef67 140adf1dd406d99519c1c9f9d542daa81efe6e76 jamie-m-a <jma@ebi.ac.uk> 1670591937 +0000	pull: fast-forward
.git/logs/refs/remotes/upstream/olaaustine-patch-1:0000000000000000000000000000000000000000 2bb2075e0311092e357295580e0be38266fe0638 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/feature/source:0000000000000000000000000000000000000000 71946b07098829e15b54d6c2d3ebb2e4953c8df2 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/feature/vcf-backend:0000000000000000000000000000000000000000 f2e252dd66efc87efd3865143a6632dfb66265c5 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/feature/transcript-haplotypes:0000000000000000000000000000000000000000 6cee10862f90eaec419bf2aea72ce4146164474f jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/feature/sample:0000000000000000000000000000000000000000 b3be0d959ad2460b7e2959ce15d541a1e09d73f8 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/feature/backup_db:0000000000000000000000000000000000000000 94280b081171c1b391f95b946d38e4398a8eb269 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/feature/sv_freq:0000000000000000000000000000000000000000 e25578640f8d12643a2af794607b877eae5d6d8d jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/fix_phenotype_warning_106:0000000000000000000000000000000000000000 0fc10caeb225d3523e5c3f956e973086a525affb jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/feature84/rest_overlap_region:0000000000000000000000000000000000000000 29db0f21be6ffdefff89c5bb16f85f6379730997 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/update_regulation_pipeline:0000000000000000000000000000000000000000 ed8771b7f31460b46642c06b816146d65f7b03df jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/37:0000000000000000000000000000000000000000 22e339ba87af550c3668a832b4698034ba711348 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/61:0000000000000000000000000000000000000000 1dff0ae4d988279d0125b96837f27b33f94685d2 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/84:0000000000000000000000000000000000000000 0b4e91a94dabf9f2644f6d4e94d027349d5e1ab8 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/46:0000000000000000000000000000000000000000 44017021e19a33c0d5f29863999a10729b723676 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/103:0000000000000000000000000000000000000000 06320c480e6b731c18126b8652ef24ef6e5938ce jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/90:0000000000000000000000000000000000000000 00c29b749cf582a89e534f68e48185a791239dfe jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/102:0000000000000000000000000000000000000000 2716d2e86f168de1d64cc4e70b0bd5d09342c1c1 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/77:0000000000000000000000000000000000000000 5afc212d89b7b9a64124672a76206f5e9537d5e6 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/35:0000000000000000000000000000000000000000 6410afdfc4a428a2673ae5f070ebd712f74ed2c1 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/82:0000000000000000000000000000000000000000 f35c52194a9c20bb43966a1e3a2f5e36fcd3d3bf jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/69:0000000000000000000000000000000000000000 26cd4b60317a3001c1370f1140820a1ed82f101d jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/101:0000000000000000000000000000000000000000 819eef27499d2de430792e552bf9e6060ca4b472 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/34:0000000000000000000000000000000000000000 5a20a31bc6358d3f0524e0454eda787b81592697 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/85:0000000000000000000000000000000000000000 5ac54a6a43cfd09c48f686330d02e3e58af77943 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/91:0000000000000000000000000000000000000000 c78d8b45aad15a830057c4f15d5b0ead6b3b2cfb jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/55:0000000000000000000000000000000000000000 7e1c0690421a9750cc9f3b5a58739b75007825fb jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/100:0000000000000000000000000000000000000000 dd0b3c749a87446a4a8b08e977776d8dce870771 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/81:0000000000000000000000000000000000000000 f421fb686d79ede1db5ef8e22d566cdf37ec8765 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/52:0000000000000000000000000000000000000000 145ad143060a6cf8372266ba9544f25c75bceb06 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/42:0000000000000000000000000000000000000000 84e7ee964b0ea478063d14d517cb28aeebc1daa9 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/64:0000000000000000000000000000000000000000 d5bcb5d5a67f715ce6d978631059c0793b89caf6 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/68:0000000000000000000000000000000000000000 d8feea2454e7fe54406f3805e94298b6350b42cd jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/44:0000000000000000000000000000000000000000 473ea1fd1d980e906fbf46506c821dd38f5797e7 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/93:0000000000000000000000000000000000000000 b5c76478ba7566481afabd2a71fbc3188e29bbbe jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/104:0000000000000000000000000000000000000000 6154f8ba2a8499bbedde5211fb264c9c849a93d0 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/78:0000000000000000000000000000000000000000 f230332acb4e95b29618eec262956670f3f98676 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/48:0000000000000000000000000000000000000000 b7dc5576e528d709b1a84c3707f3ae0c2c72b516 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/63:0000000000000000000000000000000000000000 2d6eadeee724a36a5dfc5b16224a0c894207b8de jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/74:0000000000000000000000000000000000000000 4a3d8417c85eb3e5df2e71c0c81f9935d36627b5 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/62:0000000000000000000000000000000000000000 8264d32f77e60c566902250b9bbdbd519c1e4753 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/87:0000000000000000000000000000000000000000 314c4e3f5708d9060605b7822b5cb8d4d867278c jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/79:0000000000000000000000000000000000000000 a4942752489ad1f8f1751bae4eb4b68b2947d740 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/88:0000000000000000000000000000000000000000 e22c7a8c3d9b568258082d05cd99cbd5e1dedf45 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/95:0000000000000000000000000000000000000000 858de3ee083fd066bc0b8a78e8a449176dd51bce jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/92:0000000000000000000000000000000000000000 77a06cfe0cc0125fe01a8eedaa20a93691300916 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/70:0000000000000000000000000000000000000000 6ab6f296f7ae81d74b25f1b8661625ef8cf82235 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/27:0000000000000000000000000000000000000000 55c92cfb353eb757a57d33722116b3ded924d1fb jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/76:0000000000000000000000000000000000000000 b6e1d606a27d0d8da33c238caef7e6203140a041 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/80:0000000000000000000000000000000000000000 f20ac41b9ce02289f5b71e12593e4760310b9970 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/86:0000000000000000000000000000000000000000 a5089a0d302eacc696e0f0df14add2cdeb3f505e jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/97:0000000000000000000000000000000000000000 26a059c2c03bbc373621daf3ac87e20fd888e9df jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/57:0000000000000000000000000000000000000000 c3865546732d6cd44999a13c0b95ff71ee31d11c jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/60:0000000000000000000000000000000000000000 f1d671215610aa222632aeb585e8fecd8857203c jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/107:0000000000000000000000000000000000000000 ab78711df6429b0fe98514b29e59b9ff4561cb9c jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/56:0000000000000000000000000000000000000000 3e05ced4d68aecf03c109c1d4dbe95d49c509992 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/67:0000000000000000000000000000000000000000 07c269e072b6635820f0f4f6fccac5c124105eab jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/72:0000000000000000000000000000000000000000 b1248e9f7255e0c7a4b583e546a2e156d6be0c58 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/108:0000000000000000000000000000000000000000 a885ada3058bcd8f284c09396e7d911341f8aec2 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/51:0000000000000000000000000000000000000000 cda4f74ac1fad0909f4b36e710ef13791ee6e0c2 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/28:0000000000000000000000000000000000000000 8e52b64a4e617bbfd55b245307dbf4d1641fb4b7 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/40:0000000000000000000000000000000000000000 729eaa2ab19d2fd40efd4882acc75cb6514472c4 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/30:0000000000000000000000000000000000000000 a84fac28f05eb17aada045e70f6bad6975335ce8 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/109:0000000000000000000000000000000000000000 b225ed687933ab61f0f2f7981cc7917e0eddd9e8 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/109:b225ed687933ab61f0f2f7981cc7917e0eddd9e8 0eb2deb4aec4581e512965933b23defe517c963c jamie-m-a <jma@ebi.ac.uk> 1670591937 +0000	pull: fast-forward
.git/logs/refs/remotes/upstream/release/98:0000000000000000000000000000000000000000 7a544e703a0370cbda0ed05fedf97fbea0d4f5ba jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/73:0000000000000000000000000000000000000000 33db34696e5ee216a0af27b71e7858c62f56a0af jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/54:0000000000000000000000000000000000000000 e88f6eaab80a836bcc67ae6fc3a1e8d7368fed72 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/99:0000000000000000000000000000000000000000 a7f8736d7400d18fc0c2988ee0b5d45fdf6b1ca2 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/32:0000000000000000000000000000000000000000 63af287a53503cecc4b0187f75e3afc9a9fa3069 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/65:0000000000000000000000000000000000000000 b40b3abe29db7d6ce4eeab6fda3946f6e5f3a1d0 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/59:0000000000000000000000000000000000000000 80c2bbb8c55e7b204c5a2be7752cb4bba6524a7e jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/36:0000000000000000000000000000000000000000 6d872c3e67fefddd25003884311d700f4d493023 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/50:0000000000000000000000000000000000000000 49c51605fea3351809afe5bbf329d3e1ccfe2b8b jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/39:0000000000000000000000000000000000000000 ce9acc990832bbd82301dbbbeabe92c4e83d2789 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/45:0000000000000000000000000000000000000000 80acf2c2097eac156ea5a5175245b3c83491fabf jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/105:0000000000000000000000000000000000000000 ac8178e987511a0bd2357334150c4271e6698896 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/96:0000000000000000000000000000000000000000 617872b92b3e4b42425286fb0c17ca3f3b961078 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/89:0000000000000000000000000000000000000000 0e12f4e5faa636286aa14f39d49e1034d5d7337c jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/58:0000000000000000000000000000000000000000 bdfad258f523cd2d286eb54205af6bf1363328af jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/106:0000000000000000000000000000000000000000 2aa7a5dd99bd3334dcce19c6476c26f1710b74a1 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/83:0000000000000000000000000000000000000000 ff110c850b54536322b60230cad0c34e163aae1b jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/41:0000000000000000000000000000000000000000 785628b2e38220fda176316f0622b74cf1564e9c jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/66:0000000000000000000000000000000000000000 a01c0f0c7b574d34373ec1aa7c100df7c303a855 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/43:0000000000000000000000000000000000000000 9ed8085f052ea972bd484c2272086a1732052ee4 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/71:0000000000000000000000000000000000000000 b5f1a03c9e630dc288e8ed0fd917a80ce95a3c3e jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/94:0000000000000000000000000000000000000000 066b102ed9c4f99dacd1998ada9438aa867da117 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/29:0000000000000000000000000000000000000000 dbc5a853a4d3ea6e74bceefa81380ecd40c3c698 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/75:0000000000000000000000000000000000000000 e395d4db93d2e57759be22d546bc10363ab07655 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/49:0000000000000000000000000000000000000000 49c51605fea3351809afe5bbf329d3e1ccfe2b8b jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/38:0000000000000000000000000000000000000000 88caf20bf9ffad413fc83c413ca8ae69e10ab72d jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/33:0000000000000000000000000000000000000000 88886eeda3d51c0fb634295db026374a6d6c1436 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/31:0000000000000000000000000000000000000000 98e6c0ee19c5b5c4febc37fd578bbf9ad0f3c1cf jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/53:0000000000000000000000000000000000000000 ece456e6e19125755da1a7719edea857be8fa6db jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release/47:0000000000000000000000000000000000000000 94e079610d24da9c82e92cce9685d9ccb1923b2a jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/update_travis_yml:0000000000000000000000000000000000000000 470f8d86675c5f4802458281e000901b1ca844fa jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/revert-699-vr_var_synonyms_104:0000000000000000000000000000000000000000 76e007fb0200fde08ec69acf3fcd21f878f88153 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/display_sv_freq_exp:0000000000000000000000000000000000000000 b0eedf1c768552966326cfeb405b7dc4e9064e80 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/upstream/release1:0000000000000000000000000000000000000000 642e1cd05f4cd91e9b22d98357e85fedcf85f776 jamie-m-a <jma@ebi.ac.uk> 1669825458 +0000	fetch upstream: storing head
.git/logs/refs/remotes/origin/main:0000000000000000000000000000000000000000 b9473b2c6e52fb93813d2799349de914847eef67 jamie-m-a <jma@ebi.ac.uk> 1669825579 +0000	update by push
.git/logs/refs/remotes/origin/HEAD:0000000000000000000000000000000000000000 ac8178e987511a0bd2357334150c4271e6698896 jamie-m-a <jma@ebi.ac.uk> 1669825272 +0000	clone: from https://github.com/jamie-m-a/ensembl-variation
.git/config:	url = https://github.com/jamie-m-a/ensembl-variation
.git/config:	url = https://github.com/Ensembl/ensembl-variation
.git/hooks/update.sample:# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
.git/hooks/update.sample:# ------
.git/hooks/update.sample:# --- Command line
.git/hooks/update.sample:# --- Safety check
.git/hooks/update.sample:if [ -z "$GIT_DIR" ]; then
.git/hooks/update.sample:if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
.git/hooks/update.sample:# --- Config
.git/hooks/update.sample:allowunannotated=$(git config --type=bool hooks.allowunannotated)
.git/hooks/update.sample:allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
.git/hooks/update.sample:denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
.git/hooks/update.sample:allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
.git/hooks/update.sample:allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
.git/hooks/update.sample:projectdesc=$(sed -e '1q' "$GIT_DIR/description")
.git/hooks/update.sample:# --- Check types
.git/hooks/update.sample:zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
.git/hooks/update.sample:	newrev_type=$(git cat-file -t $newrev)
.git/hooks/update.sample:		# un-annotated tag
.git/hooks/update.sample:			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
.git/hooks/update.sample:			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
.git/hooks/update.sample:		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
.git/hooks/update.sample:		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
.git/hooks/update.sample:# --- Finished
.git/hooks/pre-commit.sample:# exit with non-zero status after issuing an appropriate message if
.git/hooks/pre-commit.sample:# To enable this hook, rename this file to "pre-commit".
.git/hooks/pre-commit.sample:if git rev-parse --verify HEAD >/dev/null 2>&1
.git/hooks/pre-commit.sample:	against=$(git hash-object -t tree /dev/null)
.git/hooks/pre-commit.sample:# If you want to allow non-ASCII filenames set this variable to true.
.git/hooks/pre-commit.sample:allownonascii=$(git config --type=bool hooks.allownonascii)
.git/hooks/pre-commit.sample:# Cross platform projects tend to avoid non-ASCII filenames; prevent
.git/hooks/pre-commit.sample:	test $(git diff --cached --name-only --diff-filter=A -z $against |
.git/hooks/pre-commit.sample:	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
.git/hooks/pre-commit.sample:Error: Attempt to add a non-ASCII file name.
.git/hooks/pre-commit.sample:exec git diff-index --check --cached $against --
.git/hooks/pre-push.sample:# pushed.  If this script exits with a non-zero status nothing will be pushed.
.git/hooks/pre-push.sample:# $1 -- Name of the remote to which the push is being done
.git/hooks/pre-push.sample:# $2 -- URL to which the push is being done
.git/hooks/pre-push.sample:zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
.git/hooks/pre-push.sample:		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
.git/hooks/pre-push.sample:		if test -n "$commit"
.git/hooks/applypatch-msg.sample:# applypatch from an e-mail message.
.git/hooks/applypatch-msg.sample:# The hook should exit with non-zero status after issuing an
.git/hooks/applypatch-msg.sample:# To enable this hook, rename this file to "applypatch-msg".
.git/hooks/applypatch-msg.sample:. git-sh-setup
.git/hooks/applypatch-msg.sample:commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
.git/hooks/applypatch-msg.sample:test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
.git/hooks/pre-merge-commit.sample:# exit with non-zero status after issuing an appropriate message to
.git/hooks/pre-merge-commit.sample:# To enable this hook, rename this file to "pre-merge-commit".
.git/hooks/pre-merge-commit.sample:. git-sh-setup
.git/hooks/pre-merge-commit.sample:test -x "$GIT_DIR/hooks/pre-commit" &&
.git/hooks/pre-merge-commit.sample:        exec "$GIT_DIR/hooks/pre-commit"
.git/hooks/pre-applypatch.sample:# by applypatch from an e-mail message.
.git/hooks/pre-applypatch.sample:# The hook should exit with non-zero status after issuing an
.git/hooks/pre-applypatch.sample:# To enable this hook, rename this file to "pre-applypatch".
.git/hooks/pre-applypatch.sample:. git-sh-setup
.git/hooks/pre-applypatch.sample:precommit="$(git rev-parse --git-path hooks/pre-commit)"
.git/hooks/pre-applypatch.sample:test -x "$precommit" && exec "$precommit" ${1+"$@"}
.git/hooks/pre-receive.sample:# To enable this hook, rename this file to "pre-receive".
.git/hooks/pre-receive.sample:if test -n "$GIT_PUSH_OPTION_COUNT"
.git/hooks/pre-receive.sample:	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
.git/hooks/pre-receive.sample:			echo "echo from the pre-receive-hook: ${value#*=}" >&2
.git/hooks/post-update.sample:# To enable this hook, rename this file to "post-update".
.git/hooks/post-update.sample:exec git update-server-info
.git/hooks/pre-rebase.sample:# The "pre-rebase" hook is run just before "git rebase" starts doing
.git/hooks/pre-rebase.sample:# non-zero status.
.git/hooks/pre-rebase.sample:# $1 -- the upstream the series was forked from.
.git/hooks/pre-rebase.sample:# $2 -- the branch being rebased (or empty when rebasing the current branch).
.git/hooks/pre-rebase.sample:	topic=`git symbolic-ref HEAD` ||
.git/hooks/pre-rebase.sample:git show-ref -q "$topic" || {
.git/hooks/pre-rebase.sample:not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
.git/hooks/pre-rebase.sample:if test -z "$not_in_master"
.git/hooks/pre-rebase.sample:only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
.git/hooks/pre-rebase.sample:only_next_2=`git rev-list ^master           ${publish} | sort`
.git/hooks/pre-rebase.sample:	not_in_topic=`git rev-list "^$topic" master`
.git/hooks/pre-rebase.sample:	if test -z "$not_in_topic"
.git/hooks/pre-rebase.sample:	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
.git/hooks/pre-rebase.sample:	/usr/bin/perl -e '
.git/hooks/pre-rebase.sample:			/^([0-9a-f]+) /;
.git/hooks/pre-rebase.sample:				/^([0-9a-f]+) (.*)$/;
.git/hooks/pre-rebase.sample:			if (!exists $not_in_next{$elem->[0]}) {
.git/hooks/pre-rebase.sample:				print STDERR " $elem->[1]\n";
.git/hooks/pre-rebase.sample:    build on top of it -- other people may already want to
.git/hooks/pre-rebase.sample:		   o---o---o---o---o---o---o---o---o---o "next"
.git/hooks/pre-rebase.sample:		 /   a---a---b A     /           /
.git/hooks/pre-rebase.sample:	       /   /   c---c---c---c B         /
.git/hooks/pre-rebase.sample:	     /   /   /   b---b C     \       /
.git/hooks/pre-rebase.sample:    ---o---o---o---o---o---o---o---o---o---o---o "master"
.git/hooks/pre-rebase.sample:	git rev-list ^master ^topic next
.git/hooks/pre-rebase.sample:	git rev-list ^master        next
.git/hooks/pre-rebase.sample:	git rev-list master..topic
.git/hooks/commit-msg.sample:# that has the commit message.  The hook should exit with non-zero
.git/hooks/commit-msg.sample:# To enable this hook, rename this file to "commit-msg".
.git/hooks/commit-msg.sample:# Uncomment the below to add a Signed-off-by line to the message.
.git/hooks/commit-msg.sample:# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
.git/hooks/commit-msg.sample:# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
.git/hooks/commit-msg.sample:# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
.git/hooks/commit-msg.sample:# This example catches duplicate Signed-off-by lines.
.git/hooks/commit-msg.sample:test "" = "$(grep '^Signed-off-by: ' "$1" |
.git/hooks/commit-msg.sample:	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
.git/hooks/commit-msg.sample:	echo >&2 Duplicate Signed-off-by lines.
.git/hooks/fsmonitor-watchman.sample:# To enable this hook, rename this file to "query-watchman" and set
.git/hooks/fsmonitor-watchman.sample:# 'git config core.fsmonitor .git/hooks/query-watchman'
.git/hooks/fsmonitor-watchman.sample:	die "Unsupported query-fsmonitor hook version '$version'.\n" .
.git/hooks/fsmonitor-watchman.sample:		output_result($o->{clock}, @{$o->{files}});
.git/hooks/fsmonitor-watchman.sample:	# open (my $fh, ">", ".git/watchman-output.out");
.git/hooks/fsmonitor-watchman.sample:	return $json_pkg->new->utf8->decode($response);
.git/hooks/fsmonitor-watchman.sample:	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
.git/hooks/fsmonitor-watchman.sample:	# open (my $fh, ">", ".git/watchman-query.json");
.git/hooks/fsmonitor-watchman.sample:	# open ($fh, ">", ".git/watchman-response.json");
.git/hooks/fsmonitor-watchman.sample:	return $json_pkg->new->utf8->decode($response);
.git/hooks/fsmonitor-watchman.sample:	my $error = $output->{error};
.git/hooks/fsmonitor-watchman.sample:		$retry--;
.git/hooks/fsmonitor-watchman.sample:		$output = $json_pkg->new->utf8->decode($response);
.git/hooks/fsmonitor-watchman.sample:		$error = $output->{error};
.git/hooks/fsmonitor-watchman.sample:		# open (my $fh, ">", ".git/watchman-output.out");
.git/hooks/fsmonitor-watchman.sample:		$error = $output->{error};
.git/hooks/fsmonitor-watchman.sample:		output_result($o->{clock}, ("/"));
.git/hooks/fsmonitor-watchman.sample:		$last_update_token = $o->{clock};
.git/hooks/prepare-commit-msg.sample:# message file.  If the hook fails with a non-zero status,
.git/hooks/prepare-commit-msg.sample:# To enable this hook, rename this file to "prepare-commit-msg".
.git/hooks/prepare-commit-msg.sample:# The second includes the output of "git diff --name-status -r"
.git/hooks/prepare-commit-msg.sample:# commented because it doesn't cope with --amend or with squashed
.git/hooks/prepare-commit-msg.sample:# The third example adds a Signed-off-by line to the message, that can
.git/hooks/prepare-commit-msg.sample:/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
.git/hooks/prepare-commit-msg.sample:#    /usr/bin/perl -i.bak -pe '
.git/hooks/prepare-commit-msg.sample:#       print "\n" . `git diff --cached --name-status -r`
.git/hooks/prepare-commit-msg.sample:# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
.git/hooks/prepare-commit-msg.sample:# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
.git/hooks/prepare-commit-msg.sample:# if test -z "$COMMIT_SOURCE"
.git/hooks/prepare-commit-msg.sample:#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
.git/hooks/push-to-checkout.sample:# An example hook script to update a checked-out tree on a git push.
.git/hooks/push-to-checkout.sample:# This hook is invoked by git-receive-pack(1) when it reacts to git
.git/hooks/push-to-checkout.sample:# It can exit with a non-zero status to refuse the push (when it does
.git/hooks/push-to-checkout.sample:# For example, the hook can simply run git read-tree -u -m HEAD "$1"
.git/hooks/push-to-checkout.sample:# with git push, as the two-tree form of git read-tree -u -m is
.git/hooks/push-to-checkout.sample:# The below is a more-or-less exact translation to shell of the C code
.git/hooks/push-to-checkout.sample:# for the default behaviour for git's push-to-checkout hook defined in
.git/hooks/push-to-checkout.sample:# the push_to_deploy() function in builtin/receive-pack.c.
.git/hooks/push-to-checkout.sample:if ! git update-index -q --ignore-submodules --refresh
.git/hooks/push-to-checkout.sample:	die "Up-to-date check failed"
.git/hooks/push-to-checkout.sample:if ! git diff-files --quiet --ignore-submodules --
.git/hooks/push-to-checkout.sample:if git cat-file -e HEAD 2>/dev/null
.git/hooks/push-to-checkout.sample:	head=$(git hash-object -t tree --stdin </dev/null)
.git/hooks/push-to-checkout.sample:if ! git diff-index --quiet --cached --ignore-submodules $head --
.git/hooks/push-to-checkout.sample:if ! git read-tree -u -m "$commit"
Binary file .git/objects/37/82869956f41279feac4cad9d20f1cbfebd1bda matches
Binary file .git/objects/e0/bb9309852ee386d10b6572e6978ab5cd9c084d matches
Binary file .git/objects/c0/ec356f325763aa92158ef76cc1001cf8f17cdc matc